<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Austin Brant</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-03-23T07:02:04.343Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Austin Brant</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>API签名认证机制</title>
    <link href="http://yoursite.com/2020/03/23/API%E7%AD%BE%E5%90%8D%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2020/03/23/API签名认证机制/</id>
    <published>2020-03-23T06:59:05.000Z</published>
    <updated>2020-03-23T07:02:04.343Z</updated>
    
    <content type="html"><![CDATA[<p>本文档主要针对RESTful API做访问认证。</p><h2 id="API认证简介"><a href="#API认证简介" class="headerlink" title="API认证简介"></a>API认证简介</h2><p>对于认证方式，需要通过使用AccessKeyId/SecretAccessKey加密的方法来验证某个请求的发送者身份。</p><blockquote><p>AccessKeyId（AK）用于标示用户，<br>SecretAccessKey（SK）是用户用于加密认证字符串和Server端用来验证认证字符串的密钥</p></blockquote><p>其中SK必须保密，只有用户和Dayu知道。</p><p>当Server端接收到用户的请求后，系统将使用相同的SK和同样的认证机制生成认证字符串，并与用户请求中包含的认证字符串进行比对。如果认证字符串相同，系统认为用户拥有指定的操作权限，并执行相关操作；如果认证字符串不同，系统将忽略该操作并返回错误码。</p><h3 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h3><p>本章节涉及的核心名词解释如下：</p><ul><li><p>认证字符串：非匿名请求中必须携带的认证信息。包含生成待签名串CanonicalRequest所必须的信息以及签名摘要signature。  </p></li><li><p>authStringPrefix：认证字符串的前缀部分。</p></li><li><p>canonicalRequest：待签名串。携带经过规范化处理后的请求信息。</p></li><li><p>signingKey：签名Key。server不直接使用SK对待签名串生成摘要。相反的，server端首先使用SK和认证字符串前缀生成signingKey，然后用signingKey对待签名串生成摘要。</p></li><li><p>signature：签名摘要。Server端使用signingKey对canonicalRequest使用HMAC算法计算签名。</p></li></ul><h3 id="API认证优势"><a href="#API认证优势" class="headerlink" title="API认证优势"></a>API认证优势</h3><p>API认证将为用户带来以下优势：</p><ul><li><p>对于请求者的身份进行验证。认证字符串使用指定用户的AK/SK对HTTP请求进行签名，可以起到验证用户身份的作用。</p></li><li><p>对被传输内容进行保护，防止非法篡改。用户基于HTTP请求的指定内容生成认证字符串，如果在传输过程中遭到非法篡改，将导致系统生成的认证字符串与用户生成的认证字符串不匹配，最终导致认证失败。</p></li><li><p>防止重放攻击。认证字符串都具有指定的生效时间，一个请求必须要在指定时间内到达百度云，否则系统将拒绝该请求。</p></li><li><p>为了保护用户的SK信息，百度云不直接使用SK信息，而是使用SK生成SigningKey，同时在SigningKey中包含有效时间范围。这样可以减少用户因SigningKey丢失带来的安全隐患。</p></li></ul><h3 id="API认证方式"><a href="#API认证方式" class="headerlink" title="API认证方式"></a>API认证方式</h3><p>通过认证算法对HTTP请求的指定内容进行计算并输出认证字符串用于认证。开发者需要首先将HTTP请求的指定内容连接成字符串，结合服务分配的SK，通过HMAC算法计算密文摘要，这个过程也就是对HTTP请求进行签名过程。基于认证字符串的HTTP请求签名机制来验证用户身份。对于每个HTTP请求，都需要携带一个认证字符串然后通过以下两种方式将这个认证字符串包含在请求中：</p><ul><li><p>在HTTP Header中包含认证字符串<br>通常使用的方法是在HTTP请求的Authorization头域中包含认证字符串，除了匿名请求之外，所有与Server的交互都应该包含该字段。即：在HTTP Header中加入Authorization: &lt;认证字符串&gt;。</p></li><li><p>在URL中包含认证字符串<br>用户也可以认证字符串放在HTTP请求Query String的authorization参数中。常用于生成URL给第三方使用的场景，例如要临时把某个数据开放给他人下载。即在URL的Query String中加入authorization = &lt;认证字符串&gt;。</p></li></ul><h3 id="认证字符串生成简介"><a href="#认证字符串生成简介" class="headerlink" title="认证字符串生成简介"></a>认证字符串生成简介</h3><p>认证字符串的生成机制如下图所示：<br><img src="/images/api_authentication_structure.jpg" alt></p><p>API使用基于认证字符串的HTTP请求签名机制来验证用户身份，对于非匿名方式的HTTP请求，都应携带一个认证字符串。当Dayu收到用户的HTTP请求后，系统将按照下图所示流程进行处理。<br><img src="/images/api_signature_pro.jpg" alt></p><ul><li><p>（1）判断用户的HTTP请求是否为匿名请求，即用户的请求中是否包含Authorization认证字符串。如果不包含认证字符串，则需要根据不同业务情况，参考其他相关流程进行处理；如果包含认证字符串，则执行下一步操作。</p></li><li><p>（2）判断用户的请求是否超时，即服务器收到请求的时间需要符合以下要求：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;timestamp&#125; - 5分钟 &lt; 服务器接收到请求时间 &lt; &#123;timestamp&#125; + &#123;expirationPeriodInSeconds&#125; + 5分钟</span><br></pre></td></tr></table></figure><p><code>timestamp</code>代表签名生效UTC时间，<code>expirationPeriodInSeconds</code>代表签名有效期限。</p><p>为了防止用户时钟与服务器时钟不同步而导致的认证失败，此处引入5分钟的宽松系数。如果服务器收到请求的时间不符合以上时间要求，则认为请求超时，拒绝该请求；如果符合上述要求，则执行下一步操作。</p><ul><li><p>（3）基于HTTP请求信息，使用相同的算法，生成Signature字符串。</p></li><li><p>（4）使用服务器生成的Signature字符串与用户提供的字符串进行比对，如果内容不一致，则认为认证失败，拒绝该请求；如果内容一致，则表示认证成功，系统将按照用户的请求内容进行操作。</p></li></ul><h2 id="生成认证字符串"><a href="#生成认证字符串" class="headerlink" title="生成认证字符串"></a>生成认证字符串</h2><h3 id="UriEncode函数"><a href="#UriEncode函数" class="headerlink" title="UriEncode函数"></a>UriEncode函数</h3><p>RFC3986规定，”URI非保留字符”包括以下字符：字母（A-Z，a-z）、数字（0-9）、连字号（-）、点号（.）、下划线（_)、波浪线（~），算法实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 将字符串转换成UTF-8编码的字节流</span><br><span class="line">2. 保留所有“URI非保留字符”原样不变</span><br><span class="line">3. 对其余字节做一次RFC 3986中规定的百分号编码（Percent-encoding），即一个“%”后面跟着两个表示该字节值的十六进制字母，字母一律采用大写形式。</span><br></pre></td></tr></table></figure><p>UriEncode()函数Java版本参考代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">uriEncode</span><span class="params">(CharSequence input, <span class="keyword">boolean</span> encodeSlash)</span> </span>&#123;</span><br><span class="line">StringBuilder result = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; input.length(); i++) &#123;</span><br><span class="line">    <span class="keyword">char</span> ch = input.charAt(i);</span><br><span class="line">    <span class="keyword">if</span> ((ch &gt;= <span class="string">'A'</span> &amp;&amp; ch &lt;= <span class="string">'Z'</span>) || (ch &gt;= <span class="string">'a'</span> &amp;&amp; ch &lt;= <span class="string">'z'</span>) || (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) </span><br><span class="line">    || ch == <span class="string">'_'</span> || ch == <span class="string">'-'</span> || ch == <span class="string">'~'</span> || ch == <span class="string">'.'</span>) &#123;</span><br><span class="line">        result.append(ch);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">'/'</span>) &#123;</span><br><span class="line">        result.append(encodeSlash ? <span class="string">"%2F"</span> : ch);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result.append(toHexUTF8(ch)); <span class="comment">// 转换成:%&lt;两个表示该字节值的十六进制字母&gt;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-生成CanonicalRequest"><a href="#2-生成CanonicalRequest" class="headerlink" title="2 生成CanonicalRequest"></a>2 生成CanonicalRequest</h3><pre><code>CanonicalRequest = HTTP Method + &quot;\n&quot; + CanonicalURI + &quot;\n&quot; + CanonicalQueryString + &quot;\n&quot; + CanonicalHeaders</code></pre><p>其中：</p><ul><li><p>HTTP Method：指HTTP协议中定义的GET、PUT、POST等请求，必须使用全大写的形式。例如：<br>GET、POST、PUT、DELETE、HEAD</p></li><li><p>CanonicalURI：是对URL中的绝对路径进行编码后的结果。要求绝对路径必须以“/”开头，不以“/”开头的需要补充上，空路径为“/”，即CanonicalURI = uriEncode(Path, false)。</p></li><li><p>CanonicalQueryString：对于URL中的Query String（Query String即URL中“？”后面的“key1=valve1&amp;key2=valve2 ”字符串）进行编码后的结果。<br>编码方法为：</p><pre><code>1. 将Query String根据&amp;拆开成若干项，每一项是key=value或者只有key的形式。2. 对拆开后的每一项进行如下处理：    a. 对于key是authorization，直接忽略。    b. 对于只有key的项，转换为uriEncode(key) + &quot;=&quot;的形式。    c. 对于key=value的项，转换为 uriEncode(key) + &quot;=&quot; + uriEncode(value) 的形式。这里value可以是空字符串。3. 将上面转换后的所有字符串按照字典顺序排序。4. 将排序后的字符串按顺序用 &amp; 符号链接起来。</code></pre></li><li><p>CanonicalHeaders：对HTTP请求中的Header部分进行选择性编码的结果。<br>您可以自行决定哪些Header 需要编码。大多数情况下，我们推荐您对以下Header进行编码：</p><ul><li><p>Host</p></li><li><p>Content-Type  </p><p>如果您不想对header进行编码，那么认证字符串中的 {signedHeaders} 可以直接留空，无需填写。您也可以自行选择自己想要编码的Header，只需要在认证字符串中填写 {signedHeaders} 。填写方法为，把所有在这一阶段进行了编码的Header名字转换成全小写之后按照字典序排列，然后用分号（;）连接。</p><p>对于每个要编码的Header进行如下处理：</p><ol><li>将Header的名字变成全小写。</li><li>将Header的值去掉开头和结尾的空白字符。</li><li>经过上一步之后值为空字符串的Header忽略，其余的转换为 uriEncode(name) + “:” + uriEncode(value) 的形式。</li><li>把上面转换后的所有字符串按照字典序进行排序。</li><li>将排序后的字符串按顺序用<code>\n</code>符号连接起来得到最终的CanonicalQueryHeaders。<br>注意：很多发送HTTP请求的第三方库，会添加或者删除你指定的header（例如：某些库会删除content-length:0这个header），如果签名错误，请检查您真实发出的http请求的header，看看是否与签名时的header一样。</li></ol></li></ul></li></ul><h3 id="3-生成SigningKey"><a href="#3-生成SigningKey" class="headerlink" title="3 生成SigningKey"></a>3 生成SigningKey</h3><pre><code>SigningKey = HMAC-SHA256-HEX(sk, authStringPrefix)</code></pre><p>其中：</p><ul><li>sk为用户的SecretAccessKey。</li><li>authStringPrefix代表认证字符串的前缀部分，即:<code>{accessKeyId}/{timestamp}/{expirationPeriodInSeconds}</code>。</li></ul><h3 id="4-生成Signature"><a href="#4-生成Signature" class="headerlink" title="4 生成Signature"></a>4 生成Signature</h3><pre><code>Signature = HMAC-SHA256-HEX(SigningKey, CanonicalRequest)</code></pre><h3 id="5-生成认证字符串"><a href="#5-生成认证字符串" class="headerlink" title="5 生成认证字符串"></a>5 生成认证字符串</h3><pre><code>认证字符串 = {accessKeyId}/{timestamp}/{expirationPeriodInSeconds}/{signedHeaders}/{signature}</code></pre><ul><li><p>timestamp：签名生效UTC时间戳，格式为13位，例如：1543495783836，默认值为当前时间。</p></li><li><p>expirationPeriodInSeconds：签名有效期限，从timestamp所指定的时间开始计算，时间为秒，默认值为1800秒（30）分钟。</p></li><li><p>signedHeaders：签名算法中涉及到的HTTP头域列表。HTTP头域名字一律要求小写且头域名字之间用分号（;）分隔，如host;content-type。当signedHeaders为空时表示未对header签名。</p></li></ul><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="签名函数Java样例"><a href="#签名函数Java样例" class="headerlink" title="签名函数Java样例"></a>签名函数Java样例</h3><p>HMAC-SHA256-HEX()实现样例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 调用HMAC SHA256算法，根据开发者提供的密钥（signingKey）和密文（stringToSign）输出密文摘要，并把结果转换为小写形式的十六进制字符串。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> signingKey   签名密钥</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> stringToSign 待签名文本</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">hmacSha256Hex</span><span class="params">(String signingKey, String stringToSign)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InvalidKeyException, NoSuchAlgorithmException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Mac mac = Mac.getInstance(<span class="string">"HmacSHA256"</span>);</span><br><span class="line">        mac.init(<span class="keyword">new</span> SecretKeySpec(signingKey.getBytes(UTF8), mac.getAlgorithm()));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(Hex.encodeHex(mac.doFinal(stringToSign.getBytes(UTF8))));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(<span class="string">"Fail to generate the signature, &#123;&#125;"</span>, e.getMessage());</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文档主要针对RESTful API做访问认证。&lt;/p&gt;
&lt;h2 id=&quot;API认证简介&quot;&gt;&lt;a href=&quot;#API认证简介&quot; class=&quot;headerlink&quot; title=&quot;API认证简介&quot;&gt;&lt;/a&gt;API认证简介&lt;/h2&gt;&lt;p&gt;对于认证方式，需要通过使用Acces
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
      <category term="认证" scheme="http://yoursite.com/categories/Java/%E8%AE%A4%E8%AF%81/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="认证" scheme="http://yoursite.com/tags/%E8%AE%A4%E8%AF%81/"/>
    
  </entry>
  
  <entry>
    <title>[转载] Serializable：明明就一个空接口！为什么还要实现它？</title>
    <link href="http://yoursite.com/2020/03/23/%E8%BD%AC%E8%BD%BD-Serializable%EF%BC%9A%E6%98%8E%E6%98%8E%E5%B0%B1%E4%B8%80%E4%B8%AA%E7%A9%BA%E6%8E%A5%E5%8F%A3%EF%BC%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E5%AE%9E%E7%8E%B0%E5%AE%83%EF%BC%9F/"/>
    <id>http://yoursite.com/2020/03/23/转载-Serializable：明明就一个空接口！为什么还要实现它？/</id>
    <published>2020-03-23T06:38:02.000Z</published>
    <updated>2020-03-23T06:57:51.101Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文出处： <a href="https://mp.weixin.qq.com/s/B1pWrvAGkii4Z5qSn0L7QA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/B1pWrvAGkii4Z5qSn0L7QA</a></p></blockquote><p>对于 Java 的序列化，我一直停留在最浅显的认知上——把那个要序列化的类实现 <code>Serializbale</code> 接口就可以了。我不愿意做更深入的研究，因为会用就行了嘛。</p><p>但随着时间的推移，见到 <code>Serializbale</code> 的次数越来越多，我便对它产生了浓厚的兴趣。是时候花点时间研究研究了。</p><h2 id="先来点理论"><a href="#先来点理论" class="headerlink" title="先来点理论"></a>先来点理论</h2><p>Java 序列化是 JDK 1.1 时引入的一组开创性的特性，用于将 Java 对象转换为字节数组，便于存储或传输。此后，仍然可以将字节数组转换回 Java 对象原有的状态。</p><p><strong>序列化的思想是“冻结”对象状态，然后写到磁盘或者在网络中传输；反序列化的思想是“解冻”对象状态，重新获得可用的 Java 对象。</strong></p><p>再来看看序列化 Serializbale 接口的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>明明就一个空的接口嘛，竟然能够保证实现了它的“类的对象”被序列化和反序列化？</p><h2 id="再来点实战"><a href="#再来点实战" class="headerlink" title="再来点实战"></a>再来点实战</h2><p>在回答上述问题之前，我们先来创建一个类（只有两个字段，和对应的 <code>getter/setter</code>），用于序列化和反序列化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wanger</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来创建一个测试类，通过 <code>ObjectOutputStream</code> 将“18 岁的王二”写入到文件当中，实际上就是一种序列化的过程；再通过 <code>ObjectInputStream</code> 将“18 岁的王二”从文件中读出来，实际上就是一种反序列化的过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 初始化</span></span><br><span class="line">        Wanger wanger = <span class="keyword">new</span> Wanger();</span><br><span class="line">        wanger.setName(<span class="string">"王二"</span>);</span><br><span class="line">        wanger.setAge(<span class="number">18</span>);</span><br><span class="line">        System.out.println(wanger);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把对象写到文件中</span></span><br><span class="line">        <span class="keyword">try</span> (ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"chenmo"</span>));)&#123;</span><br><span class="line">            oos.writeObject(wanger);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从文件中读出对象</span></span><br><span class="line">        <span class="keyword">try</span> (ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">"chenmo"</span>)));)&#123;</span><br><span class="line">            Wanger wanger1 = (Wanger) ois.readObject();</span><br><span class="line">            System.out.println(wanger1);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过，由于 <code>Wanger</code> 没有实现 <code>Serializbale</code> 接口，所以在运行测试类的时候会抛出异常，堆栈信息如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java.io.NotSerializableException: com.cmower.java_demo.xuliehua.Wanger</span><br><span class="line">    at java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:<span class="number">1184</span>)</span><br><span class="line">    at java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:<span class="number">348</span>)</span><br><span class="line">    at com.cmower.java_demo.xuliehua.Test.main(Test.java:<span class="number">21</span>)</span><br></pre></td></tr></table></figure><p>顺着堆栈信息，我们来看一下 <code>ObjectOutputStream</code> 的 <code>writeObject0()</code> 方法。其部分源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">    writeString((String) obj, unshared);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (cl.isArray()) &#123;</span><br><span class="line">    writeArray(obj, desc, unshared);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Enum) &#123;</span><br><span class="line">    writeEnum((Enum&lt;?&gt;) obj, desc, unshared);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Serializable) &#123;</span><br><span class="line">    writeOrdinaryObject(obj, desc, unshared);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NotSerializableException(</span><br><span class="line">            cl.getName() + <span class="string">"\n"</span> + debugInfoStack.toString());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NotSerializableException(cl.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说，<code>ObjectOutputStream</code> 在序列化的时候，会判断被序列化的对象是哪一种类型，字符串？数组？枚举？还是 <code>Serializable</code>，如果全都不是的话，抛出 <code>NotSerializableException</code>。</p><p>假如 <code>Wanger</code> 实现了 <code>Serializable</code> 接口，就可以序列化和反序列化了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wanger</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2095916884810199532L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体怎么序列化呢？</p><p>以 <code>ObjectOutputStream</code> 为例吧，它在序列化的时候会依次调用 <code>writeObject() → writeObject0() → writeOrdinaryObject() → writeSerialData() → invokeWriteObject() → defaultWriteFields()</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">defaultWriteFields</span><span class="params">(Object obj, ObjectStreamClass desc)</span> </span></span><br><span class="line"><span class="function">                        <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Class&lt;?&gt; cl = desc.forClass();</span><br><span class="line">    desc.checkDefaultSerialize();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> primDataSize = desc.getPrimDataSize();</span><br><span class="line">    desc.getPrimFieldValues(obj, primVals);</span><br><span class="line">    bout.write(primVals, <span class="number">0</span>, primDataSize, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    ObjectStreamField[] fields = desc.getFields(<span class="keyword">false</span>);</span><br><span class="line">    Object[] objVals = <span class="keyword">new</span> Object[desc.getNumObjFields()];</span><br><span class="line">    <span class="keyword">int</span> numPrimFields = fields.length - objVals.length;</span><br><span class="line">    desc.getObjFieldValues(obj, objVals);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; objVals.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            writeObject0(objVals[i], </span><br><span class="line">                fields[numPrimFields + i].isUnshared());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那怎么反序列化呢？</p><p>以 <code>ObjectInputStream</code> 为例，它在反序列化的时候会依次调用 <code>readObject() → readObject0() → readOrdinaryObject() → readSerialData() → defaultReadFields()</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">defaultReadFields</span><span class="params">(Object obj, ObjectStreamClass desc)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Class&lt;?&gt; cl = desc.forClass();</span><br><span class="line">    <span class="keyword">if</span> (cl != <span class="keyword">null</span> &amp;&amp; obj != <span class="keyword">null</span> &amp;&amp; !cl.isInstance(obj)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ClassCastException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> primDataSize = desc.getPrimDataSize();</span><br><span class="line">    <span class="keyword">if</span> (primVals == <span class="keyword">null</span> || primVals.length &lt; primDataSize) &#123;</span><br><span class="line">        primVals = <span class="keyword">new</span> <span class="keyword">byte</span>[primDataSize];</span><br><span class="line">    &#125;</span><br><span class="line">        bin.readFully(primVals, <span class="number">0</span>, primDataSize, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (obj != <span class="keyword">null</span>) &#123;</span><br><span class="line">        desc.setPrimFieldValues(obj, primVals);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> objHandle = passHandle;</span><br><span class="line">    ObjectStreamField[] fields = desc.getFields(<span class="keyword">false</span>);</span><br><span class="line">    Object[] objVals = <span class="keyword">new</span> Object[desc.getNumObjFields()];</span><br><span class="line">    <span class="keyword">int</span> numPrimFields = fields.length - objVals.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; objVals.length; i++) &#123;</span><br><span class="line">        ObjectStreamField f = fields[numPrimFields + i];</span><br><span class="line">        objVals[i] = readObject0(f.isUnshared());</span><br><span class="line">        <span class="keyword">if</span> (f.getField() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            handles.markDependency(objHandle, passHandle);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (obj != <span class="keyword">null</span>) &#123;</span><br><span class="line">        desc.setObjFieldValues(obj, objVals);</span><br><span class="line">    &#125;</span><br><span class="line">    passHandle = objHandle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我想看到这，你应该会恍然大悟的“哦”一声了。<code>Serializable</code> 接口之所以定义为空，是因为它只起到了一个标识的作用，告诉程序实现了它的对象是可以被序列化的，但真正序列化和反序列化的操作并不需要它来完成。</p><h2 id="static-amp-amp-transient"><a href="#static-amp-amp-transient" class="headerlink" title="static &amp;&amp; transient"></a>static &amp;&amp; transient</h2><p>开门见山的说吧，<code>static</code> 和 <code>transient</code> 修饰的字段是不会被序列化的。</p><p>为什么呢？我们先来证明，再来解释原因。</p><p>首先，在 <code>Wanger</code> 类中增加两个字段。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wanger</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2095916884810199532L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String pre = <span class="string">"沉默"</span>;</span><br><span class="line">    <span class="keyword">transient</span> String meizi = <span class="string">"王三"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Wanger&#123;"</span> + <span class="string">"name="</span> + name + <span class="string">",age="</span> + age + <span class="string">",pre="</span> + pre + <span class="string">",meizi="</span> + meizi + <span class="string">"&#125;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其次，在测试类中打印序列化前和反序列化后的对象，并在序列化后和反序列化前改变 <code>static</code> 字段的值。具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">Wanger wanger = <span class="keyword">new</span> Wanger();</span><br><span class="line">wanger.setName(<span class="string">"王二"</span>);</span><br><span class="line">wanger.setAge(<span class="number">18</span>);</span><br><span class="line">System.out.println(wanger);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把对象写到文件中</span></span><br><span class="line"><span class="keyword">try</span> (ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"chenmo"</span>));)&#123;</span><br><span class="line">        oos.writeObject(wanger);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改变 static 字段的值</span></span><br><span class="line">Wanger.pre =<span class="string">"不沉默"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从文件中读出对象</span></span><br><span class="line"><span class="keyword">try</span> (ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">"chenmo"</span>)));)&#123;</span><br><span class="line">    Wanger wanger1 = (Wanger) ois.readObject();</span><br><span class="line">    System.out.println(wanger1);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Wanger&#123;name=王二,age=18,pre=沉默,meizi=王三&#125;</span></span><br><span class="line"><span class="comment">// Wanger&#123;name=王二,age=18,pre=不沉默,meizi=null&#125;</span></span><br></pre></td></tr></table></figure><p>从结果的对比当中，我们可以发现：</p><p>1）序列化前，<code>pre</code> 的值为“沉默”，序列化后，<code>pre</code> 的值修改为“不沉默”，反序列化后，<code>pre</code> 的值为“不沉默”，而不是序列化前的状态“沉默”。</p><p>为什么呢？ 因为序列化保存的是对象的状态，而 <code>static</code> 修饰的字段属于类的状态，因此可以证明序列化并不保存 <code>static</code> 修饰的字段。</p><p>2）序列化前，<code>meizi</code> 的值为“王三”，反序列化后，<code>meizi</code> 的值为 <code>null</code>，而不是序列化前的状态“王三”。</p><p>为什么呢？ <code>transient</code> 的中文字义为“临时的”（论英语的重要性），它可以阻止字段被序列化到文件中，在被反序列化后，<code>transient</code> 字段的值被设为初始值，比如 <code>int</code> 型的初始值为 <code>0</code>，对象型的初始值为 <code>null</code>。</p><p>如果想要深究源码的话，你可以在 <code>ObjectStreamClass</code> 中发现下面这样的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ObjectStreamField[] getDefaultSerialFields(Class&lt;?&gt; cl) &#123;</span><br><span class="line">    Field[] clFields = cl.getDeclaredFields();</span><br><span class="line">    ArrayList&lt;ObjectStreamField&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> mask = Modifier.STATIC | Modifier.TRANSIENT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> size = list.size();</span><br><span class="line">    <span class="keyword">return</span> (size == <span class="number">0</span>) ? NO_FIELDS :</span><br><span class="line">        list.toArray(<span class="keyword">new</span> ObjectStreamField[size]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到 <code>Modifier.STATIC</code> | <code>Modifier.TRANSIENT</code>，是不是感觉更好了呢？</p><h2 id="Externalizable"><a href="#Externalizable" class="headerlink" title="Externalizable"></a>Externalizable</h2><p>除了 <code>Serializable</code> 之外，Java 还提供了一个序列化接口 <code>Externalizable</code>（念起来有点拗口）。</p><p>两个接口有什么不一样的吗？试一试就知道了。</p><p>首先，把 <code>Wanger</code> 类实现的接口  <code>Serializable</code> 替换为 <code>Externalizable</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wanger</span> <span class="keyword">implements</span> <span class="title">Externalizable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Wanger</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Wanger&#123;"</span> + <span class="string">"name="</span> + name + <span class="string">",age="</span> + age + <span class="string">"&#125;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeExternal</span><span class="params">(ObjectOutput out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readExternal</span><span class="params">(ObjectInput in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现 <code>Externalizable</code>和实现 <code>Serializable</code> 接口的 Wanger 类有一些不同：</p><p>1）新增了一个无参的构造方法。</p><p>使用 <code>Externalizable</code> 进行反序列化的时候，会调用被序列化类的无参构造方法去创建一个新的对象，然后再将被保存对象的字段值复制过去。否则的话，会抛出以下异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">java.io.InvalidClassException: com.cmower.java_demo.xuliehua1.Wanger; no valid constructor</span><br><span class="line">    at java.io.ObjectStreamClass$ExceptionInfo.newInvalidClassException(ObjectStreamClass.java:<span class="number">150</span>)</span><br><span class="line">    at java.io.ObjectStreamClass.checkDeserialize(ObjectStreamClass.java:<span class="number">790</span>)</span><br><span class="line">    at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:<span class="number">1782</span>)</span><br><span class="line">    at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:<span class="number">1353</span>)</span><br><span class="line">    at java.io.ObjectInputStream.readObject(ObjectInputStream.java:<span class="number">373</span>)</span><br><span class="line">    at com.cmower.java_demo.xuliehua1.Test.main(Test.java:<span class="number">27</span>)</span><br></pre></td></tr></table></figure><p>2）新增了两个方法 <code>writeExternal()</code> 和 <code>readExternal()</code>，实现 <code>Externalizable</code> 接口所必须的。</p><p>然后，我们再在测试类中打印序列化前和反序列化后的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">Wanger wanger = <span class="keyword">new</span> Wanger();</span><br><span class="line">wanger.setName(<span class="string">"王二"</span>);</span><br><span class="line">wanger.setAge(<span class="number">18</span>);</span><br><span class="line">System.out.println(wanger);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把对象写到文件中</span></span><br><span class="line"><span class="keyword">try</span> (ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"chenmo"</span>));) &#123;</span><br><span class="line">    oos.writeObject(wanger);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从文件中读出对象</span></span><br><span class="line"><span class="keyword">try</span> (ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">"chenmo"</span>)));) &#123;</span><br><span class="line">    Wanger wanger1 = (Wanger) ois.readObject();</span><br><span class="line">    System.out.println(wanger1);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Wanger&#123;name=王二,age=18&#125;</span></span><br><span class="line"><span class="comment">// Wanger&#123;name=null,age=0&#125;</span></span><br></pre></td></tr></table></figure><p>从输出的结果看，反序列化后得到的对象字段都变成了默认值，也就是说，序列化之前的对象状态没有被“冻结”下来。</p><p>为什么呢？因为我们没有为 <code>Wanger</code> 类重写具体的 <code>writeExternal()</code> 和 <code>readExternal()</code> 方法。那该怎么重写呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeExternal</span><span class="params">(ObjectOutput out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    out.writeObject(name);</span><br><span class="line">    out.writeInt(age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readExternal</span><span class="params">(ObjectInput in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    name = (String) in.readObject();</span><br><span class="line">    age = in.readInt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1）调用 <code>ObjectOutput</code> 的 <code>writeObject()</code> 方法将字符串类型的 <code>name</code> 写入到输出流中；</p><p>2）调用 <code>ObjectOutput</code> 的 <code>writeInt()</code> 方法将整型的 <code>age</code> 写入到输出流中；</p><p>3）调用 <code>ObjectInput</code> 的 <code>readObject()</code> 方法将字符串类型的 <code>name</code> 读入到输入流中；</p><p>4）调用 <code>ObjectInput</code> 的 <code>readInt()</code> 方法将字符串类型的 <code>age</code> 读入到输入流中；</p><p>再运行一次测试了类，你会发现对象可以正常地序列化和反序列化了。</p><h2 id="serialVersionUID"><a href="#serialVersionUID" class="headerlink" title="serialVersionUID"></a>serialVersionUID</h2><p><code>serialVersionUID</code> 被称为序列化 ID，它是决定 Java 对象能否反序列化成功的重要因子。在反序列化时，Java 虚拟机会把字节流中的 <code>serialVersionUID</code> 与被序列化类中的 <code>serialVersionUID</code> 进行比较，如果相同则可以进行反序列化，否则就会抛出序列化版本不一致的异常。</p><p>当一个类实现了 <code>Serializable</code> 接口后，IDE 就会提醒该类最好产生一个序列化 ID，就像下面这样：</p><p><img src="media/15840823582780/15840835449125.jpg" alt></p><p><strong>三种解决方式：</strong></p><p>1）添加一个默认版本的序列化 ID：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>。</span><br></pre></td></tr></table></figure><p>2）添加一个随机生成的不重复的序列化 ID。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2095916884810199532L</span>;</span><br></pre></td></tr></table></figure><p>3）添加 <code>@SuppressWarnings</code> 注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"serial"</span>)</span><br></pre></td></tr></table></figure><p>怎么选择呢？</p><p>首先，我们采用第二种办法，在被序列化类中添加一个随机生成的序列化 ID。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wanger</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2095916884810199532L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他代码忽略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，序列化一个 <code>Wanger</code> 对象到文件中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">Wanger wanger = <span class="keyword">new</span> Wanger();</span><br><span class="line">wanger.setName(<span class="string">"王二"</span>);</span><br><span class="line">wanger.setAge(<span class="number">18</span>);</span><br><span class="line">System.out.println(wanger);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把对象写到文件中</span></span><br><span class="line"><span class="keyword">try</span> (ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"chenmo"</span>));) &#123;</span><br><span class="line">    oos.writeObject(wanger);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候，我们悄悄地把 <code>Wanger</code> 类的序列化 ID 偷梁换柱一下，嘿嘿。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// private static final long serialVersionUID = -2095916884810199532L;</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2095916884810199533L</span>;</span><br></pre></td></tr></table></figure><p>好了，准备反序列化吧。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">"chenmo"</span>)));) &#123;</span><br><span class="line">    Wanger wanger = (Wanger) ois.readObject();</span><br><span class="line">    System.out.println(wanger);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>哎呀，出错了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java.io.InvalidClassException:  local class incompatible: stream classdesc </span><br><span class="line">serialVersionUID = -<span class="number">2095916884810199532</span>,</span><br><span class="line">local <span class="class"><span class="keyword">class</span> <span class="title">serialVersionUID</span> </span>= -<span class="number">2095916884810199533</span></span><br><span class="line">    at java.io.ObjectInputStream.readClassDesc(ObjectInputStream.java:<span class="number">1521</span>)</span><br><span class="line">    at com.cmower.java_demo.xuliehua1.Test.main(Test.java:<span class="number">27</span>)</span><br></pre></td></tr></table></figure><p>异常堆栈信息里面告诉我们，从持久化文件里面读取到的序列化 ID 和本地的序列化 ID 不一致，无法反序列化。</p><p>那假如我们采用第三种方法，为 <code>Wanger</code> 类添加个 <code>@SuppressWarnings(&quot;serial&quot;)</code> 注解呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"serial"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wanger3</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，再来一次反序列化吧。可惜依然报错。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java.io.InvalidClassException:  local class incompatible: stream classdesc </span><br><span class="line">serialVersionUID = -<span class="number">2095916884810199532</span>, </span><br><span class="line">local <span class="class"><span class="keyword">class</span> <span class="title">serialVersionUID</span> </span>= -<span class="number">3818877437117647968</span></span><br><span class="line">    at java.io.ObjectInputStream.readClassDesc(ObjectInputStream.java:<span class="number">1521</span>)</span><br><span class="line">    at com.cmower.java_demo.xuliehua1.Test.main(Test.java:<span class="number">27</span>)</span><br></pre></td></tr></table></figure><p>异常堆栈信息里面告诉我们，本地的序列化 ID 为 <code>-3818877437117647968</code>，和持久化文件里面读取到的序列化 ID 仍然不一致，无法反序列化。这说明什么呢？使用 <code>@SuppressWarnings(&quot;serial&quot;)</code> 注解时，该注解会为被序列化类自动生成一个随机的序列化 ID。</p><p>由此可以证明，Java 虚拟机是否允许反序列化，不仅取决于类路径和功能代码是否一致，还有一个非常重要的因素就是序列化 ID 是否一致。</p><p>也就是说，如果没有特殊需求，采用默认的序列化 ID（1L）就可以，这样可以确保代码一致时反序列化成功。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;原文出处： &lt;a href=&quot;https://mp.weixin.qq.com/s/B1pWrvAGkii4Z5qSn0L7QA&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://mp.weixin.qq.com/s/
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
      <category term="基础" scheme="http://yoursite.com/categories/Java/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Serializable" scheme="http://yoursite.com/tags/Serializable/"/>
    
  </entry>
  
  <entry>
    <title>熔断、限流、降级入门</title>
    <link href="http://yoursite.com/2020/03/23/%E7%86%94%E6%96%AD%E3%80%81%E9%99%90%E6%B5%81%E3%80%81%E9%99%8D%E7%BA%A7%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2020/03/23/熔断、限流、降级入门/</id>
    <published>2020-03-23T06:30:21.000Z</published>
    <updated>2020-03-23T06:35:36.148Z</updated>
    
    <content type="html"><![CDATA[<p>本文将大概讲解下高并发场景下经常用到的熔断、限流、降级基本概念。</p><h2 id="熔断"><a href="#熔断" class="headerlink" title="熔断"></a>熔断</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>熔断本质上是一个过载保护机制。</p><p>在互联网系统中的熔断机制是指：</p><blockquote><p>当下游服务因访问压力过大而响应变慢或失败，上游服务为了保护自己以及系统整体的可用性，可以暂时切断对下游服务的调用。</p></blockquote><p>做熔断的思路大体上就是：<strong>一个中心思想，分四步走</strong>。</p><p>中心思想是：<strong>量力而行</strong>。因为软件和人不同，没有奇迹会发生，什么样的性能撑多少流量是固定的。这是根本。</p><p>然后，这四步走分别是：</p><ul><li><p>（1）定义一个识别是否处于“不可用”状态的策略</p></li><li><p>（2）切断联系</p></li><li><p>（3）定义一个识别是否处于“可用”状态的策略，并尝试探测</p></li><li><p>（4）重新恢复正常</p></li></ul><p>定义一个识别是否处于“不正常”状态的策略，识别一个系统是否正常，无非是两个点：</p><ul><li>是不是能调通</li><li>如果能调通，耗时是不是超过预期的长</li></ul><h3 id="熔断状态机"><a href="#熔断状态机" class="headerlink" title="熔断状态机"></a>熔断状态机</h3><h4 id="不可用状态"><a href="#不可用状态" class="headerlink" title="不可用状态"></a>不可用状态</h4><p> 由于分布式系统被建立在一个并不是 100% 可靠的网络上，所以上述的情况总有发生，因此我们不能将偶发的瞬时异常等同于系统“不可用”（避免以偏概全）。由此我们需要引入一个「时间窗口」的概念，这个时间窗口用来“放宽”判定“不可用”的区间，也意味着多给了系统几次证明自己“可用”机会。但是，如果系统还是在这个时间窗口内达到了你定义“不可用”标准，那么我们就要“断臂求生”了。</p><p>这个标准可以有两种方式来指定。</p><ul><li><p><strong>阈值</strong>: 比如，在 10 秒内出现 100 次“无法连接”或者出现 100 次大于 5 秒的请求。</p></li><li><p><strong>百分比</strong>: 比如，在 10 秒内有 30% 请求“无法连接”或者 30% 的请求大于 5 秒。</p></li></ul><p>最终会形成这样这样的一段代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">全局变量 errorcount = 0; // 有个独立的线程每隔 10 秒（时间窗口）重置为 0。</span><br><span class="line">全局变量 isOpenCircuitBreaker = false;</span><br><span class="line"> </span><br><span class="line">//do some thing...</span><br><span class="line"> </span><br><span class="line">if(success)&#123;</span><br><span class="line">    return success;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    errorcount++;</span><br><span class="line">    if(errorcount == 不可用阈值)&#123;</span><br><span class="line">        isOpenCircuitBreaker = true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="切断联系"><a href="#切断联系" class="headerlink" title="切断联系"></a>切断联系</h4><p>切断联系要尽可能的“果断”，既然已经认定了对方“不可用”，那么索性就默认“失败”，避免做无用功，也顺带能缓解对方的压力。</p><p>分布式系统中的程序间调用，一般都会通过一些 RPC 框架进行。那么，这个时候作为客户端一方，在自己进程内通过代理发起调用之前就可以直接返回失败，不走网络。这就是常说的「<strong>fail fast</strong>」机制。就是在前面提到的代码段之前增加下面的这段代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(isOpenCircuitBreaker == true)&#123;</span><br><span class="line">    return fail;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//do some thing...</span><br></pre></td></tr></table></figure><h4 id="可用状态"><a href="#可用状态" class="headerlink" title="可用状态"></a>可用状态</h4><p>定义一个识别是否处于“可用”状态的策略，并尝试探测</p><p>切断联系后，功能的完整性必然会受影响，所以还是需要尽快恢复回来，以提供完整的服务能力。这事肯定不能人为去干预，及时性必然会受到影响。那么如何能够自动的识别依赖系统是否“可用”呢？这也需要你来定义一个策略。</p><p>一般来说这个策略与识别“不可用”的策略类似，只是这里是一个反向指标。</p><ul><li><p>阈值。比如，在 10 秒内出现 100 次“调用成功”并且耗时都小于 1 秒。</p></li><li><p>百分比。比如，在 10 秒内有 95% 请求“调用成功”并且 98% 的请求小于 1 秒。</p></li></ul><p>同样包含「时间窗口」、「阈值」以及「百分比」。</p><p>稍微不同的地方在于，大多数情况下，一个系统“不可用”的状态往往会持续一段时间，不会那么快就恢复过来。所以我们不需要像第一步中识别“不可用”那样，无时无刻的记录请求状况，而只需要在每隔一段时间之后去进行探测即可。所以，这里多了一个「间隔时间」的概念。这个间隔幅度可以是固定的，比如 30 秒。也可以是动态增加的，通过线性增长或者指数增长等方式。</p><p>这个用代码表述大致是这样。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">全局变量 successCount = 0; </span><br><span class="line">// 有个独立的线程每隔 10 秒（时间窗口）重置为 0。</span><br><span class="line">// 并且将下面的 isHalfOpen 设为 false。</span><br><span class="line">全局变量 isHalfOpen = true;</span><br><span class="line">// 有个独立的线程每隔 30 秒（间隔时间）重置为 true。</span><br><span class="line"></span><br><span class="line">//do some thing...</span><br><span class="line">if(success)&#123;</span><br><span class="line">    if(isHalfOpen)&#123;</span><br><span class="line">        successCount ++;</span><br><span class="line">        if(successCount = 可用阈值)&#123;</span><br><span class="line">            isOpenCircuitBreaker = false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return success;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    errorcount++;</span><br><span class="line">    if(errorcount == 不可用阈值)&#123;</span><br><span class="line">        isOpenCircuitBreaker = true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，尝试探测本质上是一个“试错”，要控制下“试错成本”。所以我们不可能拿 100% 的流量去验证，一般会有以下两种方式：</p><ul><li><p><strong>放行一定比例的流量去验证。</strong></p></li><li><p>如果在整个通信框架都是统一的情况下，还可以<strong>统一给每个系统增加一个专门用于验证程序健康状态检测的独立接口</strong>。这个接口额外可以多返回一些系统负载信息用于判断健康状态，如 CPU、I/O 的情况等。</p></li></ul><h4 id="重新恢复正常"><a href="#重新恢复正常" class="headerlink" title="重新恢复正常"></a>重新恢复正常</h4><p>一旦通过了衡量是否“可用”的验证，整个系统就恢复到了“正常”状态，此时需要重新开启识别“不可用”的策略。就这样，系统会形成一个循环。</p><p><img src="/images/rongduan_status.jpg" alt></p><h3 id="熔断的最佳实践"><a href="#熔断的最佳实践" class="headerlink" title="熔断的最佳实践"></a>熔断的最佳实践</h3><p>什么场景最适合做熔断<br>一个事物在不同的场景里会发挥出不同的效果。以下是我能想到最适合熔断发挥更大优势的几个场景：</p><ul><li><p>所依赖的系统本身是一个共享系统，当前客户端只是其中的一个客户端。这是因为，如果其它客户端进行胡乱调用也会影响到你的调用。</p></li><li><p>所以依赖的系统被部署在一个共享环境中（资源未做隔离），并不独占使用。比如，和某个高负荷的数据库在同一台服务器上。</p></li><li><p>所依赖的系统是一个经常会迭代更新的服务。这点也意味着，越“敏捷”的系统越需要“熔断”。</p></li><li><p>当前所在的系统流量大小是不确定的。比如，一个电商网站的流量波动会很大，你能抗住突增的流量不代表所依赖的后端系统也能抗住。这点也反映出了我们在软件设计中带着“面向怀疑”的心态的重要性。</p></li></ul><p>与所有事物一样，熔断也不是一个完美的事物，我们特别需要注意 2 个问题：</p><ul><li><p>首先，如果所依赖的系统是多副本或者做了分区的，那么要注意其中个别节点的异常并不等于所有节点都存在异常，所以需要区别对待。</p></li><li><p>其次，熔断往往应作为最后的选择，我们应优先使用一些「降级」或者「限流」方案。因为“部分胜于无”，虽然无法提供完整的服务，但尽可能的降低影响是要持续去努力的。比如，抛弃非核心业务、给出友好提示等等。</p></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>上面的这些代码示例中也可以看到，熔断代码所在的位置要么在实际方法之前，要么在实际方法之后。它非常适合 <strong>AOP</strong> 编程思想的发挥，所以我们平常用到的熔断框架都会基于 AOP 去做。</p><p>熔断只是一个保护壳，在周围出现异常的时候保全自身。但是从长远来看平时定期做好压力测试才能更好的防范于未然，降低触发熔断的次数。如果清楚的知道每个系统有几斤几两，在这个基础上再把「限流」和「降级」做好，这基本就将“高压”下触发熔断的概率降到最低了。</p><h2 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h2><p>想象一个稍微极端一点的场景，如果系统流量不是很稳定，导致频繁触发熔断的话，是不是意味着系统一直熔断的三种状态中不断切换。导致的结果是每次从开启熔断到关闭熔断的期间，必然会导致大量的用户无法正常使用。</p><p>那么限流的作用就很显而易见了：<strong>只要系统没宕机，系统只是因为资源不够，而无法应对大量的请求，为了保证有限的系统资源能够提供最大化的服务能力，因而对系统按照预设的规则进行流量（输出或输入）限制的一种方法，确保被接收的流量不会超过系统所能承载的上限。</strong></p><p>限流最好能“限”在一个系统处理能力的上限附近，所以：</p><ol><li><p>通过「压力测试」等方式获得系统的能力上限在哪个水平是第一步。</p></li><li><p>其次，就是制定干预流量的策略。比如标准该怎么定、是否只注重结果还是也要注重过程的平滑性等。</p></li><li><p>最后，就是处理“被干预掉”的流量。能不能直接丢弃？不能的话该如何处理？</p></li></ol><p>常用的策略就 4 种，我给它起了一个简单的定义——「两窗两桶」。两窗就是：固定窗口、滑动窗口，两桶就是：漏桶、令牌桶。</p><h3 id="固定窗口"><a href="#固定窗口" class="headerlink" title="固定窗口"></a>固定窗口</h3><p>固定窗口就是定义一个“固定”的统计周期，比如 1 分钟或者 30 秒、10 秒这样。然后在每个周期统计当前周期中被接收到的请求数量，经过计数器累加后如果达到设定的阈值就触发「流量干预」。直到进入下一个周期后，计数器清零，流量接收恢复正常状态。</p><p><img src="/images/limit_chunk.jpg" alt></p><p>这个策略最简单，写起代码来也没几行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">全局变量 int totalCount = 0;  // 有一个「固定周期」会触发的定时器将数值清零。</span><br><span class="line"> </span><br><span class="line">if(totalCount &gt; 限流阈值) &#123;</span><br><span class="line">    return; // 不继续处理请求。</span><br><span class="line">&#125;</span><br><span class="line">totalCount++;</span><br><span class="line">    </span><br><span class="line">// do something...</span><br></pre></td></tr></table></figure><p>固定窗口有一点需要注意的是，假如请求的进入非常集中，那么所设定的「<strong>限流阈值</strong>」等同于你需要承受的最大并发数。所以，如果需要<strong>顾忌到并发问题，那么这里的「固定周期」设定的要尽可能的短</strong>。因为，这样的话「限流阈值」的数值就可以相应的减小。甚至，<strong>限流阈值就可以直接用并发数来指定</strong>。比如，假设固定周期是 3 秒，那么这里的阈值就可以设定为「平均并发数 *3」。</p><p>不过不管怎么设定，固定窗口永远存在的缺点是：<strong>由于流量的进入往往都不是一个恒定的值，所以一旦流量进入速度有所波动，要么计数器会被提前计满，导致这个周期内剩下时间段的请求被“限制”。要么就是计数器计不满，也就是「限流阈值」设定的过大，导致资源无法充分利用。</strong></p><p>「滑动窗口」可以改善这个问题。</p><h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p>滑动窗口其实就是对固定窗口做了进一步的细分，将原先的粒度切的更细，比如 1 分钟的固定窗口切分为 60 个 1 秒的滑动窗口。然后统计的时间范围随着时间的推移同步后移。</p><p><img src="/images/limit_chunk_slick.jpg" alt></p><p>同时，我们还可以得出一个结论是：如果固定窗口的「固定周期」已经很小了，那么使用滑动窗口的意义也就没有了。举个例子，现在的固定窗口周期已经是 1 秒了，再切分到毫秒级别能反而得不偿失，会带来巨大的性能和资源损耗。</p><p>滑动窗口大致的代码逻辑是这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">全局数组 链表 []  counterList = new 链表 [切分的滑动窗口数量];</span><br><span class="line">// 有一个定时器，在每一次统计时间段起点需要变化的时候就将索引 0 位置的元素移除，并在末端追加一个新元素。</span><br><span class="line"> </span><br><span class="line">int sum = counterList.Sum();</span><br><span class="line">if(sum &gt; 限流阈值) &#123;</span><br><span class="line">    return; // 不继续处理请求。</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int 当前索引 = 当前时间的秒数 % 切分的滑动窗口数量 ;</span><br><span class="line">counterList[当前索引]++;</span><br><span class="line"> </span><br><span class="line">// do something...</span><br></pre></td></tr></table></figure><p>虽然说滑动窗口可以改善这个问题，但是本质上还是预先划定时间片的方式，属于一种“预测”，意味着几乎肯定无法做到 100% 的物尽其用。</p><p>但是，「桶」模式可以做的更好，因为「桶」模式中多了一个缓冲区（桶本身）。</p><h3 id="漏桶"><a href="#漏桶" class="headerlink" title="漏桶"></a>漏桶</h3><p>首先聊聊「漏桶」吧。漏桶模式的核心是固定“出口”的速率，不管进来多少量，出去的速率一直是这么多。如果涌入的量多到桶都装不下了，那么就进行「流量干预」。</p><p><img src="/images/limit_leak_bucket.jpg" alt></p><p>实现代码的简化表示如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 全局变量 </span><br><span class="line">int unitSpeed;  // 出口当前的流出速率。每隔一个速率计算周期（比如 1 秒）会触发定时器将数值清零。</span><br><span class="line"></span><br><span class="line">// 全局变量 </span><br><span class="line">int waterLevel; // 当前缓冲区的水位线。</span><br><span class="line"> </span><br><span class="line">if(unitSpeed &lt; 速率阈值) &#123;</span><br><span class="line">    unitSpeed++;</span><br><span class="line">    </span><br><span class="line">    //do something...</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    if(waterLevel &gt; 水位阈值)&#123;</span><br><span class="line">        return; // 不继续处理请求。</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    waterLevel++;</span><br><span class="line">    </span><br><span class="line">    while(unitSpeed &gt;= 速率阈值)&#123;</span><br><span class="line">        sleep(一小段时间)。</span><br><span class="line">    &#125;</span><br><span class="line">    unitSpeed++;</span><br><span class="line">    waterLevel--;</span><br><span class="line">        </span><br><span class="line">    //do something...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="令牌桶"><a href="#令牌桶" class="headerlink" title="令牌桶"></a>令牌桶</h3><p>令牌桶算法和漏桶算法效果一样但方向相反的算法，更加容易理解。随着时间流逝，系统会按恒定1/QPS时间间隔（如果QPS=100，则间隔是10ms）往桶里加入令牌（想象和漏洞漏水相反，有个水龙头在不断的加水），如果桶已经满了就不再加了。新请求来临时，会各自拿走一个令牌，如果没有令牌可拿了就阻塞或者拒绝服务。<strong>这种算法可以应对突发程度的请求，因此比漏桶算法好。</strong> 示意图（来源网络）如下：</p><p><img src="/images/limit_lingpai.jpg" alt></p><h4 id="Guava单机版实现"><a href="#Guava单机版实现" class="headerlink" title="Guava单机版实现"></a>Guava单机版实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.util.concurrent.RateLimiter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RateLimiterExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// qps设置为5，代表一秒钟只允许处理五个并发请求</span></span><br><span class="line">        RateLimiter rateLimiter = RateLimiter.create(<span class="number">5</span>);</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">int</span> nTasks = <span class="number">10</span>;</span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(nTasks);</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nTasks; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> j = i;</span><br><span class="line">            executorService.submit(() -&gt; &#123;</span><br><span class="line">                rateLimiter.acquire(<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" gets job "</span> + j + <span class="string">" done"</span>);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"10 jobs gets done by 5 threads concurrently in "</span> + (end - start) + <span class="string">" milliseconds"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pool-1-thread-1 gets job 0 done</span><br><span class="line">pool-1-thread-2 gets job 1 done</span><br><span class="line">pool-1-thread-3 gets job 2 done</span><br><span class="line">pool-1-thread-4 gets job 3 done</span><br><span class="line">pool-1-thread-5 gets job 4 done</span><br><span class="line">pool-1-thread-6 gets job 5 done</span><br><span class="line">pool-1-thread-7 gets job 6 done</span><br><span class="line">pool-1-thread-8 gets job 7 done</span><br><span class="line">pool-1-thread-9 gets job 8 done</span><br><span class="line">pool-1-thread-10 gets job 9 done</span><br><span class="line">10 jobs gets done by 5 threads concurrently in 2805 milliseconds</span><br></pre></td></tr></table></figure><p>上面例子中我们提交10个工作任务，每个任务大概耗时1000微秒，开启10个线程，并且使用RateLimiter设置了qps为5，一秒内只允许五个并发请求被处理，虽然有10个线程，但是我们设置了qps为5，一秒之内只能有五个并发请求。我们预期的总耗时大概是2000微秒左右，结果为2805和预期的差不多。</p><h4 id="Redisson分布式实现"><a href="#Redisson分布式实现" class="headerlink" title="Redisson分布式实现"></a>Redisson分布式实现</h4><p>基于Redis的<a href="http://static.javadoc.io/org.redisson/redisson/3.10.6/org/redisson/api/RRateLimiter.html" target="_blank" rel="noopener">分布式限流器（RateLimiter）</a>可以用来在分布式环境下现在请求方的调用频率。既适用于不同Redisson实例下的多线程限流，也适用于相同Redisson实例下的多线程限流。该算法不保证公平性。除了同步接口外，还提供了异步（<a href="http://static.javadoc.io/org.redisson/redisson/3.10.6/org/redisson/api/RRateLimiterAsync.html" target="_blank" rel="noopener">Async</a>）、反射式（<a href="http://static.javadoc.io/org.redisson/redisson/3.10.6/org/redisson/api/RRateLimiterReactive.html" target="_blank" rel="noopener">Reactive</a>）和 <a href="http://static.javadoc.io/org.redisson/redisson/3.10.6/org/redisson/api/RRateLimiterRx.html" target="_blank" rel="noopener">RxJava2</a> 标准的接口。</p><blockquote><p>Redisson 3.10+ 版本以上</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">limt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Config config = <span class="keyword">new</span> Config();</span><br><span class="line">    RedissonClient redisson = Redisson.create(config);</span><br><span class="line">    RRateLimiter rateLimiter = redisson.getRateLimiter(<span class="string">"myRateLimiter"</span>);</span><br><span class="line">    <span class="comment">// 初始化, 最大流速 = 每1秒钟产生10个令牌</span></span><br><span class="line">    rateLimiter.trySetRate(RateType.OVERALL, <span class="number">10</span>, <span class="number">1</span>, RateIntervalUnit.SECONDS);</span><br><span class="line">    rateLimiter.tryAcquire(<span class="number">2</span>);</span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        rateLimiter.acquire(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="限流的最佳实践"><a href="#限流的最佳实践" class="headerlink" title="限流的最佳实践"></a>限流的最佳实践</h3><p>一个成熟的分布式系统大致是这样的。<br><img src="/images/limit_best_pratice.jpg" alt></p><p>每一个上游系统都可以理解为是其下游系统的客户端。可能你发现前面聊的「限流」都没有提到到底是在<strong>客户端做限流还是服务端做</strong>，甚至看起来更倾向是建立在服务端的基础上做。但是你知道，在一个分布式系统中，一个服务端本身就可能存在多个副本，并且还会提供给多个客户端调用，甚至其自身也会作为客户端角色。那么，在如此交错复杂的一个环境中，该如何下手做限流呢？我的思路是通过<strong>「一纵一横」</strong>来考量。</p><p><strong>纵</strong><br>都知道「限流」是一个保护措施，那么可以将它想象成一个盾牌。另外，一个请求在系统中的处理过程是链式的。那么，正如古时候军队打仗一样，盾牌兵除了有小部分在老大周围保护，剩下的全在最前线。因为盾的位置越前，能受益的范围越大。</p><p>分布式系统中最前面的是什么？接入层。如果你的系统有接入层，比如用 nginx 做的反向代理。那么可以通过它的 <strong>ngx_http_limit_conn_module</strong> 以及 <strong>ngx_http_limit_req_module</strong> 来做限流，是很成熟的一个解决方案。</p><p>如果没有接入层，那么只能在应用层以 AOP 的思路去做了。但是，由于应用是分散的，出于成本考虑你需要针对性的去做限流。比如 ToC 的应用必然比 ToB 的应用更需要做，高频的缓存系统必然比低频的报表系统更需要做，Web 应用由于存在 Filter 的机制做起来必然比 Service 应用更方便。</p><blockquote><p>那么应用间的限流到底是做到客户端还是服务端呢？</p></blockquote><p>z 哥的观点是，从效果上<strong>客户端模式肯定是优于服务端模式的</strong>，因为当处于被限流状态的时候，客户端模式连建立连接的动作都省了。另一个潜在的好处是，与集中式的服务端模式相比，可以把少数的服务端程序的压力分散掉。但是在客户端做成本也更高，因为它是去中心化的，假如需要多个节点之间的数据共通的话，是一个很麻烦的事情。</p><p>所以，最终 z 哥建议你：<strong>如果考虑成本就服务端模式，考虑效果就客户端模式</strong>。当然也不是绝对，比如一个服务端的流量大部分都来源于某一个客户端，那么就可以直接在这个客户端做限流，这也不失为一个好方案。</p><p>数据库层面的话，一般连接字符串中本身就会包含「最大连接数」的概念，就可以起到限流的作用。如果想做更精细的控制就只能做到统一封装的数据库访问层框架中了。</p><p><strong>横</strong><br>不管是多个客户端，还是同一个服务端的多个副本。每个节点的性能必然会存在差异，如何设立合适的阈值？以及如何让策略的变更尽可能快的在集群中的多个节点生效？说起来很简单，引入一个性能监控平台和配置中心。但这些真真要做好不容易。</p><h2 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h2><p>降级的目的用一句话概括就是：将有限的资源效益最大化。</p><p>根据 28 原则，我们知道一个系统 80% 的效益是由最核心的 20% 的功能产出的。剩下的 20% 效益需要投入 80% 的资源才能达到。</p><p>这就意味着，假如系统平时需要花费 100% 资源做 100% 的事情，如果现在访问量增多 3 倍的话必定扛不住（需要 300% 的资源）。那么，在不增加资源的情况下，我希望系统不能宕机，依旧能正常工作，必然需要让出那解决剩下 20% 问题的 80% 资源。如此一来，理论上这 100% 的资源就可以支撑原先 5 倍的访问量。副作用是功能的完整性上受损 80%。</p><p>当然，在实际的场景中不会降级掉 80% 的功能这么夸张，毕竟还得为用户的体验考虑。</p><p>举个电商场景典型的例子，在大促的时候，最重要的是什么？转化咯～赚钱咯～ 那么这个时候如果说「评论」功能占用了很多资源，你会怎么处理？其实我们可以选择临时关闭提交评论入口、关闭翻页功能等等，让下单的过程有更多的资源来处理。</p><p>主要分为两个环节：<strong>定级定序</strong> 和 <strong>降级实现</strong></p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p>[1] <a href="https://www.javazhiyin.com/39808.html" target="_blank" rel="noopener">微服务架构下的分布式限流方案全解析</a></p><p>[2] <a href="https://www.infoq.cn/article/JLb9z4up64MyQjN_ZbSd" target="_blank" rel="noopener">分布式系统关注点：99% 人看得懂的“熔断”以及最佳实践</a></p><p>[3] <a href="https://www.infoq.cn/article/UhixHoWebU_TYJewJwcL" target="_blank" rel="noopener">分布式系统关注点——限流该怎么做？</a></p><p>[4] <a href="https://www.infoq.cn/article/uEIk76o3*3ZpYtcSUQkB" target="_blank" rel="noopener">让你的系统“坚挺不倒”的最后一个大招——「降级」</a></p><p>[5] <a href="https://juejin.im/post/5c7510f3518825625e4ae41b" target="_blank" rel="noopener">Guava RateLimiter限流</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文将大概讲解下高并发场景下经常用到的熔断、限流、降级基本概念。&lt;/p&gt;
&lt;h2 id=&quot;熔断&quot;&gt;&lt;a href=&quot;#熔断&quot; class=&quot;headerlink&quot; title=&quot;熔断&quot;&gt;&lt;/a&gt;熔断&lt;/h2&gt;&lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;
      
    
    </summary>
    
      <category term="分布式" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="高可用" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E9%AB%98%E5%8F%AF%E7%94%A8/"/>
    
    
      <category term="分布式" scheme="http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="熔断" scheme="http://yoursite.com/tags/%E7%86%94%E6%96%AD/"/>
    
      <category term="限流" scheme="http://yoursite.com/tags/%E9%99%90%E6%B5%81/"/>
    
      <category term="降级" scheme="http://yoursite.com/tags/%E9%99%8D%E7%BA%A7/"/>
    
  </entry>
  
  <entry>
    <title>分布式一致性算法</title>
    <link href="http://yoursite.com/2020/03/23/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2020/03/23/分布式一致性算法/</id>
    <published>2020-03-23T06:04:21.000Z</published>
    <updated>2020-03-23T06:13:14.411Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Paxos"><a href="#Paxos" class="headerlink" title="Paxos"></a>Paxos</h2><h2 id="ZAB协议"><a href="#ZAB协议" class="headerlink" title="ZAB协议"></a>ZAB协议</h2><p>ZAB (Zookeeper Atomic Broadcast, Zookeeper 原子消息广播协议)继承了Paxos的理念专门为zookeeper设计的一套数据一致性算法。</p><p>ZK 使用一个单一的主进程来保持集群中各副本之间数据的一致性；</p><p>将服务器数据的状态变更以事物 <code>Proposal</code> 的形式广播到所有的副本进程上去；</p><p>ZAB 协议包括两种基本模式：崩溃恢复 和 消息广播</p><h3 id="消息广播"><a href="#消息广播" class="headerlink" title="消息广播"></a>消息广播</h3><p><img src="/images/message_broadcast.jpg" alt></p><p>详细过程：</p><ul><li><p>Leader 服务器会为每个事物请求生成对应的 Proposal 来进行广播，并在广播之前为 Proposal 分配一个全局单调递增的唯一 ID（即 ZXID）；</p></li><li><p>Leader 服务器为每个 Follower 服务器各自分配一个单独的队列，将要广播的 Proposal 依次放入队列中，并根据 FIFO 策略进行消息发送；</p></li><li><p>每个 Follower 服务器在收到 Proposal 后，会先将其以事物日志的形式写入本地磁盘，写入成功后，给 Leader 返回 Ack；</p></li><li><p>当 Leader 收到超过半数 Follower 的 Ack 响应后，就会广播 Commit 消息给所有 Follower 服务器通知其开始事物提交；</p></li></ul><p>存在问题：无法处理 Leader 服务器崩溃退出而带来的数据不一致问题，所以 ZAB 协议增加了 崩溃恢复 模式；</p><h3 id="崩溃恢复"><a href="#崩溃恢复" class="headerlink" title="崩溃恢复"></a>崩溃恢复</h3><p>当服务框架在启动中或 Leader 服务器出现网络中断、崩溃、重启情况时，ZAB协议就会进入恢复模式并选举新的Leader；</p><p><strong>ZXID</strong></p><ul><li><p>在 ZAB 协议的事物编号 ZXID 设计中，ZXID 是一个 64 位的数字，低 32 位是简单单调递增计数器，每一个客户端请求 Leader 生成新事物 Proposal 对该计数器 +1；</p></li><li><p>高 32 位表示 Leader 周期 epoch 编号，每当选举产生一个新的 Leader 服务器，就会从这个 Leader 服务器上取出本地日志最大失误 Proposal 的 ZXID，并从 ZXID 中解析出对应的 epoch 值，并 +1，之后就以此编号作为新的 epoch，并将低 32 位，置 0 来开始新的 ZXID；<br><img src="/images/zk_zxid.jpg" alt></p></li></ul><h4 id="集群启动时，Leader-选举"><a href="#集群启动时，Leader-选举" class="headerlink" title="集群启动时，Leader 选举"></a>集群启动时，Leader 选举</h4><p><img src="/images/zk_leader.jpg" alt></p><p>上图中，<code>(1, 1, 0)</code></p><ul><li>第一位数代表投出该选票的服务器的logicClock;</li><li>第二位数代表被推荐的服务器的myid;</li><li>第三位代表被推荐的服务器的最大的zxid;</li></ul><p>由于该步骤中所有选票都投给自己，所以第二位的myid即是自己的myid，第三位的zxid即是自己的zxid。此时各自的票箱中只有自己投给自己的一票</p><p><img src="/images/zk_leader2.jpg" alt></p><p>服务器收到外部投票后，进行选票PK，相应更新自己的选票并广播出去，并将合适的选票存入自己的票箱。</p><p>服务器1收到服务器2的选票（1, 2, 0）和服务器3的选票（1, 3, 0）后，由于所有的logicClock都相等，所有的zxid都相等，因此根据myid判断应该将自己的选票按照服务器3的选票更新为（1, 3, 0），并将自己的票箱全部清空，再将服务器3的选票与自己的选票存入自己的票箱，接着将自己更新后的选票广播出去。此时服务器1票箱内的选票为(1, 3)，(3, 3)。</p><p>同理，服务器2收到服务器3的选票后也将自己的选票更新为（1, 3, 0）并存入票箱然后广播。此时服务器2票箱内的选票为(2, 3)，(3, ,3)。</p><p>服务器3根据上述规则，无须更新选票，自身的票箱内选票仍为（3, 3）。</p><p>服务器1与服务器2更新后的选票广播出去后，由于三个服务器最新选票都相同，最后三者的票箱内都包含三张投给服务器3的选票。</p><p><img src="/images/zk_leader3.jpg" alt></p><p>三个服务器一致认为此时服务器3应该是Leader。因此服务器1和2都进入FOLLOWING状态，而服务器3进入LEADING状态。之后Leader发起并维护与Follower间的心跳。</p><h4 id="集群运行时，Leader-选举"><a href="#集群运行时，Leader-选举" class="headerlink" title="集群运行时，Leader 选举"></a>集群运行时，Leader 选举</h4><p>当过半机器与 Leader 完成状态同步后，ZAB 协议退出恢复模式；</p><h2 id="Raft协议"><a href="#Raft协议" class="headerlink" title="Raft协议"></a>Raft协议</h2><p>Raft协议在功能上是完全等同于(Multi)-Paxos协议的。Raft也是一个原子广播协议（原子广播协议参见《由浅入深理解Paxos协议（1）》），它在分布式系统中的功能以及使用方法和Paxos是完全一样的。我们可以用Raft来替代分布式系统中的Paxos协议</p><h3 id="Raft的设计理念"><a href="#Raft的设计理念" class="headerlink" title="Raft的设计理念"></a>Raft的设计理念</h3><p>严格来说Raft并不属于Paxos的一个变种。Raft协议并不是对Paxos的改进，也没有使用Paxos的基础协议（The Basic Protocol）。Raft协议在设计理念上和Paxos协议是完全相反的。正是由于这个完全不同的理念，使得Raft协议变得简单起来。</p><p>Paxos协议中有一个基本的假设前提：<strong>可能会同时有多个Leader存在</strong>。这里把Paxos协议执行的过程分为以下两个部分：</p><ul><li><p>Leader选举</p></li><li><p>数据广播</p></li></ul><p>在《由浅入深理解Paxos协议（2）》的“Leader的选取”一节中提到过，<strong>Paxos协议并没有给出详细的Leader选举机制。Paxos对于Leader的选举没有限制，用户可以自己定义</strong>。这是因为Paxos协议设计了一个巧妙的数据广播过程，即<strong>Paxos的基本通讯协议（The Basic Protocol）。它有很强的数据一致性保障，即使在多个Leader同时出现时也能够保证广播数据的一致性</strong>。</p><p>而Raft协议走了完全相反的一个思路：<font color="red"><strong>保证不会同时有多个Leader存在</strong></font>。因此Raft协议对Leader的选举做了详细的设计，从而保证不会有多个Leader同时存在。相反，数据广播的过程则变的简单易于理解了。</p><h3 id="Raft的日志广播过程"><a href="#Raft的日志广播过程" class="headerlink" title="Raft的日志广播过程"></a>Raft的日志广播过程</h3><p>为了保证数据被复制到多数的节点上，Raft的广播过程尽管简单仍然要使用多数派协议，只是这个过程要容易理解的多：</p><ul><li><p>发送日志到所有Followers（Raft中将非Leader节点称为Follower）；</p></li><li><p>Followers收到日志后，应答收到日志；</p></li><li><p>当半数以上的Followers应答后，Leader通知Followers日志广播成功；</p></li></ul><p><strong>日志和日志队列</strong></p><p>Raft将用户数据称作日志（Log），存储在一个日志队列里。每个节点上都有一份。队列里的每个日志都一个序号，这个序号是连续递增的不能有缺。<br><img src="/images/raft_log_queue.jpg" alt></p><p>日志队列里有一个重要的位置叫做提交日志的位置（Commit Index）。将日志队列里的日志分为了两个部分：<br> <img src="/images/raft_commit_log.jpg" alt></p><ul><li><p>已提交日志：已经复制到超过半数节点的数据，这些是可以让应用读取到的日志；</p></li><li><p>未提交日志：还未复制到超过半数节点的数据；</p></li></ul><p>当Followers收到日志后，将日志按顺序存储到队列里。但这时Commit Index不会更新，因此这些日志是未提交的日志，不能被读取到。当Leader收到超过半数的Followers的应答后，会更新自己的Commit Index，并将Commit Index广播到Followers上。这时Followers更新Commit Index，未提交的日志就变成了已提交的日志，可以被应用程序去读取到了。</p><p>从上面的解释我们可以知道，<strong>日志队列中已经提交的日志是不可改变的，而未提交的日志则可以被更新成其他的日志（在Leader发生变化时会发生）</strong>。</p><h3 id="Raft的Leader选举"><a href="#Raft的Leader选举" class="headerlink" title="Raft的Leader选举"></a>Raft的Leader选举</h3><p>Raft称它的Leader为“Strong Leader”。Strong Leader 有以下特点：</p><ul><li><p>同一时间只有一个Leader；</p></li><li><p>只能从Leader向Followers发送数据，反之不行；</p></li></ul><p>下面我们看一下Raft通过哪些机制来实现Strong Leader。</p><h4 id="多数派协议"><a href="#多数派协议" class="headerlink" title="多数派协议"></a>多数派协议</h4><p>为了保证只有一个Leader被选举出来，选举的过程使用了多数派协议。这样很好理解，当一个Candidate（申请成为Leader的节点）请求成为Leader时，只有半数以上的Followers同意后，才能成为Leader。投票过程如下：</p><ul><li><p>当发现Leader无响应后（一段时间内没有日志或心跳），Candidate发送投票请求；</p></li><li><p>Followers投票；</p></li><li><p>如果超过半数的Followers投了票，则Candidate自动变成Leader，开始广播日志；</p></li></ul><h4 id="随机超时机制"><a href="#随机超时机制" class="headerlink" title="随机超时机制"></a>随机超时机制</h4><p>和《由浅入深理解Paxos协议（1）》中提到问题一样，这里也会发生多个Candidate同时发送投票请求，而导致谁都不能够得到多数赞成票的情况，有可能永远也选不出Leader。为了保证Leader选举的效率，Raft在投票选举中使用了随机超时的机制：</p><ul><li><p>在每个Followers上设定的Leader超时时间是在一个范围内随机的。这样可以尽量让Followers不在同一时间发起Leader选举；</p></li><li><p>每个Candidate发起投票后，如果在一段时间内没有任何Candidate称为Leader则，需要重新发起Leader选举。这段等待的时间，在每个Candidate上也是随机的。从而保证不会有多个Candidate同时重新发起Leader选举。</p></li></ul><p>虽说是随机的超时时间，但是也有个范围，太小或者太大都会影响系统的可用性。太小会导致过多的选举冲突，太大又会影响系统的平滑运行。在Raft的论文中，作者将这个超时时间称为electionTimeout，并给出了合理的范围，公式如下：</p><pre><code>broadcastTime ≪ electionTimeout ≪ MTBF</code></pre><p><code>≪</code> 代表数量级上的差异（10倍以上）。</p><h4 id="日志长度过半机制"><a href="#日志长度过半机制" class="headerlink" title="日志长度过半机制"></a>日志长度过半机制</h4><p><strong>Candidate的日志长度要等于或者超过半数节点才能选为Leader。</strong></p><p>当Leader故障时，Followers上日志的状态很可能是不一致的。有的多有的少，而且Commit Index也不尽相同。<br><img src="/images/raft_log_half.jpg" alt></p><p>我们知道已经提交的日志是不能够丢弃的，必须要最终复制到所有的节点上才行。假如在选Leader时，图中Candidate A变成了Leader，就必须要首先从Candidate B上将日志4复制过来，然后才能开始处理新的日志。为了减少复杂性，raft就规定，只有包含了所有已提交日志的Candidate才能当选为Leader。</p><p>实现也很简单：</p><ul><li><p>当发现Leader无响应后（一段时间内没有数据或心跳），Candidate发送投票请求，请求中包含自己日志队列的长度（或者说最大日志的Index）；</p></li><li><p>Followers检查Candidate的日志长度，只有Candidate的日志等于或者长于自己才投票；</p></li><li><p>如果超过半数的Followers投了票，则Candidate自动变成Leader，开始广播数据；</p></li></ul><p><strong>因为已经提交的日志一定被复制到了多数节点上，所以日志长度等于或者长于多数节点的Candidate一定包含了所有已经提交的日志。</strong></p><p><em>为什么不是检查Commit Index？</em></p><blockquote><p>因为Leader故障时，很有可能只有Leader的Commit Index是最大的。<br><img src="/images/raft_leader_stragey.jpg" alt></p><p>如果图中的Candidate A被选举为Leader，那么日志4就会被丢弃。但是日志4已经在原来的Leader上提交了，因此必须被保留才行。所以只能让日志长度更长的Candidate B选为Leader。这种做法有可能把原来Leader没广播完成的日志（图中的日志5）接着广播完成，这没有什么关系。</p></blockquote><h4 id="Followers日志补齐"><a href="#Followers日志补齐" class="headerlink" title="Followers日志补齐"></a>Followers日志补齐</h4><p>当Leader故障时，Followers上的日志状态是不一样的，有长有短。因此新的Leader选出后，首先要将所有Followers的日志补齐才行。因此Leader要询问Followers的日志长度，从最小的日志位置开始补齐。</p><h4 id="Followers未提交日志的更新"><a href="#Followers未提交日志的更新" class="headerlink" title="Followers未提交日志的更新"></a>Followers未提交日志的更新</h4><p>新Leader的日志一定包含所有已经提交的日志。但新Leader的日志不一定是最长的，那些新Leader没有的日志，一定是未提交的日志，因此可以被更新，没有关系的。Leader只需要从自己的当前位置开始插入日志并广播出去就可以了。Followers会用新的日志去更新指定位置上的日志。</p><h3 id="新旧Leader的交替"><a href="#新旧Leader的交替" class="headerlink" title="新旧Leader的交替"></a>新旧Leader的交替</h3><p>新的Leader选出后，开始广播日志。这时如果旧的Leader故障恢复了（比如网络临时中断），并且还认为自己是Leader，也会广播日志。这不就导致了同时有两个Leader出现吗？是的，Raft也没办法让旧的Leader不发日志，但是Raft有办法让Followers拒绝旧Leader的日志。</p><h4 id="Term"><a href="#Term" class="headerlink" title="Term"></a>Term</h4><p>Raft将时间划分为连续的时间段，称为Term。 Term是指从一次Leader选举开始到下一次Leader选举的一段时间。这段时间内只能有一个Leader被选举成功，并负责管理系统或者没有Leader选出。</p><p> <img src="/images/term_raft.jpg" alt></p><p>每个Term都有一个唯一的数字编号。所有Term的数字编号是从小到大连续排列的。</p><h4 id="作废旧Leader"><a href="#作废旧Leader" class="headerlink" title="作废旧Leader"></a>作废旧Leader</h4><p>Term编号在作废旧Leader的过程中至关重要，但却十分简单。过程如下：</p><ul><li><p>发送日志到所有Followers，Leader的Term编号随日志一起发送;</p></li><li><p>Followers收到日志后，检查Leader的Term编号。如果Leader的Term编号等于或者大于自己的当前Term（Current Term）编号，则存储日志到队列并且应答收到日志。否则发送失败消息给Leader，消息中包含自己的当前Term编号。</p></li><li><p>当Leader收到任何Term编号比自己的Term编号大的消息时，则将自己变成Follower。收到的消息包括：Follower给自己的回复消息、新Leader的日志广播消息、Leader的选举消息。</p></li></ul><h2 id="Gossip协议"><a href="#Gossip协议" class="headerlink" title="Gossip协议"></a>Gossip协议</h2><p><strong>RedisCluster是基于Gossip协议的PING/PONG通讯来保证数据分片集群中的状态一致性。</strong></p><p>Gossip协议主要用在分布式系统中各个节点的数据同步。</p><h3 id="Gossip协议原理"><a href="#Gossip协议原理" class="headerlink" title="Gossip协议原理"></a>Gossip协议原理</h3><p>Gossip协议由种子节点发起请求（种子节点即状态发生改变的节点），当一个种子节点有状态需要更新到网络中的其他节点时，它会随机选择周围几个节点进行散播消息，收到消息的节点也会重复此过程，直至网络中的所有节点都收到消息，这个过程需要一定的时间，因此Gossip是一个最终一致性协议。<br><img src="/images/gossip_protocol.jpg" alt></p><p>Gossip协议中提供了三种通讯类型：</p><ul><li><p>PUSH类型：A节点将数据发送给B节点，B节点更新A节点比自己新的数据。</p></li><li><p>PULL类型：A节点将数据发送给B节点，B节点返回比A节点新的数据，A节点再更新自己。</p></li><li><p>PULL/PUSH类型：A节点将数据发送给B节点，B节点返回比A节点新的数据，A节点再更新自己，然后A节点将数据发送给B节点，B节点更新A节点比自己新的数据。</p></li></ul><blockquote><p>PUSH类型发送一次请求，目的是让其他节点更新。</p><p>PULL类型发送两次请求，目的是更新自身节点的信息。</p><p>每个消息都有一个时间戳，用来区分新老信息。</p></blockquote><h3 id="RedisCluster中的PING-PONG通讯"><a href="#RedisCluster中的PING-PONG通讯" class="headerlink" title="RedisCluster中的PING/PONG通讯"></a>RedisCluster中的PING/PONG通讯</h3><ul><li><p>PING：发送集群中节点的信息、角色、集群ID、时间戳。</p></li><li><p>PONG：响应PING的请求。</p></li></ul><p>PING请求即Gossip协议中的PUSH，目的是让其他节点进行更新。</p><p> <img src="/images/redis_ping_pong.jpg" alt></p><p>RedisCluster中的每个节点都会定期的向其他节点发送PING请求，用于集群间状态的同步以及检测节点的可用性。</p><p>当集群中有新节点加入时（经过Meet操作），该节点会向其他节点发送PING请求，同时其他节点也会向其发送PING请求，最终达到数据一致性。</p><ul><li><p>RedisCluster中的节点故障是通过Master投票决定的，当有半数的Master认为该节点故障时，那么集群认为该节点故障，如果故障的节点是Master，那么会将其Slave节点切换为Master。</p></li><li><p>当RedisCluster中有一半的Master同时失效，那么整个集群将不可用，因为已经没有足够的Master进行投票。</p></li></ul><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.cnblogs.com/hugb/p/8955505.html" target="_blank" rel="noopener">图解分布式一致性协议Paxos</a></p><p><a href="https://dbaplus.cn/news-141-1875-1.html" target="_blank" rel="noopener">实例详解ZooKeeper ZAB协议、分布式锁与领导选举</a></p><p><a href="https://blog.csdn.net/weixin_44861409/article/details/89406795" target="_blank" rel="noopener">Redis集群管理</a></p><p><a href="https://blog.csdn.net/u010003835/article/details/88650121" target="_blank" rel="noopener">大数据_Zookeeper_Raft 协议</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Paxos&quot;&gt;&lt;a href=&quot;#Paxos&quot; class=&quot;headerlink&quot; title=&quot;Paxos&quot;&gt;&lt;/a&gt;Paxos&lt;/h2&gt;&lt;h2 id=&quot;ZAB协议&quot;&gt;&lt;a href=&quot;#ZAB协议&quot; class=&quot;headerlink&quot; title=&quot;ZAB
      
    
    </summary>
    
      <category term="分布式" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="一致性" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E4%B8%80%E8%87%B4%E6%80%A7/"/>
    
    
      <category term="分布式" scheme="http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="一致性" scheme="http://yoursite.com/tags/%E4%B8%80%E8%87%B4%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>分布式事务简介</title>
    <link href="http://yoursite.com/2020/03/23/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%AE%80%E4%BB%8B/"/>
    <id>http://yoursite.com/2020/03/23/分布式事务简介/</id>
    <published>2020-03-23T03:21:21.000Z</published>
    <updated>2020-03-23T03:41:02.852Z</updated>
    
    <content type="html"><![CDATA[<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>数据库事务（简称：事务，Transaction）是指数据库执行过程中的一个逻辑单位，由一个有限的数据库操作序列构成。</p><p>事务拥有以下四个特性，习惯上被称为 ACID 特性：</p><ol><li><p><strong>原子性</strong>（Atomicity）：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。</p></li><li><p><strong>一致性</strong>（Consistency）：事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态是指数据库中的数据应满足完整性约束。除此之外，一致性还有另外一层语义，就是事务的中间状态不能被观察到（这层语义也有说应该属于原子性）。</p></li><li><p><strong>隔离性</strong>（Isolation）：多个事务并发执行时，一个事务的执行不应影响其他事务的执行，如同只有这一个操作在被数据库所执行一样。</p></li><li><p><strong>持久性</strong>（Durability）：已被提交的事务对数据库的修改应该永久保存在数据库中。在事务结束时，此操作将不可逆转。</p></li></ol><p><strong>本地事务</strong>：基于单个服务单一数据库资源访问的事务，被称为本地事务（Local Transaction）；</p><p><strong>分布式事务</strong>： 当一个服务操作访问不同的数据库资源，或者是多个服务操作多个数据库资源需要保证一致性时，就需要使用分布式事务；</p><h2 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h2><p>CAP理论说的是：在一个分布式系统中，最多只能满足C、A、P中的两个需求。</p><p>CAP的含义：</p><ul><li><p>C：Consistency 一致性<br>同一数据的多个副本是否实时相同。</p></li><li><p>A：Availability 可用性<br>可用性：一定时间内 &amp; 系统返回一个明确的结果 则称为该系统可用。</p></li><li><p>P：Partition tolerance 分区容错性<br>将同一服务分布在多个系统中，从而保证某一个系统宕机，仍然有其他系统提供相同的服务。</p></li></ul><p>CAP理论告诉我们，在分布式系统中，C、A、P三个条件中我们最多只能选择两个</p><h2 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h2><p>CAP理论告诉我们一个悲惨但不得不接受的事实——我们只能在C、A、P中选择两个条件。而对于业务系统而言，我们往往选择牺牲一致性来换取系统的可用性和分区容错性。不过这里要指出的是，所谓的“牺牲一致性”并不是完全放弃数据一致性，而是<strong>牺牲强一致性换取弱一致性</strong>。下面来介绍下BASE理论。</p><ul><li><p>BA：Basic Available 基本可用<br>分布式系统在出现故障时，允许损失部分可用功能，保证核心功能可用。只不过“基本可用”和“高可用”的区别是：</p><ul><li>“一定时间”可以适当延长, 当举行大促时，响应时间可以适当延长</li><li>给部分用户直接返回一个降级页面，从而缓解服务器压力。但要注意，返回降级页面仍然是返回明确结果。</li></ul></li><li><p>S：Soft State：柔性状态<br>允许系统中存在中间状态，这个状态不影响系统可用性，这里指的是CAP中的不一致。</p></li><li><p>E：Eventual Consisstency：最终一致性<br>同一数据的不同副本的状态，可以不需要实时一致，但一定要保证经过一定时间后最终是一致的。</p></li></ul><h2 id="分布式事务协议"><a href="#分布式事务协议" class="headerlink" title="分布式事务协议"></a>分布式事务协议</h2><h3 id="两阶段提交协议-2PC"><a href="#两阶段提交协议-2PC" class="headerlink" title="两阶段提交协议 2PC"></a>两阶段提交协议 2PC</h3><p>分布式系统的一个难点是如何保证多个节点在进行事务性操作的时候一致性。为实现这个目的，二阶段提交算法的成立基于以下假设：</p><ul><li><p>该分布式系统中，存在一个全局事务管理器（TM，Transaction Manager）和多个资源管理器（RM，Resource Manager）。且节点之间可以进行网络通信。</p></li><li><p>所有节点都采用预写式日志，且日志被写入后即被保持在可靠的存储设备上，即使节点损坏不会导致日志数据的消失。</p></li><li><p>所有节点不会永久性损坏，即使损坏后仍然可以恢复。</p></li></ul><p><img src="/images/tx_tm.jpg" alt></p><p><strong>1. 准备阶段（投票阶段）：</strong></p><ul><li>TM 向每个 RM 发送准备消息；</li><li>如果 RM 的本地事务操作执行成功（并将Undo信息和Redo信息写入日志），则返回成功；</li><li>如果 RM 的本地事务操作执行失败，则返回失败；</li></ul><p>注意：若成功这里其实每个 RM 已经执行了事务操作。</p><p><strong>2. 提交阶段（执行阶段）：</strong></p><ul><li><p>如果 TM 收到了所有 RM 回复的成功消息，则向每个 RM 发送提交消息；</p></li><li><p>否则发送回滚消息；RM 根据 TM 的指令执行提交或者回滚本地事务操作，释放所有事务处理过程中使用的锁资源。</p></li></ul><p>不管最后结果如何，第二阶段都会结束当前事务。</p><p>二阶段提交看起来确实能够提供原子性的操作，但是不幸的事，二阶段提交还是有几个缺点的：</p><ul><li><p>执行过程中，所有参与节点都是事务阻塞型的。当参与者占有公共资源时，其他第三方节点访问公共资源不得不处于阻塞状态。</p></li><li><p>参与者发生故障。协调者需要给每个参与者额外指定超时机制，超时后整个事务失败。（没有多少容错机制）</p></li><li><p>协调者发生故障。参与者会一直阻塞下去。需要额外的备机进行容错。（这个可以依赖后面要讲的Paxos协议实现HA）</p></li><li><p>二阶段无法解决的问题：协调者在发出commit消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经提交。</p></li></ul><p>为此，Dale Skeen和Michael Stonebraker在“A Formal Model of Crash Recovery in a Distributed System”中提出了三阶段提交协议（3PC）。</p><h3 id="三阶段提交协议-3PC"><a href="#三阶段提交协议-3PC" class="headerlink" title="三阶段提交协议 3PC"></a>三阶段提交协议 3PC</h3><p>与两阶段提交不同的是，三阶段提交有两个改动点。</p><ul><li>引入超时机制。同时在协调者和参与者中都引入超时机制。</li><li>在第一阶段和第二阶段中插入一个准备阶段。保证了在最后提交阶段之前各参与节点的状态是一致的。</li></ul><p>也就是说，除了引入超时机制之外，3PC把2PC的准备阶段再次一分为二，这样三阶段提交就有<strong>CanCommit</strong>、<strong>PreCommit</strong>、<strong>DoCommit</strong>三个阶段。</p><h4 id="CanCommit阶段"><a href="#CanCommit阶段" class="headerlink" title="CanCommit阶段"></a>CanCommit阶段</h4><p>3PC的CanCommit阶段其实和2PC的准备阶段很像。</p><ul><li><p>事务询问<br>协调者向参与者发送CanCommit请求。询问是否可以执行事务提交操作。然后开始等待参与者的响应；</p></li><li><p>响应反馈<br>参与者接到CanCommit请求之后，正常情况下，如果其自身认为可以顺利执行事务，则返回Yes响应，并进入预备状态。否则反馈No；</p></li></ul><h4 id="PreCommit阶段"><a href="#PreCommit阶段" class="headerlink" title="PreCommit阶段"></a>PreCommit阶段</h4><p>协调者根据参与者的反应情况来决定是否可以进行事务的PreCommit操作。根据响应情况，有以下两种可能：</p><ul><li><p>所有反馈都是Yes响应，那么就会执行事务的预执行：</p><ul><li><p>发送预提交请求<br>协调者向参与者发送PreCommit请求，并进入Prepared阶段；</p></li><li><p>事务预提交<br>参与者接收到PreCommit请求后，会执行事务操作，并将undo和redo信息记录到事务日志中；</p></li><li><p>响应反馈<br>如果参与者成功的执行了事务操作，则返回ACK响应，同时开始等待最终指令；</p></li></ul></li></ul><ul><li><p>任何一个参与者反馈了No响应，或者等待超时之后，协调者都没有接到参与者的响应，那么就执行事务的中断：</p><ul><li><p>发送中断请求<br>协调者向所有参与者发送abort请求；</p></li><li><p>中断事务<br>参与者收到来自协调者的abort请求之后（或超时之后，仍未收到协调者的请求），执行事务的中断；</p></li></ul></li></ul><h4 id="DoCommit阶段"><a href="#DoCommit阶段" class="headerlink" title="DoCommit阶段"></a>DoCommit阶段</h4><p>该阶段进行真正的事务提交，也可以分为以下两种情况：</p><ul><li><p>执行提交</p><ul><li><p>发送提交请求<br>协调接收到参与者发送的ACK响应，那么他将从预提交状态进入到提交状态。并向所有参与者发送doCommit请求；</p></li><li><p>事务提交<br>参与者接收到doCommit请求之后，执行正式的事务提交。并在完成事务提交之后释放所有事务资源；</p></li><li><p>响应反馈<br>事务提交完之后，向协调者发送Ack响应；</p></li><li><p>完成事务<br>协调者接收到所有参与者的ack响应之后，完成事务；</p></li></ul></li><li><p>中断事务<br>协调者没有接收到参与者发送的ACK响应（可能是接受者发送的不是ACK响应，也可能响应超时），那么就会执行中断事务：</p><ul><li><p>发送中断请求<br>协调者向所有参与者发送abort请求；</p></li><li><p>事务回滚<br>参与者接收到abort请求之后，利用其在阶段二记录的undo信息来执行事务的回滚操作，并在完成回滚之后释放所有的事务资源；</p></li><li><p>反馈结果<br>参与者完成事务回滚之后，向协调者发送ACK消息；</p></li><li><p>中断事务<br>协调者接收到参与者反馈的ACK消息之后，执行事务的中断；</p></li></ul></li></ul><h2 id="分布式事务模型"><a href="#分布式事务模型" class="headerlink" title="分布式事务模型"></a>分布式事务模型</h2><h3 id="XA协议"><a href="#XA协议" class="headerlink" title="XA协议"></a>XA协议</h3><p>最早的分布式事务模型是 X/Open 国际联盟提出的 X/Open Distributed Transaction Processing（DTP）模型，也就是大家常说的 X/Open XA 协议，简称 XA 协议。</p><p><img src="/images/xa_protocol.jpg" alt></p><p>DTP 模型中包含一个<strong>全局事务管理器</strong>（TM，Transaction Manager）和<strong>多个资源管理器</strong>（RM，Resource Manager）。</p><ul><li>全局事务管理器负责管理全局事务状态与参与的资源，协同资源一起提交或回滚；</li><li>资源管理器则负责具体的资源操作；</li></ul><p>XA 协议描述了 TM 与 RM 之间的接口，允许多个资源在同一分布式事务中访问。</p><h4 id="基于-DTP-模型的分布式事务流程"><a href="#基于-DTP-模型的分布式事务流程" class="headerlink" title="基于 DTP 模型的分布式事务流程"></a>基于 DTP 模型的分布式事务流程</h4><p><img src="/images/dtp_distributed_model.jpg" alt></p><ol><li><p>应用程序（AP，Application）向 TM 申请开始一个全局事务；</p></li><li><p>针对要操作的 RM，AP 会先向 TM 注册（TM 负责记录 AP 操作过哪些 RM，即分支事务），TM 通过 XA 接口函数通知相应 RM 开启分布式事务的子事务，接着 AP 就可以对该 RM 管理的资源进行操作；</p></li><li><p>当 AP 对所有 RM 操作完毕后，AP 根据执行情况通知 TM 提交或回滚该全局事务，TM 通过 XA 接口函数通知各 RM 完成操作。TM 会先要求各个 RM 做预提交，所有 RM 返回成功后，再要求各 RM 做正式提交，XA 协议要求，一旦 RM 预提交成功，则后续的正式提交也必须能成功；如果任意一个 RM 预提交失败，则 TM 通知各 RM 回滚；</p></li><li><p>所有 RM 提交或回滚完成后，全局事务结束。</p></li></ol><h4 id="XA模型ACID"><a href="#XA模型ACID" class="headerlink" title="XA模型ACID"></a>XA模型ACID</h4><ul><li><p>原子性<br>XA 协议使用 2PC（Two Phase Commit，两阶段提交）原子提交协议来保证分布式事务原子性。</p></li><li><p>隔离性<br>XA 协议中没有描述如何实现分布式事务的隔离性，但是 XA 协议要求 DTP 模型中的每个 RM 都要实现本地事务，也就是说，基于 XA 协议实现的分布式事务的隔离性是由每个 RM 本地事务的隔离性来保证的，当一个分布式事务的所有子事务都是隔离的，那么这个分布式事务天然的就实现了隔离性。</p></li><li><p>一致性<br>一致性有两层语义，一层是确保事务执行结束后，数据库从一个一致状态转变为另一个一致状态。另一层语义是事务执行过程中的中间状态不能被观察到。</p><p>  前一层语义的实现很简单，<strong>通过原子性、隔离性以及 RM 自身一致性的实现就可以保证</strong>。至于后一层语义，我们先来看看单个 RM 上的本地事务是怎么实现的。还是以 MySQL 举例，MySQL 通过 MVCC（Multi Version Concurrency Control，多版本并发控制）机制，为每个一致性状态生成快照（Snapshot），每个事务看到的都是各 Snapshot 对应的一致性状态，从而也就保证了本地事务的中间状态不会被观察到。</p><p>  很多分布式数据库都自己实现了分布式 MVCC 机制来提供全局的一致性读。一个基本思路是<strong>用一个集中式或者逻辑上单调递增的东西来控制生成全局 Snapshot，每个事务或者每条 SQL 执行时都去获取一次，从而实现不同隔离级别下的一致性</strong>。比如 Google 的 Spanner 就是用 TrueTime 来控制访问全局 Snapshot。</p></li></ul><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>XA 协议<strong>通常实现在数据库资源层，直接作用于资源管理器上</strong>。因此，基于 XA 协议实现的分布式事务产品，无论是分布式数据库，还是分布式事务框架，对业务几乎都没有侵入，就像使用普通数据库一样。</p><p>XA 协议严格保障事务 ACID 特性，能够满足所有业务领域的功能需求，但是，这同样是一把双刃剑。</p><p>由于隔离性的互斥要求，在事务执行过程中<strong>，所有的资源都被锁定，只适用于执行时间确定的短事务</strong>。同时，<strong>整个事务期间都是独占数据，对于热点数据的并发性能可能会很低</strong>，实现了分布式 MVCC 或乐观锁（optimistic locking）以后，性能可能会有所提升。</p><p>同时，为了保障一致性，要求所有 RM 同等可信、可靠，要求故障恢复机制可靠、快速，在网络故障隔离的情况下，服务基本不可用。</p><h3 id="TCC模型"><a href="#TCC模型" class="headerlink" title="TCC模型"></a>TCC模型</h3><p>TCC（Try-Confirm-Cancel）分布式事务模型相对于 XA 等传统模型，其特征在于它<strong>不依赖资源管理器</strong>（RM）对分布式事务的支持，而是<strong>通过对业务逻辑的分解来实现分布式事务</strong>。</p><p>TCC 模型认为对于业务系统中一个特定的业务逻辑，其对外提供服务时，必须接受一些不确定性，即<strong>对业务逻辑初步操作的调用仅是一个临时性操作，调用它的主业务服务保留了后续的取消权</strong>。如果主业务服务认为全局事务应该回滚，它会要求取消之前的临时性操作，这就对应从业务服务的取消操作。而当主业务服务认为全局事务应该提交时，它会放弃之前临时性操作的取消权，这对应从业务服务的确认操作。每一个初步操作，最终都会被确认或取消。</p><h4 id="三段业务逻辑"><a href="#三段业务逻辑" class="headerlink" title="三段业务逻辑"></a>三段业务逻辑</h4><p>针对一个具体的业务服务，TCC 分布式事务模型需要业务系统提供三段业务逻辑：</p><p><img src="/images/3_submit_protocol.jpg" alt></p><ul><li><p>（1）初步操作<strong>Try</strong>：完成所有业务检查，预留必须的业务资源；</p></li><li><p>（2）确认操作<strong>Confirm</strong>：真正执行的业务逻辑，不作任何业务检查，只使用 Try 阶段预留的业务资源。因此，只要 Try 操作成功，Confirm 必须能成功。另外，Confirm 操作需满足幂等性，保证一笔分布式事务有且只能成功一次；</p></li><li><p>（3）取消操作<strong>Cancel</strong>：释放 Try 阶段预留的业务资源。同样的，Cancel 操作也需要满足幂等性；</p></li></ul><p>TCC 分布式事务模型包括三部分：</p><p><strong>1. 主业务服务：</strong> 主业务服务为整个业务活动的发起方，服务的编排者，负责发起并完成整个业务活动；</p><p><strong>2. 从业务服务：</strong> 从业务服务是整个业务活动的参与方，负责提供 TCC 业务操作，实现初步操作（Try）、确认操作（Confirm）、取消操作（Cancel）三个接口，供主业务服务调用；</p><p><strong>3. 业务活动管理器：</strong> 业务活动管理器管理控制整个业务活动，包括记录维护 TCC 全局事务的事务状态和每个从业务服务的子事务状态，并在业务活动提交时调用所有从业务服务的 Confirm 操作，在业务活动取消时调用所有从业务服务的 Cancel 操作。</p><h4 id="完整的TCC分布式事务流程"><a href="#完整的TCC分布式事务流程" class="headerlink" title="完整的TCC分布式事务流程"></a>完整的TCC分布式事务流程</h4><ol><li><p>主业务服务首先开启本地事务；</p></li><li><p>主业务服务向业务活动管理器申请启动分布式事务主业务活动；</p></li><li><p>然后针对要调用的从业务服务，主业务活动先向业务活动管理器注册从业务活动，然后调用从业务服务的 Try 接口；</p></li><li><p>当所有从业务服务的 Try 接口调用成功，主业务服务提交本地事务；若调用失败，主业务服务回滚本地事务；</p></li><li><p>若主业务服务提交本地事务，则 TCC 模型分别调用所有从业务服务的 Confirm 接口；若主业务服务回滚本地事务，则分别调用 Cancel 接口；</p></li><li><p>所有从业务服务的 Confirm 或 Cancel 操作完成后，全局事务结束。</p></li></ol><h4 id="TCC模型ACID"><a href="#TCC模型ACID" class="headerlink" title="TCC模型ACID"></a>TCC模型ACID</h4><ul><li><p>原子性<br>TCC 模型也使用 2PC 原子提交协议来保证事务原子性。Try 操作对应 2PC 的一阶段准备（Prepare）；Confirm 对应 2PC 的二阶段提交（Commit），Cancel 对应 2PC 的二阶段回滚（Rollback），可以说 TCC 就是应用层的 2PC。</p></li><li><p>隔离性<br>TCC 分布式事务模型仅提供两阶段原子提交协议，保证分布式事务原子性。事务的隔离交给业务逻辑来实现。</p></li><li><p>一致性<br>再来看看 TCC 分布式事务模型下的一致性实现。与 XA 协议实现一致性第一层语义类似，通过原子性保证事务的原子提交、业务隔离性控制事务的并发访问，实现分布式事务的一致性状态转变。</p></li></ul><h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>TCC 分布式事务模型的业务实现特性决定了其<strong>可以跨 DB、跨服务实现资源管理</strong>，将对不同的 DB 访问、不同的业务操作通过 TCC 模型协调为一个原子操作，解决了分布式应用架构场景下的事务问题。</p><p>TCC 模型<strong>通过 2PC 原子提交协议保证分布式事务的的原子性，把资源层的隔离性上升到业务层，交给业务逻辑来实现。TCC 的每个操作对于资源层来说，就是单个本地事务的使用，操作结束则本地事务结束，规避了资源层在 2PC 和 2PL 下对资源占用导致的性能低下问题</strong>。</p><p>同时，TCC 模型也可以根据业务需要，做一些定制化的功能，比如交易异步化实现削峰填谷等。</p><p>但是，业务接入 TCC 模型需要拆分业务逻辑成两个阶段，并实现 Try、Confirm、Cancel 三个接口，定制化程度高，开发成本高。</p><h2 id="常用解决方案"><a href="#常用解决方案" class="headerlink" title="常用解决方案"></a>常用解决方案</h2><h3 id="基于MQ的分布式事务"><a href="#基于MQ的分布式事务" class="headerlink" title="基于MQ的分布式事务"></a>基于MQ的分布式事务</h3><p>通过消息中间件来实现。假设有A和B两个系统，分别可以处理任务A和任务B。此时系统A中存在一个业务流程，需要将任务A和任务B在同一个事务中处理。下面来介绍基于消息中间件来实现这种分布式事务。</p><blockquote><p>尽量选择支持事务型消息的消息中间件来实现分布式事务，如RocketMQ</p></blockquote><p><img src="/images/tx_rocket_mq1.jpg" alt></p><p>具体流程:</p><ul><li><p>在系统A处理任务A前，首先向消息中间件发送一条消息;</p></li><li><p>消息中间件收到后将该条消息持久化，但并不投递。此时下游系统B仍然不知道该条消息的存在;</p></li><li><p>消息中间件持久化成功后，便向系统A返回一个确认应答；</p></li><li><p>系统A收到确认应答后，则可以开始处理任务A；</p></li><li><p>任务A处理完成后，向消息中间件发送Commit请求。该请求发送完成后，对系统A而言，该事务的处理过程就结束了，此时它可以处理别的任务了；但commit消息可能会在传输途中丢失，从而消息中间件并不会向系统B投递这条消息，从而系统就会出现不一致性。这个问题由<strong>消息中间件的事务回查机制</strong>完成；</p></li><li><p>消息中间件收到Commit指令后，便向系统B投递该消息，从而触发任务B的执行；</p></li><li><p>当任务B执行完成后，系统B向消息中间件返回一个确认应答，告诉消息中间件该消息已经成功消费，此时，这个分布式事务完成。</p></li></ul><p>在上述过程中：</p><blockquote><ul><li>消息中间件扮演者分布式事务协调者的角色；</li></ul></blockquote><blockquote><ul><li>系统A完成任务A后，到任务B执行完成之间，会存在一定的时间差。在这个时间差内，整个系统处于数据不一致的状态，但这短暂的不一致性是可以接受的，因为经过短暂的时间后，系统又可以保持数据一致性，满足BASE理论；</li></ul></blockquote><h4 id="任务A处理失败-回滚"><a href="#任务A处理失败-回滚" class="headerlink" title="任务A处理失败-回滚"></a>任务A处理失败-回滚</h4><p><img src="/images/tx_rocket_mq2.jpg" alt></p><ul><li><p>若系统A在处理任务A时失败，那么就会向消息中间件发送Rollback请求。和发送Commit请求一样，系统A发完之后便可以认为回滚已经完成，它便可以去做其他的事情。</p></li><li><p>消息中间件收到回滚请求后，直接将该消息丢弃，而不投递给系统B，从而不会触发系统B的任务B。</p></li></ul><p>此时系统又处于一致性状态，因为任务A和任务B都没有执行。</p><h4 id="Commit和Rollback指令丢失"><a href="#Commit和Rollback指令丢失" class="headerlink" title="Commit和Rollback指令丢失"></a>Commit和Rollback指令丢失</h4><p>在实际系统中，Commit和Rollback指令都有可能在传输途中丢失。那么当出现这种情况的时候，消息中间件是如何保证数据一致性呢？——答案就是<strong>超时询问机制</strong></p><p><img src="/images/tx_rocket_mq3.jpg" alt></p><p>系统A除了实现正常的业务流程外，还需提供一个<strong>事务询问</strong>的接口，供消息中间件调用。</p><p>当消息中间件收到一条事务型消息后便开始计时，如果到了超时时间也没收到系统A发来的Commit或Rollback指令的话，就会<strong>主动调用系统A提供的事务询问接口询问该系统目前的状态</strong>。该接口会返回三种结果：</p><ul><li><strong>提交</strong>  若获得的状态是“提交”，则将该消息投递给系统B；</li><li><strong>回滚</strong>  若获得的状态是“回滚”，则直接将条消息丢弃；</li><li><strong>处理中</strong> 若获得的状态是“处理中”，则继续等待。</li></ul><p><strong>消息中间件的超时询问机制能够防止上游系统因在传输过程中丢失Commit/Rollback指令而导致的系统不一致情况，而且能降低上游系统的阻塞时间</strong>，上游系统只要发出Commit/Rollback指令后便可以处理其他任务，无需等待确认应答。而Commit/Rollback指令丢失的情况通过超时询问机制来弥补，这样大大降低上游系统的阻塞时间，提升系统的并发度。</p><h4 id="保证可靠消费"><a href="#保证可靠消费" class="headerlink" title="保证可靠消费"></a>保证可靠消费</h4><p>当上游系统执行完任务并向消息中间件提交了Commit指令后，便可以处理其他任务了，此时它可以认为事务已经完成，接下来消息中间件<strong>一定会保证消息被下游系统成功消费掉！</strong> 那么这是怎么做到的呢？这<strong>由消息中间件的投递流程</strong>来保证。</p><p><strong>等待下游ACK</strong><br>消息中间件向下游系统投递完消息后便进入阻塞等待状态，下游系统便立即进行任务的处理，任务处理完成后便向消息中间件返回应答。消息中间件收到确认应答后便认为该事务处理完毕！</p><p>如果消息在投递过程中丢失，或消息的确认应答在返回途中丢失，那么消息中间件在等待确认应答超时之后就会<strong>重新投递</strong>，直到下游消费者返回消费成功响应为止。</p><p><img src="/images/tx_rocket_mq4.jpg" alt></p><p><img src="/images/tx_rocket_mq5.jpg" alt></p><p>当然，一般消息中间件可以设置消息重试的次数和时间间隔，比如：当第一次投递失败后，每隔五分钟重试一次，一共重试3次。如果重试3次之后仍然投递失败，那么这条消息就需要人工干预。</p><h4 id="消息投递失败后为什么不回滚消息"><a href="#消息投递失败后为什么不回滚消息" class="headerlink" title="消息投递失败后为什么不回滚消息"></a>消息投递失败后为什么不回滚消息</h4><p>消息投递失败后为什么不回滚消息，而是不断尝试重新投递？</p><p>这就涉及到整套分布式事务系统的实现成本问题。<br>我们知道，当系统A将向消息中间件发送Commit指令后，它便去做别的事情了。如果此时消息投递失败，需要回滚的话，就需要让系统A事先提供回滚接口，这无疑增加了额外的开发成本，业务系统的复杂度也将提高。对于一个业务系统的设计目标是，在保证性能的前提下，最大限度地降低系统复杂度，从而能够降低系统的运维成本。</p><p>另外一方面，常见的购物网站，一旦付款成功，没有理由回滚到下单失败，即使出了问题，也会想办法保证订单成功。</p><h4 id="问题思考"><a href="#问题思考" class="headerlink" title="问题思考"></a>问题思考</h4><p>上游系统A向消息中间件提交Commit/Rollback消息采用的是异步方式，也就是当上游系统提交完消息后便可以去做别的事情，接下来提交、回滚就完全交给消息中间件来完成，并且完全信任消息中间件，认为它一定能正确地完成事务的提交或回滚。</p><p>然而，消息中间件向下游系统投递消息的过程是同步的。也就是消息中间件将消息投递给下游系统后，它会阻塞等待，等下游系统成功处理完任务返回确认应答后才取消阻塞等待。为什么这两者在设计上是不一致的呢？</p><ul><li><p>上游系统和消息中间件之间采用异步通信</p><blockquote><p>上游系统和消息中间件之间采用异步通信是为了提高系统并发度。</p><p>业务系统直接和用户打交道，用户体验尤为重要，因此这种异步通信方式能够极大程度地降低用户等待时间。</p><p>此外，异步通信相对于同步通信而言，没有了长时间的阻塞等待，因此系统的并发性也大大增加。</p><p>但异步通信可能会引起Commit/Rollback指令丢失的问题，这就由消息中间件的超时询问机制来弥补。</p></blockquote></li><li><p>消息中间件和下游系统之间采用同步通信</p><blockquote><p>异步能提升系统性能，但随之会增加系统复杂度；</p><p>而同步虽然降低系统并发度，但实现成本较低。</p><p>因此，在对并发度要求不是很高的情况下，或者服务器资源较为充裕的情况下，我们可以选择同步来降低系统的复杂度。</p><p>消息中间件是一个独立于业务系统的第三方中间件，它不和任何业务系统产生直接的耦合，它也不和用户产生直接的关联，它一般部署在独立的服务器集群上，具有良好的可扩展性，所以不必太过于担心它的性能，如果处理速度无法满足我们的要求，可以增加机器来解决。</p><p>而且，即使消息中间件处理速度有一定的延迟那也是可以接受的，因为前面所介绍的BASE理论就告诉我们了，我们追求的是最终一致性，而非实时一致性，因此消息中间件产生的时延导致事务短暂的不一致是可以接受的。</p></blockquote></li></ul><h3 id="本地消息表"><a href="#本地消息表" class="headerlink" title="本地消息表"></a>本地消息表</h3><p>本地消息表这个方案最初是ebay提出的<a href="https://queue.acm.org/detail.cfm?id=1394128" target="_blank" rel="noopener">ebay的完整方案</a>。</p><p>此方案的核心是<strong>将需要分布式处理的任务通过消息日志的方式来异步执行</strong>。<br>消息日志可以存储到本地文本、数据库或消息队列，再通过业务规则自动或人工发起重试。人工重试更多的是应用于支付场景，通过对账系统对事后问题的处理。<br><img src="/images/tx_local_table.jpg" alt></p><p>对于不支持事务型消息的消息中间件，如果要实现分布式事务的话，就可以采用这种方式。它能够通过<strong>重试机制+定期校对</strong>实现分布式事务最终一致性。</p><h3 id="Saga事务"><a href="#Saga事务" class="headerlink" title="Saga事务"></a>Saga事务</h3><p>其核心思想是将长事务拆分为多个本地短事务，由Saga事务协调器协调，如果正常结束那就正常完成，如果某个步骤失败，则根据相反顺序一次调用补偿操作。</p><p>Saga的组成：</p><ul><li><p>每个Saga由一系列<strong>sub-transaction</strong> <code>Ti</code> 组成;</p></li><li><p>每个Ti 都有对应的补偿动作Ci，补偿动作用于撤销Ti造成的结果, 这里的每个T，都是一个本地事务;</p></li></ul><p>可以看到，和TCC相比，Saga没有“预留 try”动作，它的Ti就是直接提交到库。</p><p>Saga的执行顺序有两种：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">T1, T2, T3, ..., Tn</span><br><span class="line"></span><br><span class="line">T1, T2, ..., Tj, Cj,..., C2, C1，其中0 &lt; j &lt; n</span><br></pre></td></tr></table></figure><p>Saga定义了两种恢复策略：</p><ul><li><p>向后恢复<br>即上面提到的第二种执行顺序，其中j是发生错误的sub-transaction，这种做法的效果是撤销掉之前所有成功的sub-transation，使得整个Saga的执行结果撤销;</p></li><li><p>向前恢复<br>适用于必须要成功的场景，执行顺序是类似于这样的：<code>T1, T2, ..., Tj(失败), Tj(重试),..., Tn</code>，其中j是发生错误的sub-transaction。该情况下不需要Ci。</p></li></ul><p><strong>注意</strong><br>在saga模式中不能保证隔离性，因为没有锁住资源，其他事务依然可以覆盖或者影响当前事务。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://juejin.im/post/5aa3c7736fb9a028bb189bca" target="_blank" rel="noopener">常用的分布式事务解决方案</a></p><p><a href="https://www.infoq.cn/article/g1avP9FUA6CDOYRAlv4R" target="_blank" rel="noopener">一篇文章带你学习分布式事务</a></p><p><a href="https://juejin.im/post/5b5a0bf9f265da0f6523913b#heading-12" target="_blank" rel="noopener">再有人问你分布式事务，把这篇扔给他</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;事务&quot;&gt;&lt;a href=&quot;#事务&quot; class=&quot;headerlink&quot; title=&quot;事务&quot;&gt;&lt;/a&gt;事务&lt;/h2&gt;&lt;p&gt;数据库事务（简称：事务，Transaction）是指数据库执行过程中的一个逻辑单位，由一个有限的数据库操作序列构成。&lt;/p&gt;
&lt;p&gt;事务拥有
      
    
    </summary>
    
      <category term="分布式" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="事务" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E4%BA%8B%E5%8A%A1/"/>
    
    
      <category term="分布式事务" scheme="http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    
      <category term="XA" scheme="http://yoursite.com/tags/XA/"/>
    
  </entry>
  
  <entry>
    <title>Shell常用脚本整理</title>
    <link href="http://yoursite.com/2020/03/20/Shell%E5%B8%B8%E7%94%A8%E8%84%9A%E6%9C%AC%E6%95%B4%E7%90%86/"/>
    <id>http://yoursite.com/2020/03/20/Shell常用脚本整理/</id>
    <published>2020-03-20T09:22:14.000Z</published>
    <updated>2020-03-23T03:10:05.587Z</updated>
    
    <content type="html"><![CDATA[<h2 id="读取文件每一行"><a href="#读取文件每一行" class="headerlink" title="读取文件每一行"></a>读取文件每一行</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 方法1</span></span><br><span class="line">while read line</span><br><span class="line">do</span><br><span class="line">    echo $line</span><br><span class="line">done &lt; filename(待读取的文件)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 方法2</span></span><br><span class="line">cat filename(待读取的文件) | while read line</span><br><span class="line">do</span><br><span class="line">    echo $line</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 方法3</span></span><br><span class="line">for line in `cat filename(待读取的文件)`</span><br><span class="line">do</span><br><span class="line">    echo $line</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h2 id="变量自增"><a href="#变量自增" class="headerlink" title="变量自增"></a>变量自增</h2><p>写循环时，常常要用到变量的自增，现在总结一下整型变量自增的方法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">i=`expr $i + 1`</span><br><span class="line"></span><br><span class="line">let i+=1;</span><br><span class="line"></span><br><span class="line">((i++));</span><br><span class="line"></span><br><span class="line">i=$[$i+1];</span><br><span class="line"></span><br><span class="line">i=$(( $i + 1 ))</span><br></pre></td></tr></table></figure><h2 id="字符串去空格"><a href="#字符串去空格" class="headerlink" title="字符串去空格"></a>字符串去空格</h2><p>（1）去行首空格</p><pre><code>sed &apos;s/^[ \t]*//g&apos;</code></pre><p>（2）去行尾空格</p><pre><code>sed &apos;s/[ \t]*$//g&apos;</code></pre><p>（3）去所有空格</p><pre><code>sed &apos;s/[[:space:]]//g&apos;</code></pre><h2 id="shell参数扩展"><a href="#shell参数扩展" class="headerlink" title="shell参数扩展"></a>shell参数扩展</h2><ul><li><p>如果parameter为null或者未设置，整个参数替换表达式值为word   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;parameter:-word&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果parameter为null或者未设置，整个参数替换表达式值为word，并且parameter参数值设置为word   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;parameter:=word&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果parameter为null或者未设置，则打印出错误信息。否则，整个参数替换表达式值为$parameter  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;parameter:?word&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果parameter不为null或者未设置，则整个参数替换表达式值为word  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;parameter:+word&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li>获得字符串的长度   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;#parameter&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>从尾开始扫描word，将匹配word正则表达式的字符过滤掉, %为最短匹配，%%为最长匹配       </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$&#123;parameter%word&#125;</span><br><span class="line">$&#123;parameter%%word&#125;</span><br></pre></td></tr></table></figure></li><li><p>从头开始扫描word，将匹配word正则表达的字符过滤掉, #为最短匹配，##为最长匹配   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$&#123;parameter#word&#125;</span><br><span class="line">$&#123;parameter##word&#125;</span><br></pre></td></tr></table></figure></li><li><p>截取字符串,截取parameter的值的子字符串   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$&#123;parameter:offset&#125;   从offset到结束</span><br><span class="line">$&#123;parameter:offset:length&#125;   从offset开始截取length个</span><br></pre></td></tr></table></figure></li><li><p>字符串替换，将parameter对应值的pattern字符串替换成为string字符串, /表示只替换一次，//表示全部替换   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$&#123;parameter/pattern/string&#125;</span><br><span class="line">$&#123;parameter//pattern/string&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Supervise进程监控"><a href="#Supervise进程监控" class="headerlink" title="Supervise进程监控"></a>Supervise进程监控</h2><p>supervise   监控进程，如果挂了，重启进程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-p,  状态路径，supervise运行时会在该路径下保存一些文件</span><br><span class="line">-f,   启动新的进程命令</span><br><span class="line">-F,   配置文件路径 the config file path, if not given, supervise will use the default value &quot;supervise.conf&quot;</span><br><span class="line">-r,   while the service exits, supervise will excute the program RESTART_SH before restart the service, and the exiting times be passed          to RESTART_SH as the only argument.</span><br><span class="line"> -t,   after TIME_LIMIT seconds, the counter for the exiting times will be reset.</span><br><span class="line"> -v,  print the version of supervise and exit.</span><br><span class="line"> -h,  print the help message and exit.</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">supervise -p ../supervise/status/hdfs-dumper -f &quot;sh ./control.sh start&quot; -F ../supervise/conf/supervise.conf</span><br></pre></td></tr></table></figure><h2 id="远程操作"><a href="#远程操作" class="headerlink" title="远程操作"></a>远程操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">LIST_FILE=hdfsdumper.num.list</span><br><span class="line"></span><br><span class="line">size=`cat ./$LIST_FILE | wc -l`</span><br><span class="line"></span><br><span class="line">line_index=1</span><br><span class="line">while [ $line_index -le $size ]</span><br><span class="line">do</span><br><span class="line">    machine=`cat ./$LIST_FILE | sed -n -e &quot;$&#123;line_index&#125;p&quot; | awk -F&apos; &apos; &apos;&#123;print $1&#125;&apos;`</span><br><span class="line">    number=`cat ./$LIST_FILE | sed -n -e &quot;$&#123;line_index&#125;p&quot; | awk -F&apos; &apos; &apos;&#123;print $2&#125;&apos;`</span><br><span class="line">    nohup expect -c &quot;</span><br><span class="line">        spawn ssh root@$machine;</span><br><span class="line">        expect &#123;</span><br><span class="line">        \&quot;Are you sure you want to continue connecting (yes/no)? \&quot; &#123;send \&quot;yes\r\&quot;;exp_continue&#125;</span><br><span class="line">        \&quot;*password: \&quot; &#123;send \&quot;password\n \&quot;; exp_continue&#125;</span><br><span class="line">        \&quot;]# \&quot; &#123;send \&quot;su work; exit\n\&quot;; exp_continue&#125;</span><br><span class="line">        \&quot;bash-4.1$*\&quot; &#123;send \&quot;cd /home/work/xxx &amp;&amp; sh control.sh start; exit\n\&quot;; exp_continue&#125;</span><br><span class="line">        \&quot;]$ \&quot; &#123;send \&quot;cd /home/work/xxx &amp;&amp; sh control.sh start; exit\n\&quot;; exp_continue&#125;</span><br><span class="line">        &#125;&quot; &amp;</span><br><span class="line">    line_index=`expr $line_index + 1`</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h2 id="远程同步文件"><a href="#远程同步文件" class="headerlink" title="远程同步文件"></a>远程同步文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">LIST_FILE=hdfsdumper.num.list</span><br><span class="line"></span><br><span class="line">size=`cat ./$LIST_FILE | wc -l`</span><br><span class="line"></span><br><span class="line">file_name=./dumper/jdk.tar.gz</span><br><span class="line"></span><br><span class="line">line_index=1</span><br><span class="line">while [ $line_index -le $size ]</span><br><span class="line">do</span><br><span class="line">    machine=`cat ./$LIST_FILE | sed -n -e &quot;$&#123;line_index&#125;p&quot; | awk -F&apos; &apos; &apos;&#123;print $1&#125;&apos;`</span><br><span class="line">    number=`cat ./$LIST_FILE | sed -n -e &quot;$&#123;line_index&#125;p&quot; | awk -F&apos; &apos; &apos;&#123;print $2&#125;&apos;`</span><br><span class="line">    expect -c &quot;</span><br><span class="line">        spawn rsync -avz $file_name root@$machine:/home/work/opencrawler</span><br><span class="line">        expect &#123;</span><br><span class="line">        \&quot;Are you sure you want to continue connecting (yes/no)? \&quot; &#123;send \&quot;yes\r\&quot;;exp_continue&#125;</span><br><span class="line">        \&quot;*password: \&quot; &#123;send \&quot;password\n \&quot;; interact&#125;; &#125;&quot;;</span><br><span class="line">    line_index=`expr $line_index + 1`</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h2 id="switch-case"><a href="#switch-case" class="headerlink" title="switch case"></a>switch case</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">cmd=$1</span><br><span class="line">case $cmd in</span><br><span class="line">start)</span><br><span class="line">    echo &quot;in start command.&quot;</span><br><span class="line">    if [ -f &quot;running_tag.txt&quot; ];then</span><br><span class="line">        echo &quot;running_tag file is exist, already running!&quot;</span><br><span class="line">        exit 1</span><br><span class="line">    fi  </span><br><span class="line">    nohup java -Xms1000m -Xmx1000m -Xmn500m -XX:+UseParallelGC $&#123;MAIN_CLASSNAME&#125; &gt;&gt;log/crontabservice_terminal.log 2&gt;&amp;1 &amp;</span><br><span class="line">    ret=$?</span><br><span class="line">    if [ $ret -eq 0 ];then</span><br><span class="line">        echo &quot;start [OK].&quot;</span><br><span class="line">    else</span><br><span class="line">        echo &quot;start [FAILED].&quot;</span><br><span class="line">    fi</span><br><span class="line">    ;;</span><br><span class="line">stop)</span><br><span class="line">    echo &quot;in stop command.&quot;</span><br><span class="line">    ret=`ps aux | grep &quot;$&#123;MAIN_CLASSNAME&#125;&quot; | grep -v &quot;grep&quot; | awk &apos;&#123;print $2&#125;&apos;`</span><br><span class="line">    if [ ! $ret ];then</span><br><span class="line">        echo &quot;MODULE:$&#123;MAIN_CLASSNAME&#125; not started.&quot;</span><br><span class="line">        exit 1</span><br><span class="line">    fi</span><br><span class="line">    echo &quot;pid:$ret&quot;</span><br><span class="line">    kill -9 $ret</span><br><span class="line">    if [ $? -eq 0 ];then</span><br><span class="line">        rm -f running_tag.txt</span><br><span class="line">    fi</span><br><span class="line">    rm -f running_tag.txt</span><br><span class="line">    echo &quot;Stop [OK].&quot;</span><br><span class="line">    ;;</span><br><span class="line">*)</span><br><span class="line">    help</span><br><span class="line">    exit 1</span><br><span class="line">    ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;读取文件每一行&quot;&gt;&lt;a href=&quot;#读取文件每一行&quot; class=&quot;headerlink&quot; title=&quot;读取文件每一行&quot;&gt;&lt;/a&gt;读取文件每一行&lt;/h2&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=
      
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="脚本" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/%E8%84%9A%E6%9C%AC/"/>
    
    
      <category term="脚本" scheme="http://yoursite.com/tags/%E8%84%9A%E6%9C%AC/"/>
    
      <category term="Shell" scheme="http://yoursite.com/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>Python常用脚本整理</title>
    <link href="http://yoursite.com/2020/03/20/Python%E5%B8%B8%E7%94%A8%E8%84%9A%E6%9C%AC%E6%95%B4%E7%90%86/"/>
    <id>http://yoursite.com/2020/03/20/Python常用脚本整理/</id>
    <published>2020-03-20T08:42:00.000Z</published>
    <updated>2020-03-20T09:53:45.234Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Log日志"><a href="#Log日志" class="headerlink" title="Log日志"></a>Log日志</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">标准日志配置</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> logging.handlers</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init_log</span><span class="params">(log_path, level=logging.INFO, when=<span class="string">"D"</span>, backup=<span class="number">7</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">             format=<span class="string">"%(levelname)s: %(asctime)s: %(filename)s:%(lineno)d %(message)s"</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">             datefmt=<span class="string">"%m-%d %H:%M:%S"</span>)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    init_log - initialize log module</span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">      log_path      - Log file path prefix.</span></span><br><span class="line"><span class="string">                      Log data will go to two files: log_path.log and log_path.log.wf</span></span><br><span class="line"><span class="string">                      Any non-exist parent directories will be created automatically</span></span><br><span class="line"><span class="string">      level         - msg above the level will be displayed</span></span><br><span class="line"><span class="string">                      DEBUG &lt; INFO &lt; WARNING &lt; ERROR &lt; CRITICAL</span></span><br><span class="line"><span class="string">                      the default value is logging.INFO</span></span><br><span class="line"><span class="string">      when          - how to split the log file by time interval</span></span><br><span class="line"><span class="string">                      'S' : Seconds</span></span><br><span class="line"><span class="string">                      'M' : Minutes</span></span><br><span class="line"><span class="string">                      'H' : Hours</span></span><br><span class="line"><span class="string">                      'D' : Days</span></span><br><span class="line"><span class="string">                      'W' : Week day</span></span><br><span class="line"><span class="string">                      default value: 'D'</span></span><br><span class="line"><span class="string">      format        - format of the log</span></span><br><span class="line"><span class="string">                      default format:</span></span><br><span class="line"><span class="string">                      %(levelname)s: %(asctime)s: %(filename)s:%(lineno)d * %(thread)d %(message)s</span></span><br><span class="line"><span class="string">                      INFO: 12-09 18:02:42: log.py:40 * 139814749787872 HELLO WORLD</span></span><br><span class="line"><span class="string">      backup        - how many backup file to keep</span></span><br><span class="line"><span class="string">                      default value: 7</span></span><br><span class="line"><span class="string">    Raises:</span></span><br><span class="line"><span class="string">        OSError: fail to create log directories</span></span><br><span class="line"><span class="string">        IOError: fail to open log file</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    formatter = logging.Formatter(format, datefmt)</span><br><span class="line">    logger = logging.getLogger()</span><br><span class="line">    logger.setLevel(level)</span><br><span class="line">    dir = os.path.dirname(log_path)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.isdir(dir):</span><br><span class="line">        os.makedirs(dir)</span><br><span class="line">    handler = logging.handlers.TimedRotatingFileHandler(log_path + <span class="string">".log"</span>,</span><br><span class="line">                                                        when=when,</span><br><span class="line">                                                        backupCount=backup)</span><br><span class="line">    handler.setLevel(level)</span><br><span class="line">    handler.setFormatter(formatter)</span><br><span class="line">    logger.addHandler(handler)</span><br><span class="line">    handler = logging.handlers.TimedRotatingFileHandler(log_path + <span class="string">".log.wf"</span>,</span><br><span class="line">                                                        when=when,</span><br><span class="line">                                                        backupCount=backup)</span><br><span class="line">    handler.setLevel(logging.WARNING)</span><br><span class="line">    handler.setFormatter(formatter)</span><br><span class="line">    logger.addHandler(handler)</span><br></pre></td></tr></table></figure><p>日志初始化样例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> log</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">初始化日志配置</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">cur_time = os.popen(<span class="string">"date +%Y%m%d"</span>).read().strip()</span><br><span class="line">log_path = <span class="string">"./log/sample"</span> + cur_time</span><br><span class="line">log.init_log(log_path)</span><br></pre></td></tr></table></figure><h2 id="Http请求"><a href="#Http请求" class="headerlink" title="Http请求"></a>Http请求</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> urllib2</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">reload(sys)</span><br><span class="line">sys.setdefaultencoding(<span class="string">'utf8'</span>)</span><br><span class="line"><span class="keyword">import</span> __init__</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line">TIME_OUT = <span class="number">60</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getHeader</span><span class="params">(request, headers)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    组装header</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> headers:</span><br><span class="line">        request.add_header(k, headers[k.strip()])</span><br><span class="line">    <span class="keyword">return</span> request</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(url, headers=&#123;&#125;)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    headers : &#123; 'User-Agent' : user_agent &#125;  字典</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        request = urllib2.Request(url)</span><br><span class="line">        request = getHeader(request, headers)</span><br><span class="line">        response = urllib2.urlopen(request, timeout=TIME_OUT)</span><br><span class="line">        result = response.read().encode(<span class="string">'utf-8'</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">except</span> Exception, e:</span><br><span class="line">        logging.error(str(e))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(url, headers, body)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    headers : &#123; 'User-Agent' : user_agent &#125;  字典</span></span><br><span class="line"><span class="string">    body : String 通过header中的Content-Type来表示解析类型</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        request = urllib2.Request(url)</span><br><span class="line">        request = getHeader(request, headers)</span><br><span class="line">        request.get_method = <span class="keyword">lambda</span>: <span class="string">'POST'</span></span><br><span class="line">        <span class="keyword">if</span> body <span class="keyword">and</span> body != <span class="string">"&#123;&#125;"</span>:</span><br><span class="line">            request.add_data(body)</span><br><span class="line">        response = urllib2.urlopen(request, timeout=TIME_OUT)</span><br><span class="line">        result = response.read().encode(<span class="string">'utf-8'</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        logging.error(str(e))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(url, headers)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    headers : &#123; 'User-Agent' : user_agent &#125;  字典</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        request = urllib2.Request(url)</span><br><span class="line">        request = getHeader(request, headers)</span><br><span class="line">        request.get_method = <span class="keyword">lambda</span>: <span class="string">'DELETE'</span></span><br><span class="line">        response = urllib2.urlopen(request, timeout=TIME_OUT)</span><br><span class="line">        result = response.read().encode(<span class="string">'utf-8'</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">except</span> Exception, e:</span><br><span class="line">        logging.error(str(e))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><h2 id="Mysql连接"><a href="#Mysql连接" class="headerlink" title="Mysql连接"></a>Mysql连接</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> MySQLdb</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exe_sql</span><span class="params">(sql, type=<span class="number">0</span>)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    返回结果为元组格式</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        conn = MySQLdb.connect(host, user, passwd, db, port)</span><br><span class="line">        cur = conn.cursor()</span><br><span class="line">        cur.execute(sql)</span><br><span class="line">        results = cur.fetchall()</span><br><span class="line">        conn.commit()</span><br><span class="line">        cur.close()</span><br><span class="line">        conn.close()</span><br><span class="line">        <span class="keyword">return</span> results</span><br><span class="line">    <span class="keyword">except</span> MySQLdb.Error, e:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Mysql Error %d: %s"</span> % (e.args[<span class="number">0</span>], e.args[<span class="number">1</span>])</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exe_sql_return_dict</span><span class="params">(sql, type=<span class="number">0</span>)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    返回结果为字典格式</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        conn = MySQLdb.connect(host, user, passwd, db, port)</span><br><span class="line">        cur = conn.cursor(MySQLdb.cursors.DictCursor)</span><br><span class="line">        cur.execute(sql)</span><br><span class="line">        results = cur.fetchall()</span><br><span class="line">        conn.commit()</span><br><span class="line">        cur.close()</span><br><span class="line">        conn.close()</span><br><span class="line">        <span class="keyword">return</span> results</span><br><span class="line">    <span class="keyword">except</span> MySQLdb.Error, e:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Mysql Error %d: %s"</span> % (e.args[<span class="number">0</span>], e.args[<span class="number">1</span>])</span><br></pre></td></tr></table></figure><h2 id="Main函数"><a href="#Main函数" class="headerlink" title="Main函数"></a>Main函数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys </span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line">reload(sys)</span><br><span class="line">sys.setdefaultencoding(<span class="string">'utf8'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> sys.stdin:</span><br><span class="line">        <span class="keyword">print</span> line.strip()</span><br></pre></td></tr></table></figure><h2 id="Write文件"><a href="#Write文件" class="headerlink" title="Write文件"></a>Write文件</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_to_file</span><span class="params">(filepath, content, mode=<span class="string">"a+"</span>)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    写入文件</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">with</span> open(filepath, mode) <span class="keyword">as</span> fw:</span><br><span class="line">        <span class="comment"># fw.write(content + "\n")</span></span><br><span class="line">        fw.write(content)</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_pretty</span><span class="params">(filepath, content)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    写带缩进json内容到文件</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">with</span> open(filepath, <span class="string">'at'</span>) <span class="keyword">as</span> fw:</span><br><span class="line">        res = json.dump(content, fw, sort_keys=<span class="literal">True</span>, indent=<span class="number">4</span>, separators=(<span class="string">','</span>, <span class="string">': '</span>))</span><br></pre></td></tr></table></figure><h2 id="Read配置"><a href="#Read配置" class="headerlink" title="Read配置"></a>Read配置</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">读取配置文件</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span> ConfigParser</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> log</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parser</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    读取配置文件</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, configfile)</span>:</span></span><br><span class="line">        self.cf  = ConfigParser.ConfigParser()</span><br><span class="line">        self.cf.read(configfile)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_all_sections</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        获取所有的section</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        secs = self.cf.sections()</span><br><span class="line">        <span class="keyword">return</span> secs</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">list_options</span><span class="params">(self, section)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        获取某个section中所有的key</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        opts = self.cf.options(section)</span><br><span class="line">        <span class="keyword">return</span> opts</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_key</span><span class="params">(self, section, key)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        根据section和key获取value</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            value = self.cf.get(section, key)</span><br><span class="line">            <span class="keyword">if</span> value:</span><br><span class="line">                <span class="keyword">return</span> value</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            logging.error(key + <span class="string">" in "</span> + section + <span class="string">" does't exist!"</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    conf = Parser(<span class="string">"host.conf"</span>)</span><br><span class="line">    <span class="keyword">for</span> section <span class="keyword">in</span> conf.get_all_sections():</span><br><span class="line">        <span class="keyword">print</span> section</span><br><span class="line">        keys = conf.list_options(section)</span><br><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> keys:</span><br><span class="line">            <span class="keyword">print</span> key + <span class="string">' : '</span> + conf.get_key(section, key)</span><br></pre></td></tr></table></figure><p>host.conf内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[CHINA]</span><br><span class="line">provice=Beijing</span><br><span class="line">city=Beijing</span><br><span class="line">district=Haidian</span><br><span class="line"></span><br><span class="line">[USA]</span><br><span class="line">provice=State of New York</span><br><span class="line">city=NewYork</span><br><span class="line">district=B13</span><br></pre></td></tr></table></figure><p>脚本输出内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CHINA</span><br><span class="line">provice : Beijing</span><br><span class="line">city : Beijing</span><br><span class="line">district : Haidian</span><br><span class="line">USA</span><br><span class="line">provice : State of New York</span><br><span class="line">city : NewYork</span><br><span class="line">district : B13</span><br></pre></td></tr></table></figure><h2 id="Http服务"><a href="#Http服务" class="headerlink" title="Http服务"></a>Http服务</h2><h3 id="SimpleHttpServer"><a href="#SimpleHttpServer" class="headerlink" title="SimpleHttpServer"></a>SimpleHttpServer</h3><p>一键启动一个http服务，可以快速满足文件下载等需求。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m SimpleHTTPServer [端口号]</span><br></pre></td></tr></table></figure><h3 id="Flask"><a href="#Flask" class="headerlink" title="Flask"></a>Flask</h3><p>flask是python提供的一个便捷http服务框架，简单高效。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> flask</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> make_response,render_template,Response</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    stamp = str(int(time.time()))</span><br><span class="line">    <span class="keyword">print</span> stamp</span><br><span class="line">    token = hashlib.md5((<span class="string">"bigdata-meta"</span> + stamp + <span class="string">"z2spmoowoeao2bzvqs796a8t08tszso0"</span>).encode(<span class="string">'utf8'</span>)).hexdigest()</span><br><span class="line">    result = <span class="string">"timestamp: %s &lt;br/&gt;&lt;br/&gt; token: %s"</span> % (stamp, token)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">    </span><br><span class="line"><span class="meta">@app.route('/callback')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"callback"</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    app.run(host=<span class="string">'0.0.0.0'</span>, debug=<span class="literal">True</span>, port=<span class="number">8343</span>)</span><br></pre></td></tr></table></figure><h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">对util模块进行测试</span></span><br><span class="line"><span class="string">Authors: austin</span></span><br><span class="line"><span class="string">Date:    16/7/12 17:24.</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys </span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> util</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UtilTestCase</span><span class="params">(unittest.TestCase)</span>:</span></span><br><span class="line">    <span class="string">""" </span></span><br><span class="line"><span class="string">    测试类</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setUp</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        初始化</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.cs_list = [<span class="string">'3182242396,2726385067,72'</span>,<span class="string">'4030018123,3852097821,72'</span>]</span><br><span class="line">        self.expect_url_list = [<span class="string">'http://t10.baidu.com/it/u=3182242396,2726385067&amp;fm=72'</span>,</span><br><span class="line">                                <span class="string">'http://t10.baidu.com/it/u=4030018123,3852097821&amp;fm=72'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_get_cs_url</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">""" </span></span><br><span class="line"><span class="string">        测试生成url函数正确性</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        ret = map(util.get_cs_url, self.cs_list)</span><br><span class="line">        self.assertEqual(ret, self.expect_url_list)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    unittest.main()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Log日志&quot;&gt;&lt;a href=&quot;#Log日志&quot; class=&quot;headerlink&quot; title=&quot;Log日志&quot;&gt;&lt;/a&gt;Log日志&lt;/h2&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter
      
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="脚本" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/%E8%84%9A%E6%9C%AC/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="脚本" scheme="http://yoursite.com/tags/%E8%84%9A%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>Mysql事务执行过程详解</title>
    <link href="http://yoursite.com/2020/03/12/Mysql%E4%BA%8B%E5%8A%A1%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2020/03/12/Mysql事务执行过程详解/</id>
    <published>2020-03-12T03:47:24.000Z</published>
    <updated>2020-03-23T03:51:43.964Z</updated>
    
    <content type="html"><![CDATA[<h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><p><img src="/images/mysql_tx_process.jpg" alt></p><ul><li><p>写data buffer和redolog buffer几乎同时；</p></li><li><p>data buffer只在checkponit点才会刷新到磁盘；</p></li><li><p>redolog buffer会在事务执行过程中随时写入磁盘，且对应事务的脏页写入到磁盘之后，redo log的使命也就完成了，重做日志占用的空间就可以重用（被覆盖）；</p></li><li><p>undolog会在事务开始之前基于当前版本生成，undo 也会产生 redo 来保证undo log的可靠性；</p></li><li><p>当事务提交之后，undo log并不能立马被删除，而是放入待清理的链表，由purge线程判断是否由其他事务在使用undo段中表的上一个事务之前的版本信息，决定是否可以清理undo log的日志空间；</p></li><li><p>默认情况下undo文件是保持在<strong>共享表空间</strong>的，也即ibdatafile文件中；</p></li><li><p>事务提交的时候，一次性将事务中的sql语句（一个事物可能对应多个sql语句）按照一定的格式记录到binlog中；</p></li></ul><h2 id="数据刷盘规则"><a href="#数据刷盘规则" class="headerlink" title="数据刷盘规则"></a>数据刷盘规则</h2><p>内存中(buffer pool)未刷到磁盘的数据称为脏数据(dirty data)。由于数据和日志都以页的形式存在，所以脏页表示脏数据和脏日志。</p><p>innodb中，数据刷盘的规则只有一个：checkpoint。但是触发checkpoint的情况却有几种。不管怎样，<strong>checkpoint触发后，会将buffer中脏数据页和脏日志页都刷到磁盘。</strong></p><p>innodb存储引擎中checkpoint分为两种：</p><ul><li><p>sharp checkpoint：在重用redo log文件(例如切换日志文件)的时候，将所有已记录到redo log中对应的脏数据刷到磁盘。</p></li><li><p>fuzzy checkpoint：一次只刷一小部分的日志到磁盘，而非将所有脏日志刷盘。</p></li></ul><p>由于刷脏页需要一定的时间来完成，所以记录检查点的位置是在每次刷盘结束之后才在redo log中标记的。</p><h2 id="LSN"><a href="#LSN" class="headerlink" title="LSN"></a>LSN</h2><p>LSN称为日志的逻辑序列号(log sequence number)，在innodb存储引擎中，lsn占用8个字节。LSN的值会随着日志的写入而逐渐增大。</p><p>根据LSN，可以获取到几个有用的信息：</p><ul><li><p>1.数据页的版本信息。</p></li><li><p>2.写入的日志总量，通过LSN开始号码和结束号码可以计算出写入的日志量。</p></li><li><p>3.可知道检查点的位置。</p></li></ul><p>实际上还可以获得很多隐式的信息。</p><p>LSN不仅存在于redo log中，还存在于数据页中，在每个数据页的头部，有一个fil_page_lsn记录了当前页最终的LSN值是多少。<strong>通过数据页中的LSN值和redo log中的LSN值比较，如果页中的LSN值小于redo log中LSN值，则表示数据丢失了一部分，这时候可以通过redo log的记录来恢复到redo log中记录的LSN值时的状态。</strong></p><h2 id="redolog"><a href="#redolog" class="headerlink" title="redolog"></a>redolog</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>redo log包括两部分：一是内存中的日志缓冲(redo log buffer)，该部分日志是易失性的；二是磁盘上的重做日志文件(redo log file)，该部分日志是持久的.</p><p>为了确保每次日志都能写入到事务日志文件中，在每次将log buffer中的日志写入日志文件的过程中都会调用一次操作系统的fsync操作(即fsync()系统调用)。</p><p>MySQL支持用户自定义在commit时如何将log buffer中的日志刷log file中。这种控制通过变量 innodb_flush_log_at_trx_commit 的值来决定。但注意，这个变量只是<strong>控制commit动作是否刷新log buffer到磁盘</strong>。</p><ul><li><p><strong>1</strong>： 默认值，事务每次提交都会将log buffer中的日志写入os buffer并调用fsync()刷到log file on disk中。这种方式即使系统崩溃也不会丢失任何数据，但是因为每次提交都写入磁盘，IO的性能较差。</p></li><li><p><strong>0</strong>：事务提交时不会将log buffer中日志写入到os buffer，而是每秒写入os buffer并调用fsync()写入到log file on disk中。也就是(大约)每秒刷新写入到磁盘中的，当系统崩溃，会丢失1秒钟的数据。</p></li><li><p><strong>2</strong>：每次提交都仅写入到os buffer，然后是每秒调用fsync()将os buffer中的日志写入到log file on disk。</p></li></ul><p><img src="/images/mysql_flush_cache.jpg" alt></p><p>在主从复制结构中，要保证事务的持久性和一致性，需要对日志相关变量设置为如下：</p><ul><li><p>如果启用了二进制日志，则设置 <code>sync_binlog=1</code>，即每提交一次事务同步写到磁盘中;</p></li><li><p>设置<code>innodb_flush_log_at_trx_commit=1</code>，即每提交一次事务都写到磁盘中;</p></li></ul><h3 id="redolog日志刷盘规则"><a href="#redolog日志刷盘规则" class="headerlink" title="redolog日志刷盘规则"></a>redolog日志刷盘规则</h3><p>log buffer中未刷到磁盘的日志称为脏日志(dirty log)。</p><p>刷日志到磁盘有以下几种规则：</p><ul><li><p>1.发出commit动作时。commit发出后是否刷日志由变量 <code>innodb_flush_log_at_trx_commit</code> 控制。</p></li><li><p>2.每秒刷一次。这个刷日志的频率由变量 <code>innodb_flush_log_at_timeout</code> 值决定，默认是1秒。要注意，这个刷日志频率和commit动作无关。</p></li><li><p>3.当log buffer中已经使用的内存超过一半时。</p></li><li><p>4.当有checkpoint时，checkpoint在一定程度上代表了刷到磁盘时日志所处的LSN位置</p></li></ul><h2 id="undolog"><a href="#undolog" class="headerlink" title="undolog"></a>undolog</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>undo log有两个作用：<strong>提供回滚和多个行版本控制(MVCC)</strong>。</p><p>在数据修改的时候，不仅记录了redo，还记录了相对应的undo，如果因为某些原因导致事务失败或回滚了，可以借助该undo进行回滚。</p><p>undo log和redo log记录物理日志不一样，它是<strong>逻辑日志</strong>。可以认为当delete一条记录时，undo log中会记录一条对应的insert记录，反之亦然，当update一条记录时，它记录一条对应相反的update记录。</p><p>当执行rollback时，就可以从undo log中的逻辑记录读取到相应的内容并进行回滚。有时候应用到行版本控制的时候，也是通过undo log来实现的：当读取的某一行被其他事务锁定时，它可以从undo log中分析出该行记录以前的数据是什么，从而提供该行版本信息，让用户实现非锁定一致性读取。</p><p><strong>undo log是采用段(segment)的方式来记录的，每个undo操作在记录的时候占用一个undo log segment</strong>。</p><p>另外，<strong>undo log也会产生redo log，因为undo log也要实现持久性保护</strong>。</p><h3 id="undolog清理机制"><a href="#undolog清理机制" class="headerlink" title="undolog清理机制"></a>undolog清理机制</h3><p>当事务提交的时候，innodb不会立即删除undo log，因为后续还可能会用到undo log，如隔离级别为repeatable read时，事务读取的都是开启事务时的最新提交行版本，只要该事务不结束，该行版本就不能删除，即undo log不能删除。</p><p>但是在事务提交的时候，会将该事务对应的undo log放入到删除列表中，未来通过purge来删除。并且提交事务时，还会判断undo log分配的页是否可以重用，如果可以重用，则会分配给后面来的事务，避免为每个独立的事务分配独立的undo log页而浪费存储空间和性能。</p><p>通过undo log记录delete和update操作的结果发现：(insert操作无需分析，就是插入行而已)</p><ul><li><p>delete操作实际上不会直接删除，而是将delete对象打上delete flag，标记为删除，最终的删除操作是purge线程完成的。</p></li><li><p>update分为两种情况：update的列是否是主键列。</p><ul><li>如果不是主键列，在undo log中直接反向记录是如何update的。即update是直接进行的。</li><li>如果是主键列，update分两部执行：先删除该行，再插入一行目标行</li></ul></li></ul><h2 id="redo-log与binlog的区别"><a href="#redo-log与binlog的区别" class="headerlink" title="redo log与binlog的区别"></a>redo log与binlog的区别</h2><ul><li><p>第一: redo log是在InnoDB存储引擎层产生，而binlog是MySQL数据库的上层产生的，并且二进制日志不仅仅针对INNODB存储引擎，MySQL数据库中的任何存储引擎对于数据库的更改都会产生二进制日志。</p></li><li><p>第二：两种日志记录的内容形式不同。MySQL的binlog是逻辑日志，其记录是对应的SQL语句。而innodb存储引擎层面的重做日志是<strong>物理日志</strong>, 它具有幂等性，。</p></li><li><p>第三：两种日志与记录写入磁盘的时间点不同，<strong>二进制日志只在事务提交完成后进行一次写入</strong>。而<strong>innodb存储引擎的重做日志在事务进行中不断地被写入，并日志不是随事务提交的顺序进行写入的</strong>。 <font color="red"><strong>并且二进制日志先于redo log被记录</strong></font></p><p>  <strong>二进制日志仅在事务提交时记录，并且对于每一个事务，仅在事务提交时记录，并且对于每一个事务，仅包含对应事务的一个日志</strong>。而对于innodb存储引擎的重做日志，由于其记录是物理操作日志，因此<strong>每个事务对应多个日志条目，并且事务的重做日志写入是并发的，并非在事务提交时写入，其在文件中记录的顺序并非是事务开始的顺序</strong>。</p></li><li><p>第四：binlog不是循环使用，在写满或者重启之后，会生成新的binlog文件，<strong>redo log是循环使用</strong>。</p></li><li><p>第五：binlog可以作为恢复数据使用，主从复制搭建，redo log作为异常宕机或者介质故障后的数据恢复使用。</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>原子性：使用 undo log ，从而达到回滚</p></li><li><p>持久性：使用 redo log，从而达到故障后恢复</p></li><li><p>隔离性：使用锁以及MVCC,运用的优化思想有读写分离，读读并行，读写并行</p></li><li><p>一致性：通过回滚，以及恢复，和在并发环境下的隔离做到一致性。</p></li></ul><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章:"></a>参考文章:</h2><p><a href="https://www.cnblogs.com/wy123/p/8365234.html" target="_blank" rel="noopener">MySQL中的重做日志（redo log），回滚日志（undo log），以及二进制日志（binlog）的简单总结</a></p><p><a href="https://blog.csdn.net/wanbin6470398/article/details/81941586" target="_blank" rel="noopener">MySQL redo log 与 binlog 的区别</a></p><p><a href="https://juejin.im/entry/5ba0a254e51d450e735e4a1f" target="_blank" rel="noopener">详细分析MySQL事务日志(redo log和undo log)</a></p><p><a href="https://mp.weixin.qq.com/s/NrbFDZxEeZgflBBZkjIjvg" target="_blank" rel="noopener">Mysql的事务实现原理</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;总览&quot;&gt;&lt;a href=&quot;#总览&quot; class=&quot;headerlink&quot; title=&quot;总览&quot;&gt;&lt;/a&gt;总览&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/images/mysql_tx_process.jpg&quot; alt&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;写data buf
      
    
    </summary>
    
      <category term="Mysql" scheme="http://yoursite.com/categories/Mysql/"/>
    
      <category term="事务" scheme="http://yoursite.com/categories/Mysql/%E4%BA%8B%E5%8A%A1/"/>
    
    
      <category term="Mysql" scheme="http://yoursite.com/tags/Mysql/"/>
    
      <category term="事务" scheme="http://yoursite.com/tags/%E4%BA%8B%E5%8A%A1/"/>
    
      <category term="原理" scheme="http://yoursite.com/tags/%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Java常见面试题总结</title>
    <link href="http://yoursite.com/2020/03/06/Java%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2020/03/06/Java常见面试题总结/</id>
    <published>2020-03-06T08:11:42.000Z</published>
    <updated>2020-03-20T09:45:14.936Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JAVA基础"><a href="#JAVA基础" class="headerlink" title="JAVA基础"></a>JAVA基础</h2><h3 id="Java的collection接口继承关系"><a href="#Java的collection接口继承关系" class="headerlink" title="Java的collection接口继承关系"></a>Java的collection<t>接口继承关系</t></h3><p><img src="/images/collection_inherit.png" alt></p><p><img src="/images/collection_inherit2.png" alt></p><p><img src="/images/colletion_inherit3.jpg" alt></p><h3 id="jdk1-7-用的是哪种垃圾回收机制-1-8用的是啥"><a href="#jdk1-7-用的是哪种垃圾回收机制-1-8用的是啥" class="headerlink" title="jdk1.7 用的是哪种垃圾回收机制  1.8用的是啥"></a>jdk1.7 用的是哪种垃圾回收机制  1.8用的是啥</h3><p>jdk1.6 用的是 UseParallelGC， ParallelGCThreads=4<br>jdk1.8</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> java -XX:+PrintCommandLineFlags -version</span><br><span class="line">-XX:InitialHeapSize=134217728 </span><br><span class="line">-XX:MaxHeapSize=2147483648 </span><br><span class="line">-XX:+PrintCommandLineFlags </span><br><span class="line">-XX:+UseCompressedClassPointers </span><br><span class="line">-XX:+UseCompressedOops </span><br><span class="line">-XX:+UseParallelGC</span><br><span class="line">java version "1.8.0_181"</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_181-b13)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.181-b13, mixed mode)</span><br></pre></td></tr></table></figure><p>UseParallelGC 即 <code>Parallel Scavenge + Serial Old</code>, 再查看详细信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+PrintGCDetails -version</span><br><span class="line">java version "1.8.0_181"</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_181-b13)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.181-b13, mixed mode)</span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 38400K, used 1331K [0x0000000795580000, 0x0000000798000000, 0x00000007c0000000)</span><br><span class="line">  eden space 33280K, 4% used [0x0000000795580000,0x00000007956cce48,0x0000000797600000)</span><br><span class="line">  from space 5120K, 0% used [0x0000000797b00000,0x0000000797b00000,0x0000000798000000)</span><br><span class="line">  to   space 5120K, 0% used [0x0000000797600000,0x0000000797600000,0x0000000797b00000)</span><br><span class="line"> ParOldGen       total 87552K, used 0K [0x0000000740000000, 0x0000000745580000, 0x0000000795580000)</span><br><span class="line">  object space 87552K, 0% used [0x0000000740000000,0x0000000740000000,0x0000000745580000)</span><br><span class="line"> Metaspace       used 2233K, capacity 4480K, committed 4480K, reserved 1056768K</span><br><span class="line">  class space    used 243K, capacity 384K, committed 384K, reserved 1048576K</span><br></pre></td></tr></table></figure><h3 id="List和Array的区别，添加和删除元素的时间复杂度怎样"><a href="#List和Array的区别，添加和删除元素的时间复杂度怎样" class="headerlink" title="List和Array的区别，添加和删除元素的时间复杂度怎样"></a>List和Array的区别，添加和删除元素的时间复杂度怎样</h3><p>1) 因为Array是基于索引(index)的数据结构，它使用索引在数组中搜索和读取数据是很快的。Array获取数据的时间复杂度是O(1),但是要删除数据却是开销很大的，因为这需要重排数组中的所有数据。</p><p>2) 相对于ArrayList，LinkedList插入是更快的。因为LinkedList不像ArrayList一样，不需要改变数组的大小，也不需要在数组装满的时候要将所有的数据重新装入一个新的数组，这是ArrayList最坏的一种情况，时间复杂度是O(n)，而LinkedList中插入或删除的时间复杂度仅为O(1)。ArrayList在插入数据时还需要更新索引（除了插入数组的尾部）。</p><p>3) 类似于插入数据，删除数据时，LinkedList也优于ArrayList。</p><p>4) LinkedList需要更多的内存，因为ArrayList的每个索引的位置是实际的数据，而LinkedList中的每个节点中存储的是实际的数据和前后节点的位置。</p><p>5） Array和List都属于顺序表。Array、ArrayList是一段连续的存储结构</p><h3 id="红黑树添加元素和获取元素的时间复杂度"><a href="#红黑树添加元素和获取元素的时间复杂度" class="headerlink" title="红黑树添加元素和获取元素的时间复杂度"></a>红黑树添加元素和获取元素的时间复杂度</h3><p>插入一个元素到红黑树的时间为 <em>O(log(N))*，其中 *N</em> 为当前红黑树的元素个数，因此，采用插入方式构建元素个数为N的红黑树的时间复杂度为:</p><p><code>log(1) + log(2) + log(N-1) = log((N-1)!) = Nlog(N)</code></p><p>那么采用<code>迭代器</code>遍历一棵红黑树的时间复杂度是多少呢？ 是 <em>O(N)</em> 。 也就是说非递归遍历一棵红黑树的时间复杂度和遍历数组的时间复杂度是一样的</p><p>原文链接：<a href="https://blog.csdn.net/gongyiling3468/article/details/47804223" target="_blank" rel="noopener">https://blog.csdn.net/gongyiling3468/article/details/47804223</a></p><h3 id="CMS垃圾收集器"><a href="#CMS垃圾收集器" class="headerlink" title="CMS垃圾收集器"></a>CMS垃圾收集器</h3><p><img src="/images/java_gc_cms-collec.jpg" alt></p><p><img src="/images/java_cms_advantage.jpg" alt></p><p><img src="/images/java_cms_parameter.jpg" alt></p><h3 id="线程池原理，增长策略，拒绝策略哪几种，四种线程池分别有什么优缺点，有什么坑，线程池使用该怎么选择"><a href="#线程池原理，增长策略，拒绝策略哪几种，四种线程池分别有什么优缺点，有什么坑，线程池使用该怎么选择" class="headerlink" title="线程池原理，增长策略，拒绝策略哪几种，四种线程池分别有什么优缺点，有什么坑，线程池使用该怎么选择"></a>线程池原理，增长策略，拒绝策略哪几种，四种线程池分别有什么优缺点，有什么坑，线程池使用该怎么选择</h3><ul><li><p>线程池原理：<br>复用Thead线程，减少创建和回收的CPU、内存资源消耗，过多任务加入等待队列或拒绝</p></li><li><p>增长策略：<br>当前线程数 &lt; 核心线程 : 直接开启新线程执行任务<br>当前线程数 &gt; 核心线程 : 加入等待队列<br>队列已满&amp; 当前线程数 &lt; 最大线程 : 开启新线程<br>队列已满&amp; 当前线程数 &gt; 最大线程 : 执行拒绝策略</p></li><li><p>拒绝策略</p><ol><li><p>CallerRunsPolicy：  只要线程池没有被关闭，那么由提交任务的线程自己来执行这个任务</p></li><li><p>AbortPolicy：不管怎样，直接抛出 RejectedExecutionException 异常， 这个是默认的策略， 如果我们构造线程池的时候不传相应的 handler 的话，那就会指定使用这个</p></li><li><p>DiscardPolicy：不做任何处理，直接忽略掉这个任务</p></li><li><p>DiscardOldestPolicy： 这个相对霸道一点，如果线程池没有被关闭的话， 把队列队头的任务(也就是等待了最长时间的)直接扔掉，然后提交这个任务到等待队列中</p></li></ol></li><li><p>线程池对比</p><ul><li><p>FixedThreadPool是一个典型且优秀的线程池，它具有线程池提高程序效率和节省创建线程时所耗的开销的优点。但在线程池空闲时，即线程池中没有可运行任务时，它不会释放工作线程，还会占用一定的系统资源。</p></li><li><p>CachedThreadPool的特点就是在线程池空闲时，即线程池中没有可运行任务时，它会释放工作线程，从而释放工作线程所占用的资源。但是，但当出现新任务时，又要创建一新的工作线程，又要一定的系统开销。并且，在使用CachedThreadPool时，一定要注意控制任务的数量，否则，由于大量线程同时运行，很有会造成系统瘫痪</p></li></ul></li></ul><h3 id="锁粗化、锁消除"><a href="#锁粗化、锁消除" class="headerlink" title="锁粗化、锁消除"></a>锁粗化、锁消除</h3><ul><li><p>锁粗化(程序员控制)<br>通常情况下，为了保证多线程间的有效并发，会要求每个线程持有锁的时间尽可能短，但是大某些情况下，一个程序对同一个锁不间断、高频地请求、同步与释放，会消耗掉一定的系统资源，因为锁的轻求、同步与释放本身会带来性能损耗，这样高频的锁请求就反而不利于系统性能的优化了，虽然单次同步操作的时间可能很短。</p><p>  锁粗化就是告诉我们任何事情都有个度，有些情况下我们反而希望把很多次锁的请求合并成一个请求，以降低短时间内大量锁请求、同步、释放带来的性能损耗。</p></li></ul><p>一种极端的情况如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomethingMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">        <span class="comment">//do some thing</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这是还有一些代码，做其它不需要同步的工作，但能很快执行完毕</span></span><br><span class="line">    <span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">        <span class="comment">//do other thing</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码是有两块需要同步操作的，但在这两块需要同步操作的代码之间，需要做一些其它的工作，而这些工作只会花费很少的时间，那么我们就可以把这些工作代码放入锁内，将两个同步代码块合并成一个，以降低多次锁请求、同步、释放带来的系统性能消耗，合并后的代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomethingMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//进行锁粗化：整合成一次锁请求、同步、释放</span></span><br><span class="line">    <span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">        <span class="comment">//do some thing</span></span><br><span class="line">        <span class="comment">//做其它不需要同步但能很快执行完的工作</span></span><br><span class="line">        <span class="comment">//do other thing</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：这样做是有前提的，就是中间不需要同步的代码能够很快速地完成，如果不需要同步的代码需要花很长时间，就会导致同步块的执行需要花费很长的时间，这样做也就不合理了。</p></blockquote><ul><li>锁消除<br>锁消除是<strong>发生在编译器级别</strong>的一种锁优化方式。有时候我们写的代码完全不需要加锁，却执行了加锁操作。虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行削除。<br>锁削除的主要判定依据来源于<strong>逃逸分析</strong>的数据支持，如果判断到一段代码中，在堆上的所有数据都不会逃逸出去被其他线程访问到，那就可以把它们当作栈上数据对待，认为它们是线程私有的，同步加锁自然就无须进行。 </li></ul><p>锁消除前提是java必须运行在<strong>server模式</strong>（server模式会比client模式作更多的优化），同时<strong>必须开启逃逸分析</strong>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-server -XX:+DoEscapeAnalysis -XX:+EliminateLocks</span><br></pre></td></tr></table></figure><p>其中<code>+DoEscapeAnalysis</code>表示开启逃逸分析，<code>+EliminateLocks</code>表示锁消除。</p><h3 id="异步thrift原理"><a href="#异步thrift原理" class="headerlink" title="异步thrift原理"></a>异步thrift原理</h3><p>服务方起草接口标准，负责实现，RPC框架生成服务端和客户端代理，服务端代理自启动，客户端代理绑定调用方，调用方按照接口标准，调用客户端代理，等价于RPC远程调用服务方实现</p><p><img src="/images/thrify_async.jpg" alt></p><p>定义一个Thrift Service</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. IDL编写的接口</span></span><br><span class="line">service AddService &#123;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="number">1</span>:<span class="keyword">int</span> n1, <span class="number">2</span>:<span class="keyword">int</span> n2)</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p>Thrift Service方法会提供两种类型的实现：</p><ul><li><p>Iface</p></li><li><p>AsyncIface</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2. thrift.exe生成接口的客户端代理 - 异步实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddService</span></span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> n1, <span class="keyword">int</span> n2, AsyncMethodCallback callback)</span> </span>&#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3. 接口的服务端实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddServiceImpl</span> <span class="keyword">implements</span> <span class="title">AddService</span>.<span class="title">Iface</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> n1, <span class="keyword">int</span> n2)</span> </span></span><br><span class="line"><span class="function">   return n1 + n2</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//4. 服务端监听</span></span><br><span class="line">TNonblockingServerSocket socket = <span class="keyword">new</span> TNonblockingServerSocket(<span class="number">9090</span>);</span><br><span class="line">TServer server = <span class="keyword">new</span> TNonblockingServer(socket, AddServiceImpl);</span><br><span class="line">server.start();</span><br></pre></td></tr></table></figure><p>外部的调用过程就是，先获得一个CallBack，然后调用start方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//5. 客户端请求</span></span><br><span class="line">TNonblockingTransport socket = <span class="keyword">new</span> TNonblockingSocket(<span class="string">"localhost"</span>, <span class="number">9090</span>);</span><br><span class="line">AddService.AsyncClient client = <span class="keyword">new</span> AddService.AsyncClient(socket);</span><br><span class="line">client.add(<span class="number">1</span>,<span class="number">2</span>,<span class="keyword">new</span> AsynCallback(<span class="keyword">this</span>)&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">onError</span><span class="params">(Exception exception)</span> </span>&#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>异步使用原则</strong><br>如果使用了AsynIface实现Service，需要注意几点：</p><ul><li><p>不能直接在方法内处理req，req需要和handler（callback）封装交给另外的线程进行处理（暂且把这些线程叫做worker线程）</p></li><li><p>worker线程只做计算逻辑，也就是根据req的要求进行操作，在操作req结束以后获得的resp或者error，不能直接调用handler（callback）的方法（因为callback中的方法是一个网络IO的操作，有可能会block当前线程，如果网络IO操作是一个异步操作的话就不会block当前线程）</p></li></ul><h3 id="讲几个jvm优化的案例"><a href="#讲几个jvm优化的案例" class="headerlink" title="讲几个jvm优化的案例"></a>讲几个jvm优化的案例</h3><h3 id="堆外内存泄漏怎么排查"><a href="#堆外内存泄漏怎么排查" class="headerlink" title="堆外内存泄漏怎么排查"></a>堆外内存泄漏怎么排查</h3><ul><li><p>异常堆栈<br><img src="/images/heap_out_exception.jpg" alt></p></li><li><p>top信息<br><img src="/images/heap_exception_top_info.jpg" alt></p></li></ul><p>一定时间过后，java 进程内存增长到接近 90%，服务器报警。此时 old 区内存在 50%左右，由于未达到 CMS GC 的阈值，因此不会触发 CMS GC，而导致服务器内存溢出崩溃。</p><ul><li><p>堆外内存计算方式</p><ul><li><p>广义堆外内存为：进程内存 - (Young 区占用 + Old 区占用)，可通过直接内存大小参数: <code>-神器:MaxDirectMemorySize</code> 设置, JVM申请直接内存时，会判断是否超过可申请的直接内存阈值，如果超过则会调用 <code>System.gc()</code> 触发GC，如果 GC 后内存还是不足，则抛出 <code>OutOfMemoryError</code> 异常</p></li><li><p>狭义堆外内存为：<code>java.nio.DirectByteBuffer</code> 创建的时候分配的内存</p></li></ul></li><li><p>查看堆内存命令</p><blockquote><p>jstat -gc <pid> 1000 : 每秒输出堆内存实际大小信息<br>jstat -gcutil <pid> 1000 : 每秒输出堆内存百分比信息</pid></pid></p></blockquote></li><li><p>jvisual VM可视化监控内存实时情况， 通过dump文件可以找到对象的引用根节点。</p></li><li><p>jmeter压测；</p></li><li><p>为了分析堆外内存到底是谁占用了，不得不安装<code>google-perftools</code>工具进行分析，它的原理是在java应用程序运行时，当调用 <code>malloc</code> 时换用它的<code>libtcmalloc.so</code>，这样就能做一些统计了</p></li></ul><p>原文链接：<a href="https://blog.csdn.net/u012099869/article/details/82757999" target="_blank" rel="noopener">https://blog.csdn.net/u012099869/article/details/82757999</a></p><h3 id="Tomcat响应web请求的过程"><a href="#Tomcat响应web请求的过程" class="headerlink" title="Tomcat响应web请求的过程"></a>Tomcat响应web请求的过程</h3><blockquote><p>Service -&gt; Connector(Socket) -&gt; Container (HttpServletRequest) -&gt; Engine -&gt; Host -&gt; Context -&gt; WrapServlet</p></blockquote><p>Pipeline-Valve-责任链模式</p><ul><li>StandardEnginePipeValve</li><li>StandardHostPipeValve</li><li>StandardContextPipeValve</li><li>StandardWraperPipeValve</li></ul><h3 id="CopyOnWriteArrayList、CopyOnWriteArraySet"><a href="#CopyOnWriteArrayList、CopyOnWriteArraySet" class="headerlink" title="CopyOnWriteArrayList、CopyOnWriteArraySet"></a>CopyOnWriteArrayList、CopyOnWriteArraySet</h3><p>CopyOnWriteArrayList原理：</p><blockquote><p>在写的时候不对原集合进行修改，而是重新复制一份，修改完之后，再移动指针</p></blockquote><p><strong>CopyOnWriteArrayList add()方法</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Appends the specified element to the end of this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e element to be appended to this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;<span class="comment">//重入锁</span></span><br><span class="line">    lock.lock();<span class="comment">//加锁啦</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);<span class="comment">//拷贝新数组</span></span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        setArray(newElements);<span class="comment">//将引用指向新数组  1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();<span class="comment">//解锁啦</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>add()</code>在添加集合的时候加上了锁，保证了同步，避免了多线程写的时候会Copy出N个副本出来.</p><p>有这么一种情况，当一个线程刚好调用完<code>add()</code>方法，也就是刚好执行到上面1处的代码，也就是刚好将引用指向新数组，而此时有线程正在遍历呢？会不会报错呢？<br>答案是不会的，因为你<strong>正在遍历的集合是旧的</strong>。</p><p><strong>优缺点</strong></p><ul><li><p>缺点：</p><ul><li>1、耗内存（集合复制）</li><li>2、实时性不高</li></ul></li><li><p>优点：</p><ul><li>1、数据一致性完整，为什么？因为加锁了，并发数据不会乱</li><li>2、解决了像ArrayList、Vector这种集合多线程遍历迭代问题，记住，Vector虽然线程安全，只不过是加了synchronized关键字，迭代问题完全没有解决！</li></ul></li></ul><p><strong>使用场景</strong></p><ul><li>读多写少（白名单，黑名单，商品类目的访问和更新场景），为什么？因为写的时候会复制新集合</li><li>集合不大，为什么？因为写的时候会复制新集合</li><li>实时性要求不高，为什么，因为有可能会读取到旧的集合数据</li></ul><h3 id="项目中使用延迟队列的场景，延迟队列是如何实现的"><a href="#项目中使用延迟队列的场景，延迟队列是如何实现的" class="headerlink" title="项目中使用延迟队列的场景，延迟队列是如何实现的"></a>项目中使用延迟队列的场景，延迟队列是如何实现的</h3><ul><li>DelayQueue基本原理<br>DelayQueue是一个<strong>没有边界BlockingQueue实现</strong>，加入其中的元素<strong>必需实现Delayed接口</strong>。当生产者线程调用put之类的方法加入元素时，会触发Delayed接口中的compareTo方法进行排序，也就是说队列中元素的顺序是按到期时间排序的，而非它们进入队列的顺序。排在队列头部的元素是最早到期的，越往后到期时间赿晚。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 消息体定义 实现Delayed接口就是实现两个方法即compareTo 和 getDelay</span></span><br><span class="line"><span class="comment"> * 最重要的就是getDelay方法，这个方法用来判断是否到期</span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"> <span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span> <span class="keyword">implements</span> <span class="title">Delayed</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;  </span><br><span class="line">    <span class="keyword">private</span> String body; <span class="comment">// 消息内容  </span></span><br><span class="line">    <span class="comment">// 延迟时长，这个是必须的属性因为要按照这个判断延时时长。  </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> excuteTime;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Message</span><span class="params">(<span class="keyword">int</span> id, String body, <span class="keyword">long</span> delayTime)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.id = id;  </span><br><span class="line">        <span class="keyword">this</span>.body = body;  </span><br><span class="line">        <span class="keyword">this</span>.excuteTime = TimeUnit.NANOSECONDS.convert(delayTime, </span><br><span class="line">            TimeUnit.MILLISECONDS) + System.nanoTime();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 自定义实现比较方法返回 1 0 -1三个参数  </span></span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Delayed delayed)</span> </span>&#123;  </span><br><span class="line">        Message msg = (Message) delayed;  </span><br><span class="line">        <span class="keyword">return</span> Integer.valueOf(<span class="keyword">this</span>.id) &gt; Integer.valueOf(msg.id) ? <span class="number">1</span>  </span><br><span class="line">                : (Integer.valueOf(<span class="keyword">this</span>.id) &lt; Integer.valueOf(msg.id) ? -<span class="number">1</span> : <span class="number">0</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 延迟任务是否到时就是按照这个方法判断如果返回的是负数则说明到期否则还没到期  </span></span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit unit)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> unit.convert(<span class="keyword">this</span>.excuteTime - System.nanoTime(), TimeUnit.NANOSECONDS);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费者线程查看队列头部的元素，注意是查看不是取出。然后调用元素的getDelay方法，如果此方法返回的值小０或者等于０，则消费者线程会从队列中取出此元素，并进行处理。如果getDelay方法返回的值大于0，则消费者线程wait返回的时间值后，再从队列头部取出元素，此时元素应该已经到期。</p><p><img src="/images/delay_queue_header.jpg" alt></p><p>DelayQueue是<strong>Leader-Followr</strong>模式的变种，消费者线程处于等待状态时，总是等待最先到期的元素，而不是长时间的等待。消费者线程尽量把时间花在处理任务上，最小化空等的时间，以提高线程的利用效率。</p><p>消费者线程的<strong>数量要够，处理任务的速度要快</strong>。否则，队列中的到期元素无法被及时取出并处理，造成任务延期、队列元素堆积等情况。</p><ul><li><p>应用场景</p><ul><li><p>关闭空闲连接。服务器中，有很多客户端的连接，空闲一段时间之后需要关闭之。</p></li><li><p>清理过期数据业务上。比如缓存中的对象，超过了空闲时间，需要从缓存中移出。</p></li><li><p>任务超时处理。在网络协议滑动窗口请求应答式交互时，处理超时未响应的请求。</p></li><li><p>下单之后如果三十分钟之内没有付款就自动取消订单。</p></li><li><p>订餐通知:下单成功后60s之后给用户发送短信通知。</p></li><li><p>当订单一直处于未支付状态时，如何及时的关闭订单，并退还库存</p></li><li><p>如何定期检查处于退款状态的订单是否已经退款成功</p></li><li><p>新创建店铺，N天内没有上传商品，系统如何知道该信息，并发送激活短信</p></li><li><p>定时任务调度：使用DelayQueue保存当天将会执行的任务和执行时间，一旦从DelayQueue中获取到任务就开始执行。</p></li></ul></li></ul><p>参考链接：<br><a href="https://juejin.im/post/5b5e52ecf265da0f716c3203" target="_blank" rel="noopener">https://juejin.im/post/5b5e52ecf265da0f716c3203</a><br><a href="https://blog.csdn.net/dkfajsldfsdfsd/article/details/88966814" target="_blank" rel="noopener">https://blog.csdn.net/dkfajsldfsdfsd/article/details/88966814</a></p><h3 id="内存溢出的排除、定位，虚拟机参数；"><a href="#内存溢出的排除、定位，虚拟机参数；" class="headerlink" title="内存溢出的排除、定位，虚拟机参数；"></a>内存溢出的排除、定位，虚拟机参数；</h3><p>查看堆占用情况：</p><ul><li>jmap 查看heap内存使用情况   </li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> jmap -heap 30124</span><br><span class="line">Attaching to process ID 30124, please wait...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is 25.152-b16</span><br><span class="line"></span><br><span class="line">using thread-local object allocation.</span><br><span class="line">Parallel GC with 4 thread(s)</span><br><span class="line"></span><br><span class="line">Heap Configuration:</span><br><span class="line">   MinHeapFreeRatio         = 0</span><br><span class="line">   MaxHeapFreeRatio         = 100</span><br><span class="line">   MaxHeapSize              = 4215275520 (4020.0MB)</span><br><span class="line">   NewSize                  = 88080384 (84.0MB)</span><br><span class="line">   MaxNewSize               = 1405091840 (1340.0MB)</span><br><span class="line">   OldSize                  = 176160768 (168.0MB)</span><br><span class="line">   NewRatio                 = 2</span><br><span class="line">   SurvivorRatio            = 8</span><br><span class="line">   MetaspaceSize            = 21807104 (20.796875MB)</span><br><span class="line">   CompressedClassSpaceSize = 1073741824 (1024.0MB)</span><br><span class="line">   MaxMetaspaceSize         = 17592186044415 MB</span><br><span class="line">   G1HeapRegionSize         = 0 (0.0MB)</span><br><span class="line"></span><br><span class="line">Heap Usage:</span><br><span class="line">PS Young Generation</span><br><span class="line">Eden Space:</span><br><span class="line">   capacity = 490733568 (468.0MB)</span><br><span class="line">   used     = 197747880 (188.58707427978516MB)</span><br><span class="line">   free     = 292985688 (279.41292572021484MB)</span><br><span class="line">   40.296383393116486% used</span><br><span class="line">From Space:</span><br><span class="line">   capacity = 12058624 (11.5MB)</span><br><span class="line">   used     = 8982888 (8.566749572753906MB)</span><br><span class="line">   free     = 3075736 (2.9332504272460938MB)</span><br><span class="line">   74.49347454568614% used</span><br><span class="line">To Space:</span><br><span class="line">   capacity = 30932992 (29.5MB)</span><br><span class="line">   used     = 0 (0.0MB)</span><br><span class="line">   free     = 30932992 (29.5MB)</span><br><span class="line">   0.0% used</span><br><span class="line">PS Old Generation</span><br><span class="line">   capacity = 275251200 (262.5MB)</span><br><span class="line">   used     = 53956432 (51.45686340332031MB)</span><br><span class="line">   free     = 221294768 (211.0431365966797MB)</span><br><span class="line">   19.60261462983631% used</span><br></pre></td></tr></table></figure><p>可以查看到<code>MetaspaceSize</code>, <code>CompressedClassSpaceSize</code>, <code>MaxMetaSize</code></p><p>jmap和jdk版本有关系，有些jdk版本会查看不到内存信息，可以使用jstat来查看统计信息</p><ul><li>jstat 收集统计信息</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 占用大小</span><br><span class="line"><span class="meta">$</span> jstat -gc 30124</span><br><span class="line"> S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT   </span><br><span class="line">29696.0 6656.0  0.0   6144.1 462848.0 95727.6   268800.0   52699.8   63320.0 61816.0 7552.0 7224.3     15    0.327   3      0.626    0.953</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 占用比例</span><br><span class="line"><span class="meta">$</span> jstat -gcutil 30124</span><br><span class="line">  S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT   </span><br><span class="line">  0.00  92.31  28.60  19.61  97.62  95.66     15    0.327     3    0.626    0.953</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-Xms 堆初始内存</span><br><span class="line">-Xmx 堆最大内存</span><br><span class="line">-XX:+UseG1GC/CMS 垃圾回收器</span><br><span class="line">-XX:+DisableEx神器icitGC 禁止显示GC</span><br><span class="line">-XX:MaxDirectM神器orySize 设置最大堆外内存，默认是:进程内存 - (Young 区占用 + Old 区占用)</span><br><span class="line">-Xss：每个线程的堆栈大小，默认1M</span><br><span class="line">-Xmn: 年轻代大小（eden区 + 2 * survivor）</span><br><span class="line">-XX:NewRatio=4 年轻代与老年代1:4</span><br><span class="line">-XX:survivorRa神器o=8 Eden区与survivor大小比值</span><br></pre></td></tr></table></figure><p> 具体步骤：</p><ul><li>jps找到进程id</li><li>jstat -gc -gcutil确认堆占用情况及是否频繁full gc</li><li>jmap -histo:live pid | head  找到最多的几个instance</li><li>jmap dump:live,format=b,file=head.hprof pid dump出存活的实例堆栈信息</li><li>jvisualvm载入dump文件，从类信息栏找到占用内存最大的类，点击查询实例详情，进一步找到引用对象</li></ul><h2 id="ZooKeeper"><a href="#ZooKeeper" class="headerlink" title="ZooKeeper"></a>ZooKeeper</h2><h3 id="zk选主的详细过程"><a href="#zk选主的详细过程" class="headerlink" title="zk选主的详细过程"></a>zk选主的详细过程</h3><p>在Zookeeper集群中，主要分为三者角色，而每一个节点同时只能扮演一种角色，这三种角色分别是：</p><ul><li><p><strong>Leader</strong><br>接受所有Follower的提案请求并统一协调发起提案的投票，负责与所有的Follower进行内部的数据交换(同步);</p></li><li><p><strong>Follower</strong><br>直接为客户端服务并参与提案的投票，同时与Leader进行数据交换(同步);</p></li><li><p><strong>Observer</strong><br>直接为客户端服务但并不参与提案的投票，同时也与Leader进行数据交换(同步); Observer的作用是为了拓展系统，提高读取速度。</p></li></ul><p><strong>Server工作过程中四种状态</strong></p><ul><li>LOOKING：竞选状态，当前Server不知道leader是谁，正在搜寻。</li><li>LEADING：领导者状态，表明当前服务器角色是leader。</li><li>FOLLOWING：随从状态，表明当前服务器角色是follower，同步leader状态，参与投票。</li><li>OBSERVING，观察状态，表明当前服务器角色是observer，同步leader状态，不参与投票。</li></ul><p><strong>选主机制</strong><br>Zookeeper的核心是<strong>原子广播</strong>，这个机制保证了各个Server之间的同步。实现这个机制的协议叫做<strong>Zab协议</strong>。</p><p>Zab协议有两种模式，它们分别是：  </p><ul><li>恢复模式（选主）</li><li>广播模式（同步</li></ul><p>当<strong>服务启动或者在领导者崩溃</strong>后，Zab就进入了恢复模式，当领导者被选举出来，且大多数Server完成了和leader的状态同步以后，恢复模式就结束了。</p><ul><li>状态同步保证了leader和Server具有相同的系统状态。</li><li>leader选举是保证分布式数据一致性的关键</li></ul><p>当zk集群中的一台服务器出现以下两种情况之一时，就会开始leader选举。  </p><ul><li>（1）服务器初始化启动。</li><li>（2）服务器运行期间无法和leader保持连接。</li></ul><p>而当一台机器进入leader选举流程时，当前集群也可能处于以下两种状态。</p><ul><li>（1）集群中本来就已经存在一个leader。</li><li>（2）集群中确实不存在leader。</li></ul><p>首先第一种情况，通常是集群中某一台机器启动比较晚，在它启动之前，集群已经正常工作，即已经存在一台leader服务器。当该机器试图去选举leader时，会被告知当前服务器的leader信息，它仅仅需要和leader机器建立连接，并进行状态同步即可。</p><p>下面重点看第二种情况，即集群中leader不存在的情况下如何进行leader选举。</p><p><strong>数据模型</strong><br>投票信息中包含两个最基本的信息。</p><ul><li><p><strong>sid</strong>: 即<strong>server id</strong>，用来标识该机器在集群中的机器序号；</p></li><li><p><strong>zxid</strong>: 即zookeeper<strong>事务id</strong>。ZooKeeper状态的每一次改变, 都对应着一个递增的Transaction id, 该id称为<strong>zxid</strong>. 由于zxid的递增性质, 如果zxid1小于zxid2, 那么zxid1肯定先于zxid2发生. 创建任意节点, 或者更新任意节点的数据, 或者删除任意节点, 都会导致Zookeeper状态发生改变, 从而导致zxid的值增加.</p></li><li><p><strong>electionEpoch</strong>：逻辑时钟，用来判断多个投票是否在同一轮选举周期中，该值在服务端是一个自增序列，每次进入新一轮的投票后，都会对该值进行加1操作;</p></li><li><p><strong>state</strong>：当前服务器的状态;</p></li></ul><p>以<code>（sid，zxid）</code>的形式来标识一次投票信息。例如，如果当前服务器要推举sid为1，zxid为8的服务器成为leader，那么投票信息可以表示为（1，8）</p><p><strong>规则</strong><br>集群中的每台机器发出自己的投票后，也会接受来自集群中其他机器的投票。每台机器都会根据一定的规则，来处理收到的其他机器的投票，以此来决定是否需要变更自己的投票。<br>规则如下：   </p><ul><li>（1）初始阶段，都会给自己投票。</li><li>（2）当接收到来自其他服务器的投票时，都需要将别人的投票和自己的投票进行pk，规则如下：<ul><li>优先检查zxid, zxid比较大的服务器优先作为leader;</li><li>如果zxid相同的话，就比较sid，sid比较大的服务器作为leader;</li></ul></li></ul><p><strong>总结：</strong></p><ul><li><p>首先判断该投票的有效性，如检查是否是本轮投票、是否来自LOOKING状态的服务器。如果发现该外部选票的选举轮次小于当前服务器的，那么忽略该外部投票，同时立即发送自己的内部投票。</p></li><li><p>第二轮根据第一轮比较结果再次向集群中所有机器发出上一次投票信息即可。</p></li><li><p>一旦确定了Leader，每个服务器就会更新自己的状态，如果是Follower，那么就变更为FOLLOWING，如果是Leader，就变更为LEADING</p></li><li><p>在3.4.0后的Zookeeper的版本只保留了TCP版本的FastLeaderElection选举算法</p></li><li><p>electionEpoch：逻辑时钟，用来判断多个投票是否在同一轮选举周期中，该值在服务端是一个自增序列，每次进入新一轮的投票后，都会对该值进行加1操作。</p></li></ul><p>链接：<a href="https://www.jianshu.com/p/75e48405d678" target="_blank" rel="noopener">https://www.jianshu.com/p/75e48405d678</a></p><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><h3 id="redispool线程池工作原理，JDK怎么实现"><a href="#redispool线程池工作原理，JDK怎么实现" class="headerlink" title="redispool线程池工作原理，JDK怎么实现"></a>redispool线程池工作原理，JDK怎么实现</h3><ul><li><p>复用socket连接，存储到LinkedBlockingDeque中</p></li><li><p>imeBetweenEvictionRunsMillis毫秒秒检查一次连接池中空闲的连接,把空闲时间超过minEvictableIdleTimeMillis毫秒的连接断开,直到连接池中的连接数到minIdle为止</p></li></ul><h3 id="redis-事务-MULTI"><a href="#redis-事务-MULTI" class="headerlink" title="redis 事务 MULTI"></a>redis 事务 MULTI</h3><p>严格意义来讲,redis的事务和我们理解的传统数据库(如mysql)的事务是不一样的。</p><p><strong>Redis中的事务（transaction）是一组命令的集合</strong>。</p><p>事务的原理是先<strong>将属于一个事务的命令发送给Redis，然后再让Redis依次执行这些命令</strong>。</p><p>如果在发送EXEC命令前客户端断线了，则Redis会清空事务队列，事务中的所有命令都不会执行。而一旦客户端发送了EXEC命令，所有的命令就都会被执行，即使此后客户端断线也没关系，因为Redis中已经记录了所有要执行的命令。</p><p>除此之外，Redis的事务还能保证一个事务内的命令依次执行而不被其他命令插入。试想客户端A需要执行几条命令，同时客户端B发送了一条命令，如果不使用事务，则客户端B的命令可能会插入到客户端A的几条命令中执行。如果不希望发生这种情况，也可以使用事务。</p><p>和传统的mysql事务不同的事，即使我们的加钱操作失败,我们也无法在这一组命令中让整个状态回滚到操作之前。</p><ul><li><p>语法错误<br>语法错误指命令不存在或者命令参数的个数不对，比如跟在MULTI命令后执行了3个命令：一个是正确的命令，成功地加入事务队列；其余两个命令都有语法错误。而只要有一个命令有语法错误，执行EXEC命令后Redis就会直接返回错误，连语法正确的命令也不会执行。</p></li><li><p>运行错误<br>运行错误指在命令执行时出现的错误，比如使用散列类型的命令操作集合类型的键，这种错误在实际执行之前Redis是无法发现的，所以在事务里这样的命令是会被Redis接受并执行的。如果事务里的一条命令出现了运行错误，事务里其他的命令依然会继续执行，Redis的事务没有关系数据库事务提供的回滚（rollback）功能。为此开发者必须在事务执行出错后自己收拾剩下的摊子。</p></li></ul><h3 id="redis-watch机制"><a href="#redis-watch机制" class="headerlink" title="redis watch机制"></a>redis watch机制</h3><blockquote><p>WATCH命令可以监控一个或多个键，一旦其中有一个键被修改（或删除），之后的事务就不会执行。监控一直持续到EXEC命令（<strong>事务中的命令是在EXEC之后才执行的</strong>，所以在MULTI命令后可以修改WATCH监控的键值）</p></blockquote><p><strong>利用watch实现incr</strong><br>具体做法如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">WATCH mykey</span><br><span class="line">val = GET mykey</span><br><span class="line">val = val + 1</span><br><span class="line">MULTI</span><br><span class="line">SET mykey $val</span><br><span class="line">EXEC</span><br></pre></td></tr></table></figure><p>注意点<br>由于WATCH命令的作用<strong>只是当被监控的键值被修改后阻止之后一个事务的执行</strong>，而<strong>不能保证其他客户端不修改这一键值</strong>，所以在一般的情况下我们需要在EXEC执行失败后重新执行整个函数。</p><p>执行EXEC命令后会取消对所有键的监控，如果不想执行事务中的命令也可以使用UNWATCH命令来取消监控。</p><h3 id="Redis为什么扩容时会产生超时"><a href="#Redis为什么扩容时会产生超时" class="headerlink" title="Redis为什么扩容时会产生超时"></a>Redis为什么扩容时会产生超时</h3><h3 id="skiplist与平衡树、哈希表的比较"><a href="#skiplist与平衡树、哈希表的比较" class="headerlink" title="skiplist与平衡树、哈希表的比较"></a>skiplist与平衡树、哈希表的比较</h3><ul><li><p>skiplist和各种平衡树（如AVL、红黑树等）的元素是有序排列的，而哈希表不是有序的。因此，在哈希表上只能做单个key的查找，不适宜做范围查找。所谓范围查找，指的是查找那些大小在指定的两个值之间的所有节点。</p></li><li><p>在做范围查找的时候，平衡树比skiplist操作要复杂。在平衡树上，我们找到指定范围的小值之后，还<strong>需要以中序遍历的顺序继续寻找其它不超过大值的节点</strong>。如果不对平衡树进行一定的改造，这里的中序遍历并不容易实现。而在skiplist上进行范围查找就非常简单，<strong>只需要在找到小值之后，对第1层链表进行若干步的遍历就可以实现</strong>。</p></li><li><p><strong>平衡树的插入和删除操作可能引发子树的调整，逻辑复杂</strong>，而<strong>skiplist的插入和删除只需要修改相邻节点的指针，操作简单又快速</strong>。</p></li><li><p>从内存占用上来说，skiplist比平衡树更灵活一些。一般来说，平衡树每个节点包含2个指针（分别指向左右子树），而skiplist每个节点包含的指针数目平均为<strong><em>1/(1-p)</em></strong>，具体取决于参数p的大小。如果像Redis里的实现一样，取p=1/4，那么平均每个节点包含 <strong>1.33</strong> 个指针，比平衡树更有优势。</p></li><li><p>查找单个key，skiplist和平衡树的时间复杂度都为<strong><em>O(logN)</em></strong>，大体相当；而哈希表在保持较低的哈希值冲突概率的前提下，查找时间复杂度接近O(1)，性能更高一些。所以我们平常使用的各种Map或dictionary结构，大都是基于哈希表实现的。</p></li><li><p>从算法实现难度上来比较，skiplist比平衡树要简单得多。</p></li></ul><p>链接：<a href="https://juejin.im/post/57fa935b0e3dd90057c50fbc" target="_blank" rel="noopener">https://juejin.im/post/57fa935b0e3dd90057c50fbc</a></p><h3 id="redis跳跃表"><a href="#redis跳跃表" class="headerlink" title="redis跳跃表"></a>redis跳跃表</h3><p><img src="/images/redis_skip_list.jpg" alt></p><ul><li>各种搜索结构提高效率的方式都是通过空间换时间得到的；</li><li>跳表最终形成的结构和搜索树很相似；</li><li>跳表通过随机的方式来决定新插入节点来决定索引的层数；</li><li>跳表搜索的时间复杂度是 O(logn)，插入/删除也是；</li></ul><p>为了满足自身的功能需要， Redis 基于 William Pugh 论文中描述的跳跃表进行了以下修改：</p><ul><li><p>允许重复的 score 值：多个不同的 member 的 score 值可以相同。</p></li><li><p>进行对比操作时，不仅要检查 score 值，还要检查 member ：当 score 值可以重复时，单靠 score 值无法判断一个元素的身份，所以需要连 member 域都一并检查才行。</p></li><li><p>每个节点都带有一个高度为 1 层的后退指针，用于从表尾方向向表头方向迭代：当执行 ZREVRANGE 或 ZREVRANGEBYSCORE 这类以逆序处理有序集的命令时，就会用到这个属性。</p></li></ul><p>实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; ZADD s 6 x 10 y 15 z</span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line">redis&gt; ZRANGE s 0 -1 WITHSCORES</span><br><span class="line">1) &quot;x&quot;</span><br><span class="line">2) &quot;6&quot;</span><br><span class="line">3) &quot;y&quot;</span><br><span class="line">4) &quot;10&quot;</span><br><span class="line">5) &quot;z&quot;</span><br><span class="line">6) &quot;15&quot;</span><br></pre></td></tr></table></figure><p>在底层实现中， Redis 为 x 、 y 和 z 三个 member 分别创建了三个字符串， 值分别为 double 类型的 6 、 10 和 15 ， 然后用跳跃表将这些指针有序地保存起来， 形成这样一个跳跃表：</p><p><img src="/images/redis_skip_list_realize.jpg" alt></p><ul><li><p>跳跃表是一种随机化数据结构，查找、添加、删除操作都可以在对数期望时间下完成。</p></li><li><p>跳跃表目前在 Redis 的唯一作用，就是作为有序集类型的底层数据结构之一，另一个构成有序集的结构是字典。<br>  为了满足自身的需求，Redis 基于 William Pugh 论文中描述的跳跃表进行了修改，包括：</p><ul><li>score 值可重复， 经典skiplist中是不允许的；</li><li>对比一个元素需要同时检查它的 score 和 memeber；</li><li>每个节点带有高度为 1 层的后退指针，双向链表，用于从表尾方向向表头方向迭代；</li><li>在skiplist中可以很方便地计算出每个元素的排名(rank)；</li></ul></li></ul><p>实际上，Redis中sorted set的实现是这样的：</p><ul><li><p>当数据较少时，sorted set是由一个ziplist来实现的。</p></li><li><p>当数据多的时候，sorted set是由一个dict + 一个skiplist来实现的。简单来讲，dict用来查询数据到分数的对应关系，而skiplist用来根据分数查询数据（可能是范围查找）。</p><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2></li></ul><h3 id="tcp确认机制"><a href="#tcp确认机制" class="headerlink" title="tcp确认机制"></a>tcp确认机制</h3><p>在TCP确认机制中，无法有效处理非连续TCP片段。<strong>确认号表明所有低于该编号的sequence number已经被发送该编号的设备接收</strong>。如果我们收到的字节数落在两个非连续的范围内，则无法只通过一个编号来确认。这可能导致潜在严重的性能问题，特别是高速或可靠性较差的网络。</p><ul><li><p><strong>仅重传超时片段</strong><br>每个片段发送后，发送端都有一个计时器，在一定时间内没有收到包含该片段的ack信息，就认为该片段接收超时。<br>这是一种更加保守的方式，仅重传超时的片段，希望其他片段都能够成功接收。如果该片段之后的其他片段实际上接收到了，这一方式是最佳的，如果没接收到，就无法正常执行。后者的情况每一个片段需要单独计时并重传。<br>假设上述最坏情况下，所有20个500字节片段都丢失了。我们需要等片段1超时并重传。这一片段也许会得到确认，但之后我们需要等待片段2超时并重传。这一过程会重复多次。</p></li><li><p><strong>重传所有片段</strong><br>这是一种更激进或者说更悲观的方式。无论何时一个片段超时了，不仅重传该片段，还有所有其他尚未确认的片段。这一方式确保了任何时间都有一个等待确认的停顿时间，在所有未确认片段丢失的情况下，会刷新全部未确认片段，以使对端设备多一次接收机会。在所有20个片段都丢失的情况下，相对于第一种方式节省了大量时间。这种方式的问题在于可能这些重传是不必要的。如果第一个片段丢失而其他19个实际上接收到了，也得重传那9500字节数据。</p></li></ul><p>由于TCP不知道其他片段是否接收到，所以它也无法确认哪种方法更好，但只能选择一种方式。解决方式是对TCP滑动窗口算法进行扩展，添加允许设备分别确认非连续片段的功能。这一功能称为<strong>选择确认</strong>（selective acknowledgment, SACK）。</p><p><strong>选择确认：</strong><br>通过SACK，连接的两方设备必须同时支持这一功能，通过连接时使用的SYN片段来协商是否允许SACK。这一过程完成之后，任一设备都可以在常规TCP片段中使用SACK选项。<br>这一选项包含一个关于 <strong>已接收但未确认片段数据sequence number范围的列表</strong>，由于它们是非连续的。</p><p>各设备对重传队列进行修改，如果该片段已被选择确认过，则该片段中的SACK比特位置为1。<strong>该设备使用图2中激进方式的改进版本，一个片段重传之后，之后所有片段也会重传，除非SACK比特位为1</strong>。</p><p>例如，在4个片段的情况下，如果客户端接收到片段4而没有接收到片段3，当它发回确认号为201（片段1和片段2）的确认信息，其中包含一个SACK选项指明：“已接收到字节361至500，但尚未确认”。如果片段4在片段1和2之后到达，上述信息也可以通过第二个确认片段来完成。服务器确认片段4的字节范围，并为片段4打开SACK位。当片段3重传时，服务器看到片段4的SACK位为1，就不会对其重传。</p><p>在片段3重传之后，片段4的SACK位被清除。这是为了防止客户端出于某种原因改变片段4已接收的想法。客户端应当发送确认号为501或更高的确认信息，正式确认片段3和4接收到。<strong>如果这一情况没有发生，服务器必须接收到片段4的另一条选择确认信息才能将它的SACK位打开，否则，在片段3重传时或计时器超时的情况下会对其自动重传</strong>。</p><p><a href="https://wizardforcel.gitbooks.io/network-basic/9.html" target="_blank" rel="noopener">https://wizardforcel.gitbooks.io/network-basic/9.html</a></p><h3 id="为什么tcp是可靠协议，怎么做到不丢包的？"><a href="#为什么tcp是可靠协议，怎么做到不丢包的？" class="headerlink" title="为什么tcp是可靠协议，怎么做到不丢包的？"></a>为什么tcp是可靠协议，怎么做到不丢包的？</h3><blockquote><p>窗口滑动协议<br>重传机制</p></blockquote><p>将TCP与UDP这样的简单传输协议区分开来的是它<strong>传输数据的质量</strong>。TCP对于发送数据进行跟踪，这种数据管理需要协议有以下两大关键功能：</p><ul><li><strong>可靠性</strong>：保证数据确实到达目的地。如果未到达，能够发现并重传；</li><li><strong>数据流控</strong>：管理数据的发送速率，以使接收设备不致于过载；</li></ul><p>要完成这些任务，整个协议操作是围绕滑动窗口确认机制来进行的。</p><p><strong>TCP面向流的滑动窗口确认机制:</strong><br>每一条消息都有一个识别编号，每一条消息都能够被独立地确认，因此同一时刻可以发送多条信息。设备B定期发送给A一条发送限制参数，制约设备A一次能发送的消息最大数量。设备B可以对该参数进行调整，以控制设备A的数据流。</p><p>为了提高速度，TCP并没有按照字节单个发送而是将<strong>数据流划分为片段</strong>。<strong>片段内所有字节都是一起发送和接收的，因此也是一起确认的</strong>。确认机制没有采用message ID字段，而是<strong>使用的片段内最后一个字节的sequence number</strong>。因此一次可以处理不同的字节数，这一数量即为片段内的sequence number。</p><ul><li><p><strong>发送窗口</strong><br>整个过程关键的操作在于接收方允许发送方一次能容纳的未确认的字节数，有时也称为窗口。该窗口决定了发送方允许传送的字节数。</p></li><li><p><strong>可用窗口</strong><br>考虑到正在传输的数据量，发送方仍被允许发送的数据量。</p></li></ul><p><a href="https://wizardforcel.gitbooks.io/network-basic/7.html" target="_blank" rel="noopener">https://wizardforcel.gitbooks.io/network-basic/7.html</a></p><h3 id="七层负载均衡和四层负载均衡的区别"><a href="#七层负载均衡和四层负载均衡的区别" class="headerlink" title="七层负载均衡和四层负载均衡的区别"></a>七层负载均衡和四层负载均衡的区别</h3><ul><li><p>二层负载均衡会通过一个虚拟 MAC 地址接收请求，然后再分配到真实的 MAC 地址；</p></li><li><p>三层负载均衡会通过一个虚拟 IP 地址接收请求，然后再分配到真实的 IP 地址；</p></li><li><p>四层通过虚拟 IP + 端口接收请求，然后再分配到真实的服务器；</p></li><li><p>七层通过虚拟的 URL 或主机名接收请求，然后再分配到真实的服务器。</p></li></ul><p>所谓的四到七层负载均衡，就是在对后台的服务器进行负载均衡时，依据四层的信息或七层的信息来决定怎么样转发流量。</p><p>对于一般的应用来说，有了Nginx就够了。<strong>Nginx可以用于七层负载均衡</strong>。但是对于一些大的网站，一般会采用DNS+四层负载+七层负载的方式进行多层次负载均衡。<br><img src="/images/four_seven_rebalance.jpg" alt></p><p>对比：<br>负载均衡器通常称为四层交换机或七层交换机。</p><ul><li>四层交换机主要分析 IP 层及 TCP/UDP 层，实现四层流量负载均衡。</li><li>七层交换机除了支持四层负载均衡以外，还有分析应用层的信息，如 HTTP 协议 URI 或 Cookie 信息。</li><li>负载均衡分为 L4 Switch（四层交换），即在 OSI第4层工作，就是 TCP层。<br>此种 Load Balancer 不理解应用协议（如 HTTP/FTP/MySQL 等等）。例子：LVS，F5。</li><li>L7 Switch（七层交换），OSI 的最高层，应用层。<br>此时，该 Load Balancer 能理解应用协议。例子： HAProxy，MySQL Proxy。</li></ul><p>注意：上面的很多 Load Balancer 既可以做四层交换，也可以做七层交换。<br><img src="/images/rebalce_layer_diff.jpg" alt></p><h3 id="常用负载均衡工具"><a href="#常用负载均衡工具" class="headerlink" title="常用负载均衡工具"></a>常用负载均衡工具</h3><p>Nginx/LVS/HAProxy是目前使用最广泛的三种负载均衡软件。</p><ul><li><p>LVS<br>LVS（Linux Virtual Server），也就是Linux虚拟服务器, 是一个由章文嵩博士发起的自由软件项目。使用LVS技术要达到的目标是：<strong>通过LVS提供的负载均衡技术和Linux操作系统实现一个高性能、高可用的服务器群集</strong>，它具有良好可靠性、可扩展性和可操作性。从而以低廉的成本实现最优的服务性能。</p><p>  <strong>LVS主要用来做四层负载均衡</strong>。</p></li><li><p>Nginx<br>Nginx（发音同engine x）是一个网页服务器，它能反向代理HTTP, HTTPS, SMTP, POP3, IMAP的协议链接，以及一个负载均衡器和一个HTTP缓存。</p><p>  <strong>Nginx主要用来做七层负载均衡</strong>。</p></li><li><p>HAProxy<br>HAProxy是一个使用C语言编写的自由及开放源代码软件，其提供高可用性、负载均衡，以及基于TCP和HTTP的应用程序代理。</p><p>  <strong>Haproxy主要用来做七层负载均衡。</strong></p></li></ul><p>负载均衡算法可以分为两类：<strong>静态负载均衡算法</strong>和<strong>动态负载均衡算法</strong>。</p><p>静态负载均衡算法包括：<strong>轮询，比率，优先权</strong></p><p>动态负载均衡算法包括: <strong>最少连接数, 最快响应速度，观察方法，预测法，动态性能分配， 动态服务器补充， 服务质量， 服务类型， 规则模式</strong>。</p><p><a href="https://cloud.tencent.com/developer/article/1082047" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1082047</a></p><h3 id="微信网页扫码登陆的通信过程是什么样的；"><a href="#微信网页扫码登陆的通信过程是什么样的；" class="headerlink" title="微信网页扫码登陆的通信过程是什么样的；"></a>微信网页扫码登陆的通信过程是什么样的；</h3><p>OAuth2协议</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> +----------+</span><br><span class="line"> | Resource |</span><br><span class="line"> |   Owner  |</span><br><span class="line"> |          |</span><br><span class="line"> +----------+</span><br><span class="line">      ^</span><br><span class="line">      |</span><br><span class="line">     (B)</span><br><span class="line"> +----|-----+          Client Identifier      +---------------+</span><br><span class="line"> |         -+----(A)-- &amp; Redirection URI ----&gt;|               |</span><br><span class="line"> |  User-   |                                 | Authorization |</span><br><span class="line"> |  Agent  -+----(B)-- User authenticates ---&gt;|     Server    |</span><br><span class="line"> |          |                                 |               |</span><br><span class="line"> |         -+----(C)-- Authorization Code ---&lt;|               |</span><br><span class="line"> +-|----|---+                                 +---------------+</span><br><span class="line">   |    |                                         ^      v</span><br><span class="line">  (A)  (C)                                        |      |</span><br><span class="line">   |    |                                         |      |</span><br><span class="line">   ^    v                                         |      |</span><br><span class="line"> +---------+                                      |      |</span><br><span class="line"> |         |&gt;---(D)-- Authorization Code ---------&apos;      |</span><br><span class="line"> |  Client |          &amp; Redirection URI                  |</span><br><span class="line"> | (Web后端)|                                             |</span><br><span class="line"> |         |&lt;---(E)----- Access Token -------------------&apos;</span><br><span class="line"> +---------+       (w/ Optional Refresh Token)</span><br><span class="line"></span><br><span class="line">Note: The lines illustrating steps (A), (B), and (C) are broken into two parts as they pass through the user-agent.</span><br></pre></td></tr></table></figure><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="求一个int数二进制形式中1出现的个数"><a href="#求一个int数二进制形式中1出现的个数" class="headerlink" title="求一个int数二进制形式中1出现的个数"></a>求一个int数二进制形式中1出现的个数</h3><p>位运算<br>(1) count = n &amp; 1; n&gt;&gt;1;  循环32次<br>(2) n &amp; (n-1), 每次可把最低位1变成 0；</p><h3 id="一个二叉树某一个路径和等于某值"><a href="#一个二叉树某一个路径和等于某值" class="headerlink" title="一个二叉树某一个路径和等于某值"></a>一个二叉树某一个路径和等于某值</h3><p>回溯算法</p><h3 id="字符串倒转的时间复杂度和空间复杂度"><a href="#字符串倒转的时间复杂度和空间复杂度" class="headerlink" title="字符串倒转的时间复杂度和空间复杂度"></a>字符串倒转的时间复杂度和空间复杂度</h3><p>双指针法一次遍历，使用 O(1) 的额外空间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverseString</span><span class="params">(<span class="keyword">char</span>[] s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> temp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = s.length - <span class="number">1</span>; i &lt;= j; i++, j--)&#123;</span><br><span class="line">        temp = s[j];</span><br><span class="line">        s[j] = s[i];</span><br><span class="line">        s[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：<em>O(N)*，执行了 *N/2</em> 次的交换。<br>空间复杂度：<em>O(1)</em>，只使用了常数级空间</p><h3 id="两个链表分别表示两个数，求和"><a href="#两个链表分别表示两个数，求和" class="headerlink" title="两个链表分别表示两个数，求和"></a>两个链表分别表示两个数，求和</h3><ul><li>双队列法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        Stack&lt;ListNode&gt; stack1 = <span class="keyword">new</span> Stack&lt;ListNode&gt;();</span><br><span class="line">        Stack&lt;ListNode&gt; stack2 = <span class="keyword">new</span> Stack&lt;ListNode&gt;();</span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack1.add(l1);</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack2.add(l2);</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode h0 = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode cur1 , cur2;</span><br><span class="line">        <span class="keyword">int</span> re = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!stack1.isEmpty() || !stack2.isEmpty())&#123;</span><br><span class="line">            cur1 = <span class="keyword">null</span>;</span><br><span class="line">            cur2 = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span>(!stack1.isEmpty())&#123;</span><br><span class="line">                cur1 = stack1.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!stack2.isEmpty())&#123;</span><br><span class="line">                cur2 = stack2.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(cur1 == <span class="keyword">null</span>)&#123;</span><br><span class="line">                cur1 = cur2;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(cur2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">                cur1.val += cur2.val; </span><br><span class="line">            &#125;</span><br><span class="line">            cur1.val += re;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> temp = cur1.val;</span><br><span class="line">            cur1.val = temp % <span class="number">10</span>;</span><br><span class="line">            re = temp / <span class="number">10</span>;</span><br><span class="line">            cur1.next = h0.next;</span><br><span class="line">            h0.next = cur1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(re != <span class="number">0</span>)&#123;</span><br><span class="line">            ListNode node = <span class="keyword">new</span> ListNode(re);</span><br><span class="line">            node.next = h0.next;</span><br><span class="line">            h0.next = node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> h0.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>递归法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flow=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1==<span class="keyword">null</span>) <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span>(l2==<span class="keyword">null</span>) <span class="keyword">return</span> l1;</span><br><span class="line">        ListNode res1=l1,res2=l2;</span><br><span class="line">        <span class="keyword">int</span> len1=<span class="number">0</span>,len2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l1!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            len1++;</span><br><span class="line">            l1=l1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(l2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            len2++;</span><br><span class="line">            l2=l2.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode res=len1&gt;len2?add(res1,res2,len1,len2):add(res2,res1,len2,len1);</span><br><span class="line">        <span class="keyword">if</span>(flow==<span class="number">1</span>) &#123;</span><br><span class="line">            res1=<span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">            res1.next=res;</span><br><span class="line">            <span class="keyword">return</span> res1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">add</span><span class="params">(ListNode l1, ListNode l2,<span class="keyword">int</span> len1,<span class="keyword">int</span> len2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="keyword">if</span>((len1==<span class="number">1</span>)&amp;&amp;(len2==<span class="number">1</span>))&#123;</span><br><span class="line">            temp=l1.val;</span><br><span class="line">            l1.val=(l1.val+l2.val)%<span class="number">10</span>;</span><br><span class="line">            flow=(temp+l2.val)/<span class="number">10</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len1&gt;len2) &#123;</span><br><span class="line">            temp=l1.val;</span><br><span class="line">            l1.next=add(l1.next, l2, len1-<span class="number">1</span>, len2);</span><br><span class="line">            l1.val=(temp+flow)%<span class="number">10</span>;</span><br><span class="line">            flow=(temp+flow)/<span class="number">10</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l1.next=add(l1.next, l2.next, len1-<span class="number">1</span>, len2-<span class="number">1</span>);</span><br><span class="line">            temp=l1.val;</span><br><span class="line">            l1.val=(temp+flow+l2.val)%<span class="number">10</span>;</span><br><span class="line">            flow=(temp+flow+l2.val)/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="两个list分别表示两个数，求和"><a href="#两个list分别表示两个数，求和" class="headerlink" title="两个list分别表示两个数，求和"></a>两个list分别表示两个数，求和</h3><h3 id="paxo算法是啥，zab算法"><a href="#paxo算法是啥，zab算法" class="headerlink" title="paxo算法是啥，zab算法"></a>paxo算法是啥，zab算法</h3><h3 id="怎么对ip进行限流，比如某个ip-1小时最多访问1万次，写出代码；"><a href="#怎么对ip进行限流，比如某个ip-1小时最多访问1万次，写出代码；" class="headerlink" title="怎么对ip进行限流，比如某个ip 1小时最多访问1万次，写出代码；"></a>怎么对ip进行限流，比如某个ip 1小时最多访问1万次，写出代码；</h3><h3 id="从A、B两个数组中各取一个数，求两数差值最小"><a href="#从A、B两个数组中各取一个数，求两数差值最小" class="headerlink" title="从A、B两个数组中各取一个数，求两数差值最小"></a>从A、B两个数组中各取一个数，求两数差值最小</h3><p>N个数组中取两个数差值最小， N个数组中取两个数差值最小</p><h3 id="电梯算法"><a href="#电梯算法" class="headerlink" title="电梯算法"></a>电梯算法</h3><p>每层有一个value表示可上或可下value层，求A层到B层的最短按键数</p><h3 id="实现一个栈，-有push-pop-获取最小值-三个方法-要求-快！"><a href="#实现一个栈，-有push-pop-获取最小值-三个方法-要求-快！" class="headerlink" title="实现一个栈， 有push pop 获取最小值 三个方法  要求 快！"></a>实现一个栈， 有push pop 获取最小值 三个方法  要求 快！</h3><h3 id="直播间在线人数统计"><a href="#直播间在线人数统计" class="headerlink" title="直播间在线人数统计"></a>直播间在线人数统计</h3><p>有一个日志文件，一个人进入直播间会有一个uid和进入时间，退出直播间会有一个uid和退出时间，一次直播的过程中 同一时刻最多的在线人数怎么求？</p><blockquote><p>一次遍历，第一次出现 +1， 第二次出现 -1；</p></blockquote><p>接上一题，如果日志文件不是按照时间排序的，那在o(n)时间内求同一时刻最多的在线人数</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JAVA基础&quot;&gt;&lt;a href=&quot;#JAVA基础&quot; class=&quot;headerlink&quot; title=&quot;JAVA基础&quot;&gt;&lt;/a&gt;JAVA基础&lt;/h2&gt;&lt;h3 id=&quot;Java的collection接口继承关系&quot;&gt;&lt;a href=&quot;#Java的collection接
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
      <category term="面试" scheme="http://yoursite.com/categories/Java/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>OAuth2 协议简介</title>
    <link href="http://yoursite.com/2020/02/23/OAuth2-%E5%8D%8F%E8%AE%AE%E7%AE%80%E4%BB%8B/"/>
    <id>http://yoursite.com/2020/02/23/OAuth2-协议简介/</id>
    <published>2020-02-23T03:16:08.000Z</published>
    <updated>2020-03-23T03:21:53.976Z</updated>
    
    <content type="html"><![CDATA[<p>OAuth是一个关于授权的开放网络标准，用来授权第三方应用，获取用户的数据。其最终的目的是为了给第三方应用颁发一个有时效性的令牌access_token，第三方应用根据这个access_token就可以去获取用户的相关资源，如头像，昵称，email这些信息。现在大家用的基本是2.0的版本。</p><h2 id="协议流程"><a href="#协议流程" class="headerlink" title="协议流程"></a>协议流程</h2><p>在详细介绍oAuth2协议流程之前，先来简单了解几个角色，方便后续的理解。</p><ul><li><p><strong>Resource Owner</strong>： 资源所有者，因为是请求用户的头像和昵称的一些信息，所以资源的所有者一般指用户自己；</p></li><li><p><strong>Client</strong>：客户端，如web网站，app等；</p></li><li><p><strong>Resource Server</strong>： 资源服务器，托管受保护资源的服务器；</p></li><li><p><strong>Authorization Server</strong>： 授权服务器，一般和资源服务器是同一家公司的应用，主要是用来处理授权，给客户端颁发令牌；</p></li><li><p><strong>User-agent</strong>：用户代理，一般为web浏览器，在手机上就是app</p></li></ul><p>了解了上面这些角色之后，来看下oAuth2.0的运行流程是怎么样的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+--------+                               +---------------+</span><br><span class="line">|        |--(A)- Authorization Request -&gt;|   Resource    |</span><br><span class="line">|        |                               |     Owner     |</span><br><span class="line">|        |&lt;-(B)-- Authorization Grant ---|               |</span><br><span class="line">|        |                               +---------------+</span><br><span class="line">|        |</span><br><span class="line">|        |                               +---------------+</span><br><span class="line">|        |--(C)-- Authorization Grant --&gt;| Authorization |</span><br><span class="line">| Client |                               |     Server    |</span><br><span class="line">|        |&lt;-(D)----- Access Token -------|               |</span><br><span class="line">|        |                               +---------------+</span><br><span class="line">|        |</span><br><span class="line">|        |                               +---------------+</span><br><span class="line">|        |--(E)----- Access Token ------&gt;|    Resource   |</span><br><span class="line">|        |                               |     Server    |</span><br><span class="line">|        |&lt;-(F)--- Protected Resource ---|               |</span><br><span class="line">+--------+                               +---------------+</span><br></pre></td></tr></table></figure><ul><li><p>(A). 用户打开客户端(Client)，客户端向资源所有者(Resource Owner)也就是用户发送一个授权请求；</p></li><li><p>(B). 用户同意给客户端(Client)授权</p></li><li><p>(C). 客户端使用刚才的授权去向认证服务器(Authorization Server)认证</p></li><li><p>(D). 认证服务器认证通过后，会给客户端发放令牌(Access Token)</p></li><li><p>(E). 客户端拿着令牌(Access Token)，去向资源服务器(Resource Server)申请获取资源</p></li><li><p>(F). 资源服务器确认令牌之后，给客户端返回受保护的资源(Protected Resource)</p></li></ul><h2 id="授权方式"><a href="#授权方式" class="headerlink" title="授权方式"></a>授权方式</h2><p>在oAuth2当中，定义了四种授权方式，针对不同的业务场景：</p><ul><li><p>授权码模式(authorization code)<br>流程最完整和严密的一种授权方式，服务器和客户端配合使用，主要是针对web服务器的情况采用</p></li><li><p>简化模式(implicit)<br>主要用于移动应用程序或纯前端的web应用程序，主要是针对没有web服务器的情况采用</p></li><li><p>密码模式(resource owner password credentials)<br>不推荐，用户需要向客户端提供自己的账号和密码，如果客户端是自家应用的话，也是可以的</p></li><li><p>客户端模式(client credentials)<br>客户端以自己的名义，而不是用户的名义，向“服务提供商”进行认证，如微信公众号以此access_token来拉取所有已关注用户的信息，docker到dockerhub拉取镜像等</p></li></ul><h2 id="授权码模式"><a href="#授权码模式" class="headerlink" title="授权码模式"></a>授权码模式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> +----------+</span><br><span class="line"> | Resource |</span><br><span class="line"> |   Owner  |</span><br><span class="line"> |          |</span><br><span class="line"> +----------+</span><br><span class="line">      ^</span><br><span class="line">      |</span><br><span class="line">     (B)</span><br><span class="line"> +----|-----+          Client Identifier      +---------------+</span><br><span class="line"> |         -+----(A)-- &amp; Redirection URI ----&gt;|               |</span><br><span class="line"> |  User-   |                                 | Authorization |</span><br><span class="line"> |  Agent  -+----(B)-- User authenticates ---&gt;|     Server    |</span><br><span class="line"> |          |                                 |               |</span><br><span class="line"> |         -+----(C)-- Authorization Code ---&lt;|               |</span><br><span class="line"> +-|----|---+                                 +---------------+</span><br><span class="line">   |    |                                         ^      v</span><br><span class="line">  (A)  (C)                                        |      |</span><br><span class="line">   |    |                                         |      |</span><br><span class="line">   ^    v                                         |      |</span><br><span class="line"> +---------+                                      |      |</span><br><span class="line"> |         |&gt;---(D)-- Authorization Code ---------&apos;      |</span><br><span class="line"> |  Client |          &amp; Redirection URI                  |</span><br><span class="line"> | (Web后端)|                                             |</span><br><span class="line"> |         |&lt;---(E)----- Access Token -------------------&apos;</span><br><span class="line"> +---------+       (w/ Optional Refresh Token)</span><br><span class="line"></span><br><span class="line">Note: The lines illustrating steps (A), (B), and (C) are broken into two parts as they pass through the user-agent.</span><br></pre></td></tr></table></figure><p>授权码模式如上图所示，这种流程是功能最完整，流程也是最严密的授权方式，适用于那些<strong>有后端的web应用</strong>。它的特点是<strong>通过客户端的后台服务器和服务商的认证服务器进行通讯</strong>。它的流程如下,如果我想使用github来接入第三方登录：</p><p>(A). 用户(Resource Owner)在用户代理(User-Agent，如web浏览器，app)上选择了第三方应用(如github)来进行登录，会重定向到github的授权端点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/login/oauth/authorize?</span><br><span class="line">response_type=code&amp;</span><br><span class="line">client_id=your_code&amp;</span><br><span class="line">redirect_uri=重定向的url&amp;</span><br><span class="line">scope=read&amp;</span><br><span class="line">state=uuid</span><br></pre></td></tr></table></figure><table><thead><tr><th>字段</th><th>描述</th></tr></thead><tbody><tr><td>response_type</td><td>必须，在授权码模式中固定为code</td></tr><tr><td>client_id</td><td>必须，唯一标识了客户端，在github注册时获得的客户端ID</td></tr><tr><td>redirect_url</td><td>客户端在github注册的重定向url，用户同意或拒绝的时候都会跳转到这个重定向url</td></tr><tr><td>scope</td><td>可选，请求资源范围，如有多项，使用多个空格隔开</td></tr><tr><td>state</td><td>推荐，客户端生成的随机数，资源服务器会原样返回，防止CSRF的攻击</td></tr></tbody></table><p>(B). 页面跳转后，github会要求用户登录，然后询问是否给予客户端授权，用户点击同意。</p><p>(C). 然后github就会将授权码(Authorization Code)返回给redirect_uri(重定向uri)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redirect_uri?code=xxxxxxx</span><br></pre></td></tr></table></figure><table><thead><tr><th>字段</th><th>描述</th></tr></thead><tbody><tr><td>code</td><td>必须，授权码</td></tr><tr><td>state</td><td>防止CSRF攻击的参数</td></tr></tbody></table><p>(D). 客户端(Client)在通过在URL中取出授权码之后，就可以在后端向github请求令牌</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/login/oauth/access_token?</span><br><span class="line">client_id=your_code&amp;</span><br><span class="line">client_secret=your_secret&amp;</span><br><span class="line">grant_type=authorization_code&amp;</span><br><span class="line">code=取出的code&amp;</span><br><span class="line">redirect_uri=重定向的url</span><br></pre></td></tr></table></figure><table><thead><tr><th>字段</th><th>描述</th></tr></thead><tbody><tr><td>client_id</td><td>必须，客户端在github注册的唯一标识</td></tr><tr><td>client_secret</td><td>必须，客户端在github注册时返回的密钥</td></tr><tr><td>grant_type</td><td>必须，authorization_code/refresh_code</td></tr><tr><td>code</td><td>必须，上一步中取出的授权码</td></tr><tr><td>redirect_uri</td><td>必须，完成授权之后的回调地址，与在github注册时的一致</td></tr></tbody></table><p>(E). github给redirect_uri指定的地址返回AccessToken，通过JSON格式返回</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"access_token"</span>:<span class="string">"xxxxxxx"</span>,</span><br><span class="line">  <span class="attr">"token_type"</span>:<span class="string">"bearer"</span>,</span><br><span class="line">  <span class="attr">"expires_in"</span>:<span class="number">3600</span>,</span><br><span class="line">  <span class="attr">"refresh_token"</span>:<span class="string">"xxxxxxx"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端就可以在后端取到access_token, 在这段json中，还返回了一个refresh_token，这个refresh_token表示用于访问下一次的更新令牌，refresh_token的时效性比access_token长，当access_token过期时，可以使用refresh_token换取新的access_token。</p><h2 id="简化模式"><a href="#简化模式" class="headerlink" title="简化模式"></a>简化模式</h2><p>简化模式主要针对没有后端的纯前端应用，在这种情况下，因为没有后端，所以就不能采用授权码模式的这种流程了，必须要把access_token存在前端。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">+----------+</span><br><span class="line">| Resource |</span><br><span class="line">|  Owner   |</span><br><span class="line">|          |</span><br><span class="line">+----------+</span><br><span class="line">     ^</span><br><span class="line">     |</span><br><span class="line">    (B)</span><br><span class="line">+----|-----+          Client Identifier     +---------------+</span><br><span class="line">|         -+----(A)-- &amp; Redirection URI ---&gt;|               |</span><br><span class="line">|  User-   |                                | Authorization |</span><br><span class="line">|  Agent  -|----(B)-- User authenticates --&gt;|     Server    |</span><br><span class="line">|          |                                |               |</span><br><span class="line">|          |&lt;---(C)--- Redirection URI ----&lt;|               |</span><br><span class="line">|          |          with Access Token     +---------------+</span><br><span class="line">|          |            in Fragment</span><br><span class="line">|          |                                +---------------+</span><br><span class="line">|          |----(D)--- Redirection URI ----&gt;|   Web-Hosted  |</span><br><span class="line">|          |          without Fragment      |     Client    |</span><br><span class="line">|          |                                |    Resource   |</span><br><span class="line">|     (F)  |&lt;---(E)------- Script ---------&lt;|               |</span><br><span class="line">|          |                                +---------------+</span><br><span class="line">+-|--------+</span><br><span class="line">  |    |</span><br><span class="line"> (A)  (G) Access Token</span><br><span class="line">  |    |</span><br><span class="line">  ^    v</span><br><span class="line">+---------+</span><br><span class="line">|         |</span><br><span class="line">|  Client |</span><br><span class="line">|         |</span><br><span class="line">+---------+</span><br></pre></td></tr></table></figure><p>Note: The lines illustrating steps (A) and (B) are broken into two parts as they pass through the user-agent.</p><p>主要是B这个步骤，页面跳转到github网站，用户同意给予客户端授权。github就会把令牌作为URL参数，跳转回到redirect_uri的这个回调地址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">回调地址#token=xxxxxx</span><br></pre></td></tr></table></figure><p>注意，令牌的位置是 URL 锚点（fragment），而不是查询字符串（querystring），这是因为 OAuth 2.0 允许跳转网址是 HTTP 协议，因此存在”中间人攻击”的风险，而浏览器跳转时，锚点不会发到服务器，就减少了泄漏令牌的风险。</p><h2 id="密码模式"><a href="#密码模式" class="headerlink" title="密码模式"></a>密码模式</h2><p>如果你高度信任某个应用，RFC 6749 也允许用户把用户名和密码，直接告诉该应用。该应用就使用你的密码，申请令牌，这种方式称为”密码式”（password）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+----------+</span><br><span class="line"> | Resource |</span><br><span class="line"> |  Owner   |</span><br><span class="line"> |          |</span><br><span class="line"> +----------+</span><br><span class="line">      v</span><br><span class="line">      |    Resource Owner</span><br><span class="line">     (A) Password Credentials</span><br><span class="line">      |</span><br><span class="line">      v</span><br><span class="line"> +---------+                                  +---------------+</span><br><span class="line"> |         |&gt;--(B)---- Resource Owner -------&gt;|               |</span><br><span class="line"> |         |         Password Credentials     | Authorization |</span><br><span class="line"> | Client  |                                  |     Server    |</span><br><span class="line"> |         |&lt;--(C)---- Access Token ---------&lt;|               |</span><br><span class="line"> |         |    (w/ Optional Refresh Token)   |               |</span><br><span class="line"> +---------+                                  +---------------+</span><br></pre></td></tr></table></figure><p>密码模式就是用户向客户端提供自己的账号和密码，客户端使用这些信息去向我们的服务提供商去索要一个授权。</p><h2 id="客户端模式"><a href="#客户端模式" class="headerlink" title="客户端模式"></a>客户端模式</h2><p>客户端以自己的名义，而不是用户的名义，向“服务提供商”进行认证，如微信公众号以此access_token来拉取所有已关注用户的信息，docker到dockerhub拉取镜像等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+---------+                                  +---------------+</span><br><span class="line">|         |                                  |               |</span><br><span class="line">|         |&gt;--(A)- Client Authentication ---&gt;| Authorization |</span><br><span class="line">| Client  |                                  |     Server    |</span><br><span class="line">|         |&lt;--(B)---- Access Token ---------&lt;|               |</span><br><span class="line">|         |                                  |               |</span><br><span class="line">+---------+                                  +---------------+</span><br></pre></td></tr></table></figure><p>客户端模式，顾名思义就是指客户端以自己的名义而不是用户的名义去向服务的提供商去做一个认证，严格来说，这种模式并不是 oAuth 框架要解决的问题，在这种客户端模式下呢，它是直接通过客户端的密钥和id去获取一个access_token的，不需要用户去参与。</p><p>参考文章：<br><a href="https://juejin.im/post/5dd34a47f265da0c091575e5" target="_blank" rel="noopener">理解 OAuth2 协议</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;OAuth是一个关于授权的开放网络标准，用来授权第三方应用，获取用户的数据。其最终的目的是为了给第三方应用颁发一个有时效性的令牌access_token，第三方应用根据这个access_token就可以去获取用户的相关资源，如头像，昵称，email这些信息。现在大家用的基本
      
    
    </summary>
    
      <category term="协议" scheme="http://yoursite.com/categories/%E5%8D%8F%E8%AE%AE/"/>
    
      <category term="OAuth2" scheme="http://yoursite.com/categories/%E5%8D%8F%E8%AE%AE/OAuth2/"/>
    
    
      <category term="认证协议" scheme="http://yoursite.com/tags/%E8%AE%A4%E8%AF%81%E5%8D%8F%E8%AE%AE/"/>
    
      <category term="OAuth2" scheme="http://yoursite.com/tags/OAuth2/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot基本原理</title>
    <link href="http://yoursite.com/2020/01/10/SpringBoot%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2020/01/10/SpringBoot基本原理/</id>
    <published>2020-01-10T12:51:16.000Z</published>
    <updated>2020-01-10T12:57:31.108Z</updated>
    
    <content type="html"><![CDATA[<h2 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h2><p>启动类代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringBootDemoApplication</span> <span class="keyword">extends</span> <span class="title">SpringBootServletInitializer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringBootDemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对照上面的典型代码，这个两个元素分别是：</p><blockquote><p>@SpringBootApplication<br>SpringApplication 以及 run() 方法</p></blockquote><p>SpringApplication 这个类应该算是 SpringBoot 框架 的“创新”产物了，原始的 Spring中并没有这个类，SpringApplication 里面封装了一套 Spring 应用的启动流程，然而这对用户完全透明，因此我们上手 SpringBoot 时感觉简洁、轻量。</p><p>一般来说默认的 SpringApplication 执行流程已经可以满足大部分需求，但是 若用户想干预这个过程，则可以通过 SpringApplication 在流程某些地方开启的 扩展点 来完成对流程的扩展，典型的扩展方案那就是使用 set 方法。<br>我们来举一个栗子，把我们天天司空见惯的 SpringBoot 应用的启动类来拆解一下写出来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringBootDemoApplication</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 这是传统SpringBoot应用的启动，一行代码搞定，内部默认做了很多事</span></span><br><span class="line"><span class="comment">// SpringApplication.run( SpringBootDemoApplication args ); </span></span><br><span class="line">SpringApplication app = <span class="keyword">new</span> SpringApplication(SpringBootDemoApplication );</span><br><span class="line">app.setXXX( ... ); <span class="comment">// 用户自定的扩展在此 ！！！</span></span><br><span class="line">app.run( args );</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一拆解后我们发现，我们也需要先构造 SpringApplication 类对象，然后调用该对象的 run() 方法。那么接下来就讲讲 SpringApplication 的构造过程 以及其 run() 方法的流程，搞清楚了这个，那么也就搞清楚了SpringBoot应用是如何运行起来的！</p><h3 id="SpringApplication-实例的初始化"><a href="#SpringApplication-实例的初始化" class="headerlink" title="SpringApplication 实例的初始化"></a>SpringApplication 实例的初始化</h3><p>首先看下SpringApplication的构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SpringApplication</span><span class="params">(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">Assert.notNull(primarySources, <span class="string">"PrimarySources must not be null"</span>);</span><br><span class="line"><span class="keyword">this</span>.primarySources = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(Arrays.asList(primarySources));</span><br><span class="line"><span class="comment">// (1) 推断应用的类型</span></span><br><span class="line"><span class="keyword">this</span>.webApplicationType = WebApplicationType.deduceFromClasspath();</span><br><span class="line"><span class="comment">// (2) 查找并加载 classpath下 META-INF/spring.factories文件中所有可用的 ApplicationContextInitializer</span></span><br><span class="line">setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));</span><br><span class="line"><span class="comment">// (3) 查找并加载 classpath下 META-INF/spring.factories文件中的所有可用的 ApplicationListener</span></span><br><span class="line">setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));</span><br><span class="line"><span class="comment">// (4) 推断并设置 main方法的定义类</span></span><br><span class="line"><span class="keyword">this</span>.mainApplicationClass = deduceMainApplicationClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>详细过程如下：</p><ul><li>（1）推断应用的类型：根据你classpath 下是否能找到对应的class文件， 推断应用类型， 优先级依次是：REACTIVE 、NONE、SERVLET(默认)。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> WebApplicationType <span class="title">deduceFromClasspath</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (ClassUtils.isPresent(WEBFLUX_INDICATOR_CLASS, <span class="keyword">null</span>) &amp;&amp; !ClassUtils.isPresent(WEBMVC_INDICATOR_CLASS, <span class="keyword">null</span>)</span><br><span class="line">&amp;&amp; !ClassUtils.isPresent(JERSEY_INDICATOR_CLASS, <span class="keyword">null</span>)) &#123;</span><br><span class="line"><span class="keyword">return</span> WebApplicationType.REACTIVE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (String className : SERVLET_INDICATOR_CLASSES) &#123;</span><br><span class="line"><span class="keyword">if</span> (!ClassUtils.isPresent(className, <span class="keyword">null</span>)) &#123;</span><br><span class="line"><span class="keyword">return</span> WebApplicationType.NONE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> WebApplicationType.SERVLET;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>（2）使用 SpringFactoriesLoader查找并加载 classpath下 <code>META-INF/spring.factories</code>文件中所有可用的 ApplicationContextInitializer</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Initializers</span><br><span class="line">org.springframework.context.ApplicationContextInitializer=\</span><br><span class="line">org.springframework.boot.autoconfigure.SharedMetadataReaderFactoryContextInitializer,\</span><br><span class="line">org.springframework.boot.autoconfigure.logging.ConditionEvaluationReportLoggingListener</span><br></pre></td></tr></table></figure><ul><li>(3) 使用 SpringFactoriesLoader查找并加载 classpath下 <code>META-INF/spring.factories</code>文件中的所有可用的 ApplicationListener</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Application Listeners</span><br><span class="line">org.springframework.context.ApplicationListener=\</span><br><span class="line">org.springframework.boot.autoconfigure.BackgroundPreinitializer</span><br></pre></td></tr></table></figure><ul><li>(4) 推断并设置main方法的定义类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Class&lt;?&gt; deduceMainApplicationClass() &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">StackTraceElement[] stackTrace = <span class="keyword">new</span> RuntimeException().getStackTrace();</span><br><span class="line"><span class="keyword">for</span> (StackTraceElement stackTraceElement : stackTrace) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="string">"main"</span>.equals(stackTraceElement.getMethodName())) &#123;</span><br><span class="line"><span class="keyword">return</span> Class.forName(stackTraceElement.getClassName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line"><span class="comment">// Swallow and continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SpringApplication-的run-方法"><a href="#SpringApplication-的run-方法" class="headerlink" title="SpringApplication 的run()方法"></a>SpringApplication 的run()方法</h3><p>先看代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">    StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">stopWatch.start();</span><br><span class="line">ConfigurableApplicationContext context = <span class="keyword">null</span>;</span><br><span class="line">Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">configureHeadlessProperty();</span><br><span class="line"><span class="comment">// 通过 SpringFactoriesLoader 加载META-INF/spring.factories文件，获取并创建 SpringApplicationRunListener对象</span></span><br><span class="line">SpringApplicationRunListeners listeners = getRunListeners(args);</span><br><span class="line"><span class="comment">// 然后由 SpringApplicationRunListener 来发出 starting 消息</span></span><br><span class="line">listeners.starting();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="comment">// 创建参数，并配置当前 SpringBoot 应用将要使用的 Environment</span></span><br><span class="line">ApplicationArguments applicationArguments = <span class="keyword">new</span> DefaultApplicationArguments(args);</span><br><span class="line"><span class="comment">// 完成之后，依然由 SpringApplicationRunListener 来发出 environmentPrepared 消息</span></span><br><span class="line">ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments);</span><br><span class="line">configureIgnoreBeanInfo(environment);</span><br><span class="line"><span class="comment">// 打印欢迎页信息</span></span><br><span class="line">Banner printedBanner = printBanner(environment);</span><br><span class="line">context = createApplicationContext();</span><br><span class="line">exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter.class,</span><br><span class="line"><span class="keyword">new</span> Class[] &#123; ConfigurableApplicationContext.class &#125;, context);</span><br><span class="line"><span class="comment">// 初始化 ApplicationContext，并设置 Environment，加载相关配置等</span></span><br><span class="line">prepareContext(context, environment, listeners, applicationArguments, printedBanner);</span><br><span class="line"><span class="comment">// 刷新context，最重要的一步，完成IOC容器注入整个过程</span></span><br><span class="line">refreshContext(context);</span><br><span class="line">afterRefresh(context, applicationArguments);</span><br><span class="line">stopWatch.stop();</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</span><br><span class="line"><span class="keyword">new</span> StartupInfoLogger(<span class="keyword">this</span>.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);</span><br><span class="line">&#125;</span><br><span class="line">listeners.started(context);</span><br><span class="line">callRunners(context, applicationArguments);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">handleRunFailure(context, ex, exceptionReporters, listeners);</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">listeners.running(context);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">handleRunFailure(context, ex, exceptionReporters, <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>流程图如下：<br><img src="/images/spring_boot_starter_pro.png" alt></p><h2 id="自动装配原理"><a href="#自动装配原理" class="headerlink" title="自动装配原理"></a>自动装配原理</h2><h3 id="自动装配过程分析"><a href="#自动装配过程分析" class="headerlink" title="自动装配过程分析"></a>自动装配过程分析</h3><p>自动装配原理得从 <code>@SpringbootApplication</code> 入手分析</p><p><img src="/images/spring_boot_application.png" alt></p><p><code>@SpringbootApplication</code>包含了<code>@SpringBootConfiguration</code>，<code>@EnableAutoConfiguration</code>，<code>@ComponentScan</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(excludeFilters = &#123;</span><br><span class="line">        <span class="meta">@Filter</span>(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span><br><span class="line">        <span class="meta">@Filter</span>(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</span><br></pre></td></tr></table></figure><ul><li><p><code>@ComponentScan</code>如果没有指定扫描包，因此它默认扫描的是与该类同级的类或者同级包下的所有类;</p></li><li><p><code>@SpringBootConfiguration</code>通过源码得知它是一个<code>@Configuration</code>;</p></li><li><p><code>@EnableAutoConfiguration</code> 一旦加上此注解，那么将会开启自动装配功能，简单点讲，Spring会试图在你的classpath下找到所有配置的Bean然后进行装配。当然装配Bean时，会根据若干个<code>@Conditional</code>定制规则来进行初始化;</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"deprecation"</span>)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import</span>(EnableAutoConfigurationImportSelector.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br><span class="line"></span><br><span class="line">    String ENABLED_OVERRIDE_PROPERTY = <span class="string">"spring.boot.enableautoconfiguration"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Exclude specific auto-configuration classes such that they will never be applied.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the classes to exclude</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Class&lt;?&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Exclude specific auto-configuration class names such that they will never be</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String[] excludeName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>根据文档注释的说明它指点我们去看<code>EnableAutoConfigurationImportSelector</code>。但是该类在SpringBoot1.5.X版本已经过时了，因此我们看一下它的父类<code>AutoConfigurationImportSelector</code>;</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AutoConfigurationImportSelector</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">DeferredImportSelector</span>, <span class="title">BeanClassLoaderAware</span>, <span class="title">ResourceLoaderAware</span>,</span></span><br><span class="line"><span class="class">        <span class="title">BeanFactoryAware</span>, <span class="title">EnvironmentAware</span>, <span class="title">Ordered</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] NO_IMPORTS = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log logger = LogFactory</span><br><span class="line">            .getLog(AutoConfigurationImportSelector.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ConfigurableListableBeanFactory beanFactory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Environment environment;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ClassLoader beanClassLoader;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ResourceLoader resourceLoader;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isEnabled(annotationMetadata)) &#123;</span><br><span class="line">            <span class="keyword">return</span> NO_IMPORTS;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 读取mata-info/spring-autoconfigure-metadata.properties元数据与元数据的相关属性</span></span><br><span class="line">            AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader</span><br><span class="line">                    .loadMetadata(<span class="keyword">this</span>.beanClassLoader);</span><br><span class="line">            AnnotationAttributes attributes = getAttributes(annotationMetadata);</span><br><span class="line">            <span class="comment">// 去 mata-info/spring.factories 文件中查询 EnableAutoConfiguration值</span></span><br><span class="line">            List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata,</span><br><span class="line">                    attributes);</span><br><span class="line">            <span class="comment">// 去除重复的配置类，若我们自己写的starter可能存在重复的</span></span><br><span class="line">            configurations = removeDuplicates(configurations);</span><br><span class="line">            configurations = sort(configurations, autoConfigurationMetadata);</span><br><span class="line">            Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);</span><br><span class="line">            checkExcludedClasses(configurations, exclusions);</span><br><span class="line">            configurations.removeAll(exclusions);</span><br><span class="line">            <span class="comment">// 根据maven导入的启动器过滤出需要导入的配置类</span></span><br><span class="line">            configurations = filter(configurations, autoConfigurationMetadata);</span><br><span class="line">            fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line">            <span class="keyword">return</span> configurations.toArray(<span class="keyword">new</span> String[configurations.size()]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isEnabled</span><span class="params">(AnnotationMetadata metadata)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先该类实现了<code>DeferredImportSelector</code>接口，这个接口继承了<code>ImportSelector</code>, 该接口主要是为了导入 <code>@Configuration</code> 的配置项，而 <code>DeferredImportSelector</code> 是延期导入，当所有的<code>@Configuration</code>都处理过后才会执行;</p><ul><li>回过头来我们看一下 <code>AutoConfigurationImportSelector</code> 的<code>selectImport</code>方法, 该方法刚开始会先判断是否进行自动装配，而后会从 <code>META-INF/spring-autoconfigure-metadata.properties</code> 读取元数据与元数据的相关属性，紧接着会调用<code>getCandidateConfigurations</code>方法：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;String&gt; <span class="title">getCandidateConfigurations</span><span class="params">(AnnotationMetadata metadata,</span></span></span><br><span class="line"><span class="function"><span class="params">            AnnotationAttributes attributes)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(</span><br><span class="line">                getSpringFactoriesLoaderFactoryClass(), getBeanClassLoader());</span><br><span class="line">        Assert.notEmpty(configurations,</span><br><span class="line">                <span class="string">"No auto configuration classes found in META-INF/spring.factories. If you "</span></span><br><span class="line">                        + <span class="string">"are using a custom packaging, make sure that file is correct."</span>);</span><br><span class="line">        <span class="keyword">return</span> configurations;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the class used by &#123;<span class="doctag">@link</span> SpringFactoriesLoader&#125; to load configuration candidates.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; getSpringFactoriesLoaderFactoryClass() &#123;</span><br><span class="line">    <span class="keyword">return</span> EnableAutoConfiguration.class;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里又遇到<code>SpringFactoryiesLoader</code>, 它会读取<code>META-INF/spring.factories</code>下的<code>EnableAutoConfiguration</code>的配置，紧接着在进行排除与过滤，进而得到需要装配的类。最后让所有配置在<code>META-INF/spring.factories</code>下的<code>AutoConfigurationImportListener</code>执行<code>AutoConfigurationImportEvent</code>事件，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fireAutoConfigurationImportEvents</span><span class="params">(List&lt;String&gt; configurations,</span></span></span><br><span class="line"><span class="function"><span class="params">            Set&lt;String&gt; exclusions)</span> </span>&#123;</span><br><span class="line">    List&lt;AutoConfigurationImportListener&gt; listeners = getAutoConfigurationImportListeners();</span><br><span class="line">    <span class="keyword">if</span> (!listeners.isEmpty()) &#123;</span><br><span class="line">        AutoConfigurationImportEvent event = <span class="keyword">new</span> AutoConfigurationImportEvent(<span class="keyword">this</span>,</span><br><span class="line">                configurations, exclusions);</span><br><span class="line">        <span class="keyword">for</span> (AutoConfigurationImportListener listener : listeners) &#123;</span><br><span class="line">            invokeAwareMethods(listener);</span><br><span class="line">            listener.onAutoConfigurationImportEvent(event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;AutoConfigurationImportListener&gt; <span class="title">getAutoConfigurationImportListeners</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> SpringFactoriesLoader.loadFactories(AutoConfigurationImportListener.class,</span><br><span class="line">            <span class="keyword">this</span>.beanClassLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>1）自动装配还是利用了 <code>SpringFactoriesLoader</code> 来加载<code>META-INF/spring.factoires</code>文件里所有配置的<code>EnableAutoConfgruation</code>，它会经过<code>exclude</code>和<code>filter</code>等操作，最终确定要装配的类</p><p>2)  处理<code>@Configuration</code>的核心还是<code>ConfigurationClassPostProcessor</code>，这个类实现了<code>BeanFactoryPostProcessor</code>, 因此当<code>AbstractApplicationContext</code>执行<code>refresh()</code>方法里的<code>invokeBeanFactoryPostProcessors(beanFactory)</code>方法时会执行自动装配</p><p><img src="/images/springboot_st1.png" alt="-w974"><br><img src="/images/springboot_st2.png" alt="-w595"></p><h2 id="自定义starter"><a href="#自定义starter" class="headerlink" title="自定义starter"></a>自定义starter</h2><h2 id="Tomcat启动流程"><a href="#Tomcat启动流程" class="headerlink" title="Tomcat启动流程"></a>Tomcat启动流程</h2><p><img src="/images/spring_boot_tomcat_st.png" alt="-w1222"></p><p><code>EmbeddedWebServerFactoryCustomizerAutoConfiguration</code> 内嵌web容器工厂自定义定制器装配类</p><p>org.springframework.context.support.AbstractApplicationContext#refresh</p><h2 id="如何扫描自定义组件"><a href="#如何扫描自定义组件" class="headerlink" title="如何扫描自定义组件"></a>如何扫描自定义组件</h2><h2 id="Conditional注解"><a href="#Conditional注解" class="headerlink" title="Conditional注解"></a>Conditional注解</h2><p>常见的注解解释：</p><ul><li><p><code>@ConditionalOnBean</code><br>匹配给定的class类型或者Bean的名字是否在SpringBeanFactory中存在</p></li><li><p><code>@ConditionalOnClass</code><br>匹配给定的class类型是否在类路径(classpath)中存在</p></li><li><p><code>@ConditionalOnExpression</code><br>匹配给定springEL表达式的值返回true时</p></li><li><p><code>@ConditionalOnJava</code><br>匹配JDK的版本，其中range属性是枚举类型有两个值可以选择 </p><ul><li>EQUAL_OR_NEWER 不小于</li><li>OLDER_THAN 小于</li></ul><p>value属性用于设置jdk版本</p></li><li><p><code>ConditionalOnMissingBean</code><br>spring上下文中不存在指定bean时</p></li><li><p><code>ConditionalOnWebApplication</code><br>在web环境下创建 </p></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/niechen/p/8306376.html" target="_blank" rel="noopener">SpringBoot学习之自动装配</a><br><a href="https://www.cnblogs.com/niechen/p/9027804.html" target="_blank" rel="noopener">深入理解SpringBoot之自动装配</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;启动流程&quot;&gt;&lt;a href=&quot;#启动流程&quot; class=&quot;headerlink&quot; title=&quot;启动流程&quot;&gt;&lt;/a&gt;启动流程&lt;/h2&gt;&lt;p&gt;启动类代码&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=
      
    
    </summary>
    
      <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
      <category term="SpringBoot" scheme="http://yoursite.com/categories/Spring/SpringBoot/"/>
    
    
      <category term="原理" scheme="http://yoursite.com/tags/%E5%8E%9F%E7%90%86/"/>
    
      <category term="SpringBoot" scheme="http://yoursite.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Netty快速入门</title>
    <link href="http://yoursite.com/2020/01/08/Netty%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2020/01/08/Netty快速入门/</id>
    <published>2020-01-08T12:20:17.000Z</published>
    <updated>2020-01-10T13:01:56.941Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-NIO-核心概念"><a href="#Java-NIO-核心概念" class="headerlink" title="Java NIO 核心概念"></a>Java NIO 核心概念</h1><hr><h2 id="Linux五种I-O模型比较"><a href="#Linux五种I-O模型比较" class="headerlink" title="Linux五种I/O模型比较"></a>Linux五种I/O模型比较</h2><p><img src="/images/linux_five_io.png" alt></p><h2 id="Socket通信模型"><a href="#Socket通信模型" class="headerlink" title="Socket通信模型"></a>Socket通信模型</h2><p><img src="/images/socket_com_model.png" alt></p><h2 id="Java-NIO-Buffer"><a href="#Java-NIO-Buffer" class="headerlink" title="Java NIO Buffer"></a>Java NIO Buffer</h2><blockquote><p>一个Buffer本质上是内存中的一块， 可以将数据写入这块内存， 从这块内存获取数据 </p></blockquote><p><code>java.nio</code> 定义了以下几个Buffer的实现:</p><p><img src="/images/java_nio_buffer.png" alt></p><p>Java NIO Buffer三大核心概念：<strong>position</strong>、<strong>limit</strong>、<strong>capacity</strong></p><ul><li><p>最好理解的当然是 <code>capacity</code>，它代表这个缓冲区的容量，一旦设定就不可以更改。比如 <code>capacity</code> 为 <code>1024</code> 的 <code>IntBuffer</code>，代表其一次可以存放 <code>1024</code> 个 <code>int</code> 类型的值。</p></li><li><p>一旦 Buffer 的容量达到 capacity，需要清空 Buffer，才能重新写入值<br><img src="/images/java_nio_pos_cap.png" alt></p></li><li><p>从写操作模式到读操作模式切换的时候（flip），<code>position</code> 都会归零，这样就可以从头开始读写了。</p></li><li><p>写操作模式下，<code>limit</code> 代表的是最大能写入的数据，这个时候 <code>limit</code> 等于 <code>capacity</code>。</p></li><li><p>写结束后，切换到读模式，此时的 <code>limit</code> 等于 Buffer 中实际的数据大小，因为 Buffer 不一定被写满了</p></li></ul><p><img src="/images/java_nio_buffer_op.png" alt></p><p><strong>DirectByteBuffer &amp; HeapByteBuffer</strong></p><table><thead><tr><th></th><th>DirectByteBuffer</th><th>HeapByteBuffer</th></tr></thead><tbody><tr><td>描述</td><td>底层存储在非JVM堆上，通过native代码操作 -神器:MaxDirectMemorySize=<size></size></td><td>标准java类，维护一份byte[]在JVM堆上</td></tr><tr><td>创建开销</td><td>大</td><td>小</td></tr><tr><td>存储位置</td><td>Native Heap</td><td>Java Heap</td></tr><tr><td>数据拷贝</td><td>无需临时缓冲区做拷贝</td><td>拷贝到临时DirectByteBuffer,但临时缓冲区使用缓存， 聚集写/发散读时没有缓存临时缓冲区</td></tr><tr><td>GC影响</td><td>每次创建或者释放的时候都调用一次System.gc()</td><td>java垃圾回收机制自动回收</td></tr></tbody></table><h2 id="JAVA-NIO-Channel"><a href="#JAVA-NIO-Channel" class="headerlink" title="JAVA NIO Channel"></a>JAVA NIO Channel</h2><p>所有的NIO操作始于通道，<strong>通道是数据来源或数据写入的目的地</strong>，<code>java.nio</code> 包中主要实现的以下几个 Channel：<br><img src="/images/java_nio_channel.png" alt></p><ul><li><strong>FileChannel</strong>：文件通道，用于文件的读和写</li><li><strong>DatagramChannel</strong>：用于 UDP 连接的接收和发送</li><li><strong>SocketChannel</strong>：把它理解为 TCP 连接通道，简单理解就是 TCP 客户端</li><li><strong>ServerSocketChannel</strong>：TCP 对应的服务端，用于监听某个端口进来的请求</li></ul><h2 id="Java-NIO-Selector"><a href="#Java-NIO-Selector" class="headerlink" title="Java NIO Selector"></a>Java NIO Selector</h2><p><img src="/images/java_nio_selector.png" alt></p><ul><li><p><code>java.nio.channels.Selector</code></p></li><li><p>支持IO多路复用的抽象实体</p></li><li><p>注册<code>Selectable Channel</code></p></li><li><p>SelectionKey —— 表示Selector和被注册的channel之间关系的一份凭证</p><ul><li>SelectionKey保存channel感兴趣的事件</li></ul></li><li><p><code>Selector.select</code> 更新所有就绪的 <code>SelectionKey</code> 的状态, 并返回就绪的channel个数</p><ul><li>迭代Selected Key集合并处理就绪channel</li></ul></li></ul><p><strong>Selector基本操作</strong></p><ul><li>创建Selector   </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Selector selector = Selector.open();</span><br></pre></td></tr></table></figure><ul><li>注册Channel到Selector</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SocketChannel channel = SocketChannel.open();</span><br><span class="line">channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">SelectionKey key = channel.register(selector, SelectionKey.OP_READ);</span><br></pre></td></tr></table></figure><ul><li>register的第二个参数是一个“关注集合”，代表关注的channel状态，有四种基础类型可供监听, 用SelectionKey中的常量表示如下：  </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SelectionKey.OP_CONNECT</span><br><span class="line">SelectionKey.OP_ACCEPT</span><br><span class="line">SelectionKey.OP_READ</span><br><span class="line">SelectionKey.OP_WRITE</span><br></pre></td></tr></table></figure><ul><li>从Selector中选择channel<br>一旦向Selector注册了一个或多个channel后，就可以调用select来获取channel, <code>select()</code>方法会返回所有处于就绪状态的channel, select方法具体如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">long</span> timeout)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">selectNow</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>select()方法的返回值是一个int，代表有多少channel处于就绪了。也就是自上一次select后有多少channel进入就绪。</p><ul><li>selectedKeys()<br>在调用select并返回了有channel就绪之后，可以通过选中的key集合来获取channel，这个操作通过调用selectedKeys()方法：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</span><br></pre></td></tr></table></figure><ul><li>Selector编程模板</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</span><br><span class="line"></span><br><span class="line">Iterator&lt;SelectionKey&gt; keyIterator = selectedKeys.iterator();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(keyIterator.hasNext()) &#123;</span><br><span class="line"></span><br><span class="line">    SelectionKey key = keyIterator.next();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(key.isAcceptable()) &#123;</span><br><span class="line">        <span class="comment">// a connection was accepted by a ServerSocketChannel.</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isConnectable()) &#123;</span><br><span class="line">        <span class="comment">// a connection was established with a remote server.</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">        <span class="comment">// a channel is ready for reading</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line">        <span class="comment">// a channel is ready for writing</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    keyIterator.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Netty核心概念"><a href="#Netty核心概念" class="headerlink" title="Netty核心概念"></a>Netty核心概念</h1><p>Netty 提供<strong>异步的、事件驱动的网络应用程序框架和工具</strong>,用以快速开发高性能、高可靠性的网络服务器和客户端程序。</p><hr><h2 id="Netty主要组件"><a href="#Netty主要组件" class="headerlink" title="Netty主要组件"></a>Netty主要组件</h2><p><img src="/images/netty_total_structure.png" alt></p><ul><li><p>Netty Server启动主要流程</p><ul><li><p>设置服务端ServerBootStrap启动参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">group(parentGroup, childGroup):</span><br><span class="line">channel(NioServerSocketChannel): 设置通道类型</span><br><span class="line">handler()：设置NioServerSocketChannel的ChannelHandlerPipeline</span><br><span class="line">childHandler(): 设置NioSocketChannel的ChannelHandlerPipeline</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>通过ServerBootStrap的bind方法启动服务端，bind方法会在parentGroup中注册NioServerScoketChannel，监听客户端的连接请求</p><ul><li>会创建一个NioServerSocketChannel实例，并将其在parentGroup中进行注册</li></ul></li></ul></li><li><p>Netty Server执行主要流程</p><ul><li><p>Client发起连接CONNECT请求，parentGroup中的NioEventLoop不断轮循是否有新的客户端请求，如果有，ACCEPT事件触发</p></li><li><p>ACCEPT事件触发后，parentGroup中NioEventLoop会通过NioServerSocketChannel获取到对应的代表客户端的NioSocketChannel，并将其注册到childGroup中</p></li><li><p>childGroup中的NioEventLoop不断检测自己管理的NioSocketChannel是否有读写事件准备好，如果有的话，调用对应的ChannelHandler进行处理</p></li></ul></li></ul><h2 id="Netty-EventLoop"><a href="#Netty-EventLoop" class="headerlink" title="Netty EventLoop"></a>Netty EventLoop</h2><p><img src="/images/netty_ev_loop.png" alt></p><p><img src="/images/netty_ev_lp_grp.png" alt></p><ul><li><p>EventLoopGroup</p><ul><li>包括多个EventLoop</li><li>多个EventLoop之间不交互</li></ul></li><li><p>EventLoop</p><ul><li>每个EventLoop对应一个线程</li><li>所有连接(channel)都将注册到一个EventLoop，并且只注册到一个，整个生命周期中都不会变化</li><li>每个EventLoop管理着多个连接(channel)</li><li>EventLoop来处理连接(Channel)上的读写事件</li></ul></li><li><p>ServerBootstrap</p><ul><li>包括2个不同类型的EventLoopGroup:<ul><li>Parent EventLoop: 负责处理Accept事件，接收请求</li><li>Child EventLoop：负责处理读写事件</li></ul></li></ul></li></ul><p><strong>EventExecutor视图</strong><br><img src="/images/event_executor_view.png" alt></p><ol><li><code>EventExecutorGroup</code>里面有一个<code>EventExecutor</code>数组，保存了多个<code>EventExecutor</code>;<ol start="2"><li><code>EventExecutorGroup</code>是不干什么事情的，当收到一个请后，他就调用<code>next()</code>获得一个它里面的<code>EventExecutor</code>，再调用这个<code>executor</code>的方法；</li><li><code>next()</code>: <code>EventExecutorChooser.next()</code>定义选择<code>EventExecutor</code>的策略；</li></ol></li></ol><h2 id="ByteBuf类型"><a href="#ByteBuf类型" class="headerlink" title="ByteBuf类型"></a>ByteBuf类型</h2><ul><li><p>根据内存的位置</p><ul><li><p>HeapByteBuf </p><ul><li>基于数组- 内部为一个字节数组 (byte array)</li><li>hasArray()返回True</li><li>array()返回其内部的数组，可以对数组进行直接操作</li></ul></li><li><p>DirectByteBuf </p><ul><li>堆外内存</li><li>具有更好的性能</li><li>创建和释放开销更大</li></ul></li></ul></li><li><p>根据是否使用内存池</p><ul><li>Pooled vs Unpooled</li></ul></li><li><p>根据是否使用Unsafe操作(Unsafe)</p><ul><li>Safe vs Unsafe</li></ul></li></ul><p><strong>复合缓冲区（CompositeByteBuf）</strong></p><ul><li>多个ByteBuf组合的视图</li><li>一个ByteBuf列表，可动态的添加和删除其中的 ByteBuf</li><li>可能既包含堆缓冲区，也包含直接缓冲区<br><img src="/images/composite_buf.png" alt></li></ul><h2 id="ByteBuf分配"><a href="#ByteBuf分配" class="headerlink" title="ByteBuf分配"></a>ByteBuf分配</h2><p>不直接通过new来创建，而是通过ByteBufAllocator来创建</p><ul><li>UnpooledByteBufAllocator</li><li>PooledByteBufAllocator<br><img src="/images/byte_buf_uml.png" alt></li></ul><p><img src="/images/byte_buf_allocator.png" alt></p><p><img src="/images/unpooled_allocator.png" alt></p><h2 id="ChannelHandler"><a href="#ChannelHandler" class="headerlink" title="ChannelHandler"></a>ChannelHandler</h2><p>业务处理核心逻辑，用户自定义, Netty 提供2个重要的 ChannelHandler 子接口：</p><ul><li>ChannelInboundHandler - 处理进站数据和所有状态更改事件</li><li>ChannelOutboundHandler - 处理出站数据，允许拦截各种操作</li></ul><p><img src="/images/netty_chan_handler.png" alt></p><p><img src="/images/netty_chanelInbound.png" alt></p><p><img src="/images/channel_outboud_hd.png" alt></p><h2 id="ChannelPipline"><a href="#ChannelPipline" class="headerlink" title="ChannelPipline"></a>ChannelPipline</h2><p>ChannelPipeline是ChannelHandler容器</p><ul><li><p>包括一系列的ChannelHandler实例,用于拦截流经一个 Channel 的入站和出站事件</p></li><li><p>每个Channel都有一个其ChannelPipeline</p></li><li><p>可以修改 ChannelPipeline 通过动态添加和删除 ChannelHandler</p></li><li><p>定义了丰富的API调用来回应入站和出站事件</p></li></ul><p><img src="/images/netty_channel_pipeline.png" alt></p><h2 id="ChannelHandlerContext"><a href="#ChannelHandlerContext" class="headerlink" title="ChannelHandlerContext"></a>ChannelHandlerContext</h2><p>ChannelHandlerContext表示 ChannelHandler 和 ChannelPipeline 之间的关联，在 ChannelHandler 添加到 ChannelPipeline 时创建<br><img src="/images/netty_channel_context.png" alt></p><h1 id="Netty线程模型"><a href="#Netty线程模型" class="headerlink" title="Netty线程模型"></a>Netty线程模型</h1><hr><h2 id="Reactor模式-Doug-Lea"><a href="#Reactor模式-Doug-Lea" class="headerlink" title="Reactor模式 - Doug Lea"></a>Reactor模式 - Doug Lea</h2><ul><li>单线程Reactor<br><img src="/images/reactor_single_thread.png" alt="-w822"></li></ul><ul><li>多线程Reactor<br><img src="/images/reactor_multi_thread.png" alt></li></ul><p>所有逻辑都在I/O线程中完成，不开启单独线程。图中对应的TheadPool是在io处理handler中额外开启的业务线程池。</p><ul><li>Multiple Reactor<br><img src="/images/reactor_multi_reactor.png" alt="-w735"></li></ul><p><img src="/images/netty_reactor.png" alt></p><h2 id="Netty与Reactor模式"><a href="#Netty与Reactor模式" class="headerlink" title="Netty与Reactor模式"></a>Netty与Reactor模式</h2><ul><li>单线程Reactor</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">ServerBootStrap bootStrap = <span class="keyword">new</span> ServerBootStrap();</span><br><span class="line">bootStrap.group(bossGroup, bossGroup); <span class="comment">// 监听和处理都由一个线程完成</span></span><br></pre></td></tr></table></figure><ul><li>多线程Reactor</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">ServerBootStrap bootStrap = <span class="keyword">new</span> ServerBootStrap();</span><br><span class="line">bootStrap.group(bossGroup, bossGroup); <span class="comment">// 监听和处理都由一个线程完成</span></span><br><span class="line"><span class="comment">// 在handler中额外使用线程池处理业务</span></span><br></pre></td></tr></table></figure><ul><li>Multiple Reactor</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">ServerBootStrap bootStrap = <span class="keyword">new</span> ServerBootStrap();</span><br><span class="line">bootStrap.group(bossGroup, workerGroup); </span><br><span class="line"><span class="comment">// 在handler中额外使用线程池处理业务</span></span><br></pre></td></tr></table></figure><h2 id="Boss-EventLoopGroup"><a href="#Boss-EventLoopGroup" class="headerlink" title="Boss EventLoopGroup"></a>Boss EventLoopGroup</h2><p><img src="/images/Boss_EventLoopGroup.png" alt></p><p><img src="/images/NioEventLoop_Creation.png" alt></p><h2 id="Worker-EventLoopGroup"><a href="#Worker-EventLoopGroup" class="headerlink" title="Worker EventLoopGroup"></a>Worker EventLoopGroup</h2><p><img src="/images/Worker_EventLoopGroup.png" alt></p><h2 id="Netty-Start-Process"><a href="#Netty-Start-Process" class="headerlink" title="Netty Start Process"></a>Netty Start Process</h2><p><img src="/images/netty_start_process.png" alt></p><h2 id="ServerBootStrap"><a href="#ServerBootStrap" class="headerlink" title="ServerBootStrap"></a>ServerBootStrap</h2><p><img src="/images/serverbootstrap.png" alt></p><h1 id="Netty编码解码"><a href="#Netty编码解码" class="headerlink" title="Netty编码解码"></a>Netty编码解码</h1><hr><h2 id="半包粘包问题"><a href="#半包粘包问题" class="headerlink" title="半包粘包问题"></a>半包粘包问题</h2><ul><li>TCP/IP协议<ul><li>面向“流”协议</li><li>MSS: Maxitum Segment Size 最大分段大小，表示TCP数据包每次能够传输的最大数据分段</li><li>发送方/接收方缓冲区 （Nagle算法）</li></ul></li></ul><p><img src="/images/netty_tcp_frame.png" alt></p><p><strong>解决思路</strong></p><ul><li><p>基本思路就是不断从TCP缓冲区中读取数据，每次读取完都需要判断是否是一个完整的数据包</p><ul><li><p>若当前读取的数据不足以拼接成一个完整的业务数据包，那就保留该数据，继续从tcp缓冲区中读取，直到得到一个完整的数据包</p><ul><li>定长</li><li>分隔符</li><li>基于长度的变长包</li></ul></li><li><p>若当前读到的数据加上已经读取的数据足够拼接成一个数据包，那就将已经读取的数据拼接上本次读取的数据，够成一个完整的业务数据包传递到业务逻辑，多余的数据仍然保留，以便和下次读到的数据尝试拼接</p></li></ul></li></ul><h2 id="常用编码解码器"><a href="#常用编码解码器" class="headerlink" title="常用编码解码器"></a>常用编码解码器</h2><p>编码解码器的作用就是将原始的字节数据与自定义的消息对象进行互相转换，目前业界主流的序列化框架有：</p><ul><li>ProtoBuf</li><li>Jboss Marshalling</li><li>Java Serialization </li></ul><p>Netty常用的自带编解码器有：</p><ul><li><p><strong>LineBasedFrameDecoder</strong>（\n, \r\n)  </p><ul><li>回车换行解码器</li><li>配合StringDecoder</li></ul></li><li><p><strong>DelimiterBasedFrameDecoder</strong></p><ul><li>分隔符解码器</li></ul></li><li><p><strong>FixedLengthFrameDecoder</strong></p><ul><li>固定长度解码器</li></ul></li><li><p><strong>LengthFieldBasedFrameDecoder</strong></p><ul><li>基于包头’<strong>不固定长度</strong>‘解码器(私有协议最常用)</li><li>参数说明<ul><li><strong>maxFrameLength</strong>：包的最大长度</li><li><strong>lengthFieldOffset</strong>：长度属性的起始位（偏移位），包中存放长度属性字段的起始位置</li><li><strong>lengthFieldLength</strong>：长度属性的长度 </li><li><strong>lengthAdjustment</strong>：长度调节值，在总长被定义为包含包头长度时，修正信息长度</li><li><strong>initialBytesToStrip</strong>：跳过的字节数，根据需要跳过lengthFieldLength个字节，以便接收端直接接受到不含“长度属性”的内容</li></ul></li></ul></li></ul><h2 id="Netty拆包的基类-ByteToMessageDecoder"><a href="#Netty拆包的基类-ByteToMessageDecoder" class="headerlink" title="Netty拆包的基类 - ByteToMessageDecoder"></a>Netty拆包的基类 - ByteToMessageDecoder</h2><ul><li><p>内部维护了一个数据累积器<code>cumulation</code>，每次读取到数据都会不断累加，然后尝试对累加到的数据进行拆包，拆成一个完整的业务数据包</p></li><li><p>每次都将读取到的数据通过内存拷贝的方式， 累积到<code>cumulation</code>中</p></li><li><p>调用子类的decode方法对累积的数据尝试进行拆包</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java-NIO-核心概念&quot;&gt;&lt;a href=&quot;#Java-NIO-核心概念&quot; class=&quot;headerlink&quot; title=&quot;Java NIO 核心概念&quot;&gt;&lt;/a&gt;Java NIO 核心概念&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;Linux五种I-O模型比较&quot;&gt;
      
    
    </summary>
    
      <category term="Netty" scheme="http://yoursite.com/categories/Netty/"/>
    
      <category term="基础" scheme="http://yoursite.com/categories/Netty/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Netty" scheme="http://yoursite.com/tags/Netty/"/>
    
      <category term="网络IO" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9CIO/"/>
    
  </entry>
  
  <entry>
    <title>Spring mvc 设计思想与体系结构</title>
    <link href="http://yoursite.com/2020/01/06/Spring-mvc-%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%E4%B8%8E%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2020/01/06/Spring-mvc-设计思想与体系结构/</id>
    <published>2020-01-06T11:22:37.000Z</published>
    <updated>2020-01-10T13:01:56.634Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、spring-mvc-设计思想与体系结构组成"><a href="#一、spring-mvc-设计思想与体系结构组成" class="headerlink" title="一、spring mvc 设计思想与体系结构组成"></a>一、spring mvc 设计思想与体系结构组成</h2><hr><h3 id="回顾servlet-与jsp-执行过程"><a href="#回顾servlet-与jsp-执行过程" class="headerlink" title="回顾servlet 与jsp 执行过程"></a>回顾servlet 与jsp 执行过程</h3><p><img src="/images/servlet_work_process.png" alt="图片"></p><p><strong>流程说明：</strong></p><ol><li>请求Servlet</li><li>处理业务逻辑</li><li>设置业务Model</li><li>forward jsp Servlet</li><li>jsp Servlet 解析封装html 返回</li></ol><p>提问：这个是一个MVC应用场景吗？</p><p>spring mvc本质上还是在使用Servlet处理，并在其基础上进行了封装简化了开发流程，提高易用性、并使用程序逻辑结构变得更清晰</p><ol><li>基于注解的URL映谢</li><li>http表单参数转换</li><li>全局统一异常处理</li><li>拦截器的实现</li></ol><h3 id="spring-mvc-执行流程"><a href="#spring-mvc-执行流程" class="headerlink" title="spring mvc 执行流程"></a>spring mvc 执行流程</h3><p><img src="/images/spring_mvc_work_pro.png" alt="图片"></p><p><strong>整个过程是如何实现的？</strong></p><ol><li>dispatchServlet 如何找到对应的Control？</li><li>如何执行调用Control 当中的业务方法？</li></ol><p>回答这些问题之前我们先来认识一下spring mvc 体系结构</p><h3 id="spring-mvc-体系结构"><a href="#spring-mvc-体系结构" class="headerlink" title="spring mvc 体系结构"></a>spring mvc 体系结构</h3><ul><li><strong>HandlerMapping</strong> <ul><li>url与控制器的映谢</li></ul></li><li><strong>HandlerAdapter</strong><ul><li>控制器执行适配器</li></ul></li><li><strong>ViewResolver</strong><ul><li>视图仓库</li></ul></li><li><strong>view</strong><ul><li>具体解析视图</li></ul></li><li><strong>HandlerExceptionResolver</strong><ul><li>异常捕捕捉器</li></ul></li><li><strong>HandlerInterceptor</strong><ul><li>拦截器</li></ul></li></ul><p><strong>体系结构UML</strong><br><img src="/images/spring_mvc_uml.png" alt="图片"></p><h2 id="二、mvc-执行流程解析"><a href="#二、mvc-执行流程解析" class="headerlink" title="二、mvc 执行流程解析"></a>二、mvc 执行流程解析</h2><hr><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><ol><li>mvc 具体执行流程</li><li>HandlerMapping详解</li><li>HandlerAdapter 详解</li><li>ViewResolver与View详解</li><li>HandlerExceptionResolver详解</li><li>HandlerInterceptor 详解</li></ol><p>mvc 各组件执行流程</p><p><img src="/images/spring_mvc_execute_pro.png" alt="图片"></p><h3 id="HandlerMapping详解"><a href="#HandlerMapping详解" class="headerlink" title="HandlerMapping详解"></a>HandlerMapping详解</h3><p>其为mvc中url路径与Control对像的映射，DispatcherServlet 就是基于此组件来寻找对应的Control，如果找不到就会报<code>Not Found mapping</code> 的异常。</p><p>HandlerMapping 接口方法<br><img src="/images/hendler_mapping_in.png" alt="图片"></p><p>HandlerMapping 接口结构<br><img src="/images/handler_mapping_uml.png" alt="图片"></p><p>目前主流的三种mapping 如下：</p><ul><li><p>BeanNameUrlHandlerMapping<br>基于ioc name 中以 <code>/</code> 开头的Bean时行 注册至映谢.</p></li><li><p>SimpleUrlHandlerMapping<br>基于手动配置 url 与control 映谢</p></li><li><p>RequestMappingHandlerMapping<br>基于<code>@RequestMapping</code>注解配置对应映谢</p></li></ul><p>演示基于 BeanNameUrlHandlerMapping  配置映谢。</p><p>编写mvc 文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--简单控制器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"/user.do"</span> <span class="attr">class</span>=<span class="string">"com.tuling.mvc.control.BeanNameControl"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>beanname control 控制器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanNameControl</span> <span class="keyword">implements</span> <span class="title">HttpRequestHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        request.getRequestDispatcher(<span class="string">"/WEB-INF/page/userView.jsp"</span>).forward(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当IOC 中实例化这些类之后 DispatcherServlet 就会通过<code>org.springframework.web.servlet.DispatcherServlet#getHandler()</code> 方法基于request查找对应Handler。 但找到对应的Handler之后我们发现他是一个Object类型，并没有实现特定接口。如何调用Handler呢？</p><h3 id="HandlerAdapter详解"><a href="#HandlerAdapter详解" class="headerlink" title="HandlerAdapter详解"></a>HandlerAdapter详解</h3><p>这里spring mvc 采用适配器模式来适配调用指定Handler，根据Handler的不同种类采用不同的Adapter, 其Handler与 HandlerAdapter 对应关系如下:</p><table><thead><tr><th align="left">Handler类别</th><th align="left">对应适配器</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">Controller</td><td align="left">SimpleControllerHandlerAdapter</td><td align="left">标准控制器，返回ModelAndView</td></tr><tr><td align="left">HttpRequestHandler</td><td align="left">HttpRequestHandlerAdapter</td><td align="left">业务自行处理 请求，不需要通过modelAndView 转到视图</td></tr><tr><td align="left">Servlet</td><td align="left">SimpleServletHandlerAdapter</td><td align="left">基于标准的servlet 处理</td></tr><tr><td align="left">HandlerMethod</td><td align="left">RequestMappingHandlerAdapter</td><td align="left">基于@requestMapping对应方法处理</td></tr></tbody></table><p>HandlerAdapter  接口方法<br><img src="/images/handler_adapter_interface.png" alt="图片"></p><p>HandlerAdapter  接口结构图<br><img src="/images/handler_adapter_uml.png" alt="图片"></p><p>演示基于Servlet 处理  SimpleServletHandlerAdapter</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置控制器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"/hello.do"</span> <span class="attr">class</span>=<span class="string">"com.tuling.mvc.control.HelloServlet"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 配置适配器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.handler.SimpleServletHandlerAdapter"</span>/&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 标准Servlet</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        resp.getWriter().println(<span class="string">"hello luban "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述例子中当IOC 中实例化这些类之后 DispatcherServlet 就会通过<br>org.springframework.web.servlet.DispatcherServlet#getHandlerAdapter() 方法查找对应handler的适配器 ，如果找不到就会报 <code>No adapter for handler</code> 。</p><h3 id="ViewResolver-与View-详解"><a href="#ViewResolver-与View-详解" class="headerlink" title="ViewResolver 与View 详解"></a>ViewResolver 与View 详解</h3><p>找到应的Adapter 之后就会基于适配器调用业务处理，处理完之后业务方会返回一个ModelAndView ，在去查找对应的视图进行处理。其在<code>org.springframework.web.servlet.DispatcherServlet#resolveViewName()</code> 中遍历 <code>viewResolvers</code> 列表查找，如果找不到就会报一个 <code>Could not resolve view with name</code>异常。</p><p><img src="/images/view_resolver_interface.png" alt="图片"></p><p>下一步就是基于<code>ViewResolver.resolveViewName()</code>获取对应View来解析生成Html并返回 。对应VIEW结构如下：<br><img src="/images/view_resolver_uml.png" alt="图片"></p><p>至此整个正向流程就已经走完了，如果此时程序处理异常 MVC 该如何处理呢？</p><h3 id="HandlerExceptionResolver详解"><a href="#HandlerExceptionResolver详解" class="headerlink" title="HandlerExceptionResolver详解"></a>HandlerExceptionResolver详解</h3><p>该组件用于指示当出现异常时 mvc 该如何处理。 dispatcherServlet 会调用<code>org.springframework.web.servlet.DispatcherServlet#processHandlerException()</code> 方法，遍历 <code>handlerExceptionResolvers</code> 处理异常，处理完成之后返回errorView 跳转到异常视图。</p><p>演示自定义异常捕捉</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleExceptionHandle</span> <span class="keyword">implements</span> <span class="title">HandlerExceptionResolver</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">resolveException</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ModelAndView(<span class="string">"error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 演示异常配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.tuling.mvc.control.SimpleExceptionHandle"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>HandlerExceptionResolver 结构<br><img src="/images/hend_exception_resolver.png" alt="图片"></p><p>除了上述组件之外 spring 中还引入了  我Interceptor 拦截器 机制，类似于Filter。</p><h3 id="HandlerInterceptor详解"><a href="#HandlerInterceptor详解" class="headerlink" title="HandlerInterceptor详解"></a>HandlerInterceptor详解</h3><p>演示HandlerInterceptor </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleHandlerInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"preHandle"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"postHandle"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"afterCompletion"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置interceptor 组件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.tuling.mvc.control.SimpleHandlerInterceptor"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其实现机制是基于 HandlerExecutionChain 分别在 doDispatch 方法中执行以下方法：</p><ul><li>preHandle ：业务处理前执行</li><li>postHandle：业务处理后（异常则不执行）</li><li>afterCompletion：视图处理后</li></ul><p>具体逻辑源码参见：<code>org.springframework.web.servlet.DispatcherServlet#doDispatch</code> 方法。</p><h2 id="三、注解配置"><a href="#三、注解配置" class="headerlink" title="三、注解配置"></a>三、注解配置</h2><hr><p>演示基于注解配置mvc mapping </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.tuling.mvc.control"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 注解驱动 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 视图仓库 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span>  <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/page/"</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">".jsp"</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"viewClass"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">value</span>=<span class="string">"org.springframework.web.servlet.view.JstlView"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注解方法</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/hello.do"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ModelAndView mv = <span class="keyword">new</span> ModelAndView(<span class="string">"userView"</span>);</span><br><span class="line">    mv.addObject(<span class="string">"name"</span>, <span class="string">"luban"</span>);</span><br><span class="line">    <span class="keyword">return</span> mv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提问 为什么基于 <code>&lt;mvc:annotation-driven/&gt;</code> 配置就能实现mvc 的整个配置了，之前所提到的 <code>handlerMapping</code> 、与 <code>handlerAdapter</code> 组件都不适用了？</p><p>只要查看以类的源就可以知晓其中原因：</p><ul><li><input disabled type="checkbox"> 认识 NamespaceHandler 接口</li><li><input disabled type="checkbox"> 查看 MvcNamespaceHandler</li><li><input disabled type="checkbox"> 查看AnnotationDrivenBeanDefinitionParser</li></ul><p><strong>结论</strong><br>在 <code>&lt;mvc:annotation-driven /&gt;</code>  对应的解析器，自动向 ioc  里面注册了两个BeanDefinition。分别是：<code>RequestMappingHandlerMapping</code> 与<code>BeanNameUrlHandlerMapping</code>.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、spring-mvc-设计思想与体系结构组成&quot;&gt;&lt;a href=&quot;#一、spring-mvc-设计思想与体系结构组成&quot; class=&quot;headerlink&quot; title=&quot;一、spring mvc 设计思想与体系结构组成&quot;&gt;&lt;/a&gt;一、spring mvc 设
      
    
    </summary>
    
      <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
      <category term="Spring Mvc" scheme="http://yoursite.com/categories/Spring/Spring-Mvc/"/>
    
    
      <category term="原理" scheme="http://yoursite.com/tags/%E5%8E%9F%E7%90%86/"/>
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring事务底层基本原理</title>
    <link href="http://yoursite.com/2020/01/03/Spring%E4%BA%8B%E5%8A%A1%E5%BA%95%E5%B1%82%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2020/01/03/Spring事务底层基本原理/</id>
    <published>2020-01-03T13:14:14.000Z</published>
    <updated>2020-01-10T13:01:56.584Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据库的事务基本特性"><a href="#数据库的事务基本特性" class="headerlink" title="数据库的事务基本特性"></a>数据库的事务基本特性</h2><p>事物是区分文件存储系统与Nosql数据库重要特性之一，其存在的意义是为了保证即使在并发情况下也能正确的执行crud操作。怎样才算是正确的呢？这时提出了事物需要保证的四个特性即ACID：</p><ul><li><p>A: 原子性(atomicity)<br>事物中各项操作，要么全做要么全不做，任何一项操作的失败都会导致整个事物的失败；</p></li><li><p>C: 一致性(consistency)<br>事物结束后系统状态是一致的；</p></li><li><p>I:  隔离性(isolation)<br>并发执行的事物彼此无法看到对方的中间状态；</p></li><li><p>D: 持久性(durability)<br>事物完成后所做的改动都会被持久化，即使发生灾难性的失败。</p></li></ul><p>在高并发的情况下，要完全保证其ACID特性是非常困难的，除非把所有的事物串行化执行，但带来的负面的影响将是性能大打折扣。很多时候我们有些业务对事物的要求是不一样的，所以数据库中设计了四种隔离级别，供用户基于业务进行选择。</p><p><img src="/images/mysql_tx_isolation.png" alt></p><ul><li><p>脏读 :<br>一个事物读取到另一事物未提交的更新数据</p></li><li><p>不可重复读 :<br>在同一事物中,多次读取同一数据返回的结果有所不同, 换句话说, 后续读取可以读到另一事物已提交的更新数据. 相反, “可重复读”在同一事物中多次读取数据时, 能够保证所读数据一样, 也就是后续读取不能读到另一事物已提交的更新数据。</p></li><li><p>幻读 :<br>查询表中一条数据如果不存在就插入一条，并发的时候却发现，里面居然有两条相同的数据。这就幻读的问题。</p></li></ul><p><strong>数据库默认隔离级别：</strong></p><ul><li>Oracle中默认级别是 Read committed</li><li>mysql 中默认级别 Repeatable read。另外要注意的是mysql 执行一条查询语句默认是一个独立的事物，所以看上去效果跟Read committed一样。</li></ul><p><strong>查看mysql 的默认隔离级别</strong>  </p><blockquote><p>SELECT @@tx_isolation</p></blockquote><h2 id="Spring对事务的支持与使用"><a href="#Spring对事务的支持与使用" class="headerlink" title="Spring对事务的支持与使用"></a>Spring对事务的支持与使用</h2><h3 id="spring-事物相关API说明"><a href="#spring-事物相关API说明" class="headerlink" title="spring 事物相关API说明"></a>spring 事物相关API说明</h3><p>spring 事物是在数据库事物的基础上进行封装扩展，其主要特性如下：</p><ul><li>支持原有的数据事物的隔离级别；</li><li>加入了事物传播的概念，提供多个事物的合并或隔离的功能；</li><li>提供声明式事物，让业务代码与事物分离，事物变得更易用；</li></ul><p>怎么样去使用Spring事物呢？spring提供了三个接口供使用事物。分别是：</p><ul><li><p><code>TransactionDefinition</code><br>事物定义</p></li><li><p><code>PlatformTransactionManager</code><br>事物管理</p></li><li><p><code>TransactionStatus</code><br>事物运行时状态</p></li></ul><p>接口结构图：</p><p><img src="/images/spring_tx_stucture.png" alt></p><h3 id="基于API实现事物"><a href="#基于API实现事物" class="headerlink" title="基于API实现事物"></a>基于API实现事物</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringTransactionExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String url = <span class="string">"jdbc:mysql://192.168.0.147:3306/luban2"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String user = <span class="string">"root"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String password = <span class="string">"123456"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">openConnection</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException, SQLException </span>&#123;</span><br><span class="line">        Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">        Connection conn = DriverManager.getConnection(<span class="string">"jdbc:mysql://192.168.0.147:3306/luban2"</span>, <span class="string">"root"</span>, <span class="string">"123456"</span>);</span><br><span class="line">        <span class="keyword">return</span> conn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> DataSource ds = <span class="keyword">new</span> DriverManagerDataSource(url, user, password);</span><br><span class="line">        <span class="keyword">final</span> TransactionTemplate template = <span class="keyword">new</span> TransactionTemplate();</span><br><span class="line">        template.setTransactionManager(<span class="keyword">new</span> DataSourceTransactionManager(ds));</span><br><span class="line">        template.execute(<span class="keyword">new</span> TransactionCallback&lt;Object&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">doInTransaction</span><span class="params">(TransactionStatus status)</span> </span>&#123;</span><br><span class="line">                Connection conn = DataSourceUtils.getConnection(ds);</span><br><span class="line">                Object savePoint = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// 插入</span></span><br><span class="line">                        PreparedStatement prepare = conn.</span><br><span class="line">                                prepareStatement(<span class="string">"insert INTO account (accountName,user,money) VALUES (?,?,?)"</span>);</span><br><span class="line">                        prepare.setString(<span class="number">1</span>, <span class="string">"111"</span>);</span><br><span class="line">                        prepare.setString(<span class="number">2</span>, <span class="string">"aaaa"</span>);</span><br><span class="line">                        prepare.setInt(<span class="number">3</span>, <span class="number">10000</span>);</span><br><span class="line">                        prepare.executeUpdate();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 设置保存点</span></span><br><span class="line">                    savePoint = status.createSavepoint();</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// 插入</span></span><br><span class="line">                        PreparedStatement prepare = conn.</span><br><span class="line">                                prepareStatement(<span class="string">"insert INTO account (accountName,user,money) VALUES (?,?,?)"</span>);</span><br><span class="line">                        prepare.setString(<span class="number">1</span>, <span class="string">"222"</span>);</span><br><span class="line">                        prepare.setString(<span class="number">2</span>, <span class="string">"bbb"</span>);</span><br><span class="line">                        prepare.setInt(<span class="number">3</span>, <span class="number">10000</span>);</span><br><span class="line">                        prepare.executeUpdate();</span><br><span class="line">                    &#125;</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// 更新</span></span><br><span class="line">                        PreparedStatement prepare = conn.</span><br><span class="line">                                prepareStatement(<span class="string">"UPDATE account SET money= money+1 where user=?"</span>);</span><br><span class="line">                        prepare.setString(<span class="number">1</span>, <span class="string">"asdflkjaf"</span>);</span><br><span class="line">                        Assert.isTrue(prepare.executeUpdate() &gt; <span class="number">0</span>, <span class="string">""</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"更新失败"</span>);</span><br><span class="line">                    <span class="keyword">if</span> (savePoint != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        status.rollbackToSavepoint(savePoint);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        status.setRollbackOnly();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="声明示事物"><a href="#声明示事物" class="headerlink" title="声明示事物"></a>声明示事物</h3><p>我们前面是通过调用API来实现对事物的控制，这非常的繁琐，与直接操作JDBC事物并没有太多的改善，所以Spring提出了声明示事物，使我们对事物的操作变得非常简单，甚至不需要关心它。</p><ul><li>配置spring.xml</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/tx/spring-tx.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/aop/spring-aop.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.tuling.service.**"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.core.JdbcTemplate"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- similarly, don't forget the PlatformTransactionManager --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"txManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- don't forget the DataSource --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DriverManagerDataSource"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://192.168.0.147/luban2"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"123456"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">"txManager"</span>&gt;</span><span class="tag">&lt;/<span class="name">tx:annotation-driven</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>编写服务类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAccount</span><span class="params">(String name, <span class="keyword">int</span> initMenoy)</span> </span>&#123;</span><br><span class="line">    String accountid = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyyMMddhhmmss"</span>).format(<span class="keyword">new</span> Date());</span><br><span class="line">    jdbcTemplate.update(<span class="string">"insert INTO account (accountName,user,money) VALUES (?,?,?)"</span>, accountid, name, initMenoy);</span><br><span class="line">    <span class="comment">// 人为报错, 触发回滚</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="事物传播机制"><a href="#事物传播机制" class="headerlink" title="事物传播机制"></a>事物传播机制</h2><table>    <tr>        <td><b>类别</b></td>         <td><b>事务传播类型</b></td>         <td><b>说明</b></td>    </tr>    <tr>        <td rowspan="3">支持当前事务</td>            <td>PROPAGATION_REQUIRED         （必须的）</td>          <td>如果当前没有事物，就新建一个事物，如果已经存在一个事物中，          加入到这个事物中。这是最常见的选择</td>      </tr>    <tr>        <td>PROPAGATION_SUPPORTS（支持）</td>          <td>支持当前事物，如果当前没有事物，就以非事物方式执行</td>      </tr>    <tr>        <td>PROPAGATION_MANDATORY（强制）</td>          <td>使用当前的事物，如果当前没有事物，就抛出异常</td>      </tr>    <tr>        <td rowspan="3">不支持当前事物</td>            <td>PROPAGATION_REQUIRES_NEW(隔离)</td>          <td>新建事物，如果当前存在事物，把当前事物挂起</td>      </tr>    <tr>        <td>PROPAGATION_NOT_SUPPORTED(不支持)</td>          <td>以非事物方式执行操作，如果当前存在事物，就把当前事物挂起</td>      </tr>    <tr>        <td>PROPAGATION_NEVER(强制非事物)</td>          <td>以非事物方式执行，如果当前存在事物，则抛出异常</td>      </tr>    <tr>        <td>嵌套事物</td>          <td>PROPAGATION_NESTED（嵌套事物）</td>          <td>如果当前存在事物，则在嵌套事物内执行。如果当前没有事物，        则执行与PROPAGATION_REQUIRED类似的操作。</td>      </tr></table><p>常用事物传播机制：</p><ul><li><p><strong>PROPAGATION_REQUIRED</strong><br>这个也是默认的传播机制；</p></li><li><p><strong>PROPAGATION_NOT_SUPPORTED</strong><br>可以用于发送提示消息，站内信、短信、邮件提示等。不属于并且不应当影响主体业务逻辑，即使发送失败也不应该对主体业务逻辑回滚；</p></li><li><p><strong>PROPAGATION_REQUIRES_NEW</strong><br>总是新启一个事物，这个传播机制适用于不受父方法事物影响的操作，比如某些业务场景下需要记录业务日志，用于异步反查，那么不管主体业务逻辑是否完成，日志都需要记录下来，不能因为主体业务逻辑报错而丢失日志；</p></li></ul><p><strong>演示常用事物的传播机制</strong></p><p>用例1:<br>创建用户时初始化一个帐户，表结构和服务类如下。</p><table><thead><tr><th>表结构</th><th>服务类</th><th>功能描述</th></tr></thead><tbody><tr><td>user</td><td>UserService</td><td>创建用户并添加账户</td></tr><tr><td>account</td><td>AccountService</td><td>添加账户</td></tr></tbody></table><p><code>UserSerivce.createUser(name)</code> 实现代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createUser</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 新增用户基本信息</span></span><br><span class="line">    jdbcTemplate.update(<span class="string">"INSERT INTO `user` (name) VALUES(?)"</span>, name);</span><br><span class="line">    <span class="comment">//调用accountService添加帐户</span></span><br><span class="line">    accountService.addAccount(name, <span class="number">10000</span>);</span><br><span class="line"> ｝</span><br></pre></td></tr></table></figure><p><code>AccountService.addAccount(name,initMoney)</code> 实现代码（方法的最后有一个异常）:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span>(propagation = Propagation.REQUIRED)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAccount</span><span class="params">(String name, <span class="keyword">int</span> initMoney)</span> </span>&#123;</span><br><span class="line">    String accountid = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyyMMddhhmmss"</span>).format(<span class="keyword">new</span> Date());</span><br><span class="line">    jdbcTemplate.update(<span class="string">"insert INTO account (accountName,user,money) VALUES (?,?,?)"</span>, accountid, name, initMenoy);</span><br><span class="line">    <span class="comment">// 出现分母为零的异常</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实验预测：</p><p><img src="/images/spring_tx_test.png" alt></p><h2 id="AOP事务底层实现原理"><a href="#AOP事务底层实现原理" class="headerlink" title="AOP事务底层实现原理"></a>AOP事务底层实现原理</h2><p>讲事物原理之前我们先来做一个实验，当场景五的环境改变，把 <code>addAccount</code> 方法移至<code>UserService</code>类下，其它配置和代码不变：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createUser</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    jdbcTemplate.update(<span class="string">"INSERT INTO `user` (name) VALUES(?)"</span>, name);</span><br><span class="line">    addAccount(name, <span class="number">10000</span>);</span><br><span class="line">    <span class="comment">// 人为报错</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional</span>(propagation = Propagation.REQUIRES_NEW)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAccount</span><span class="params">(String name, <span class="keyword">int</span> initMoney)</span> </span>&#123;</span><br><span class="line">    String accountid = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyyMMddhhmmss"</span>).format(<span class="keyword">new</span> Date());</span><br><span class="line">    jdbcTemplate.update(<span class="string">"insert INTO account (accountName,user,money) VALUES (?,?,?)"</span>, accountid, name, initMoney);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过测试我们发现得出的结果与场景五并不一至，<code>required_new</code> 没有起到其对应的作用。原因在于 <strong>spring 声明示事物使用动态代理实现</strong>，而<strong>当调用同一个类的方法时，是会不会走代理逻辑的，自然事物的配置也会失效</strong>。</p><p>通过一个动态代理的实现来模拟这种场景</p><blockquote><p>UserService.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createUser</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addAccount</span><span class="params">(String name, <span class="keyword">int</span> initMoney)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>UserServiceImpl.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String url = <span class="string">"jdbc:mysql://10.101.38.255:8036/tuling"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String user = <span class="string">"root"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String password = <span class="string">"xxxxx"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DataSource dataSource;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        dataSource = <span class="keyword">new</span> DriverManagerDataSource(url, user, password);</span><br><span class="line">        jdbcTemplate = <span class="keyword">new</span> JdbcTemplate(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createUser</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        jdbcTemplate.update(<span class="string">"INSERT INTO `user` (name) VALUES(?)"</span>, name);</span><br><span class="line">        addAccount(name, <span class="number">10000</span>);</span><br><span class="line">        <span class="comment">// 人为报错</span></span><br><span class="line">        <span class="comment">//        int i = 1 / 0;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAccount</span><span class="params">(String name, <span class="keyword">int</span> initMoney)</span> </span>&#123;</span><br><span class="line">        String accountid = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyyMMddhhmmss"</span>).format(<span class="keyword">new</span> Date());</span><br><span class="line">        jdbcTemplate.update(<span class="string">"insert INTO account (accountName,user,money) VALUES (?,?,?)"</span>, accountid, name, initMoney);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>TransactionProxy.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionProxy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> UserService userSerivce = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        UserService proxyUserService = (UserService) Proxy.newProxyInstance(TransactionProxy.class.getClassLoader(),</span><br><span class="line">                <span class="keyword">new</span> Class[] &#123;UserService.class&#125;, <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            System.out.println(<span class="string">"开启事物:"</span> + method.getName());</span><br><span class="line">                            <span class="keyword">return</span> method.invoke(userSerivce, args);</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            System.out.println(<span class="string">"关闭事物:"</span> + method.getName());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        proxyUserService.createUser(<span class="string">"luban"</span>);</span><br><span class="line">        proxyUserService.addAccount(<span class="string">"austin"</span>, <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们调用 <code>createUser</code> 方法时, 仅打印了 <code>createUser</code>  的事物开启、关闭，并没有打印<code>addAccount</code>方法的事物开启、关闭，由此可见 <code>addAccount</code>  的事物配置是失效的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;数据库的事务基本特性&quot;&gt;&lt;a href=&quot;#数据库的事务基本特性&quot; class=&quot;headerlink&quot; title=&quot;数据库的事务基本特性&quot;&gt;&lt;/a&gt;数据库的事务基本特性&lt;/h2&gt;&lt;p&gt;事物是区分文件存储系统与Nosql数据库重要特性之一，其存在的意义是为了保证
      
    
    </summary>
    
      <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
      <category term="Spring Mvc" scheme="http://yoursite.com/categories/Spring/Spring-Mvc/"/>
    
    
      <category term="事务" scheme="http://yoursite.com/tags/%E4%BA%8B%E5%8A%A1/"/>
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring 核心组件</title>
    <link href="http://yoursite.com/2020/01/02/Spring-%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/"/>
    <id>http://yoursite.com/2020/01/02/Spring-核心组件/</id>
    <published>2020-01-02T11:38:35.000Z</published>
    <updated>2020-01-10T13:01:56.802Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实体Bean的创建"><a href="#实体Bean的创建" class="headerlink" title="实体Bean的创建"></a>实体Bean的创建</h2><h3 id="基于Class构建"><a href="#基于Class构建" class="headerlink" title="基于Class构建"></a>基于Class构建</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean class=&quot;com.tuling.spring.HelloSpring&quot;&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>这是最常规的方法，其原理是在spring底层会基于class属性通过反射进行构建。</p><h3 id="构造方法构建"><a href="#构造方法构建" class="headerlink" title="构造方法构建"></a>构造方法构建</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean class=&quot;com.tuling.spring.HelloSpring&quot;&gt;</span><br><span class="line">    &lt;constructor-arg name=&quot;name&quot; type=&quot;java.lang.String&quot; value=&quot;luban&quot;/&gt;</span><br><span class="line">    &lt;constructor-arg index=&quot;1&quot; type=&quot;java.lang.String&quot; value=&quot;sex&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>如果需要基于参数进行构建，就采用构造方法构建，其对应属性如下：<br><strong>name:</strong> 构造方法参数变量名称<br><strong>type:</strong> 参数类型<br><strong>index:</strong> 参数索引，从0开始<br><strong>value:</strong> 参数值，spring 会自动转换成参数实际类型值<br><strong>ref:</strong> 引用容器的其它对象</p><h3 id="静态工厂方法创建"><a href="#静态工厂方法创建" class="headerlink" title="静态工厂方法创建"></a>静态工厂方法创建</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.tuling.spring.HelloSpring"</span> <span class="attr">factory-method</span>=<span class="string">"build"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"type"</span> <span class="attr">type</span>=<span class="string">"java.lang.String"</span> <span class="attr">value</span>=<span class="string">"B"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果你正在对一个对象进行A/B测试 ，就可以采用静态工厂方法的方式创建，其于策略创建不同的对像或填充不同的属性。<br>该模式下必须创建一个静态工厂方法，并且方法返回该实例，spring 会调用该静态方法创建对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HelloSpring <span class="title">build</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (type.equals(<span class="string">"A"</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HelloSpring(<span class="string">"luban"</span>, <span class="string">"man"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="string">"B"</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HelloSpring(<span class="string">"diaocan"</span>, <span class="string">"woman"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"type must A or B"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="FactoryBean创建"><a href="#FactoryBean创建" class="headerlink" title="FactoryBean创建"></a>FactoryBean创建</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 返回的并不是LubanFactoryBean实例，而是被LubanFactoryBean包装的实例 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.tuling.spring.LubanFactoryBean"</span> <span class="attr">id</span>=<span class="string">"lubanFactoryBean"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>指定一个Bean工厂来创建对象，对象构建初始化完全交给该工厂来实现。配置Bean时指定该工厂类的类名。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LubanFactoryBean只是起到一层包装代理作用 </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LubanFactoryBean</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 真正创建的bean实例</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HelloSpring();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> HelloSpring.class;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Bean的基本特性"><a href="#Bean的基本特性" class="headerlink" title="Bean的基本特性"></a>Bean的基本特性</h2><h3 id="作用范围"><a href="#作用范围" class="headerlink" title="作用范围"></a>作用范围</h3><p>很多时候Bean对象是无状态的 ，而有些又是有状态的, 无状态的对象我们采用单例即可，而有状态则必须是多例的模式，通过scope即可创建</p><blockquote><p>scope=“prototype”<br>scope=“singleton”</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.tuling.spring.HelloSpring"</span> <span class="attr">scope</span>=<span class="string">"prototype"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果一个Bean设置成<code>prototype</code>我们可以 通过<code>BeanFactoryAware</code>获取 <code>BeanFactory</code>对象即可每次获取的都是新对像。</p><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>Bean对象的<strong>创建</strong>、<strong>初始化</strong>、<strong>销毁</strong>即是Bean的生命周期。通过 <code>init-method</code>、<code>destroy-method</code>属性可以分别指定期构建方法与初始方法。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.tuling.spring.HelloSpring"</span> <span class="attr">init-method</span>=<span class="string">"init"</span> <span class="attr">destroy-method</span>=<span class="string">"destroy"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果觉得麻烦，可以让Bean去实现 <code>InitializingBean.afterPropertiesSet()</code>、<code>DisposableBean.destroy()</code>方法。分别对应初始和销毁方法。</p><h3 id="加载机制"><a href="#加载机制" class="headerlink" title="加载机制"></a>加载机制</h3><p>指示Bean在何时进行加载。设置<code>lazy-init</code>即可，其值如下：</p><blockquote><p>true: 懒加载，即延迟加载<br>false: 非懒加载，容器启动时即创建对象<br>default: 默认，采用default-lazy-init中指定值，如果default-lazy-init 没指定就是false</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span></span></span><br><span class="line"><span class="tag"><span class="attr">default-lazy-init</span>=<span class="string">"true"</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>什么时候使用懒加载？</strong><br>懒加载会容器启动的更快，而非懒加载可以容器启动时更快的发现程序当中的错误 ，选择哪一个就看追求的是启动速度，还是希望更早的发现错误，一般我们会选择后者。</p><h2 id="Bean的构建过程"><a href="#Bean的构建过程" class="headerlink" title="Bean的构建过程"></a>Bean的构建过程</h2><p><code>spring.xml</code>文件中保存了我们对Bean的描述配置，<code>BeanFactory</code>会读取这些配置然后生成对应的Bean。这是我们对ioc原理的一般理解。但在深入一些我们会有更多的问题:</p><ol><li>配置信息最后是谁JAVA中哪个对象承载的？</li><li>这些承载对象是谁业读取XML文件并装载的？</li><li>这些承载对象又是保存在哪里？</li></ol><h3 id="BeanDefinition（Bean定义）"><a href="#BeanDefinition（Bean定义）" class="headerlink" title="BeanDefinition（Bean定义）"></a>BeanDefinition（Bean定义）</h3><p>ioc实现中我们在xml中描述的Bean信息最后都将保存至<code>BeanDefinition</code> （定义）对象中，其中<code>xml bean</code> 与<code>BeanDefinition</code> 是一对一的关系。</p><p><img src="/images/spring_bean_definition.png" alt></p><p>由此可见，xml  bean中设置的属性最后都会体现在BeanDefinition中。如:</p><table><thead><tr><th align="left">XML-bean</th><th align="left"><strong>BeanDefinition</strong></th></tr></thead><tbody><tr><td align="left">class</td><td align="left">beanClassName</td></tr><tr><td align="left">scope</td><td align="left">scope</td></tr><tr><td align="left">lazy-init</td><td align="left">lazyInit</td></tr><tr><td align="left">constructor-arg</td><td align="left">ConstructorArgument</td></tr><tr><td align="left">property</td><td align="left">MutablePropertyValues</td></tr><tr><td align="left">factory-method</td><td align="left">factoryMethodName</td></tr><tr><td align="left">destroy-method</td><td align="left">AbstractBeanDefinition.destroyMethodName</td></tr><tr><td align="left">init-method</td><td align="left">AbstractBeanDefinition.initMethodName</td></tr><tr><td align="left">autowire</td><td align="left">AbstractBeanDefinition.autowireMode</td></tr><tr><td align="left">id</td><td align="left"></td></tr><tr><td align="left">name</td><td align="left"></td></tr></tbody></table><p>BeanDefinition属性结构<br><img src="/images/bean_definition_property_structure.png" alt></p><h3 id="BeanDefinitionRegistry（Bean注册器）"><a href="#BeanDefinitionRegistry（Bean注册器）" class="headerlink" title="BeanDefinitionRegistry（Bean注册器）"></a>BeanDefinitionRegistry（Bean注册器）</h3><p>在上表中我们并没有看到 <code>xml bean</code> 中的 <code>id</code>  和<code>name</code>属性， 没有体现在定义中，原因是ID其作为当前Bean的存储key注册到了<code>BeanDefinitionRegistry</code> 注册器中。<code>name</code> 作为<strong>别名key</strong> 注册到了 <code>AliasRegistry</code> 注册中心。其最后都是指向其对应的<code>BeanDefinition</code>。</p><p><img src="/images/bean_definition_register.png" alt></p><h3 id="BeanDefinitionReader（Bean定义读取）"><a href="#BeanDefinitionReader（Bean定义读取）" class="headerlink" title="BeanDefinitionReader（Bean定义读取）"></a>BeanDefinitionReader（Bean定义读取）</h3><p>至此我们学习了 <code>BeanDefinition</code> 中存储了<code>Xml Bean</code>信息，而<code>BeanDefinitionRegister</code> 基于<code>ID</code>和<code>name</code> 保存了Bean的定义。接下要学习的是从<code>xml Bean</code>到<code>BeanDefinition</code>然后在注册至<code>BeanDefinitionRegister</code> 整个过程。</p><p><img src="/images/bean_definition_reader.png" alt></p><p>上图中可以看出Bean的定义是由<code>BeanDefinitionReader</code> 从xml 中读取配置并构建出 <code>BeanDefinitionReader</code>, 然后在基于别名注册到<code>BeanDefinitionRegister</code>中.</p><p>BeanDefinitionReader结构<br><img src="/images/bena_definition_read_st.png" alt></p><p>方法说明：</p><ul><li><p><strong>loadBeanDefinitions(Resource resource)</strong></p><ul><li>基于资源装载Bean定义并注册至注册器</li></ul></li><li><p><strong>int loadBeanDefinitions(String location)</strong></p><ul><li>基于资源路径装载Bean定义并注册至注册器</li></ul></li><li><p><strong>BeanDefinitionRegistry getRegistry()</strong></p><ul><li>获取注册器</li></ul></li><li><p><strong>ResourceLoader getResourceLoader()</strong></p><ul><li>获取资源装载器</li></ul></li></ul><p>BeanDefinitionReader装载过程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个简单注册器</span></span><br><span class="line">BeanDefinitionRegistry register = <span class="keyword">new</span> SimpleBeanDefinitionRegistry();</span><br><span class="line"><span class="comment">//创建bean定义读取器</span></span><br><span class="line">BeanDefinitionReader reader = <span class="keyword">new</span> XmlBeanDefinitionReader(register);</span><br><span class="line"><span class="comment">// 创建资源读取器</span></span><br><span class="line">DefaultResourceLoader resourceLoader = <span class="keyword">new</span> DefaultResourceLoader();</span><br><span class="line"><span class="comment">// 获取资源</span></span><br><span class="line">Resource xmlResource = resourceLoader.getResource(<span class="string">"spring.xml"</span>);</span><br><span class="line"><span class="comment">// 装载Bean的定义</span></span><br><span class="line">reader.loadBeanDefinitions(xmlResource);</span><br><span class="line"><span class="comment">// 打印构建的Bean 名称</span></span><br><span class="line">System.out.println(Arrays.toString(register.getBeanDefinitionNames());</span><br></pre></td></tr></table></figure><h3 id="Beanfactory-bean-工厂"><a href="#Beanfactory-bean-工厂" class="headerlink" title="Beanfactory(bean 工厂)"></a>Beanfactory(bean 工厂)</h3><p>有了Bean的定义就相当于有了产品的配方，接下来就是要把这个配方送到工厂进行生产了。在ioc当中Bean的构建是由 <code>BeanFactory</code> 负责的。其结构如下：<br><img src="/images/bean_factory.png" alt></p><p>方法说明：</p><ul><li><p><strong>getBean(String)</strong></p><ul><li>基于ID或name 获取一个Bean</li></ul></li><li><p>**<t> T getBean(Class<t> requiredType) **</t></t></p><ul><li>基于Bean的类别获取一个Bean（如果出现多个该类的实例，将会报错。但可以指定 primary=“true” 调整优先级来解决该错误 ）</li></ul></li><li><p><strong>Object getBean(String name, Object… args)</strong></p><ul><li>基于名称获取一个Bean，并覆盖默认的构造参数</li></ul></li><li><p><strong>boolean isTypeMatch(String name, Class&lt;?&gt; typeToMatch)</strong></p><ul><li>指定Bean与指定Class 是否匹配</li></ul></li></ul><p>以上方法中重点要关注getBean，当用户调用getBean的时候就会触发 Bean的创建动作:</p><p>基本BeanFactory获取一个Bean, 以下是运行时的栈信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 其反射实例化Bean</span></span><br><span class="line">java.lang.reflect.Constructor.newInstance(Unknown Source:-<span class="number">1</span>)</span><br><span class="line">BeanUtils.instantiateClass()</span><br><span class="line"><span class="comment">//基于实例化策略 实例化Bean</span></span><br><span class="line">SimpleInstantiationStrategy.instantiate()</span><br><span class="line">AbstractAutowireCapableBeanFactory.instantiateBean()</span><br><span class="line"><span class="comment">// 执行Bean的实例化方法</span></span><br><span class="line">AbstractAutowireCapableBeanFactory.createBeanInstance()</span><br><span class="line">AbstractAutowireCapableBeanFactory.doCreateBean()</span><br><span class="line"><span class="comment">// 执行Bean的创建</span></span><br><span class="line">AbstractAutowireCapableBeanFactory.createBean()</span><br><span class="line"><span class="comment">// 缓存中没有，调用指定Bean工厂创建Bean</span></span><br><span class="line">AbstractBeanFactory$<span class="number">1</span>.getObject()</span><br><span class="line"><span class="comment">// 从单例注册中心获取Bean缓存</span></span><br><span class="line">DefaultSingletonBeanRegistry.getSingleton()</span><br><span class="line">AbstractBeanFactory.doGetBean()</span><br><span class="line"><span class="comment">// 获取Bean</span></span><br><span class="line">AbstractBeanFactory.getBean()</span><br><span class="line"><span class="comment">// 调用的客户类</span></span><br><span class="line">com.tuling.spring.BeanFactoryExample.main()</span><br></pre></td></tr></table></figure><h3 id="Bean创建时序图"><a href="#Bean创建时序图" class="headerlink" title="Bean创建时序图"></a>Bean创建时序图</h3><p><img src="/images/bean_creation_process.png" alt></p><p>从调用过程可以总结出以下几点：</p><ol><li>调用 <code>BeanFactory.getBean()</code> 会触发Bean的实例化</li><li><code>DefaultSingletonBeanRegistry</code> 中缓存了单例Bean</li><li><code>Bean</code>的创建与初始化是由<code>AbstractAutowireCapableBeanFactory</code>完成的</li></ol><h2 id="BeanFactory-与-ApplicationContext区别"><a href="#BeanFactory-与-ApplicationContext区别" class="headerlink" title="BeanFactory 与 ApplicationContext区别"></a>BeanFactory 与 ApplicationContext区别</h2><p><code>BeanFactory</code> 可以去做IOC当中的大部分事情，为什么还要去定义一个ApplicationContext 呢？</p><p>ApplicationContext 结构图<br><img src="/images/bean_factory_context.png" alt></p><p>从图中可以看到 <code>ApplicationContext</code> 它由 <code>BeanFactory</code> 接口派生而来，因而提供了<code>BeanFactory</code> 所有的功能。除此之外<code>context</code>包还提供了以下的功能：</p><ol><li><code>MessageSource</code>, 提供国际化的消息访问</li><li>资源访问，如URL和文件</li><li>事件传播，实现了<code>ApplicationEventPublisher</code>接口的bean</li><li>载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的web层</li></ol><h2 id="Spring-advice执行顺序"><a href="#Spring-advice执行顺序" class="headerlink" title="Spring advice执行顺序"></a>Spring advice执行顺序</h2><p>advice执行顺序，就是拦截器链的执行顺序 </p><p><img src="/images/spring_advice.png" alt></p><ul><li><p>1、单个切面的场景，<code>around</code>开始 –&gt;  <code>before</code> –&gt; <code>aound</code>结束–&gt; <code>after</code> –&gt; <code>AfterReturning</code></p></li><li><p>2、对于多个切面的场景，可以通过 <code>@order</code>(序号)，来调整执行顺序。</p></li></ul><p>demo参考： <a href="https://blog.csdn.net/hxpjava1/article/details/55504513/" target="_blank" rel="noopener">Spring多个AOP执行先后顺序</a></p><p>源码分析：<br>前置通知拦截器： <code>MethodBeforeAdviceInterceptor#invoke</code><br>拦截器链：<code>ReflectiveMethodInvocation#proceed</code><br><code>proceed</code> 根据 <code>currentInterceptorIndex</code> 来确定当前应执行哪个拦截器，并在调用拦截器的 <code>invoke</code> 方法时，将自己作为参数传给该方法</p><p><img src="/images/spring_advive_procced.png" alt></p><p>参考资料<br><a href="https://www.coolblog.xyz/2018/06/22/Spring-AOP-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E6%8B%A6%E6%88%AA%E5%99%A8%E9%93%BE%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/" target="_blank" rel="noopener">Spring AOP 源码分析 - 拦截器链的执行过程</a><br><a href="https://blog.csdn.net/zly9923218/article/details/51348583" target="_blank" rel="noopener">Spring AOP 源码分析（生成代理对象）</a></p><h2 id="IOC-容器只存放单例bean吗"><a href="#IOC-容器只存放单例bean吗" class="headerlink" title="IOC 容器只存放单例bean吗"></a>IOC 容器只存放单例bean吗</h2><p><strong>结论：IOC 容器只存放单例bean</strong></p><p>IOC容器初始化的时候，会将所有bean初始化在 <code>singletonObjects</code> 这个<code>CurrentHashMap</code> 中， bean是单例的。</p><p>在获取bean的时候，首先会从<code>singletonObjects</code>去取值，通过debug，发现如果scope是单例，则可以获取到bean，如果scope是多例，则获取不到bean，需要 从一个叫 <code>mergedBeanDefinitions</code> 的<code>CurrentHashMap</code>中去获取bean的定义，然后再根据bean的scope去决定如何创建bean，如果<code>scope=prototype</code>，则每次都会创建一个新的实例。</p><p>猜想：IOC在初始化时，只会将 <code>scope = singleton</code>（单例）的对象进行实例化，而不会去实例化<code>scope=prototype</code>的对象（多例）；</p><p>证实：找到<code>singletonObjects.put</code>方法，debug看一下<code>singletonObjects.put</code>的前提条件是什么</p><p><strong>源码分析</strong>：<code>AbstractBeanFactory#doGetBean</code></p><p>单例的场景，直接从 <code>singletonObjects</code> 这个Map中获取bean</p><p><img src="/images/spring_get_bean_sigle.png" alt></p><p>多例的场景，发现从 <code>singletonObjects</code> 中拿不到值</p><p><img src="/images/spring_get_bean_sigle2.png" alt></p><p>接下来，发现它是从一个叫 <code>mergedBeanDefinitions</code>  的<code>HashMap</code>中获取了<code>RootBeanDefinition</code>，里面包含了bean的一些基础信息。</p><p><img src="/images/spring_get_bean_prototype.png" alt></p><p>最后根据 <code>bean的scope</code>属性,来做处理，如果作用域是单例，则直接从容器中获取，如果作用域是多例，则创建一个实例，当然，作用域还有其它，自己可以一一去验证</p><p><img src="/images/spring_get_bean_prototype2.png" alt></p><h2 id="Scope为request的bean是否会放入IOC容器"><a href="#Scope为request的bean是否会放入IOC容器" class="headerlink" title="Scope为request的bean是否会放入IOC容器"></a>Scope为request的bean是否会放入IOC容器</h2><p>这个应该和IOC没有关系，request对象只是一个参数。<br>场景分析：SpringMVC在接受一个http请求后，会根据URl去匹配具体的bean（可以这样理解：<code>bean=Map.get(url)</code>，这个map是在容器初始化的时候创建的），然后通过反射获取class实例，最终执行<code>method.invoke</code>方法的时候，会将request对象的值封装到args数组中，当然args可能还包含<strong>response对象、注解参数、非注解参数的值</strong>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;实体Bean的创建&quot;&gt;&lt;a href=&quot;#实体Bean的创建&quot; class=&quot;headerlink&quot; title=&quot;实体Bean的创建&quot;&gt;&lt;/a&gt;实体Bean的创建&lt;/h2&gt;&lt;h3 id=&quot;基于Class构建&quot;&gt;&lt;a href=&quot;#基于Class构建&quot; class
      
    
    </summary>
    
      <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
      <category term="Spring Mvc" scheme="http://yoursite.com/categories/Spring/Spring-Mvc/"/>
    
    
      <category term="基础" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Java堆默认大小</title>
    <link href="http://yoursite.com/2019/12/31/Java%E5%A0%86%E9%BB%98%E8%AE%A4%E5%A4%A7%E5%B0%8F/"/>
    <id>http://yoursite.com/2019/12/31/Java堆默认大小/</id>
    <published>2019-12-31T11:18:01.000Z</published>
    <updated>2020-01-10T13:01:56.740Z</updated>
    
    <content type="html"><![CDATA[<h2 id="PrintFlagsFinal"><a href="#PrintFlagsFinal" class="headerlink" title="PrintFlagsFinal"></a>PrintFlagsFinal</h2><blockquote><p>-XX:+PrintFlagsFinal<br>打印所有可设置的参数及它们的默认值(从JDK 6 update 21开始才可以用)</p></blockquote><p>示例：16G内存的Centos系统</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> java -XX:+PrintFlagsFinal -version  | grep -E 'HeapSize|PermSize|ThreadStackSize'</span><br><span class="line">     intx CompilerThreadStackSize                   = 0                                   &#123;pd product&#125;</span><br><span class="line">    uintx ErgoHeapSizeLimit                         = 0                                   &#123;product&#125;</span><br><span class="line">    uintx HeapSizePerGCThread                       = 87241520                            &#123;product&#125;</span><br><span class="line">    uintx InitialHeapSize                          := 264241152                           &#123;product&#125;</span><br><span class="line">    uintx LargePageHeapSizeThreshold                = 134217728                           &#123;product&#125;</span><br><span class="line">    uintx MaxHeapSize                              := 4215275520                          &#123;product&#125;</span><br><span class="line">     intx ThreadStackSize                           = 1024                                &#123;pd product&#125;</span><br><span class="line">     intx VMThreadStackSize                         = 1024                                &#123;pd product&#125;</span><br><span class="line">java version "1.8.0_152"</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_152-b16)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.152-b16, mixed mode)</span><br></pre></td></tr></table></figure><p>可以看出默认的:<br>堆最大大小(MaxHeapSize)：4215275520/(1024.0 * 1024 * 1024) = 3.93G<br>初始堆大小(InitialHeapSiz): 266338304/(1024.0 * 1024) = 254M<br>HeapSizePerGCThread: 87241520 / (1024.0 * 1024) = 83.20M</p><h2 id="PrintCommandLineFlags"><a href="#PrintCommandLineFlags" class="headerlink" title="PrintCommandLineFlags"></a>PrintCommandLineFlags</h2><blockquote><p>-XX:+PrintCommandLineFlags</p><p>打印出所有出现在命令行上的可选JVM参数。可用来了解JVM的参数设置，例如堆空间大小、垃圾收集器等。默认情况下，此选项是禁用的，并且不打印标记。</p></blockquote><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> java -XX:+PrintCommandLineFlags -version</span><br><span class="line">-XX:InitialHeapSize=263453376 -XX:MaxHeapSize=4215254016 -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseParallelGC </span><br><span class="line">java version "1.8.0_152"</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_152-b16)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.152-b16, mixed mode)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;PrintFlagsFinal&quot;&gt;&lt;a href=&quot;#PrintFlagsFinal&quot; class=&quot;headerlink&quot; title=&quot;PrintFlagsFinal&quot;&gt;&lt;/a&gt;PrintFlagsFinal&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;-XX:+
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
      <category term="JVM" scheme="http://yoursite.com/categories/Java/JVM/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Spring Bean生命周期</title>
    <link href="http://yoursite.com/2019/12/30/Spring-Bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://yoursite.com/2019/12/30/Spring-Bean生命周期/</id>
    <published>2019-12-30T11:03:22.000Z</published>
    <updated>2020-01-10T13:01:56.820Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring-Bean生命周期"><a href="#Spring-Bean生命周期" class="headerlink" title="Spring Bean生命周期"></a>Spring Bean生命周期</h1><h2 id="生命周期流程"><a href="#生命周期流程" class="headerlink" title="生命周期流程"></a>生命周期流程</h2><p>首先看下生命周期图：<br><img src="/images/spring_bean_process.png" alt></p><p>再来一张执行过程：</p><p><img src="/images/spring_bean_life_process.png" alt></p><p>Spring Bean的生命周期只有四个阶段。要彻底搞清楚Spring的生命周期，首先要把这四个阶段牢牢记住。实例化和属性赋值对应<strong>构造方法</strong>和<strong>setter方法</strong>的注入，<strong>初始化和销毁是用户能自定义扩展的两个阶段</strong>。在这四步之间穿插的各种扩展点。</p><ul><li><p>实例化 Instantiation</p></li><li><p>属性赋值 Populate</p></li><li><p>初始化 Initialization</p></li><li><p>销毁 Destruction</p></li></ul><p><code>实例化 -&gt; 属性赋值 -&gt; 初始化 -&gt; 销毁</code></p><p>主要逻辑都在<code>doCreateBean()</code>方法中，逻辑很清晰，就是顺序调用以下三个方法，这三个方法与三个生命周期阶段一一对应，非常重要，在后续扩展接口分析中也会涉及。</p><blockquote><p><code>createBeanInstance()</code> -&gt; 实例化<br><code>populateBean()</code> -&gt; 属性赋值<br><code>initializeBean()</code> -&gt; 初始化</p></blockquote><p>源码如下，能证明实例化，属性赋值和初始化这三个生命周期的存在。关于本文的Spring源码都将忽略无关部分，便于理解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 忽略了无关代码</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> @Nullable Object[] args)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Instantiate the bean.</span></span><br><span class="line">   BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line">   <span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="comment">// 实例化阶段！</span></span><br><span class="line">      instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Initialize the bean instance.</span></span><br><span class="line">   Object exposedObject = bean;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">// 属性赋值阶段！</span></span><br><span class="line">      populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">       <span class="comment">// 初始化阶段！</span></span><br><span class="line">      exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于销毁，是在容器关闭时调用的，详见<code>ConfigurableApplicationContext#close()</code></p><p>在谈生命周期之前有一点需要先明确：</p><blockquote><p>Spring 只帮我们管理单例模式 Bean 的完整生命周期，对于 prototype 的 bean ，Spring 在创建好交给使用者之后则不会再管理后续的生命周期。</p></blockquote><h2 id="AOP扩展bean生命周期"><a href="#AOP扩展bean生命周期" class="headerlink" title="AOP扩展bean生命周期"></a>AOP扩展bean生命周期</h2><p>Spring生命周期相关的常用切入方式非常多，主要有下列方式：</p><h3 id="注解方式"><a href="#注解方式" class="headerlink" title="注解方式"></a>注解方式</h3><p>在 bean 初始化时会经历几个阶段，首先可以使用注解 @PostConstruct, @PreDestroy 来在 bean 的创建和销毁阶段进行调用。</p><h3 id="两个生命周期接口InitializingBean-DisposableBean"><a href="#两个生命周期接口InitializingBean-DisposableBean" class="headerlink" title="两个生命周期接口InitializingBean, DisposableBean"></a>两个生命周期接口InitializingBean, DisposableBean</h3><p>还可以实现 <code>InitializingBean</code>, <code>DisposableBean</code> 这两个接口，也是在初始化以及销毁阶段调用。实例化和属性赋值都是Spring帮助我们做的，能够自己实现的就只有 <strong>初始化</strong> 和 <strong>销毁</strong> 两个生命周期阶段.</p><ul><li><p><strong>InitializingBean</strong><br>对应生命周期的初始化阶段，在源码的 <code>invokeInitMethods(beanName, wrappedBean, mbd)</code> 方法中调用。</p><p>  有一点需要注意，因为<code>Aware</code>方法都是执行在初始化方法之前，所以可以在初始化方法中放心大胆的使用Aware接口获取的资源，这也是我们自定义扩展Spring的常用方式。<br>  除了实现<code>InitializingBean</code>接口之外还能通过注解或者xml配置的方式指定初始化方法，至于这几种定义方式的调用顺序其实没有必要记。因为这几个方法对应的都是同一个生命周期，只是实现方式不同，我们一般只采用其中一种方式。</p></li><li><p><strong>DisposableBean</strong><br>类似于<code>InitializingBean</code>，对应生命周期的销毁阶段，以<code>ConfigurableApplicationContext#close()</code> 方法作为入口，实现是通过循环取所有实现了<code>DisposableBean</code>接口的Bean然后调用其`destroy() 方法;</p></li></ul><h3 id="自定义初始化和销毁方法"><a href="#自定义初始化和销毁方法" class="headerlink" title="自定义初始化和销毁方法"></a>自定义初始化和销毁方法</h3><p>也可以自定义方法用于在初始化、销毁阶段调用</p><h3 id="实现-Aware-接口"><a href="#实现-Aware-接口" class="headerlink" title="实现 Aware 接口"></a>实现 Aware 接口</h3><p>Aware类型的接口的作用就是让我们能够拿到Spring容器中的一些资源。基本都能够见名知意，Aware之前的名字就是可以拿到什么资源，例如<code>BeanNameAware</code>可以拿到<code>BeanName</code>，以此类推。调用时机需要注意：<strong>所有的Aware方法都是在初始化阶段之前调用的！</strong></p><p>Aware接口具体可以分为两组。如下排列顺序同样也是Aware接口的执行顺序:</p><ul><li><p>Aware Group1</p><blockquote><p>BeanNameAware</p><p>BeanClassLoaderAware</p><p>BeanFactoryAware</p></blockquote></li><li><p>Aware Group2</p><blockquote><p>EnvironmentAware</p></blockquote><p>EmbeddedValueResolverAware 实现该接口能够获取Spring EL解析器，用户的自定义注解需要支持spel表达式的时候可以使用，非常方便。</p><blockquote><p>ApplicationContextAware(ResourceLoaderAware、ApplicationEventPublisherAware、MessageSourceAware) 这几个接口可能让人有点懵，实际上这几个接口可以一起记，其返回值实质上都是当前的ApplicationContext对象，因为ApplicationContext是一个复合接口</p></blockquote></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationContext</span> <span class="keyword">extends</span> <span class="title">EnvironmentCapable</span>, <span class="title">ListableBeanFactory</span>, <span class="title">HierarchicalBeanFactory</span>,</span></span><br><span class="line"><span class="class">        <span class="title">MessageSource</span>, <span class="title">ApplicationEventPublisher</span>, <span class="title">ResourcePatternResolver</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>这里涉及一道面试题，<code>ApplicationContext</code> 和 <code>BeanFactory</code>的区别，可以从<code>ApplicationContext</code> 继承的这几个接口入手，除去 <code>BeanFactory</code> 相关的两个接口就是<code>ApplicationContext</code>独有的功能.</p><h3 id="BeanPostProcessor-InstantiationAwareBeanPostProcessor接口"><a href="#BeanPostProcessor-InstantiationAwareBeanPostProcessor接口" class="headerlink" title="BeanPostProcessor, InstantiationAwareBeanPostProcessor接口"></a>BeanPostProcessor, InstantiationAwareBeanPostProcessor接口</h3><p>增强处理器(<font color="red">容器级别</font>)，实现 BeanPostProcessor 接口，<strong>Spring 中所有 bean 在做初始化时都会调用该接口中的两个方法，</strong>， 正因为如此，这些接口的功能非常强大，Spring内部扩展也经常使用这些接口，例如自动注入以及AOP的实现都和他们有关。</p><p>这是Spring扩展中最重要的两个接口！</p><ul><li><p><code>InstantiationAwareBeanPostProcessor</code>作用于<strong>实例化阶段</strong>的前后；</p></li><li><p><code>BeanPostProcessor</code>作用于<strong>初始化阶段</strong>的前后；</p></li><li><p><code>InstantiationAwareBeanPostProcessor</code>实际上继承了 <code>BeanPostProcessor</code>接口，严格意义上来看他们是两父子;</p></li></ul><h2 id="Aware调用时机源码分析"><a href="#Aware调用时机源码分析" class="headerlink" title="Aware调用时机源码分析"></a>Aware调用时机源码分析</h2><p>详情如下，忽略了部分无关代码。代码位置就是<code>initializeBean</code>方法详情，这也说明了Aware都是在初始化阶段之前调用的！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 见名知意，初始化阶段调用的方法</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">initializeBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Object bean, @Nullable RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里调用的是Group1中的三个Bean开头的Aware</span></span><br><span class="line">        invokeAwareMethods(beanName, bean);</span><br><span class="line"></span><br><span class="line">        Object wrappedBean = bean;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 这里调用的是Group2中的几个Aware，</span></span><br><span class="line">        <span class="comment">// 而实质上这里就是前面所说的BeanPostProcessor的调用点！</span></span><br><span class="line">        <span class="comment">// 也就是说与Group1中的Aware不同，这里是通过BeanPostProcessor（ApplicationContextAwareProcessor）实现的。</span></span><br><span class="line">        wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">        <span class="comment">// 下文即将介绍的InitializingBean调用点</span></span><br><span class="line">        invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">        <span class="comment">// BeanPostProcessor的另一个调用点</span></span><br><span class="line">        wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> wrappedBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到并不是所有的Aware接口都使用同样的方式调用。</p><ul><li>Bean××Aware都是在代码中直接调用的;</li><li>ApplicationContext相关的Aware都是通过<code>BeanPostProcessor#postProcessBeforeInitialization()</code>实现的。</li></ul><p>具体流程可以看一下 <code>ApplicationContextAwareProcessor</code> 这个类的源码，就是判断当前创建的Bean是否实现了相关的Aware方法，如果实现了会调用回调方法将资源传递给Bean。</p><p>至于Spring为什么这么实现，应该没什么特殊的考量。也许和Spring的版本升级有关。基于对修改关闭，对扩展开放的原则，Spring对一些新的Aware采用了扩展的方式添加。</p><p>BeanPostProcessor的调用时机也能在这里体现，包围住 <code>invokeInitMethods</code> 方法，也就说明了在初始化阶段的前后执行。</p><p>关于Aware接口的执行顺序，其实只需要记住第一组在第二组执行之前就行了.</p><h2 id="实例Demo"><a href="#实例Demo" class="headerlink" title="实例Demo"></a>实例Demo</h2><h3 id="User-java"><a href="#User-java" class="headerlink" title="User.java"></a>User.java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Austin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2019/12/2 21:01   Mon</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span>, <span class="title">DisposableBean</span>, <span class="title">BeanNameAware</span>, <span class="title">ApplicationContextAware</span>,</span></span><br><span class="line"><span class="class">        <span class="title">BeanClassLoaderAware</span>, <span class="title">BeanFactoryAware</span>, <span class="title">EnvironmentAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义方法用于在初始化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"调用Bean的函数(initMethod)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postConstructor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"调用Bean的函数(postConstruct)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"调用Bean的函数(constructor)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"调用Bean的函数(setName/setAttribute)"</span>);</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"调用Bean的函数(preDestroy)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"调用Bean的函数(destroy())"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroyMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"调用Bean的函数(destroyMethod)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"调用Bean的函数(afterPropertiesSet)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"调用BeanNameAware的(setBeanName)函数"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"调用ApplicationContextAware的(setApplicationContext)函数"</span>);</span><br><span class="line">        <span class="keyword">this</span>.applicationContext = applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanClassLoader</span><span class="params">(ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"调用BeanClassLoaderAware的(setBeanClassLoader)函数"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanFactory</span><span class="params">(BeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"调用BeanFactoryAware的(setBeanFactory)函数"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEnvironment</span><span class="params">(Environment environment)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"调用EnvironmentAware的(setEnvironment)函数"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CustomBeanPostProcessor-java"><a href="#CustomBeanPostProcessor-java" class="headerlink" title="CustomBeanPostProcessor.java"></a>CustomBeanPostProcessor.java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Austin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2019/12/2 21:10   Mon</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">InstantiationAwareBeanPostProcessor</span>, <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实例化之前调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (beanClass == User.class)&#123;</span><br><span class="line">            System.out.println(<span class="string">"调用InstantiationAwareBeanPostProcessor的postProcessBeforeInstantiation()函数"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实例化之后调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">postProcessAfterInstantiation</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (bean.getClass() == User.class)&#123;</span><br><span class="line">            System.out.println(<span class="string">"调用InstantiationAwareBeanPostProcessor的postProcessAfterInstantiation()函数"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 预初始化，初始化之前调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (bean.getClass() == User.class) &#123;</span><br><span class="line">            System.out.println(<span class="string">"调用BeanPostProcessor的postProcessBeforeInitialization()函数"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 后初始化  bean 初始化完成调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (bean.getClass() == User.class) &#123;</span><br><span class="line">            System.out.println(<span class="string">"调用BeanPostProcessor的postProcessAfterInitialization()函数"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BootStrap-java"><a href="#BootStrap-java" class="headerlink" title="BootStrap.java"></a>BootStrap.java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Austin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2019/12/2 21:13   Mon</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BootStrap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(BootStrap.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(initMethod = <span class="string">"initMethod"</span>, destroyMethod = <span class="string">"destroyMethod"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">user</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setUsername(<span class="string">"xxxx"</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">调用InstantiationAwareBeanPostProcessor的postProcessBeforeInstantiation()函数</span><br><span class="line"></span><br><span class="line">调用Bean的函数(constructor)</span><br><span class="line">调用Bean的函数(setName/setAttribute)</span><br><span class="line"></span><br><span class="line">调用InstantiationAwareBeanPostProcessor的postProcessAfterInstantiation()函数</span><br><span class="line"></span><br><span class="line">调用BeanNameAware的(setBeanName)函数</span><br><span class="line">调用BeanClassLoaderAware的(setBeanClassLoader)函数</span><br><span class="line">调用BeanFactoryAware的(setBeanFactory)函数</span><br><span class="line"></span><br><span class="line">调用EnvironmentAware的(setEnvironment)函数</span><br><span class="line">调用ApplicationContextAware的(setApplicationContext)函数</span><br><span class="line"></span><br><span class="line">调用BeanPostProcessor的postProcessBeforeInitialization()函数</span><br><span class="line"></span><br><span class="line">调用Bean的函数(postConstruct)</span><br><span class="line">调用Bean的函数(afterPropertiesSet)</span><br><span class="line">调用Bean的函数(initMethod)</span><br><span class="line"></span><br><span class="line">调用BeanPostProcessor的postProcessAfterInitialization()函数</span><br><span class="line"></span><br><span class="line">调用Bean的函数(preDestroy)</span><br><span class="line">调用Bean的函数(destroy())</span><br><span class="line">调用Bean的函数(destroyMethod)</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Spring Bean的生命周期分为<strong>四个阶段</strong>和<strong>多个扩展点</strong>。扩展点又可以分为<strong>影响多个Bean</strong>和<strong>影响单个Bean</strong>。整理如下：</p><h3 id="四个阶段"><a href="#四个阶段" class="headerlink" title="四个阶段"></a>四个阶段</h3><ul><li>实例化 Instantiation</li><li>属性赋值 Populate</li><li>初始化 Initialization</li><li>销毁 Destruction</li></ul><h3 id="多个扩展点"><a href="#多个扩展点" class="headerlink" title="多个扩展点"></a>多个扩展点</h3><ul><li><p>影响多个Bean</p><ul><li>BeanPostProcessor</li><li>InstantiationAwareBeanPostProcessor</li></ul></li><li><p>影响单个Bean</p><ul><li><p>Aware</p><ul><li><p>Aware Group1</p><ul><li>BeanNameAware</li><li>BeanClassLoaderAware</li><li>BeanFactoryAware</li></ul></li><li><p>Aware Group2</p><ul><li>EnvironmentAware</li><li>EmbeddedValueResolverAware</li><li>ApplicationContextAware (ResourceLoaderAware、ApplicationEventPublisherAware、MessageSourceAware)</li></ul></li></ul></li><li><p>生命周期</p><ul><li>InitializingBean</li><li>DisposableBean</li></ul></li></ul></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.jianshu.com/p/1dec08d290c1" target="_blank" rel="noopener">请别再问Spring Bean的生命周期了！</a><br><a href="https://juejin.im/post/5ab1bf19f265da23771947f1" target="_blank" rel="noopener">Spring Bean 生命周期</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Spring-Bean生命周期&quot;&gt;&lt;a href=&quot;#Spring-Bean生命周期&quot; class=&quot;headerlink&quot; title=&quot;Spring Bean生命周期&quot;&gt;&lt;/a&gt;Spring Bean生命周期&lt;/h1&gt;&lt;h2 id=&quot;生命周期流程&quot;&gt;&lt;a hr
      
    
    </summary>
    
      <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
      <category term="Spring Boot" scheme="http://yoursite.com/categories/Spring/Spring-Boot/"/>
    
    
      <category term="Springboot" scheme="http://yoursite.com/tags/Springboot/"/>
    
      <category term="Bean" scheme="http://yoursite.com/tags/Bean/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis核心组件及常见问题总结</title>
    <link href="http://yoursite.com/2019/12/27/Mybatis%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E5%8F%8A%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/12/27/Mybatis核心组件及常见问题总结/</id>
    <published>2019-12-27T11:13:56.000Z</published>
    <updated>2020-01-10T13:01:56.877Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mybatis核心组件"><a href="#mybatis核心组件" class="headerlink" title="mybatis核心组件"></a>mybatis核心组件</h1><h2 id="mybatis-config-xml"><a href="#mybatis-config-xml" class="headerlink" title="mybatis-config.xml"></a>mybatis-config.xml</h2><p>XML 配置文件（configuration XML）中包含了对 MyBatis 系统的核心设置，包含获取数据库连接实例的数据源（DataSource）和决定事务作用域和控制方式的事务管理器（TransactionManager）</p><h2 id="SqlSessionFactoryBuilder"><a href="#SqlSessionFactoryBuilder" class="headerlink" title="SqlSessionFactoryBuilder"></a>SqlSessionFactoryBuilder</h2><ul><li><p>作用<br>SqlSessionFactoryBuilder通过类名就可以看出这个类的主要作用就是创建一个SqlSessionFactory，通过输入mybatis配置文件的字节流或者字符流，生成XMLConfigBuilder，XMLConfigBuilder创建一个Configuration，Configuration这个类中包含了mybatis的配置的一切信息，mybatis进行的所有操作都需要根据Configuration中的信息来进行。</p></li><li><p>作用域（Scope）和生命周期<br>可以重用 SqlSessionFactoryBuilder 来创建多个 SqlSessionFactory 实例，但是最好还是不要让其一直存在 ,以保证所有的 XML 解析资源开放给更重要的事情, 这个类可以被实例化、使用和丢弃，一旦创建了 SqlSessionFactory，就不再需要它了。因此 SqlSessionFactoryBuilder 实例的最佳作用域是方法作用域（也就是局部方法变量）</p></li></ul><h2 id="SqlSessionFactory接口"><a href="#SqlSessionFactory接口" class="headerlink" title="SqlSessionFactory接口"></a>SqlSessionFactory接口</h2><ul><li><p>概念<br>sql会话工厂，用于创建SqlSession</p></li><li><p>作用域（Scope）和生命周期<br>SqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在，没有任何理由对它进行清除或重建，最佳作用域是应用作用域。有很多方法可以做到，最简单的就是使用单例模式或者静态单例模式。</p></li><li><p>如何创建<br>使用xml构建</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String resource = <span class="string">"org/mybatis/example/mybatis-config.xml"</span>;</span><br><span class="line">InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br></pre></td></tr></table></figure><p>java代码构建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DataSource dataSource = BlogDataSourceFactory.getBlogDataSource();</span><br><span class="line">TransactionFactory transactionFactory = <span class="keyword">new</span> JdbcTransactionFactory();</span><br><span class="line">Environment environment = <span class="keyword">new</span> Environment(<span class="string">"development"</span>, transactionFactory, dataSource);</span><br><span class="line">Configuration configuration = <span class="keyword">new</span> Configuration(environment);</span><br><span class="line">configuration.addMapper(BlogMapper.class);</span><br><span class="line">SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(configuration);</span><br></pre></td></tr></table></figure><h2 id="SqlSession接口"><a href="#SqlSession接口" class="headerlink" title="SqlSession接口"></a>SqlSession接口</h2><ul><li><p>概念<br>SqlSession是MyBatis的一个重要接口，定义了数据库的增删改查以及事务管理的常用方法。SqlSession还提供了查找Mapper接口的有关方法。</p></li><li><p>作用域（Scope）和生命周期<br>每个线程都应该有它自己的 SqlSession 实例, SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域，每次收到的 HTTP请求，就可以打开一个 SqlSession，返回一个响应，就关闭它。</p></li><li><p>如何创建</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SqlSession session = sqlSessionFactory.openSession();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// do work</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Mapper接口"><a href="#Mapper接口" class="headerlink" title="Mapper接口"></a>Mapper接口</h2><ul><li><p>概念<br>承载了实际的业务逻辑，其生命周期比较短，由SqlSession创建,用于将Java对象和实际的SQL语句对应起来。Mapper接口是指程序员自行定义的一个数据操纵接口，类似于通常所说的DAO接口。跟DAO不同的地方在于Mapper接口只需要程序员定义，不需要程序员去实现，MyBatis会自动为Mapper接口创建动态代理对象。Mapper接口的方法通常与Mapper配置文件中的select、insert、update、delete等XML结点存在一一对应关系。</p></li><li><p>实现方式</p><ul><li>(1)使用XML配置文件的方式。</li><li>(2)使用注解方式。</li><li>(3)直接使用MyBatis提供的API。</li></ul></li></ul><h2 id="mybatis的优缺点"><a href="#mybatis的优缺点" class="headerlink" title="mybatis的优缺点"></a>mybatis的优缺点</h2><p><strong>优点</strong></p><ul><li><ol><li>易于上手和掌握。</li></ol></li><li><ol start="2"><li>sql写在xml里，便于统一管理和优化。</li></ol></li><li><ol start="3"><li>解除sql与程序代码的耦合。</li></ol></li><li><ol start="4"><li>提供映射标签，支持对象与数据库的orm字段关系映射</li></ol></li><li><ol start="5"><li>提供对象关系映射标签，支持对象关系组建维护</li></ol></li><li><ol start="6"><li>提供xml标签，支持编写动态sql。</li></ol></li></ul><p><strong>缺点</strong></p><ul><li><p>sql工作量很大，尤其是字段多、关联表多时，更是如此。</p></li><li><p>sql依赖于数据库，导致数据库移植性差。</p></li><li><p>由于xml里标签id必须唯一，导致DAO中方法不支持方法重载。</p></li><li><p>字段映射标签和对象关系映射标签仅仅是对映射关系的描述，具体实现仍然依赖于sql。（比如配置了一对多Collection标签，如果sql里没有join子表或查询子表的话，查询后返回的对象是不具备对象关系的，即Collection的对象为null）</p></li><li><p>DAO层过于简单，对象组装的工作量较大。</p></li><li><p>不支持级联更新、级联删除。</p></li><li><p>编写动态sql时,不方便调试，尤其逻辑复杂时。</p></li><li><p>提供的写动态sql的xml标签功能简单（连struts都比不上），编写动态sql仍然受限，且可读性低。</p></li><li><p>若不查询主键字段，容易造成查询出的对象有“覆盖”现象。</p></li><li><p>参数的数据类型支持不完善。（如参数为Date类型时，容易报没有get、set方法，需在参数上加@param）</p></li><li><p>多参数时，使用不方便，功能不够强大。（目前支持的方法有map、对象、注解@param以及默认采用012索引位的方式）</p></li><li><p>缓存使用不当，容易产生脏数据。</p></li></ul><h1 id="Mybatis常见问题"><a href="#Mybatis常见问题" class="headerlink" title="Mybatis常见问题"></a>Mybatis常见问题</h1><h2 id="传统-JDBC-的弊端"><a href="#传统-JDBC-的弊端" class="headerlink" title="传统 JDBC 的弊端"></a>传统 JDBC 的弊端</h2><ul><li><p>1、jdbc 底层没有用连接池、操作数据库需要频繁的创建和关联链接。消耗很大的资源</p></li><li><p>2、写原生的 jdbc 代码在 java 中，一旦我们要修改 sql 的话，java 需要整体编译，不利于系 统维护</p></li><li><p>3、使用 PreparedStatement 预编译的话对变量进行设置 123 数字，这样的序号不利于维护 4、返回 result 结果集也需要硬编码。</p></li></ul><h2 id="什么是Mybatis？"><a href="#什么是Mybatis？" class="headerlink" title="什么是Mybatis？"></a>什么是Mybatis？</h2><ul><li><p>1、Mybatis是一个半ORM（对象关系映射）框架，它内部封装了JDBC，开发时只需要关注SQL语句本身，不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。程序员直接编写原生态sql，可以严格控制sql执行性能，灵活度高。</p></li><li><p>2、MyBatis 可以使用 XML 或注解来配置和映射原生信息，将 POJO映射成数据库中的记录，避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。</p></li><li><p>3、通过xml 文件或注解的方式将要执行的各种 statement 配置起来，并通过java对象和 statement中sql的动态参数进行映射生成最终执行的sql语句，最后由mybatis框架执行sql并将结果映射为java对象并返回。（从执行sql到返回result的过程）。</p></li></ul><h2 id="Mybatis执行流程"><a href="#Mybatis执行流程" class="headerlink" title="Mybatis执行流程"></a>Mybatis执行流程</h2><p><img src="/images/mybatis_work_process.png" alt></p><h2 id="mybatis核心概念"><a href="#mybatis核心概念" class="headerlink" title="mybatis核心概念"></a>mybatis核心概念</h2><table><thead><tr><th>名称</th><th>意义</th></tr></thead><tbody><tr><td>Configuration</td><td>管理 mysql-config.xml全局配置关系类</td></tr><tr><td>SqlSessionFactory</td><td>Session 管理工厂接口</td></tr><tr><td>Session</td><td><code>SqlSession</code>是一个面向用户(程序员)的接口。SqlSession 中提 供了很多操作数据库的方法</td></tr><tr><td>Executor</td><td>执行器是一个接口(基本执行器、缓存执行器)  作用:SqlSession 内部通过执行器操作数据库</td></tr><tr><td>MappedStatement</td><td>底层封装对象 作用:对操作数据库存储封装，包括 <code>sql</code> 语句、输入输出参数</td></tr><tr><td>StatementHandler</td><td>具体操作数据库相关的 <code>handler</code> 接口</td></tr><tr><td>ResultSetHandler</td><td>具体操作数据库返回结果的 <code>handler</code> 接口</td></tr></tbody></table><h2 id="Mybatis-全局配置详解"><a href="#Mybatis-全局配置详解" class="headerlink" title="Mybatis 全局配置详解"></a>Mybatis 全局配置详解</h2><p> <img src="/images/mybatis_global_config.png" alt></p><h2 id="MyBatis与Hibernate有哪些不同？"><a href="#MyBatis与Hibernate有哪些不同？" class="headerlink" title="MyBatis与Hibernate有哪些不同？"></a>MyBatis与Hibernate有哪些不同？</h2><p>1、Mybatis和hibernate不同，它<strong>不完全是一个ORM框架</strong>，因为MyBatis需要程序员自己编写Sql语句。</p><p>2、<strong>Mybatis直接编写原生态sql，可以严格控制sql执行性能，灵活度高</strong>，非常适合对关系数据模型要求不高的软件开发，因为这类软件需求变化频繁，一但需求变化要求迅速输出成果。但是灵活的前提是mybatis无法做到数据库无关性，如果需要实现支持多种数据库的软件，则需要自定义多套sql映射文件，工作量大。</p><p>3、Hibernate对象/关系映射能力强，<strong>数据库无关性好</strong>，对于关系模型要求高的软件，如果用hibernate开发可以节省很多代码，提高效率。</p><h2 id="和-的区别是什么？"><a href="#和-的区别是什么？" class="headerlink" title="#{} 和 ${} 的区别是什么？"></a><code>#{}</code> 和 <code>${}</code> 的区别是什么？</h2><ul><li><p><code>#{}</code> 是<strong>预编译处理</strong>，Mybatis在处理<code>#{}</code>时，会将sql中的<code>#{}</code>替换为<code>?</code>号，调用<code>PreparedStatement</code>的<code>set</code>方法来赋值；</p></li><li><p><code>${}</code>是<strong>字符串替换</strong>，Mybatis在处理<code>${}</code>时，就是把<code>${}</code>替换成变量的值原样拼接在SQL中；</p></li><li><p>使用<code>#{}</code>可以有效的防止SQL注入，提高系统安全性</p></li></ul><h2 id="Dao接口的工作原理是什么？Dao接口里的方法能重载吗？"><a href="#Dao接口的工作原理是什么？Dao接口里的方法能重载吗？" class="headerlink" title="Dao接口的工作原理是什么？Dao接口里的方法能重载吗？"></a>Dao接口的工作原理是什么？Dao接口里的方法能重载吗？</h2><p>Dao接口即Mapper接口。接口的全限名，就是mapper映射文件中的<code>namespace</code>的值；</p><p>接口的方法名，就是映射文件中Mapper的<code>Statement</code>的<code>id</code>值；接口方法内的参数，就是传递给sql的参数。</p><p>Mapper接口是没有实现类的，当调用接口方法时，<strong>接口全限名+方法名</strong>拼接字符串作为key值，可唯一定位一个<code>MapperStatement</code>。</p><p>在Mybatis中，每一个 <code>&lt;select&gt;</code>、<code>&lt;insert&gt;</code>、<code>&lt;update&gt;</code>、<code>&lt;delete&gt;</code> 标签，都会被解析为一个<code>MapperStatement</code>对象。举例： <code>com.mybatis3.mappers.StudentDao.findStudentById</code> ，可以唯一找到<code>namespace</code>为 <code>com.mybatis3.mappers.StudentDao</code> 下面 <code>id</code> 为 <code>findStudentById</code> 的 <code>MapperStatement</code>。</p><p><strong>Mapper接口里的方法，是不能重载的</strong>，因为是使用 <strong>全限名+方法名</strong> 的保存和寻找策略。 </p><p>Mapper接口的工作原理是<strong>JDK动态代理</strong>，<strong>Mybatis运行时会使用JDK动态代理为Mapper接口生成代理对象proxy，代理对象会拦截接口方法，转而执行MapperStatement所代表的sql，然后将sql执行结果返回</strong>。</p><h2 id="Mybatis是如何进行分页的？分页插件的原理是什么？"><a href="#Mybatis是如何进行分页的？分页插件的原理是什么？" class="headerlink" title="Mybatis是如何进行分页的？分页插件的原理是什么？"></a>Mybatis是如何进行分页的？分页插件的原理是什么？</h2><p>Mybatis使用<code>RowBounds</code>对象进行分页，它是针对<code>ResultSet</code>结果集执行的<strong>内存分页，而非物理分页</strong>。可以在sql内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。</p><p>分页插件的基本原理是<strong>使用Mybatis提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql，根据dialect方言，添加对应的物理分页语句和物理分页参数.</strong></p><h2 id="Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？"><a href="#Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？" class="headerlink" title="Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？"></a>Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？</h2><p><code>Mybatis</code>仅支持<code>association</code>关联对象和<code>collection</code>关联集合对象的延迟加载，<code>association</code>指的就是一对一，<code>collection</code>指的就是一对多查询。</p><p>在Mybatis配置文件中，可以配置是否启用延迟加载<code>lazyLoadingEnabled=true|false</code>。</p><p>它的原理是，<strong>使用<code>CGLIB</code>创建目标对象的代理对象</strong>，当调用目标方法时，进入拦截器方法，比如调用<code>a.getB().getName()</code>，拦截器<code>invoke()</code>方法发现<code>a.getB()</code>是null值，那么就会单独发送事先保存好的查询关联B对象的sql，把B查询上来，然后调用<code>a.setB(b)</code>，于是a的对象b属性就有值了，接着完成<code>a.getB().getName()</code>方法的调用。这就是延迟加载的基本原理。</p><p>当然了，不光是<code>Mybatis</code>，几乎所有的包括<code>Hibernate</code>，支持延迟加载的原理都是一样的</p><h2 id="Mybatis的一级、二级缓存"><a href="#Mybatis的一级、二级缓存" class="headerlink" title="Mybatis的一级、二级缓存"></a>Mybatis的一级、二级缓存</h2><p>1）一级缓存: 基于 <code>PerpetualCache</code> 的 HashMap 本地缓存，其存储作用域为 <code>Session</code>，当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，<strong>默认打开一级缓存</strong>。</p><p>2）二级缓存与一级缓存其机制相同，默认也是采用 <code>PerpetualCache</code>，HashMap 存储，不同在于其存储作用域为 <code>Mapper(Namespace)</code>，并且可自定义存储源，如 <code>Ehcache</code>。<strong>默认不打开二级缓存</strong>，要开启二级缓存，使用二级缓存属性类需要实现<code>Serializable</code>序列化接口(可用来保存对象的状态), 可在它的映射文件中配置 <code>&lt;cache/&gt;</code> ；</p><p>3）对于缓存数据更新机制，当某一个作用域(一级缓存 Session/二级缓存Namespaces)的进行了C/U/D 操作后，默认该作用域下所有 <code>select</code> 中的缓存将被 <code>clear</code>。</p><h2 id="Mybatis都有哪些Executor执行器？"><a href="#Mybatis都有哪些Executor执行器？" class="headerlink" title="Mybatis都有哪些Executor执行器？"></a>Mybatis都有哪些Executor执行器？</h2><p>Mybatis有三种基本的Executor执行器，<code>SimpleExecutor</code>、<code>ReuseExecutor</code>、<code>BatchExecutor</code>。</p><ul><li><p><strong>SimpleExecutor</strong>：每执行一次<code>update</code>或<code>select</code>，就开启一个<code>Statement</code>对象，<strong>用完立刻关闭<code>Statement</code>对象</strong>。</p></li><li><p><strong>ReuseExecutor</strong>：执行<code>update</code>或<code>select</code>，<strong>以<code>sql</code>作为key查找<code>Statement</code>对象，存在就使用，不存在就创建，用完后，不关闭<code>Statement</code>对象，而是放置于<code>Map&lt;String, Statement&gt;</code>内，供下一次使用</strong>。简言之，就是重复使用<code>Statement</code>对象。</p></li><li><p><strong>BatchExecutor</strong>：执行<code>update</code>（没有select，JDBC批处理不支持select），将所有sql都添加到批处理中（<code>addBatch()</code>），等待统一执行（<code>executeBatch()</code>），它缓存了多个<code>Statement</code>对象，每个<code>Statement</code>对象都是<code>addBatch()</code>完毕后，等待逐一执行<code>executeBatch()</code>批处理。与JDBC批处理相同。</p></li></ul><p>作用范围：Executor的这些特点，都<strong>严格限制在SqlSession生命周期范围内</strong>。</p><h2 id="简述Mybatis的插件运行原理，以及如何编写一个插件。"><a href="#简述Mybatis的插件运行原理，以及如何编写一个插件。" class="headerlink" title="简述Mybatis的插件运行原理，以及如何编写一个插件。"></a>简述Mybatis的插件运行原理，以及如何编写一个插件。</h2><p>Mybatis仅可以编写针对： </p><ul><li><code>ParameterHandler</code></li><li><code>ResultSetHandler</code></li><li><code>StatementHandler</code></li><li><code>Executor</code>  </li></ul><p>这4种接口的插件，<strong>Mybatis使用JDK的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能</strong>，每当执行这4种接口对象的方法时，就会进入拦截方法，具体就是<code>InvocationHandler</code>的<code>invoke()</code>方法，当然，只会拦截那些你指定需要拦截的方法。</p><p>编写插件：</p><ul><li>① 实现Mybatis的<code>Interceptor</code>接口并覆写<code>intercept()</code>方法；</li><li>② 给插件编写注解，指定要拦截哪一个接口的哪些方法即可；</li><li>③ 在配置文件中配置你编写的插件。</li></ul><h2 id="如何获取自动生成的-主-键值"><a href="#如何获取自动生成的-主-键值" class="headerlink" title="如何获取自动生成的(主)键值"></a>如何获取自动生成的(主)键值</h2><p>一般插入数据的话，如果我们想要知道刚刚插入的数据的主键是多少，我们可以通过以下的方式来获取</p><p>需求：</p><blockquote><p>user对象插入到数据库后，新记录的主键要通过user对象返回，通过user获取主键值。</p></blockquote><p>解决思路：</p><p>通过<code>LAST_INSERT_ID()</code>获取刚插入记录的自增主键值，在<code>insert</code>语句执行后，执行<code>select LAST_INSERT_ID()</code> 就可以获取自增主键。</p><p>mysql:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;insert id="insertUser" parameterType="cn.itcast.mybatis.po.User"&gt;</span><br><span class="line">    &lt;selectKey keyProperty="id" order="AFTER" resultType="int"&gt;</span><br><span class="line">        <span class="keyword">select</span> <span class="keyword">LAST_INSERT_ID</span>()</span><br><span class="line">    &lt;/selectKey&gt;</span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">USER</span>(username,birthday,sex,address) <span class="keyword">VALUES</span>(<span class="comment">#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;)</span></span><br><span class="line">&lt;/<span class="keyword">insert</span>&gt;</span><br></pre></td></tr></table></figure><h2 id="Mybatis动态sql"><a href="#Mybatis动态sql" class="headerlink" title="Mybatis动态sql"></a>Mybatis动态sql</h2><ul><li><p>Mybatis动态sql可以让我们在Xml映射文件内，以标签的形式编写动态sql，完成逻辑判断和动态拼接sql的功能;</p></li><li><p>Mybatis提供了9种动态sql标签：<code>trim|where|set|foreach|if|choose|when|otherwise|bind</code>。</p></li><li><p>其执行原理为，使用<code>OGNL</code> 从 sql 参数对象中计算表达式的值，根据表达式的值动态拼接sql，以此来完成动态sql的功能;</p></li></ul><h2 id="Mybatis比IBatis比较大的几个改进"><a href="#Mybatis比IBatis比较大的几个改进" class="headerlink" title="Mybatis比IBatis比较大的几个改进"></a>Mybatis比IBatis比较大的几个改进</h2><ul><li><p>a.增加接口绑定,包括注解绑定sql和xml绑定Sql ,</p></li><li><p>b.动态sql由原来的节点配置变成OGNL表达式,</p></li><li><p>c. 在一对一,一对多的时候引进了<code>association</code>, 在一对多的时候引入了<code>collection</code>节点, 不过都是在<code>resultMap</code>里面配置</p></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.im/post/5ce25058e51d45105773e63f" target="_blank" rel="noopener">面试官都会问的Mybatis面试题</a></p><p><a href="https://segmentfault.com/a/1190000013678579" target="_blank" rel="noopener">Mybatis常见面试题</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;mybatis核心组件&quot;&gt;&lt;a href=&quot;#mybatis核心组件&quot; class=&quot;headerlink&quot; title=&quot;mybatis核心组件&quot;&gt;&lt;/a&gt;mybatis核心组件&lt;/h1&gt;&lt;h2 id=&quot;mybatis-config-xml&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="数据库中间件" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
      <category term="Mybatis" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E9%97%B4%E4%BB%B6/Mybatis/"/>
    
    
      <category term="Mybatis" scheme="http://yoursite.com/tags/Mybatis/"/>
    
  </entry>
  
  <entry>
    <title>分布式ID生成器</title>
    <link href="http://yoursite.com/2019/12/20/%E5%88%86%E5%B8%83%E5%BC%8FID%E7%94%9F%E6%88%90%E5%99%A8/"/>
    <id>http://yoursite.com/2019/12/20/分布式ID生成器/</id>
    <published>2019-12-20T12:31:12.000Z</published>
    <updated>2019-12-20T12:39:22.126Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本要求"><a href="#基本要求" class="headerlink" title="基本要求"></a>基本要求</h2><ul><li>全局唯一  </li><li>趋势递增  </li><li>效率高（生成、使用、索引）</li><li>控制并发</li></ul><h2 id="常用策略"><a href="#常用策略" class="headerlink" title="常用策略"></a>常用策略</h2><p><img src="/images/distribute_uuid.jpg" alt></p><p><img src="/images/distribute_mysql_autoincrement.jpg" alt></p><p><img src="/images/distribute_mysql_ad.jpg" alt></p><p><img src="/images/distribute_snowflower.jpg" alt></p><p><img src="/images/distribute_snow_ad.jpg" alt></p><p><img src="/images/distribute_id_redis.jpg" alt></p><p><img src="/images/distribute_redis_advantage.jpg" alt></p><p><img src="/images/distribute_id_pk.jpg" alt></p><p><img src="/images/distribute_id_topk.jpg" alt></p><h2 id="Twitter雪花算法SnowFlake"><a href="#Twitter雪花算法SnowFlake" class="headerlink" title="Twitter雪花算法SnowFlake"></a>Twitter雪花算法SnowFlake</h2><p><img src="/images/distribute_snow_flower.jpg" alt></p><ul><li><p>1) 1位，不用。二进制中最高位为1的都是负数，但是我们生成的id一般都使用整数，所以这个最高位固定是0</p></li><li><p>2) 41位，用来记录时间戳（毫秒）。</p></li><li><p>3) 41位可以表示2^41−1个数字，如果只用来表示正整数（计算机中正数包含0），可以表示的数值范围是：0 至 2^41−1，减1是因为可表示的数值范围是从0开始算的，而不是1。<br>也就是说41位可以表示2^41−1个毫秒的值，转化成单位年则是(2^41−1)/(1000∗60∗60∗24∗365)=69年</p></li><li><p>4) 10位，用来记录工作机器id。<br>可以部署在2^10=1024个节点，包括5位datacenterId和5位workerId</p></li><li><p>5) 5位（bit）可以表示的最大正整数是2^5−1=31，即可以用0、1、2、3、….31这32个数字，来表示不同的datecenterId或workerId</p></li><li><p>6) 12位，序列号，用来记录同毫秒内产生的不同id。<br>12位（bit）可以表示的最大正整数是2^12−1=4095，即可以用0、1、2、3、….4094这4095个数字，来表示同一机器同一时间截（毫秒)内产生的4095个ID序号<br>由于在Java中64bit的整数是long类型，所以在Java中SnowFlake算法生成的id就是long来存储的。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基本要求&quot;&gt;&lt;a href=&quot;#基本要求&quot; class=&quot;headerlink&quot; title=&quot;基本要求&quot;&gt;&lt;/a&gt;基本要求&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;全局唯一  &lt;/li&gt;
&lt;li&gt;趋势递增  &lt;/li&gt;
&lt;li&gt;效率高（生成、使用、索引）&lt;/li&gt;
&lt;li&gt;控
      
    
    </summary>
    
      <category term="分布式" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="分布式" scheme="http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Springboot集成mybatis自定义插件开发</title>
    <link href="http://yoursite.com/2019/12/20/Springboot%E9%9B%86%E6%88%90mybatis%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    <id>http://yoursite.com/2019/12/20/Springboot集成mybatis自定义插件开发/</id>
    <published>2019-12-20T12:14:43.000Z</published>
    <updated>2019-12-20T12:18:12.339Z</updated>
    
    <content type="html"><![CDATA[<h2 id="mybatis架构"><a href="#mybatis架构" class="headerlink" title="mybatis架构"></a>mybatis架构</h2><p><img src="/images/mybatis_structure.png" alt="Pasted Graphi"></p><h2 id="mybatis工作原理"><a href="#mybatis工作原理" class="headerlink" title="mybatis工作原理"></a>mybatis工作原理</h2><p><img src="/images/mybatis_process.jpg" alt="-w777"></p><p>执行流程：</p><ol><li>读取核心配置文件并返回InputStream流对象。 </li><li>根据InputStream流对象解析出Configuration对象，然后创建SqlSessionFactory工厂对象 </li><li>根据一系列属性从SqlSessionFactory工厂中创建SqlSession </li><li>从SqlSession中调用Executor执行数据库操作&amp;&amp;生成具体SQL指令 </li><li>对执行结果进行二次封装 </li><li>提交与事务</li></ol><h2 id="mybatis插件简介"><a href="#mybatis插件简介" class="headerlink" title="mybatis插件简介"></a>mybatis插件简介</h2><p>mybatis插件就是在执行数据库操作的时候，对于特定方法进行拦截增强，做一些额外的处理的一种方式。<br>myabtis的插件的增强原理是利用动态代理实现的，可以对数据库操作的执行类做拦截，mybatis主要操作流程如下：</p><p><img src="/images/mybatis_process.jpg" alt></p><p>mybatis中的几个操作数据库的执行类是：Executor、StatementHandler、ParameterHandler、ResultSetHandler，其中：</p><ul><li><p>Executor 是总的执行者，他就像一个大总管，用于协调管理其他执行者。</p></li><li><p>StatementHandler 拦截Sql语法构建的处理, 是用于生成Statement或者PreparedStatement的执行者，同时他会调用ParameterHandler进行对sql语句中的参数设值，设置完了之后会通过StatementHandler 去调用sql在数据库中执行，最后返回一个结果集，通过ResultSetHandler将结果集和对应的实体进行映射填充数据，之后会把结果实体返回给StatementHandler。</p></li><li><p>ParameterHandler ：拦截参数的处理 </p></li><li><p>ResultSetHandler ：拦截结果集的处理 </p></li></ul><p>所以，我们对这几个执行者进行拦截，比如对于StatementHandler 拦截，即是对于sql操作进行拦截，Mybatis自定义插件必须实现Interceptor接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">    <span class="function">Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line">    <span class="function">Object <span class="title">plugin</span><span class="params">(Object target)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>intercept方法：拦截器具体处理逻辑方法 </li><li>plugin方法：根据签名signatureMap生成动态代理对象 </li><li>setProperties方法：设置Properties属性</li></ul><p>下面就对于这个StatementHandler 进行拦截做一个分页实例。</p><h2 id="分页插件"><a href="#分页插件" class="headerlink" title="分页插件"></a>分页插件</h2><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>拦截数据sql,实现分页功能</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Austin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2019/9/1 11:37   Sun</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Intercepts</span>(<span class="meta">@Signature</span>(</span><br><span class="line">        type = StatementHandler.class,</span><br><span class="line">        method = <span class="string">"prepare"</span>,</span><br><span class="line">        args = &#123;Connection.class, Integer.class&#125;</span><br><span class="line">))</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PagePlugin</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;mybatis.page.plugin.dialect&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String dialect;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;mybatis.page.plugin.pageSqlId&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String pageSqlId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插件需要做的事情</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// 确定哪些方法需要做分页</span></span><br><span class="line">        StatementHandler statementHandler = (StatementHandler) invocation.getTarget();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取原始sql</span></span><br><span class="line">        BoundSql boundSql = statementHandler.getBoundSql();</span><br><span class="line">        String sql = boundSql.getSql();</span><br><span class="line">        System.out.println(<span class="string">"原始sql: "</span> + sql);</span><br><span class="line"></span><br><span class="line">        MetaObject metaObject = MetaObject.forObject(statementHandler,</span><br><span class="line">                SystemMetaObject.DEFAULT_OBJECT_FACTORY,</span><br><span class="line">                SystemMetaObject.DEFAULT_OBJECT_WRAPPER_FACTORY,</span><br><span class="line">                <span class="keyword">new</span> DefaultReflectorFactory());</span><br><span class="line"></span><br><span class="line">        MappedStatement mappedStatement = (MappedStatement) metaObject.getValue(<span class="string">"delegate.mappedStatement"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//        //sql语句类型 select、delete、insert、update</span></span><br><span class="line">        <span class="comment">//        String sqlCommandType = mappedStatement.getSqlCommandType().toString();</span></span><br><span class="line">        <span class="comment">// 获取mapper接口中的方法名</span></span><br><span class="line">        String mapperMethodName = mappedStatement.getId();</span><br><span class="line"></span><br><span class="line">        Object paramObj = boundSql.getParameterObject();</span><br><span class="line">        <span class="keyword">if</span> (mapperMethodName.matches(<span class="string">".*ByPage$"</span>)) &#123;</span><br><span class="line">            Map&lt;String, Object&gt; params = (Map&lt;String, Object&gt;) paramObj;</span><br><span class="line">            PageInfo pageInfo = (PageInfo) params.get(<span class="string">"page"</span>);   <span class="comment">// map.put("page", pageInfo)</span></span><br><span class="line"></span><br><span class="line">            String countSql = <span class="string">"select count(1) from ("</span> + sql + <span class="string">") temp "</span>;</span><br><span class="line">            System.out.println(<span class="string">"查询总数sql: "</span> + countSql);</span><br><span class="line"></span><br><span class="line">            Connection connection = (Connection) invocation.getArgs()[<span class="number">0</span>];</span><br><span class="line">            PreparedStatement countStatement = connection.prepareStatement(countSql);</span><br><span class="line">            ParameterHandler parameterHandler = (ParameterHandler) metaObject.getValue(<span class="string">"delegate.parameterHandler"</span>);</span><br><span class="line">            parameterHandler.setParameters(countStatement);</span><br><span class="line">            ResultSet rs = countStatement.executeQuery();</span><br><span class="line">            <span class="keyword">if</span> (rs.next()) &#123;</span><br><span class="line">                pageInfo.setTotalNumber(rs.getInt(<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            rs.close();</span><br><span class="line">            countStatement.close();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 改造sql limit count</span></span><br><span class="line">            String pageSql = <span class="keyword">this</span>.generatePageSql(sql, pageInfo);</span><br><span class="line">            System.out.println(<span class="string">"分页sql: "</span> + pageSql);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 改造后的sql放回</span></span><br><span class="line">            metaObject.setValue(<span class="string">"delegate.boundSql.sql"</span>, pageSql);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行流程提交mybatis</span></span><br><span class="line">        <span class="keyword">return</span> invocation.proceed();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">generatePageSql</span><span class="params">(String sql, PageInfo pageInfo)</span> </span>&#123;</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">if</span> (dialect.equals(<span class="string">"mysql"</span>)) &#123;</span><br><span class="line">            sb.append(sql);</span><br><span class="line">            sb.append(<span class="string">" limit "</span> + pageInfo.getStartIndex() + <span class="string">" ,"</span> + pageInfo.getTotalSelect());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">plugin</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Plugin.wrap(target, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>myabtis自定义插件只需要实现Interceptor接口即可，并且注解@Intercepts以及@Signature配置需要拦截的对象，其中</p><ul><li>type是需要拦截的对象Class，</li><li>method是对象里面的方法，</li><li>args是方法参数类型。</li></ul><h2 id="注入插件到拦截链"><a href="#注入插件到拦截链" class="headerlink" title="注入插件到拦截链"></a>注入插件到拦截链</h2><p>这里有两种方式注入</p><ul><li><p>方式一：直接注入</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Spring boot项目中只需要在拦截器类上加 @Component 注解即可。</span><br></pre></td></tr></table></figure></li><li><p>方式二：通过myabtis配置加入到拦截链中(多个拦截器时，这种方式可以控制拦截顺序）</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@MapperScan</span>(&#123;<span class="string">"com.springboot.demo.mapper"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperConfig</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//将插件加入到mybatis插件拦截链中</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ConfigurationCustomizer <span class="title">configurationCustomizer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConfigurationCustomizer() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(Configuration configuration)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//插件拦截链采用了责任链模式，执行顺序和加入连接链的顺序有关</span></span><br><span class="line">                MyPlugin myPlugin = <span class="keyword">new</span> MyPlugin();</span><br><span class="line">                <span class="comment">//设置参数，比如阈值等，可以在配置文件中配置，这里直接写死便于测试</span></span><br><span class="line">                Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">                <span class="comment">//这里设置慢查询阈值为1毫秒，便于测试</span></span><br><span class="line">                properties.setProperty(<span class="string">"time"</span>, <span class="string">"1"</span>);</span><br><span class="line">                myPlugin.setProperties(properties);</span><br><span class="line">                </span><br><span class="line">                configuration.addInterceptor(myPlugin);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;mybatis架构&quot;&gt;&lt;a href=&quot;#mybatis架构&quot; class=&quot;headerlink&quot; title=&quot;mybatis架构&quot;&gt;&lt;/a&gt;mybatis架构&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/images/mybatis_structure.png&quot; a
      
    
    </summary>
    
      <category term="数据库中间件" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
      <category term="Mybatis" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E9%97%B4%E4%BB%B6/Mybatis/"/>
    
    
      <category term="Mybatis" scheme="http://yoursite.com/tags/Mybatis/"/>
    
      <category term="Springboot" scheme="http://yoursite.com/tags/Springboot/"/>
    
  </entry>
  
</feed>
