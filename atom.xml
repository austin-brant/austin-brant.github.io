<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Austin Brant</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-03-20T10:10:41.186Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Austin Brant</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Shell常用脚本整理</title>
    <link href="http://yoursite.com/2020/03/20/Shell%E5%B8%B8%E7%94%A8%E8%84%9A%E6%9C%AC%E6%95%B4%E7%90%86/"/>
    <id>http://yoursite.com/2020/03/20/Shell常用脚本整理/</id>
    <published>2020-03-20T09:22:14.000Z</published>
    <updated>2020-03-20T10:10:41.186Z</updated>
    
    <content type="html"><![CDATA[<h2 id="读取文件每一行"><a href="#读取文件每一行" class="headerlink" title="读取文件每一行"></a>读取文件每一行</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 方法1</span></span><br><span class="line">while read line</span><br><span class="line">do</span><br><span class="line">    echo $line</span><br><span class="line">done &lt; filename(待读取的文件)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 方法2</span></span><br><span class="line">cat filename(待读取的文件) | while read line</span><br><span class="line">do</span><br><span class="line">    echo $line</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 方法3</span></span><br><span class="line">for line in `cat filename(待读取的文件)`</span><br><span class="line">do</span><br><span class="line">    echo $line</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h2 id="变量自增"><a href="#变量自增" class="headerlink" title="变量自增"></a>变量自增</h2><p>写循环时，常常要用到变量的自增，现在总结一下整型变量自增的方法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">i=`expr $i + 1`</span><br><span class="line"></span><br><span class="line">let i+=1;</span><br><span class="line"></span><br><span class="line">((i++));</span><br><span class="line"></span><br><span class="line">i=$[$i+1];</span><br><span class="line"></span><br><span class="line">i=$(( $i + 1 ))</span><br></pre></td></tr></table></figure><h2 id="字符串去空格"><a href="#字符串去空格" class="headerlink" title="字符串去空格"></a>字符串去空格</h2><p>（1）去行首空格</p><pre><code>sed &apos;s/^[ \t]*//g&apos;</code></pre><p>（2）去行尾空格</p><pre><code>sed &apos;s/[ \t]*$//g&apos;</code></pre><p>（3）去所有空格</p><pre><code>sed &apos;s/[[:space:]]//g&apos;</code></pre><h2 id="shell参数扩展"><a href="#shell参数扩展" class="headerlink" title="shell参数扩展"></a>shell参数扩展</h2><ul><li><p>如果parameter为null或者未设置，整个参数替换表达式值为word   </p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;parameter:-word&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果parameter为null或者未设置，整个参数替换表达式值为word，并且parameter参数值设置为word </p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    $&#123;parameter:=word&#125;  </span><br><span class="line">    ```            </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+ 如果parameter为null或者未设置，则打印出错误信息。否则，整个参数替换表达式值为$parameter</span><br></pre></td></tr></table></figure><p>  ${parameter:?word}</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+ 如果parameter不为null或者未设置，则整个参数替换表达式值为word</span><br></pre></td></tr></table></figure><p>  ${parameter:+word}</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">+ 获得字符串的长度</span><br></pre></td></tr></table></figure><p>  ${#parameter}</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">+  从尾开始扫描word，将匹配word正则表达式的字符过滤掉, %为最短匹配，%%为最长匹配</span><br></pre></td></tr></table></figure><p>  ${parameter%word}<br>  ${parameter%%word}</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+ 从头开始扫描word，将匹配word正则表达的字符过滤掉, #为最短匹配，##为最长匹配</span><br></pre></td></tr></table></figure><p>  ${parameter#word}<br>  ${parameter##word}</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+ 截取字符串,截取parameter的值的子字符串</span><br></pre></td></tr></table></figure><p>  ${parameter:offset}从offset到结束<br>  ${parameter:offset:length}从offset开始截取length个</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+ 字符串替换，将parameter对应值的pattern字符串替换成为string字符串, /表示只替换一次，//表示全部替换</span><br></pre></td></tr></table></figure><p>  ${parameter/pattern/string}<br>  ${parameter//pattern/string}</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">## Supervise进程监控</span><br><span class="line"></span><br><span class="line">supervise   监控进程，如果挂了，重启进程</span><br></pre></td></tr></table></figure></li></ul><p>-p,  状态路径，supervise运行时会在该路径下保存一些文件<br>-f,   启动新的进程命令<br>-F,   配置文件路径 the config file path, if not given, supervise will use the default value “supervise.conf”<br>-r,   while the service exits, supervise will excute the program RESTART_SH before restart the service, and the exiting times be passed          to RESTART_SH as the only argument.<br> -t,   after TIME_LIMIT seconds, the counter for the exiting times will be reset.<br> -v,  print the version of supervise and exit.<br> -h,  print the help message and exit.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">示例：</span><br></pre></td></tr></table></figure><p>supervise -p ../supervise/status/hdfs-dumper -f “sh ./control.sh start” -F ../supervise/conf/supervise.conf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 远程操作</span><br></pre></td></tr></table></figure><p>#!/bin/bash</p><p>LIST_FILE=hdfsdumper.num.list</p><p>size=<code>cat ./$LIST_FILE | wc -l</code></p><p>line_index=1<br>while [ $line_index -le $size ]<br>do<br>    machine=<code>cat ./$LIST_FILE | sed -n -e &quot;${line_index}p&quot; | awk -F&#39; &#39; &#39;{print $1}&#39;</code><br>    number=<code>cat ./$LIST_FILE | sed -n -e &quot;${line_index}p&quot; | awk -F&#39; &#39; &#39;{print $2}&#39;</code><br>    nohup expect -c “<br>        spawn ssh root@$machine;<br>        expect {<br>        &quot;Are you sure you want to continue connecting (yes/no)? &quot; {send &quot;yes\r&quot;;exp_continue}<br>        &quot;<em>password: &quot; {send &quot;password\n &quot;; exp_continue}<br>        &quot;]# &quot; {send &quot;su work; exit\n&quot;; exp_continue}<br>        &quot;bash-4.1$</em>&quot; {send &quot;cd /home/work/xxx &amp;&amp; sh control.sh start; exit\n&quot;; exp_continue}<br>        &quot;]$ &quot; {send &quot;cd /home/work/xxx &amp;&amp; sh control.sh start; exit\n&quot;; exp_continue}<br>        }” &amp;<br>    line_index=<code>expr $line_index + 1</code><br>done</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 远程同步文件</span><br></pre></td></tr></table></figure><p>#!/bin/bash</p><p>LIST_FILE=hdfsdumper.num.list</p><p>size=<code>cat ./$LIST_FILE | wc -l</code></p><p>file_name=./dumper/jdk.tar.gz</p><p>line_index=1<br>while [ $line_index -le $size ]<br>do<br>    machine=<code>cat ./$LIST_FILE | sed -n -e &quot;${line_index}p&quot; | awk -F&#39; &#39; &#39;{print $1}&#39;</code><br>    number=<code>cat ./$LIST_FILE | sed -n -e &quot;${line_index}p&quot; | awk -F&#39; &#39; &#39;{print $2}&#39;</code><br>    expect -c “<br>        spawn rsync -avz $file_name root@$machine:/home/work/opencrawler<br>        expect {<br>        &quot;Are you sure you want to continue connecting (yes/no)? &quot; {send &quot;yes\r&quot;;exp_continue}<br>        &quot;*password: &quot; {send &quot;password\n &quot;; interact}; }”;<br>    line_index=<code>expr $line_index + 1</code><br>done</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## switch case</span><br></pre></td></tr></table></figure><p>cmd=$1<br>case $cmd in<br>start)<br>    echo “in start command.”<br>    if [ -f “running_tag.txt” ];then<br>        echo “running_tag file is exist, already running!”<br>        exit 1<br>    fi<br>    nohup java -Xms1000m -Xmx1000m -Xmn500m -XX:+UseParallelGC ${MAIN_CLASSNAME} &gt;&gt;log/crontabservice_terminal.log 2&gt;&amp;1 &amp;<br>    ret=$?<br>    if [ $ret -eq 0 ];then<br>        echo “start [OK].”<br>    else<br>        echo “start [FAILED].”<br>    fi<br>    ;;<br>stop)<br>    echo “in stop command.”<br>    ret=<code>ps aux | grep &quot;${MAIN_CLASSNAME}&quot; | grep -v &quot;grep&quot; | awk &#39;{print $2}&#39;</code><br>    if [ ! $ret ];then<br>        echo “MODULE:${MAIN_CLASSNAME} not started.”<br>        exit 1<br>    fi<br>    echo “pid:$ret”<br>    kill -9 $ret<br>    if [ $? -eq 0 ];then<br>        rm -f running_tag.txt<br>    fi<br>    rm -f running_tag.txt<br>    echo “Stop [OK].”<br>    ;;<br>*)<br>    help<br>    exit 1<br>    ;;<br>esac</p><pre><code></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;读取文件每一行&quot;&gt;&lt;a href=&quot;#读取文件每一行&quot; class=&quot;headerlink&quot; title=&quot;读取文件每一行&quot;&gt;&lt;/a&gt;读取文件每一行&lt;/h2&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=
      
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="脚本" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/%E8%84%9A%E6%9C%AC/"/>
    
    
      <category term="脚本" scheme="http://yoursite.com/tags/%E8%84%9A%E6%9C%AC/"/>
    
      <category term="Shell" scheme="http://yoursite.com/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>Python常用脚本整理</title>
    <link href="http://yoursite.com/2020/03/20/Python%E5%B8%B8%E7%94%A8%E8%84%9A%E6%9C%AC%E6%95%B4%E7%90%86/"/>
    <id>http://yoursite.com/2020/03/20/Python常用脚本整理/</id>
    <published>2020-03-20T08:42:00.000Z</published>
    <updated>2020-03-20T09:53:45.234Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Log日志"><a href="#Log日志" class="headerlink" title="Log日志"></a>Log日志</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">标准日志配置</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> logging.handlers</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init_log</span><span class="params">(log_path, level=logging.INFO, when=<span class="string">"D"</span>, backup=<span class="number">7</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">             format=<span class="string">"%(levelname)s: %(asctime)s: %(filename)s:%(lineno)d %(message)s"</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">             datefmt=<span class="string">"%m-%d %H:%M:%S"</span>)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    init_log - initialize log module</span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">      log_path      - Log file path prefix.</span></span><br><span class="line"><span class="string">                      Log data will go to two files: log_path.log and log_path.log.wf</span></span><br><span class="line"><span class="string">                      Any non-exist parent directories will be created automatically</span></span><br><span class="line"><span class="string">      level         - msg above the level will be displayed</span></span><br><span class="line"><span class="string">                      DEBUG &lt; INFO &lt; WARNING &lt; ERROR &lt; CRITICAL</span></span><br><span class="line"><span class="string">                      the default value is logging.INFO</span></span><br><span class="line"><span class="string">      when          - how to split the log file by time interval</span></span><br><span class="line"><span class="string">                      'S' : Seconds</span></span><br><span class="line"><span class="string">                      'M' : Minutes</span></span><br><span class="line"><span class="string">                      'H' : Hours</span></span><br><span class="line"><span class="string">                      'D' : Days</span></span><br><span class="line"><span class="string">                      'W' : Week day</span></span><br><span class="line"><span class="string">                      default value: 'D'</span></span><br><span class="line"><span class="string">      format        - format of the log</span></span><br><span class="line"><span class="string">                      default format:</span></span><br><span class="line"><span class="string">                      %(levelname)s: %(asctime)s: %(filename)s:%(lineno)d * %(thread)d %(message)s</span></span><br><span class="line"><span class="string">                      INFO: 12-09 18:02:42: log.py:40 * 139814749787872 HELLO WORLD</span></span><br><span class="line"><span class="string">      backup        - how many backup file to keep</span></span><br><span class="line"><span class="string">                      default value: 7</span></span><br><span class="line"><span class="string">    Raises:</span></span><br><span class="line"><span class="string">        OSError: fail to create log directories</span></span><br><span class="line"><span class="string">        IOError: fail to open log file</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    formatter = logging.Formatter(format, datefmt)</span><br><span class="line">    logger = logging.getLogger()</span><br><span class="line">    logger.setLevel(level)</span><br><span class="line">    dir = os.path.dirname(log_path)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.isdir(dir):</span><br><span class="line">        os.makedirs(dir)</span><br><span class="line">    handler = logging.handlers.TimedRotatingFileHandler(log_path + <span class="string">".log"</span>,</span><br><span class="line">                                                        when=when,</span><br><span class="line">                                                        backupCount=backup)</span><br><span class="line">    handler.setLevel(level)</span><br><span class="line">    handler.setFormatter(formatter)</span><br><span class="line">    logger.addHandler(handler)</span><br><span class="line">    handler = logging.handlers.TimedRotatingFileHandler(log_path + <span class="string">".log.wf"</span>,</span><br><span class="line">                                                        when=when,</span><br><span class="line">                                                        backupCount=backup)</span><br><span class="line">    handler.setLevel(logging.WARNING)</span><br><span class="line">    handler.setFormatter(formatter)</span><br><span class="line">    logger.addHandler(handler)</span><br></pre></td></tr></table></figure><p>日志初始化样例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> log</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">初始化日志配置</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">cur_time = os.popen(<span class="string">"date +%Y%m%d"</span>).read().strip()</span><br><span class="line">log_path = <span class="string">"./log/sample"</span> + cur_time</span><br><span class="line">log.init_log(log_path)</span><br></pre></td></tr></table></figure><h2 id="Http请求"><a href="#Http请求" class="headerlink" title="Http请求"></a>Http请求</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> urllib2</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">reload(sys)</span><br><span class="line">sys.setdefaultencoding(<span class="string">'utf8'</span>)</span><br><span class="line"><span class="keyword">import</span> __init__</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line">TIME_OUT = <span class="number">60</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getHeader</span><span class="params">(request, headers)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    组装header</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> headers:</span><br><span class="line">        request.add_header(k, headers[k.strip()])</span><br><span class="line">    <span class="keyword">return</span> request</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(url, headers=&#123;&#125;)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    headers : &#123; 'User-Agent' : user_agent &#125;  字典</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        request = urllib2.Request(url)</span><br><span class="line">        request = getHeader(request, headers)</span><br><span class="line">        response = urllib2.urlopen(request, timeout=TIME_OUT)</span><br><span class="line">        result = response.read().encode(<span class="string">'utf-8'</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">except</span> Exception, e:</span><br><span class="line">        logging.error(str(e))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(url, headers, body)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    headers : &#123; 'User-Agent' : user_agent &#125;  字典</span></span><br><span class="line"><span class="string">    body : String 通过header中的Content-Type来表示解析类型</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        request = urllib2.Request(url)</span><br><span class="line">        request = getHeader(request, headers)</span><br><span class="line">        request.get_method = <span class="keyword">lambda</span>: <span class="string">'POST'</span></span><br><span class="line">        <span class="keyword">if</span> body <span class="keyword">and</span> body != <span class="string">"&#123;&#125;"</span>:</span><br><span class="line">            request.add_data(body)</span><br><span class="line">        response = urllib2.urlopen(request, timeout=TIME_OUT)</span><br><span class="line">        result = response.read().encode(<span class="string">'utf-8'</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        logging.error(str(e))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(url, headers)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    headers : &#123; 'User-Agent' : user_agent &#125;  字典</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        request = urllib2.Request(url)</span><br><span class="line">        request = getHeader(request, headers)</span><br><span class="line">        request.get_method = <span class="keyword">lambda</span>: <span class="string">'DELETE'</span></span><br><span class="line">        response = urllib2.urlopen(request, timeout=TIME_OUT)</span><br><span class="line">        result = response.read().encode(<span class="string">'utf-8'</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">except</span> Exception, e:</span><br><span class="line">        logging.error(str(e))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><h2 id="Mysql连接"><a href="#Mysql连接" class="headerlink" title="Mysql连接"></a>Mysql连接</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> MySQLdb</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exe_sql</span><span class="params">(sql, type=<span class="number">0</span>)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    返回结果为元组格式</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        conn = MySQLdb.connect(host, user, passwd, db, port)</span><br><span class="line">        cur = conn.cursor()</span><br><span class="line">        cur.execute(sql)</span><br><span class="line">        results = cur.fetchall()</span><br><span class="line">        conn.commit()</span><br><span class="line">        cur.close()</span><br><span class="line">        conn.close()</span><br><span class="line">        <span class="keyword">return</span> results</span><br><span class="line">    <span class="keyword">except</span> MySQLdb.Error, e:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Mysql Error %d: %s"</span> % (e.args[<span class="number">0</span>], e.args[<span class="number">1</span>])</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exe_sql_return_dict</span><span class="params">(sql, type=<span class="number">0</span>)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    返回结果为字典格式</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        conn = MySQLdb.connect(host, user, passwd, db, port)</span><br><span class="line">        cur = conn.cursor(MySQLdb.cursors.DictCursor)</span><br><span class="line">        cur.execute(sql)</span><br><span class="line">        results = cur.fetchall()</span><br><span class="line">        conn.commit()</span><br><span class="line">        cur.close()</span><br><span class="line">        conn.close()</span><br><span class="line">        <span class="keyword">return</span> results</span><br><span class="line">    <span class="keyword">except</span> MySQLdb.Error, e:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Mysql Error %d: %s"</span> % (e.args[<span class="number">0</span>], e.args[<span class="number">1</span>])</span><br></pre></td></tr></table></figure><h2 id="Main函数"><a href="#Main函数" class="headerlink" title="Main函数"></a>Main函数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys </span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line">reload(sys)</span><br><span class="line">sys.setdefaultencoding(<span class="string">'utf8'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> sys.stdin:</span><br><span class="line">        <span class="keyword">print</span> line.strip()</span><br></pre></td></tr></table></figure><h2 id="Write文件"><a href="#Write文件" class="headerlink" title="Write文件"></a>Write文件</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_to_file</span><span class="params">(filepath, content, mode=<span class="string">"a+"</span>)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    写入文件</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">with</span> open(filepath, mode) <span class="keyword">as</span> fw:</span><br><span class="line">        <span class="comment"># fw.write(content + "\n")</span></span><br><span class="line">        fw.write(content)</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_pretty</span><span class="params">(filepath, content)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    写带缩进json内容到文件</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">with</span> open(filepath, <span class="string">'at'</span>) <span class="keyword">as</span> fw:</span><br><span class="line">        res = json.dump(content, fw, sort_keys=<span class="literal">True</span>, indent=<span class="number">4</span>, separators=(<span class="string">','</span>, <span class="string">': '</span>))</span><br></pre></td></tr></table></figure><h2 id="Read配置"><a href="#Read配置" class="headerlink" title="Read配置"></a>Read配置</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">读取配置文件</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span> ConfigParser</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> log</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parser</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    读取配置文件</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, configfile)</span>:</span></span><br><span class="line">        self.cf  = ConfigParser.ConfigParser()</span><br><span class="line">        self.cf.read(configfile)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_all_sections</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        获取所有的section</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        secs = self.cf.sections()</span><br><span class="line">        <span class="keyword">return</span> secs</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">list_options</span><span class="params">(self, section)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        获取某个section中所有的key</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        opts = self.cf.options(section)</span><br><span class="line">        <span class="keyword">return</span> opts</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_key</span><span class="params">(self, section, key)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        根据section和key获取value</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            value = self.cf.get(section, key)</span><br><span class="line">            <span class="keyword">if</span> value:</span><br><span class="line">                <span class="keyword">return</span> value</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            logging.error(key + <span class="string">" in "</span> + section + <span class="string">" does't exist!"</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    conf = Parser(<span class="string">"host.conf"</span>)</span><br><span class="line">    <span class="keyword">for</span> section <span class="keyword">in</span> conf.get_all_sections():</span><br><span class="line">        <span class="keyword">print</span> section</span><br><span class="line">        keys = conf.list_options(section)</span><br><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> keys:</span><br><span class="line">            <span class="keyword">print</span> key + <span class="string">' : '</span> + conf.get_key(section, key)</span><br></pre></td></tr></table></figure><p>host.conf内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[CHINA]</span><br><span class="line">provice=Beijing</span><br><span class="line">city=Beijing</span><br><span class="line">district=Haidian</span><br><span class="line"></span><br><span class="line">[USA]</span><br><span class="line">provice=State of New York</span><br><span class="line">city=NewYork</span><br><span class="line">district=B13</span><br></pre></td></tr></table></figure><p>脚本输出内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CHINA</span><br><span class="line">provice : Beijing</span><br><span class="line">city : Beijing</span><br><span class="line">district : Haidian</span><br><span class="line">USA</span><br><span class="line">provice : State of New York</span><br><span class="line">city : NewYork</span><br><span class="line">district : B13</span><br></pre></td></tr></table></figure><h2 id="Http服务"><a href="#Http服务" class="headerlink" title="Http服务"></a>Http服务</h2><h3 id="SimpleHttpServer"><a href="#SimpleHttpServer" class="headerlink" title="SimpleHttpServer"></a>SimpleHttpServer</h3><p>一键启动一个http服务，可以快速满足文件下载等需求。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m SimpleHTTPServer [端口号]</span><br></pre></td></tr></table></figure><h3 id="Flask"><a href="#Flask" class="headerlink" title="Flask"></a>Flask</h3><p>flask是python提供的一个便捷http服务框架，简单高效。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> flask</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> make_response,render_template,Response</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    stamp = str(int(time.time()))</span><br><span class="line">    <span class="keyword">print</span> stamp</span><br><span class="line">    token = hashlib.md5((<span class="string">"bigdata-meta"</span> + stamp + <span class="string">"z2spmoowoeao2bzvqs796a8t08tszso0"</span>).encode(<span class="string">'utf8'</span>)).hexdigest()</span><br><span class="line">    result = <span class="string">"timestamp: %s &lt;br/&gt;&lt;br/&gt; token: %s"</span> % (stamp, token)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">    </span><br><span class="line"><span class="meta">@app.route('/callback')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"callback"</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    app.run(host=<span class="string">'0.0.0.0'</span>, debug=<span class="literal">True</span>, port=<span class="number">8343</span>)</span><br></pre></td></tr></table></figure><h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">对util模块进行测试</span></span><br><span class="line"><span class="string">Authors: austin</span></span><br><span class="line"><span class="string">Date:    16/7/12 17:24.</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys </span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> util</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UtilTestCase</span><span class="params">(unittest.TestCase)</span>:</span></span><br><span class="line">    <span class="string">""" </span></span><br><span class="line"><span class="string">    测试类</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setUp</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        初始化</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.cs_list = [<span class="string">'3182242396,2726385067,72'</span>,<span class="string">'4030018123,3852097821,72'</span>]</span><br><span class="line">        self.expect_url_list = [<span class="string">'http://t10.baidu.com/it/u=3182242396,2726385067&amp;fm=72'</span>,</span><br><span class="line">                                <span class="string">'http://t10.baidu.com/it/u=4030018123,3852097821&amp;fm=72'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_get_cs_url</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">""" </span></span><br><span class="line"><span class="string">        测试生成url函数正确性</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        ret = map(util.get_cs_url, self.cs_list)</span><br><span class="line">        self.assertEqual(ret, self.expect_url_list)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    unittest.main()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Log日志&quot;&gt;&lt;a href=&quot;#Log日志&quot; class=&quot;headerlink&quot; title=&quot;Log日志&quot;&gt;&lt;/a&gt;Log日志&lt;/h2&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter
      
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="脚本" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/%E8%84%9A%E6%9C%AC/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="脚本" scheme="http://yoursite.com/tags/%E8%84%9A%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>Java常见面试题总结</title>
    <link href="http://yoursite.com/2020/03/06/Java%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2020/03/06/Java常见面试题总结/</id>
    <published>2020-03-06T08:11:42.000Z</published>
    <updated>2020-03-20T09:45:14.936Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JAVA基础"><a href="#JAVA基础" class="headerlink" title="JAVA基础"></a>JAVA基础</h2><h3 id="Java的collection接口继承关系"><a href="#Java的collection接口继承关系" class="headerlink" title="Java的collection接口继承关系"></a>Java的collection<t>接口继承关系</t></h3><p><img src="/images/collection_inherit.png" alt></p><p><img src="/images/collection_inherit2.png" alt></p><p><img src="/images/colletion_inherit3.jpg" alt></p><h3 id="jdk1-7-用的是哪种垃圾回收机制-1-8用的是啥"><a href="#jdk1-7-用的是哪种垃圾回收机制-1-8用的是啥" class="headerlink" title="jdk1.7 用的是哪种垃圾回收机制  1.8用的是啥"></a>jdk1.7 用的是哪种垃圾回收机制  1.8用的是啥</h3><p>jdk1.6 用的是 UseParallelGC， ParallelGCThreads=4<br>jdk1.8</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> java -XX:+PrintCommandLineFlags -version</span><br><span class="line">-XX:InitialHeapSize=134217728 </span><br><span class="line">-XX:MaxHeapSize=2147483648 </span><br><span class="line">-XX:+PrintCommandLineFlags </span><br><span class="line">-XX:+UseCompressedClassPointers </span><br><span class="line">-XX:+UseCompressedOops </span><br><span class="line">-XX:+UseParallelGC</span><br><span class="line">java version "1.8.0_181"</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_181-b13)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.181-b13, mixed mode)</span><br></pre></td></tr></table></figure><p>UseParallelGC 即 <code>Parallel Scavenge + Serial Old</code>, 再查看详细信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+PrintGCDetails -version</span><br><span class="line">java version "1.8.0_181"</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_181-b13)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.181-b13, mixed mode)</span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 38400K, used 1331K [0x0000000795580000, 0x0000000798000000, 0x00000007c0000000)</span><br><span class="line">  eden space 33280K, 4% used [0x0000000795580000,0x00000007956cce48,0x0000000797600000)</span><br><span class="line">  from space 5120K, 0% used [0x0000000797b00000,0x0000000797b00000,0x0000000798000000)</span><br><span class="line">  to   space 5120K, 0% used [0x0000000797600000,0x0000000797600000,0x0000000797b00000)</span><br><span class="line"> ParOldGen       total 87552K, used 0K [0x0000000740000000, 0x0000000745580000, 0x0000000795580000)</span><br><span class="line">  object space 87552K, 0% used [0x0000000740000000,0x0000000740000000,0x0000000745580000)</span><br><span class="line"> Metaspace       used 2233K, capacity 4480K, committed 4480K, reserved 1056768K</span><br><span class="line">  class space    used 243K, capacity 384K, committed 384K, reserved 1048576K</span><br></pre></td></tr></table></figure><h3 id="List和Array的区别，添加和删除元素的时间复杂度怎样"><a href="#List和Array的区别，添加和删除元素的时间复杂度怎样" class="headerlink" title="List和Array的区别，添加和删除元素的时间复杂度怎样"></a>List和Array的区别，添加和删除元素的时间复杂度怎样</h3><p>1) 因为Array是基于索引(index)的数据结构，它使用索引在数组中搜索和读取数据是很快的。Array获取数据的时间复杂度是O(1),但是要删除数据却是开销很大的，因为这需要重排数组中的所有数据。</p><p>2) 相对于ArrayList，LinkedList插入是更快的。因为LinkedList不像ArrayList一样，不需要改变数组的大小，也不需要在数组装满的时候要将所有的数据重新装入一个新的数组，这是ArrayList最坏的一种情况，时间复杂度是O(n)，而LinkedList中插入或删除的时间复杂度仅为O(1)。ArrayList在插入数据时还需要更新索引（除了插入数组的尾部）。</p><p>3) 类似于插入数据，删除数据时，LinkedList也优于ArrayList。</p><p>4) LinkedList需要更多的内存，因为ArrayList的每个索引的位置是实际的数据，而LinkedList中的每个节点中存储的是实际的数据和前后节点的位置。</p><p>5） Array和List都属于顺序表。Array、ArrayList是一段连续的存储结构</p><h3 id="红黑树添加元素和获取元素的时间复杂度"><a href="#红黑树添加元素和获取元素的时间复杂度" class="headerlink" title="红黑树添加元素和获取元素的时间复杂度"></a>红黑树添加元素和获取元素的时间复杂度</h3><p>插入一个元素到红黑树的时间为 <em>O(log(N))*，其中 *N</em> 为当前红黑树的元素个数，因此，采用插入方式构建元素个数为N的红黑树的时间复杂度为:</p><p><code>log(1) + log(2) + log(N-1) = log((N-1)!) = Nlog(N)</code></p><p>那么采用<code>迭代器</code>遍历一棵红黑树的时间复杂度是多少呢？ 是 <em>O(N)</em> 。 也就是说非递归遍历一棵红黑树的时间复杂度和遍历数组的时间复杂度是一样的</p><p>原文链接：<a href="https://blog.csdn.net/gongyiling3468/article/details/47804223" target="_blank" rel="noopener">https://blog.csdn.net/gongyiling3468/article/details/47804223</a></p><h3 id="CMS垃圾收集器"><a href="#CMS垃圾收集器" class="headerlink" title="CMS垃圾收集器"></a>CMS垃圾收集器</h3><p><img src="/images/java_gc_cms-collec.jpg" alt></p><p><img src="/images/java_cms_advantage.jpg" alt></p><p><img src="/images/java_cms_parameter.jpg" alt></p><h3 id="线程池原理，增长策略，拒绝策略哪几种，四种线程池分别有什么优缺点，有什么坑，线程池使用该怎么选择"><a href="#线程池原理，增长策略，拒绝策略哪几种，四种线程池分别有什么优缺点，有什么坑，线程池使用该怎么选择" class="headerlink" title="线程池原理，增长策略，拒绝策略哪几种，四种线程池分别有什么优缺点，有什么坑，线程池使用该怎么选择"></a>线程池原理，增长策略，拒绝策略哪几种，四种线程池分别有什么优缺点，有什么坑，线程池使用该怎么选择</h3><ul><li><p>线程池原理：<br>复用Thead线程，减少创建和回收的CPU、内存资源消耗，过多任务加入等待队列或拒绝</p></li><li><p>增长策略：<br>当前线程数 &lt; 核心线程 : 直接开启新线程执行任务<br>当前线程数 &gt; 核心线程 : 加入等待队列<br>队列已满&amp; 当前线程数 &lt; 最大线程 : 开启新线程<br>队列已满&amp; 当前线程数 &gt; 最大线程 : 执行拒绝策略</p></li><li><p>拒绝策略</p><ol><li><p>CallerRunsPolicy：  只要线程池没有被关闭，那么由提交任务的线程自己来执行这个任务</p></li><li><p>AbortPolicy：不管怎样，直接抛出 RejectedExecutionException 异常， 这个是默认的策略， 如果我们构造线程池的时候不传相应的 handler 的话，那就会指定使用这个</p></li><li><p>DiscardPolicy：不做任何处理，直接忽略掉这个任务</p></li><li><p>DiscardOldestPolicy： 这个相对霸道一点，如果线程池没有被关闭的话， 把队列队头的任务(也就是等待了最长时间的)直接扔掉，然后提交这个任务到等待队列中</p></li></ol></li><li><p>线程池对比</p><ul><li><p>FixedThreadPool是一个典型且优秀的线程池，它具有线程池提高程序效率和节省创建线程时所耗的开销的优点。但在线程池空闲时，即线程池中没有可运行任务时，它不会释放工作线程，还会占用一定的系统资源。</p></li><li><p>CachedThreadPool的特点就是在线程池空闲时，即线程池中没有可运行任务时，它会释放工作线程，从而释放工作线程所占用的资源。但是，但当出现新任务时，又要创建一新的工作线程，又要一定的系统开销。并且，在使用CachedThreadPool时，一定要注意控制任务的数量，否则，由于大量线程同时运行，很有会造成系统瘫痪</p></li></ul></li></ul><h3 id="锁粗化、锁消除"><a href="#锁粗化、锁消除" class="headerlink" title="锁粗化、锁消除"></a>锁粗化、锁消除</h3><ul><li><p>锁粗化(程序员控制)<br>通常情况下，为了保证多线程间的有效并发，会要求每个线程持有锁的时间尽可能短，但是大某些情况下，一个程序对同一个锁不间断、高频地请求、同步与释放，会消耗掉一定的系统资源，因为锁的轻求、同步与释放本身会带来性能损耗，这样高频的锁请求就反而不利于系统性能的优化了，虽然单次同步操作的时间可能很短。</p><p>  锁粗化就是告诉我们任何事情都有个度，有些情况下我们反而希望把很多次锁的请求合并成一个请求，以降低短时间内大量锁请求、同步、释放带来的性能损耗。</p></li></ul><p>一种极端的情况如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomethingMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">        <span class="comment">//do some thing</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这是还有一些代码，做其它不需要同步的工作，但能很快执行完毕</span></span><br><span class="line">    <span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">        <span class="comment">//do other thing</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码是有两块需要同步操作的，但在这两块需要同步操作的代码之间，需要做一些其它的工作，而这些工作只会花费很少的时间，那么我们就可以把这些工作代码放入锁内，将两个同步代码块合并成一个，以降低多次锁请求、同步、释放带来的系统性能消耗，合并后的代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomethingMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//进行锁粗化：整合成一次锁请求、同步、释放</span></span><br><span class="line">    <span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">        <span class="comment">//do some thing</span></span><br><span class="line">        <span class="comment">//做其它不需要同步但能很快执行完的工作</span></span><br><span class="line">        <span class="comment">//do other thing</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：这样做是有前提的，就是中间不需要同步的代码能够很快速地完成，如果不需要同步的代码需要花很长时间，就会导致同步块的执行需要花费很长的时间，这样做也就不合理了。</p></blockquote><ul><li>锁消除<br>锁消除是<strong>发生在编译器级别</strong>的一种锁优化方式。有时候我们写的代码完全不需要加锁，却执行了加锁操作。虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行削除。<br>锁削除的主要判定依据来源于<strong>逃逸分析</strong>的数据支持，如果判断到一段代码中，在堆上的所有数据都不会逃逸出去被其他线程访问到，那就可以把它们当作栈上数据对待，认为它们是线程私有的，同步加锁自然就无须进行。 </li></ul><p>锁消除前提是java必须运行在<strong>server模式</strong>（server模式会比client模式作更多的优化），同时<strong>必须开启逃逸分析</strong>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-server -XX:+DoEscapeAnalysis -XX:+EliminateLocks</span><br></pre></td></tr></table></figure><p>其中<code>+DoEscapeAnalysis</code>表示开启逃逸分析，<code>+EliminateLocks</code>表示锁消除。</p><h3 id="异步thrift原理"><a href="#异步thrift原理" class="headerlink" title="异步thrift原理"></a>异步thrift原理</h3><p>服务方起草接口标准，负责实现，RPC框架生成服务端和客户端代理，服务端代理自启动，客户端代理绑定调用方，调用方按照接口标准，调用客户端代理，等价于RPC远程调用服务方实现</p><p><img src="/images/thrify_async.jpg" alt></p><p>定义一个Thrift Service</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. IDL编写的接口</span></span><br><span class="line">service AddService &#123;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="number">1</span>:<span class="keyword">int</span> n1, <span class="number">2</span>:<span class="keyword">int</span> n2)</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p>Thrift Service方法会提供两种类型的实现：</p><ul><li><p>Iface</p></li><li><p>AsyncIface</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2. thrift.exe生成接口的客户端代理 - 异步实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddService</span></span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> n1, <span class="keyword">int</span> n2, AsyncMethodCallback callback)</span> </span>&#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3. 接口的服务端实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddServiceImpl</span> <span class="keyword">implements</span> <span class="title">AddService</span>.<span class="title">Iface</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> n1, <span class="keyword">int</span> n2)</span> </span></span><br><span class="line"><span class="function">   return n1 + n2</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//4. 服务端监听</span></span><br><span class="line">TNonblockingServerSocket socket = <span class="keyword">new</span> TNonblockingServerSocket(<span class="number">9090</span>);</span><br><span class="line">TServer server = <span class="keyword">new</span> TNonblockingServer(socket, AddServiceImpl);</span><br><span class="line">server.start();</span><br></pre></td></tr></table></figure><p>外部的调用过程就是，先获得一个CallBack，然后调用start方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//5. 客户端请求</span></span><br><span class="line">TNonblockingTransport socket = <span class="keyword">new</span> TNonblockingSocket(<span class="string">"localhost"</span>, <span class="number">9090</span>);</span><br><span class="line">AddService.AsyncClient client = <span class="keyword">new</span> AddService.AsyncClient(socket);</span><br><span class="line">client.add(<span class="number">1</span>,<span class="number">2</span>,<span class="keyword">new</span> AsynCallback(<span class="keyword">this</span>)&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">onError</span><span class="params">(Exception exception)</span> </span>&#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>异步使用原则</strong><br>如果使用了AsynIface实现Service，需要注意几点：</p><ul><li><p>不能直接在方法内处理req，req需要和handler（callback）封装交给另外的线程进行处理（暂且把这些线程叫做worker线程）</p></li><li><p>worker线程只做计算逻辑，也就是根据req的要求进行操作，在操作req结束以后获得的resp或者error，不能直接调用handler（callback）的方法（因为callback中的方法是一个网络IO的操作，有可能会block当前线程，如果网络IO操作是一个异步操作的话就不会block当前线程）</p></li></ul><h3 id="讲几个jvm优化的案例"><a href="#讲几个jvm优化的案例" class="headerlink" title="讲几个jvm优化的案例"></a>讲几个jvm优化的案例</h3><h3 id="堆外内存泄漏怎么排查"><a href="#堆外内存泄漏怎么排查" class="headerlink" title="堆外内存泄漏怎么排查"></a>堆外内存泄漏怎么排查</h3><ul><li><p>异常堆栈<br><img src="/images/heap_out_exception.jpg" alt></p></li><li><p>top信息<br><img src="/images/heap_exception_top_info.jpg" alt></p></li></ul><p>一定时间过后，java 进程内存增长到接近 90%，服务器报警。此时 old 区内存在 50%左右，由于未达到 CMS GC 的阈值，因此不会触发 CMS GC，而导致服务器内存溢出崩溃。</p><ul><li><p>堆外内存计算方式</p><ul><li><p>广义堆外内存为：进程内存 - (Young 区占用 + Old 区占用)，可通过直接内存大小参数: <code>-神器:MaxDirectMemorySize</code> 设置, JVM申请直接内存时，会判断是否超过可申请的直接内存阈值，如果超过则会调用 <code>System.gc()</code> 触发GC，如果 GC 后内存还是不足，则抛出 <code>OutOfMemoryError</code> 异常</p></li><li><p>狭义堆外内存为：<code>java.nio.DirectByteBuffer</code> 创建的时候分配的内存</p></li></ul></li><li><p>查看堆内存命令</p><blockquote><p>jstat -gc <pid> 1000 : 每秒输出堆内存实际大小信息<br>jstat -gcutil <pid> 1000 : 每秒输出堆内存百分比信息</pid></pid></p></blockquote></li><li><p>jvisual VM可视化监控内存实时情况， 通过dump文件可以找到对象的引用根节点。</p></li><li><p>jmeter压测；</p></li><li><p>为了分析堆外内存到底是谁占用了，不得不安装<code>google-perftools</code>工具进行分析，它的原理是在java应用程序运行时，当调用 <code>malloc</code> 时换用它的<code>libtcmalloc.so</code>，这样就能做一些统计了</p></li></ul><p>原文链接：<a href="https://blog.csdn.net/u012099869/article/details/82757999" target="_blank" rel="noopener">https://blog.csdn.net/u012099869/article/details/82757999</a></p><h3 id="Tomcat响应web请求的过程"><a href="#Tomcat响应web请求的过程" class="headerlink" title="Tomcat响应web请求的过程"></a>Tomcat响应web请求的过程</h3><blockquote><p>Service -&gt; Connector(Socket) -&gt; Container (HttpServletRequest) -&gt; Engine -&gt; Host -&gt; Context -&gt; WrapServlet</p></blockquote><p>Pipeline-Valve-责任链模式</p><ul><li>StandardEnginePipeValve</li><li>StandardHostPipeValve</li><li>StandardContextPipeValve</li><li>StandardWraperPipeValve</li></ul><h3 id="CopyOnWriteArrayList、CopyOnWriteArraySet"><a href="#CopyOnWriteArrayList、CopyOnWriteArraySet" class="headerlink" title="CopyOnWriteArrayList、CopyOnWriteArraySet"></a>CopyOnWriteArrayList、CopyOnWriteArraySet</h3><p>CopyOnWriteArrayList原理：</p><blockquote><p>在写的时候不对原集合进行修改，而是重新复制一份，修改完之后，再移动指针</p></blockquote><p><strong>CopyOnWriteArrayList add()方法</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Appends the specified element to the end of this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e element to be appended to this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;<span class="comment">//重入锁</span></span><br><span class="line">    lock.lock();<span class="comment">//加锁啦</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);<span class="comment">//拷贝新数组</span></span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        setArray(newElements);<span class="comment">//将引用指向新数组  1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();<span class="comment">//解锁啦</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>add()</code>在添加集合的时候加上了锁，保证了同步，避免了多线程写的时候会Copy出N个副本出来.</p><p>有这么一种情况，当一个线程刚好调用完<code>add()</code>方法，也就是刚好执行到上面1处的代码，也就是刚好将引用指向新数组，而此时有线程正在遍历呢？会不会报错呢？<br>答案是不会的，因为你<strong>正在遍历的集合是旧的</strong>。</p><p><strong>优缺点</strong></p><ul><li><p>缺点：</p><ul><li>1、耗内存（集合复制）</li><li>2、实时性不高</li></ul></li><li><p>优点：</p><ul><li>1、数据一致性完整，为什么？因为加锁了，并发数据不会乱</li><li>2、解决了像ArrayList、Vector这种集合多线程遍历迭代问题，记住，Vector虽然线程安全，只不过是加了synchronized关键字，迭代问题完全没有解决！</li></ul></li></ul><p><strong>使用场景</strong></p><ul><li>读多写少（白名单，黑名单，商品类目的访问和更新场景），为什么？因为写的时候会复制新集合</li><li>集合不大，为什么？因为写的时候会复制新集合</li><li>实时性要求不高，为什么，因为有可能会读取到旧的集合数据</li></ul><h3 id="项目中使用延迟队列的场景，延迟队列是如何实现的"><a href="#项目中使用延迟队列的场景，延迟队列是如何实现的" class="headerlink" title="项目中使用延迟队列的场景，延迟队列是如何实现的"></a>项目中使用延迟队列的场景，延迟队列是如何实现的</h3><ul><li>DelayQueue基本原理<br>DelayQueue是一个<strong>没有边界BlockingQueue实现</strong>，加入其中的元素<strong>必需实现Delayed接口</strong>。当生产者线程调用put之类的方法加入元素时，会触发Delayed接口中的compareTo方法进行排序，也就是说队列中元素的顺序是按到期时间排序的，而非它们进入队列的顺序。排在队列头部的元素是最早到期的，越往后到期时间赿晚。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 消息体定义 实现Delayed接口就是实现两个方法即compareTo 和 getDelay</span></span><br><span class="line"><span class="comment"> * 最重要的就是getDelay方法，这个方法用来判断是否到期</span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"> <span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span> <span class="keyword">implements</span> <span class="title">Delayed</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;  </span><br><span class="line">    <span class="keyword">private</span> String body; <span class="comment">// 消息内容  </span></span><br><span class="line">    <span class="comment">// 延迟时长，这个是必须的属性因为要按照这个判断延时时长。  </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> excuteTime;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Message</span><span class="params">(<span class="keyword">int</span> id, String body, <span class="keyword">long</span> delayTime)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.id = id;  </span><br><span class="line">        <span class="keyword">this</span>.body = body;  </span><br><span class="line">        <span class="keyword">this</span>.excuteTime = TimeUnit.NANOSECONDS.convert(delayTime, </span><br><span class="line">            TimeUnit.MILLISECONDS) + System.nanoTime();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 自定义实现比较方法返回 1 0 -1三个参数  </span></span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Delayed delayed)</span> </span>&#123;  </span><br><span class="line">        Message msg = (Message) delayed;  </span><br><span class="line">        <span class="keyword">return</span> Integer.valueOf(<span class="keyword">this</span>.id) &gt; Integer.valueOf(msg.id) ? <span class="number">1</span>  </span><br><span class="line">                : (Integer.valueOf(<span class="keyword">this</span>.id) &lt; Integer.valueOf(msg.id) ? -<span class="number">1</span> : <span class="number">0</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 延迟任务是否到时就是按照这个方法判断如果返回的是负数则说明到期否则还没到期  </span></span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit unit)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> unit.convert(<span class="keyword">this</span>.excuteTime - System.nanoTime(), TimeUnit.NANOSECONDS);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费者线程查看队列头部的元素，注意是查看不是取出。然后调用元素的getDelay方法，如果此方法返回的值小０或者等于０，则消费者线程会从队列中取出此元素，并进行处理。如果getDelay方法返回的值大于0，则消费者线程wait返回的时间值后，再从队列头部取出元素，此时元素应该已经到期。</p><p><img src="/images/delay_queue_header.jpg" alt></p><p>DelayQueue是<strong>Leader-Followr</strong>模式的变种，消费者线程处于等待状态时，总是等待最先到期的元素，而不是长时间的等待。消费者线程尽量把时间花在处理任务上，最小化空等的时间，以提高线程的利用效率。</p><p>消费者线程的<strong>数量要够，处理任务的速度要快</strong>。否则，队列中的到期元素无法被及时取出并处理，造成任务延期、队列元素堆积等情况。</p><ul><li><p>应用场景</p><ul><li><p>关闭空闲连接。服务器中，有很多客户端的连接，空闲一段时间之后需要关闭之。</p></li><li><p>清理过期数据业务上。比如缓存中的对象，超过了空闲时间，需要从缓存中移出。</p></li><li><p>任务超时处理。在网络协议滑动窗口请求应答式交互时，处理超时未响应的请求。</p></li><li><p>下单之后如果三十分钟之内没有付款就自动取消订单。</p></li><li><p>订餐通知:下单成功后60s之后给用户发送短信通知。</p></li><li><p>当订单一直处于未支付状态时，如何及时的关闭订单，并退还库存</p></li><li><p>如何定期检查处于退款状态的订单是否已经退款成功</p></li><li><p>新创建店铺，N天内没有上传商品，系统如何知道该信息，并发送激活短信</p></li><li><p>定时任务调度：使用DelayQueue保存当天将会执行的任务和执行时间，一旦从DelayQueue中获取到任务就开始执行。</p></li></ul></li></ul><p>参考链接：<br><a href="https://juejin.im/post/5b5e52ecf265da0f716c3203" target="_blank" rel="noopener">https://juejin.im/post/5b5e52ecf265da0f716c3203</a><br><a href="https://blog.csdn.net/dkfajsldfsdfsd/article/details/88966814" target="_blank" rel="noopener">https://blog.csdn.net/dkfajsldfsdfsd/article/details/88966814</a></p><h3 id="内存溢出的排除、定位，虚拟机参数；"><a href="#内存溢出的排除、定位，虚拟机参数；" class="headerlink" title="内存溢出的排除、定位，虚拟机参数；"></a>内存溢出的排除、定位，虚拟机参数；</h3><p>查看堆占用情况：</p><ul><li>jmap 查看heap内存使用情况   </li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> jmap -heap 30124</span><br><span class="line">Attaching to process ID 30124, please wait...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is 25.152-b16</span><br><span class="line"></span><br><span class="line">using thread-local object allocation.</span><br><span class="line">Parallel GC with 4 thread(s)</span><br><span class="line"></span><br><span class="line">Heap Configuration:</span><br><span class="line">   MinHeapFreeRatio         = 0</span><br><span class="line">   MaxHeapFreeRatio         = 100</span><br><span class="line">   MaxHeapSize              = 4215275520 (4020.0MB)</span><br><span class="line">   NewSize                  = 88080384 (84.0MB)</span><br><span class="line">   MaxNewSize               = 1405091840 (1340.0MB)</span><br><span class="line">   OldSize                  = 176160768 (168.0MB)</span><br><span class="line">   NewRatio                 = 2</span><br><span class="line">   SurvivorRatio            = 8</span><br><span class="line">   MetaspaceSize            = 21807104 (20.796875MB)</span><br><span class="line">   CompressedClassSpaceSize = 1073741824 (1024.0MB)</span><br><span class="line">   MaxMetaspaceSize         = 17592186044415 MB</span><br><span class="line">   G1HeapRegionSize         = 0 (0.0MB)</span><br><span class="line"></span><br><span class="line">Heap Usage:</span><br><span class="line">PS Young Generation</span><br><span class="line">Eden Space:</span><br><span class="line">   capacity = 490733568 (468.0MB)</span><br><span class="line">   used     = 197747880 (188.58707427978516MB)</span><br><span class="line">   free     = 292985688 (279.41292572021484MB)</span><br><span class="line">   40.296383393116486% used</span><br><span class="line">From Space:</span><br><span class="line">   capacity = 12058624 (11.5MB)</span><br><span class="line">   used     = 8982888 (8.566749572753906MB)</span><br><span class="line">   free     = 3075736 (2.9332504272460938MB)</span><br><span class="line">   74.49347454568614% used</span><br><span class="line">To Space:</span><br><span class="line">   capacity = 30932992 (29.5MB)</span><br><span class="line">   used     = 0 (0.0MB)</span><br><span class="line">   free     = 30932992 (29.5MB)</span><br><span class="line">   0.0% used</span><br><span class="line">PS Old Generation</span><br><span class="line">   capacity = 275251200 (262.5MB)</span><br><span class="line">   used     = 53956432 (51.45686340332031MB)</span><br><span class="line">   free     = 221294768 (211.0431365966797MB)</span><br><span class="line">   19.60261462983631% used</span><br></pre></td></tr></table></figure><p>可以查看到<code>MetaspaceSize</code>, <code>CompressedClassSpaceSize</code>, <code>MaxMetaSize</code></p><p>jmap和jdk版本有关系，有些jdk版本会查看不到内存信息，可以使用jstat来查看统计信息</p><ul><li>jstat 收集统计信息</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 占用大小</span><br><span class="line"><span class="meta">$</span> jstat -gc 30124</span><br><span class="line"> S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT   </span><br><span class="line">29696.0 6656.0  0.0   6144.1 462848.0 95727.6   268800.0   52699.8   63320.0 61816.0 7552.0 7224.3     15    0.327   3      0.626    0.953</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 占用比例</span><br><span class="line"><span class="meta">$</span> jstat -gcutil 30124</span><br><span class="line">  S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT   </span><br><span class="line">  0.00  92.31  28.60  19.61  97.62  95.66     15    0.327     3    0.626    0.953</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-Xms 堆初始内存</span><br><span class="line">-Xmx 堆最大内存</span><br><span class="line">-XX:+UseG1GC/CMS 垃圾回收器</span><br><span class="line">-XX:+DisableEx神器icitGC 禁止显示GC</span><br><span class="line">-XX:MaxDirectM神器orySize 设置最大堆外内存，默认是:进程内存 - (Young 区占用 + Old 区占用)</span><br><span class="line">-Xss：每个线程的堆栈大小，默认1M</span><br><span class="line">-Xmn: 年轻代大小（eden区 + 2 * survivor）</span><br><span class="line">-XX:NewRatio=4 年轻代与老年代1:4</span><br><span class="line">-XX:survivorRa神器o=8 Eden区与survivor大小比值</span><br></pre></td></tr></table></figure><p> 具体步骤：</p><ul><li>jps找到进程id</li><li>jstat -gc -gcutil确认堆占用情况及是否频繁full gc</li><li>jmap -histo:live pid | head  找到最多的几个instance</li><li>jmap dump:live,format=b,file=head.hprof pid dump出存活的实例堆栈信息</li><li>jvisualvm载入dump文件，从类信息栏找到占用内存最大的类，点击查询实例详情，进一步找到引用对象</li></ul><h2 id="ZooKeeper"><a href="#ZooKeeper" class="headerlink" title="ZooKeeper"></a>ZooKeeper</h2><h3 id="zk选主的详细过程"><a href="#zk选主的详细过程" class="headerlink" title="zk选主的详细过程"></a>zk选主的详细过程</h3><p>在Zookeeper集群中，主要分为三者角色，而每一个节点同时只能扮演一种角色，这三种角色分别是：</p><ul><li><p><strong>Leader</strong><br>接受所有Follower的提案请求并统一协调发起提案的投票，负责与所有的Follower进行内部的数据交换(同步);</p></li><li><p><strong>Follower</strong><br>直接为客户端服务并参与提案的投票，同时与Leader进行数据交换(同步);</p></li><li><p><strong>Observer</strong><br>直接为客户端服务但并不参与提案的投票，同时也与Leader进行数据交换(同步); Observer的作用是为了拓展系统，提高读取速度。</p></li></ul><p><strong>Server工作过程中四种状态</strong></p><ul><li>LOOKING：竞选状态，当前Server不知道leader是谁，正在搜寻。</li><li>LEADING：领导者状态，表明当前服务器角色是leader。</li><li>FOLLOWING：随从状态，表明当前服务器角色是follower，同步leader状态，参与投票。</li><li>OBSERVING，观察状态，表明当前服务器角色是observer，同步leader状态，不参与投票。</li></ul><p><strong>选主机制</strong><br>Zookeeper的核心是<strong>原子广播</strong>，这个机制保证了各个Server之间的同步。实现这个机制的协议叫做<strong>Zab协议</strong>。</p><p>Zab协议有两种模式，它们分别是：  </p><ul><li>恢复模式（选主）</li><li>广播模式（同步</li></ul><p>当<strong>服务启动或者在领导者崩溃</strong>后，Zab就进入了恢复模式，当领导者被选举出来，且大多数Server完成了和leader的状态同步以后，恢复模式就结束了。</p><ul><li>状态同步保证了leader和Server具有相同的系统状态。</li><li>leader选举是保证分布式数据一致性的关键</li></ul><p>当zk集群中的一台服务器出现以下两种情况之一时，就会开始leader选举。  </p><ul><li>（1）服务器初始化启动。</li><li>（2）服务器运行期间无法和leader保持连接。</li></ul><p>而当一台机器进入leader选举流程时，当前集群也可能处于以下两种状态。</p><ul><li>（1）集群中本来就已经存在一个leader。</li><li>（2）集群中确实不存在leader。</li></ul><p>首先第一种情况，通常是集群中某一台机器启动比较晚，在它启动之前，集群已经正常工作，即已经存在一台leader服务器。当该机器试图去选举leader时，会被告知当前服务器的leader信息，它仅仅需要和leader机器建立连接，并进行状态同步即可。</p><p>下面重点看第二种情况，即集群中leader不存在的情况下如何进行leader选举。</p><p><strong>数据模型</strong><br>投票信息中包含两个最基本的信息。</p><ul><li><p><strong>sid</strong>: 即<strong>server id</strong>，用来标识该机器在集群中的机器序号；</p></li><li><p><strong>zxid</strong>: 即zookeeper<strong>事务id</strong>。ZooKeeper状态的每一次改变, 都对应着一个递增的Transaction id, 该id称为<strong>zxid</strong>. 由于zxid的递增性质, 如果zxid1小于zxid2, 那么zxid1肯定先于zxid2发生. 创建任意节点, 或者更新任意节点的数据, 或者删除任意节点, 都会导致Zookeeper状态发生改变, 从而导致zxid的值增加.</p></li><li><p><strong>electionEpoch</strong>：逻辑时钟，用来判断多个投票是否在同一轮选举周期中，该值在服务端是一个自增序列，每次进入新一轮的投票后，都会对该值进行加1操作;</p></li><li><p><strong>state</strong>：当前服务器的状态;</p></li></ul><p>以<code>（sid，zxid）</code>的形式来标识一次投票信息。例如，如果当前服务器要推举sid为1，zxid为8的服务器成为leader，那么投票信息可以表示为（1，8）</p><p><strong>规则</strong><br>集群中的每台机器发出自己的投票后，也会接受来自集群中其他机器的投票。每台机器都会根据一定的规则，来处理收到的其他机器的投票，以此来决定是否需要变更自己的投票。<br>规则如下：   </p><ul><li>（1）初始阶段，都会给自己投票。</li><li>（2）当接收到来自其他服务器的投票时，都需要将别人的投票和自己的投票进行pk，规则如下：<ul><li>优先检查zxid, zxid比较大的服务器优先作为leader;</li><li>如果zxid相同的话，就比较sid，sid比较大的服务器作为leader;</li></ul></li></ul><p><strong>总结：</strong></p><ul><li><p>首先判断该投票的有效性，如检查是否是本轮投票、是否来自LOOKING状态的服务器。如果发现该外部选票的选举轮次小于当前服务器的，那么忽略该外部投票，同时立即发送自己的内部投票。</p></li><li><p>第二轮根据第一轮比较结果再次向集群中所有机器发出上一次投票信息即可。</p></li><li><p>一旦确定了Leader，每个服务器就会更新自己的状态，如果是Follower，那么就变更为FOLLOWING，如果是Leader，就变更为LEADING</p></li><li><p>在3.4.0后的Zookeeper的版本只保留了TCP版本的FastLeaderElection选举算法</p></li><li><p>electionEpoch：逻辑时钟，用来判断多个投票是否在同一轮选举周期中，该值在服务端是一个自增序列，每次进入新一轮的投票后，都会对该值进行加1操作。</p></li></ul><p>链接：<a href="https://www.jianshu.com/p/75e48405d678" target="_blank" rel="noopener">https://www.jianshu.com/p/75e48405d678</a></p><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><h3 id="redispool线程池工作原理，JDK怎么实现"><a href="#redispool线程池工作原理，JDK怎么实现" class="headerlink" title="redispool线程池工作原理，JDK怎么实现"></a>redispool线程池工作原理，JDK怎么实现</h3><ul><li><p>复用socket连接，存储到LinkedBlockingDeque中</p></li><li><p>imeBetweenEvictionRunsMillis毫秒秒检查一次连接池中空闲的连接,把空闲时间超过minEvictableIdleTimeMillis毫秒的连接断开,直到连接池中的连接数到minIdle为止</p></li></ul><h3 id="redis-事务-MULTI"><a href="#redis-事务-MULTI" class="headerlink" title="redis 事务 MULTI"></a>redis 事务 MULTI</h3><p>严格意义来讲,redis的事务和我们理解的传统数据库(如mysql)的事务是不一样的。</p><p><strong>Redis中的事务（transaction）是一组命令的集合</strong>。</p><p>事务的原理是先<strong>将属于一个事务的命令发送给Redis，然后再让Redis依次执行这些命令</strong>。</p><p>如果在发送EXEC命令前客户端断线了，则Redis会清空事务队列，事务中的所有命令都不会执行。而一旦客户端发送了EXEC命令，所有的命令就都会被执行，即使此后客户端断线也没关系，因为Redis中已经记录了所有要执行的命令。</p><p>除此之外，Redis的事务还能保证一个事务内的命令依次执行而不被其他命令插入。试想客户端A需要执行几条命令，同时客户端B发送了一条命令，如果不使用事务，则客户端B的命令可能会插入到客户端A的几条命令中执行。如果不希望发生这种情况，也可以使用事务。</p><p>和传统的mysql事务不同的事，即使我们的加钱操作失败,我们也无法在这一组命令中让整个状态回滚到操作之前。</p><ul><li><p>语法错误<br>语法错误指命令不存在或者命令参数的个数不对，比如跟在MULTI命令后执行了3个命令：一个是正确的命令，成功地加入事务队列；其余两个命令都有语法错误。而只要有一个命令有语法错误，执行EXEC命令后Redis就会直接返回错误，连语法正确的命令也不会执行。</p></li><li><p>运行错误<br>运行错误指在命令执行时出现的错误，比如使用散列类型的命令操作集合类型的键，这种错误在实际执行之前Redis是无法发现的，所以在事务里这样的命令是会被Redis接受并执行的。如果事务里的一条命令出现了运行错误，事务里其他的命令依然会继续执行，Redis的事务没有关系数据库事务提供的回滚（rollback）功能。为此开发者必须在事务执行出错后自己收拾剩下的摊子。</p></li></ul><h3 id="redis-watch机制"><a href="#redis-watch机制" class="headerlink" title="redis watch机制"></a>redis watch机制</h3><blockquote><p>WATCH命令可以监控一个或多个键，一旦其中有一个键被修改（或删除），之后的事务就不会执行。监控一直持续到EXEC命令（<strong>事务中的命令是在EXEC之后才执行的</strong>，所以在MULTI命令后可以修改WATCH监控的键值）</p></blockquote><p><strong>利用watch实现incr</strong><br>具体做法如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">WATCH mykey</span><br><span class="line">val = GET mykey</span><br><span class="line">val = val + 1</span><br><span class="line">MULTI</span><br><span class="line">SET mykey $val</span><br><span class="line">EXEC</span><br></pre></td></tr></table></figure><p>注意点<br>由于WATCH命令的作用<strong>只是当被监控的键值被修改后阻止之后一个事务的执行</strong>，而<strong>不能保证其他客户端不修改这一键值</strong>，所以在一般的情况下我们需要在EXEC执行失败后重新执行整个函数。</p><p>执行EXEC命令后会取消对所有键的监控，如果不想执行事务中的命令也可以使用UNWATCH命令来取消监控。</p><h3 id="Redis为什么扩容时会产生超时"><a href="#Redis为什么扩容时会产生超时" class="headerlink" title="Redis为什么扩容时会产生超时"></a>Redis为什么扩容时会产生超时</h3><h3 id="skiplist与平衡树、哈希表的比较"><a href="#skiplist与平衡树、哈希表的比较" class="headerlink" title="skiplist与平衡树、哈希表的比较"></a>skiplist与平衡树、哈希表的比较</h3><ul><li><p>skiplist和各种平衡树（如AVL、红黑树等）的元素是有序排列的，而哈希表不是有序的。因此，在哈希表上只能做单个key的查找，不适宜做范围查找。所谓范围查找，指的是查找那些大小在指定的两个值之间的所有节点。</p></li><li><p>在做范围查找的时候，平衡树比skiplist操作要复杂。在平衡树上，我们找到指定范围的小值之后，还<strong>需要以中序遍历的顺序继续寻找其它不超过大值的节点</strong>。如果不对平衡树进行一定的改造，这里的中序遍历并不容易实现。而在skiplist上进行范围查找就非常简单，<strong>只需要在找到小值之后，对第1层链表进行若干步的遍历就可以实现</strong>。</p></li><li><p><strong>平衡树的插入和删除操作可能引发子树的调整，逻辑复杂</strong>，而<strong>skiplist的插入和删除只需要修改相邻节点的指针，操作简单又快速</strong>。</p></li><li><p>从内存占用上来说，skiplist比平衡树更灵活一些。一般来说，平衡树每个节点包含2个指针（分别指向左右子树），而skiplist每个节点包含的指针数目平均为<strong><em>1/(1-p)</em></strong>，具体取决于参数p的大小。如果像Redis里的实现一样，取p=1/4，那么平均每个节点包含 <strong>1.33</strong> 个指针，比平衡树更有优势。</p></li><li><p>查找单个key，skiplist和平衡树的时间复杂度都为<strong><em>O(logN)</em></strong>，大体相当；而哈希表在保持较低的哈希值冲突概率的前提下，查找时间复杂度接近O(1)，性能更高一些。所以我们平常使用的各种Map或dictionary结构，大都是基于哈希表实现的。</p></li><li><p>从算法实现难度上来比较，skiplist比平衡树要简单得多。</p></li></ul><p>链接：<a href="https://juejin.im/post/57fa935b0e3dd90057c50fbc" target="_blank" rel="noopener">https://juejin.im/post/57fa935b0e3dd90057c50fbc</a></p><h3 id="redis跳跃表"><a href="#redis跳跃表" class="headerlink" title="redis跳跃表"></a>redis跳跃表</h3><p><img src="/images/redis_skip_list.jpg" alt></p><ul><li>各种搜索结构提高效率的方式都是通过空间换时间得到的；</li><li>跳表最终形成的结构和搜索树很相似；</li><li>跳表通过随机的方式来决定新插入节点来决定索引的层数；</li><li>跳表搜索的时间复杂度是 O(logn)，插入/删除也是；</li></ul><p>为了满足自身的功能需要， Redis 基于 William Pugh 论文中描述的跳跃表进行了以下修改：</p><ul><li><p>允许重复的 score 值：多个不同的 member 的 score 值可以相同。</p></li><li><p>进行对比操作时，不仅要检查 score 值，还要检查 member ：当 score 值可以重复时，单靠 score 值无法判断一个元素的身份，所以需要连 member 域都一并检查才行。</p></li><li><p>每个节点都带有一个高度为 1 层的后退指针，用于从表尾方向向表头方向迭代：当执行 ZREVRANGE 或 ZREVRANGEBYSCORE 这类以逆序处理有序集的命令时，就会用到这个属性。</p></li></ul><p>实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; ZADD s 6 x 10 y 15 z</span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line">redis&gt; ZRANGE s 0 -1 WITHSCORES</span><br><span class="line">1) &quot;x&quot;</span><br><span class="line">2) &quot;6&quot;</span><br><span class="line">3) &quot;y&quot;</span><br><span class="line">4) &quot;10&quot;</span><br><span class="line">5) &quot;z&quot;</span><br><span class="line">6) &quot;15&quot;</span><br></pre></td></tr></table></figure><p>在底层实现中， Redis 为 x 、 y 和 z 三个 member 分别创建了三个字符串， 值分别为 double 类型的 6 、 10 和 15 ， 然后用跳跃表将这些指针有序地保存起来， 形成这样一个跳跃表：</p><p><img src="/images/redis_skip_list_realize.jpg" alt></p><ul><li><p>跳跃表是一种随机化数据结构，查找、添加、删除操作都可以在对数期望时间下完成。</p></li><li><p>跳跃表目前在 Redis 的唯一作用，就是作为有序集类型的底层数据结构之一，另一个构成有序集的结构是字典。<br>  为了满足自身的需求，Redis 基于 William Pugh 论文中描述的跳跃表进行了修改，包括：</p><ul><li>score 值可重复， 经典skiplist中是不允许的；</li><li>对比一个元素需要同时检查它的 score 和 memeber；</li><li>每个节点带有高度为 1 层的后退指针，双向链表，用于从表尾方向向表头方向迭代；</li><li>在skiplist中可以很方便地计算出每个元素的排名(rank)；</li></ul></li></ul><p>实际上，Redis中sorted set的实现是这样的：</p><ul><li><p>当数据较少时，sorted set是由一个ziplist来实现的。</p></li><li><p>当数据多的时候，sorted set是由一个dict + 一个skiplist来实现的。简单来讲，dict用来查询数据到分数的对应关系，而skiplist用来根据分数查询数据（可能是范围查找）。</p><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2></li></ul><h3 id="tcp确认机制"><a href="#tcp确认机制" class="headerlink" title="tcp确认机制"></a>tcp确认机制</h3><p>在TCP确认机制中，无法有效处理非连续TCP片段。<strong>确认号表明所有低于该编号的sequence number已经被发送该编号的设备接收</strong>。如果我们收到的字节数落在两个非连续的范围内，则无法只通过一个编号来确认。这可能导致潜在严重的性能问题，特别是高速或可靠性较差的网络。</p><ul><li><p><strong>仅重传超时片段</strong><br>每个片段发送后，发送端都有一个计时器，在一定时间内没有收到包含该片段的ack信息，就认为该片段接收超时。<br>这是一种更加保守的方式，仅重传超时的片段，希望其他片段都能够成功接收。如果该片段之后的其他片段实际上接收到了，这一方式是最佳的，如果没接收到，就无法正常执行。后者的情况每一个片段需要单独计时并重传。<br>假设上述最坏情况下，所有20个500字节片段都丢失了。我们需要等片段1超时并重传。这一片段也许会得到确认，但之后我们需要等待片段2超时并重传。这一过程会重复多次。</p></li><li><p><strong>重传所有片段</strong><br>这是一种更激进或者说更悲观的方式。无论何时一个片段超时了，不仅重传该片段，还有所有其他尚未确认的片段。这一方式确保了任何时间都有一个等待确认的停顿时间，在所有未确认片段丢失的情况下，会刷新全部未确认片段，以使对端设备多一次接收机会。在所有20个片段都丢失的情况下，相对于第一种方式节省了大量时间。这种方式的问题在于可能这些重传是不必要的。如果第一个片段丢失而其他19个实际上接收到了，也得重传那9500字节数据。</p></li></ul><p>由于TCP不知道其他片段是否接收到，所以它也无法确认哪种方法更好，但只能选择一种方式。解决方式是对TCP滑动窗口算法进行扩展，添加允许设备分别确认非连续片段的功能。这一功能称为<strong>选择确认</strong>（selective acknowledgment, SACK）。</p><p><strong>选择确认：</strong><br>通过SACK，连接的两方设备必须同时支持这一功能，通过连接时使用的SYN片段来协商是否允许SACK。这一过程完成之后，任一设备都可以在常规TCP片段中使用SACK选项。<br>这一选项包含一个关于 <strong>已接收但未确认片段数据sequence number范围的列表</strong>，由于它们是非连续的。</p><p>各设备对重传队列进行修改，如果该片段已被选择确认过，则该片段中的SACK比特位置为1。<strong>该设备使用图2中激进方式的改进版本，一个片段重传之后，之后所有片段也会重传，除非SACK比特位为1</strong>。</p><p>例如，在4个片段的情况下，如果客户端接收到片段4而没有接收到片段3，当它发回确认号为201（片段1和片段2）的确认信息，其中包含一个SACK选项指明：“已接收到字节361至500，但尚未确认”。如果片段4在片段1和2之后到达，上述信息也可以通过第二个确认片段来完成。服务器确认片段4的字节范围，并为片段4打开SACK位。当片段3重传时，服务器看到片段4的SACK位为1，就不会对其重传。</p><p>在片段3重传之后，片段4的SACK位被清除。这是为了防止客户端出于某种原因改变片段4已接收的想法。客户端应当发送确认号为501或更高的确认信息，正式确认片段3和4接收到。<strong>如果这一情况没有发生，服务器必须接收到片段4的另一条选择确认信息才能将它的SACK位打开，否则，在片段3重传时或计时器超时的情况下会对其自动重传</strong>。</p><p><a href="https://wizardforcel.gitbooks.io/network-basic/9.html" target="_blank" rel="noopener">https://wizardforcel.gitbooks.io/network-basic/9.html</a></p><h3 id="为什么tcp是可靠协议，怎么做到不丢包的？"><a href="#为什么tcp是可靠协议，怎么做到不丢包的？" class="headerlink" title="为什么tcp是可靠协议，怎么做到不丢包的？"></a>为什么tcp是可靠协议，怎么做到不丢包的？</h3><blockquote><p>窗口滑动协议<br>重传机制</p></blockquote><p>将TCP与UDP这样的简单传输协议区分开来的是它<strong>传输数据的质量</strong>。TCP对于发送数据进行跟踪，这种数据管理需要协议有以下两大关键功能：</p><ul><li><strong>可靠性</strong>：保证数据确实到达目的地。如果未到达，能够发现并重传；</li><li><strong>数据流控</strong>：管理数据的发送速率，以使接收设备不致于过载；</li></ul><p>要完成这些任务，整个协议操作是围绕滑动窗口确认机制来进行的。</p><p><strong>TCP面向流的滑动窗口确认机制:</strong><br>每一条消息都有一个识别编号，每一条消息都能够被独立地确认，因此同一时刻可以发送多条信息。设备B定期发送给A一条发送限制参数，制约设备A一次能发送的消息最大数量。设备B可以对该参数进行调整，以控制设备A的数据流。</p><p>为了提高速度，TCP并没有按照字节单个发送而是将<strong>数据流划分为片段</strong>。<strong>片段内所有字节都是一起发送和接收的，因此也是一起确认的</strong>。确认机制没有采用message ID字段，而是<strong>使用的片段内最后一个字节的sequence number</strong>。因此一次可以处理不同的字节数，这一数量即为片段内的sequence number。</p><ul><li><p><strong>发送窗口</strong><br>整个过程关键的操作在于接收方允许发送方一次能容纳的未确认的字节数，有时也称为窗口。该窗口决定了发送方允许传送的字节数。</p></li><li><p><strong>可用窗口</strong><br>考虑到正在传输的数据量，发送方仍被允许发送的数据量。</p></li></ul><p><a href="https://wizardforcel.gitbooks.io/network-basic/7.html" target="_blank" rel="noopener">https://wizardforcel.gitbooks.io/network-basic/7.html</a></p><h3 id="七层负载均衡和四层负载均衡的区别"><a href="#七层负载均衡和四层负载均衡的区别" class="headerlink" title="七层负载均衡和四层负载均衡的区别"></a>七层负载均衡和四层负载均衡的区别</h3><ul><li><p>二层负载均衡会通过一个虚拟 MAC 地址接收请求，然后再分配到真实的 MAC 地址；</p></li><li><p>三层负载均衡会通过一个虚拟 IP 地址接收请求，然后再分配到真实的 IP 地址；</p></li><li><p>四层通过虚拟 IP + 端口接收请求，然后再分配到真实的服务器；</p></li><li><p>七层通过虚拟的 URL 或主机名接收请求，然后再分配到真实的服务器。</p></li></ul><p>所谓的四到七层负载均衡，就是在对后台的服务器进行负载均衡时，依据四层的信息或七层的信息来决定怎么样转发流量。</p><p>对于一般的应用来说，有了Nginx就够了。<strong>Nginx可以用于七层负载均衡</strong>。但是对于一些大的网站，一般会采用DNS+四层负载+七层负载的方式进行多层次负载均衡。<br><img src="/images/four_seven_rebalance.jpg" alt></p><p>对比：<br>负载均衡器通常称为四层交换机或七层交换机。</p><ul><li>四层交换机主要分析 IP 层及 TCP/UDP 层，实现四层流量负载均衡。</li><li>七层交换机除了支持四层负载均衡以外，还有分析应用层的信息，如 HTTP 协议 URI 或 Cookie 信息。</li><li>负载均衡分为 L4 Switch（四层交换），即在 OSI第4层工作，就是 TCP层。<br>此种 Load Balancer 不理解应用协议（如 HTTP/FTP/MySQL 等等）。例子：LVS，F5。</li><li>L7 Switch（七层交换），OSI 的最高层，应用层。<br>此时，该 Load Balancer 能理解应用协议。例子： HAProxy，MySQL Proxy。</li></ul><p>注意：上面的很多 Load Balancer 既可以做四层交换，也可以做七层交换。<br><img src="/images/rebalce_layer_diff.jpg" alt></p><h3 id="常用负载均衡工具"><a href="#常用负载均衡工具" class="headerlink" title="常用负载均衡工具"></a>常用负载均衡工具</h3><p>Nginx/LVS/HAProxy是目前使用最广泛的三种负载均衡软件。</p><ul><li><p>LVS<br>LVS（Linux Virtual Server），也就是Linux虚拟服务器, 是一个由章文嵩博士发起的自由软件项目。使用LVS技术要达到的目标是：<strong>通过LVS提供的负载均衡技术和Linux操作系统实现一个高性能、高可用的服务器群集</strong>，它具有良好可靠性、可扩展性和可操作性。从而以低廉的成本实现最优的服务性能。</p><p>  <strong>LVS主要用来做四层负载均衡</strong>。</p></li><li><p>Nginx<br>Nginx（发音同engine x）是一个网页服务器，它能反向代理HTTP, HTTPS, SMTP, POP3, IMAP的协议链接，以及一个负载均衡器和一个HTTP缓存。</p><p>  <strong>Nginx主要用来做七层负载均衡</strong>。</p></li><li><p>HAProxy<br>HAProxy是一个使用C语言编写的自由及开放源代码软件，其提供高可用性、负载均衡，以及基于TCP和HTTP的应用程序代理。</p><p>  <strong>Haproxy主要用来做七层负载均衡。</strong></p></li></ul><p>负载均衡算法可以分为两类：<strong>静态负载均衡算法</strong>和<strong>动态负载均衡算法</strong>。</p><p>静态负载均衡算法包括：<strong>轮询，比率，优先权</strong></p><p>动态负载均衡算法包括: <strong>最少连接数, 最快响应速度，观察方法，预测法，动态性能分配， 动态服务器补充， 服务质量， 服务类型， 规则模式</strong>。</p><p><a href="https://cloud.tencent.com/developer/article/1082047" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1082047</a></p><h3 id="微信网页扫码登陆的通信过程是什么样的；"><a href="#微信网页扫码登陆的通信过程是什么样的；" class="headerlink" title="微信网页扫码登陆的通信过程是什么样的；"></a>微信网页扫码登陆的通信过程是什么样的；</h3><p>OAuth2协议</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> +----------+</span><br><span class="line"> | Resource |</span><br><span class="line"> |   Owner  |</span><br><span class="line"> |          |</span><br><span class="line"> +----------+</span><br><span class="line">      ^</span><br><span class="line">      |</span><br><span class="line">     (B)</span><br><span class="line"> +----|-----+          Client Identifier      +---------------+</span><br><span class="line"> |         -+----(A)-- &amp; Redirection URI ----&gt;|               |</span><br><span class="line"> |  User-   |                                 | Authorization |</span><br><span class="line"> |  Agent  -+----(B)-- User authenticates ---&gt;|     Server    |</span><br><span class="line"> |          |                                 |               |</span><br><span class="line"> |         -+----(C)-- Authorization Code ---&lt;|               |</span><br><span class="line"> +-|----|---+                                 +---------------+</span><br><span class="line">   |    |                                         ^      v</span><br><span class="line">  (A)  (C)                                        |      |</span><br><span class="line">   |    |                                         |      |</span><br><span class="line">   ^    v                                         |      |</span><br><span class="line"> +---------+                                      |      |</span><br><span class="line"> |         |&gt;---(D)-- Authorization Code ---------&apos;      |</span><br><span class="line"> |  Client |          &amp; Redirection URI                  |</span><br><span class="line"> | (Web后端)|                                             |</span><br><span class="line"> |         |&lt;---(E)----- Access Token -------------------&apos;</span><br><span class="line"> +---------+       (w/ Optional Refresh Token)</span><br><span class="line"></span><br><span class="line">Note: The lines illustrating steps (A), (B), and (C) are broken into two parts as they pass through the user-agent.</span><br></pre></td></tr></table></figure><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="求一个int数二进制形式中1出现的个数"><a href="#求一个int数二进制形式中1出现的个数" class="headerlink" title="求一个int数二进制形式中1出现的个数"></a>求一个int数二进制形式中1出现的个数</h3><p>位运算<br>(1) count = n &amp; 1; n&gt;&gt;1;  循环32次<br>(2) n &amp; (n-1), 每次可把最低位1变成 0；</p><h3 id="一个二叉树某一个路径和等于某值"><a href="#一个二叉树某一个路径和等于某值" class="headerlink" title="一个二叉树某一个路径和等于某值"></a>一个二叉树某一个路径和等于某值</h3><p>回溯算法</p><h3 id="字符串倒转的时间复杂度和空间复杂度"><a href="#字符串倒转的时间复杂度和空间复杂度" class="headerlink" title="字符串倒转的时间复杂度和空间复杂度"></a>字符串倒转的时间复杂度和空间复杂度</h3><p>双指针法一次遍历，使用 O(1) 的额外空间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverseString</span><span class="params">(<span class="keyword">char</span>[] s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> temp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = s.length - <span class="number">1</span>; i &lt;= j; i++, j--)&#123;</span><br><span class="line">        temp = s[j];</span><br><span class="line">        s[j] = s[i];</span><br><span class="line">        s[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：<em>O(N)*，执行了 *N/2</em> 次的交换。<br>空间复杂度：<em>O(1)</em>，只使用了常数级空间</p><h3 id="两个链表分别表示两个数，求和"><a href="#两个链表分别表示两个数，求和" class="headerlink" title="两个链表分别表示两个数，求和"></a>两个链表分别表示两个数，求和</h3><ul><li>双队列法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        Stack&lt;ListNode&gt; stack1 = <span class="keyword">new</span> Stack&lt;ListNode&gt;();</span><br><span class="line">        Stack&lt;ListNode&gt; stack2 = <span class="keyword">new</span> Stack&lt;ListNode&gt;();</span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack1.add(l1);</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack2.add(l2);</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode h0 = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode cur1 , cur2;</span><br><span class="line">        <span class="keyword">int</span> re = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!stack1.isEmpty() || !stack2.isEmpty())&#123;</span><br><span class="line">            cur1 = <span class="keyword">null</span>;</span><br><span class="line">            cur2 = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span>(!stack1.isEmpty())&#123;</span><br><span class="line">                cur1 = stack1.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!stack2.isEmpty())&#123;</span><br><span class="line">                cur2 = stack2.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(cur1 == <span class="keyword">null</span>)&#123;</span><br><span class="line">                cur1 = cur2;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(cur2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">                cur1.val += cur2.val; </span><br><span class="line">            &#125;</span><br><span class="line">            cur1.val += re;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> temp = cur1.val;</span><br><span class="line">            cur1.val = temp % <span class="number">10</span>;</span><br><span class="line">            re = temp / <span class="number">10</span>;</span><br><span class="line">            cur1.next = h0.next;</span><br><span class="line">            h0.next = cur1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(re != <span class="number">0</span>)&#123;</span><br><span class="line">            ListNode node = <span class="keyword">new</span> ListNode(re);</span><br><span class="line">            node.next = h0.next;</span><br><span class="line">            h0.next = node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> h0.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>递归法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flow=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1==<span class="keyword">null</span>) <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span>(l2==<span class="keyword">null</span>) <span class="keyword">return</span> l1;</span><br><span class="line">        ListNode res1=l1,res2=l2;</span><br><span class="line">        <span class="keyword">int</span> len1=<span class="number">0</span>,len2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l1!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            len1++;</span><br><span class="line">            l1=l1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(l2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            len2++;</span><br><span class="line">            l2=l2.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode res=len1&gt;len2?add(res1,res2,len1,len2):add(res2,res1,len2,len1);</span><br><span class="line">        <span class="keyword">if</span>(flow==<span class="number">1</span>) &#123;</span><br><span class="line">            res1=<span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">            res1.next=res;</span><br><span class="line">            <span class="keyword">return</span> res1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">add</span><span class="params">(ListNode l1, ListNode l2,<span class="keyword">int</span> len1,<span class="keyword">int</span> len2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="keyword">if</span>((len1==<span class="number">1</span>)&amp;&amp;(len2==<span class="number">1</span>))&#123;</span><br><span class="line">            temp=l1.val;</span><br><span class="line">            l1.val=(l1.val+l2.val)%<span class="number">10</span>;</span><br><span class="line">            flow=(temp+l2.val)/<span class="number">10</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len1&gt;len2) &#123;</span><br><span class="line">            temp=l1.val;</span><br><span class="line">            l1.next=add(l1.next, l2, len1-<span class="number">1</span>, len2);</span><br><span class="line">            l1.val=(temp+flow)%<span class="number">10</span>;</span><br><span class="line">            flow=(temp+flow)/<span class="number">10</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l1.next=add(l1.next, l2.next, len1-<span class="number">1</span>, len2-<span class="number">1</span>);</span><br><span class="line">            temp=l1.val;</span><br><span class="line">            l1.val=(temp+flow+l2.val)%<span class="number">10</span>;</span><br><span class="line">            flow=(temp+flow+l2.val)/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="两个list分别表示两个数，求和"><a href="#两个list分别表示两个数，求和" class="headerlink" title="两个list分别表示两个数，求和"></a>两个list分别表示两个数，求和</h3><h3 id="paxo算法是啥，zab算法"><a href="#paxo算法是啥，zab算法" class="headerlink" title="paxo算法是啥，zab算法"></a>paxo算法是啥，zab算法</h3><h3 id="怎么对ip进行限流，比如某个ip-1小时最多访问1万次，写出代码；"><a href="#怎么对ip进行限流，比如某个ip-1小时最多访问1万次，写出代码；" class="headerlink" title="怎么对ip进行限流，比如某个ip 1小时最多访问1万次，写出代码；"></a>怎么对ip进行限流，比如某个ip 1小时最多访问1万次，写出代码；</h3><h3 id="从A、B两个数组中各取一个数，求两数差值最小"><a href="#从A、B两个数组中各取一个数，求两数差值最小" class="headerlink" title="从A、B两个数组中各取一个数，求两数差值最小"></a>从A、B两个数组中各取一个数，求两数差值最小</h3><p>N个数组中取两个数差值最小， N个数组中取两个数差值最小</p><h3 id="电梯算法"><a href="#电梯算法" class="headerlink" title="电梯算法"></a>电梯算法</h3><p>每层有一个value表示可上或可下value层，求A层到B层的最短按键数</p><h3 id="实现一个栈，-有push-pop-获取最小值-三个方法-要求-快！"><a href="#实现一个栈，-有push-pop-获取最小值-三个方法-要求-快！" class="headerlink" title="实现一个栈， 有push pop 获取最小值 三个方法  要求 快！"></a>实现一个栈， 有push pop 获取最小值 三个方法  要求 快！</h3><h3 id="直播间在线人数统计"><a href="#直播间在线人数统计" class="headerlink" title="直播间在线人数统计"></a>直播间在线人数统计</h3><p>有一个日志文件，一个人进入直播间会有一个uid和进入时间，退出直播间会有一个uid和退出时间，一次直播的过程中 同一时刻最多的在线人数怎么求？</p><blockquote><p>一次遍历，第一次出现 +1， 第二次出现 -1；</p></blockquote><p>接上一题，如果日志文件不是按照时间排序的，那在o(n)时间内求同一时刻最多的在线人数</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JAVA基础&quot;&gt;&lt;a href=&quot;#JAVA基础&quot; class=&quot;headerlink&quot; title=&quot;JAVA基础&quot;&gt;&lt;/a&gt;JAVA基础&lt;/h2&gt;&lt;h3 id=&quot;Java的collection接口继承关系&quot;&gt;&lt;a href=&quot;#Java的collection接
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
      <category term="面试" scheme="http://yoursite.com/categories/Java/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot基本原理</title>
    <link href="http://yoursite.com/2020/01/10/SpringBoot%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2020/01/10/SpringBoot基本原理/</id>
    <published>2020-01-10T12:51:16.000Z</published>
    <updated>2020-01-10T12:57:31.108Z</updated>
    
    <content type="html"><![CDATA[<h2 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h2><p>启动类代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringBootDemoApplication</span> <span class="keyword">extends</span> <span class="title">SpringBootServletInitializer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringBootDemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对照上面的典型代码，这个两个元素分别是：</p><blockquote><p>@SpringBootApplication<br>SpringApplication 以及 run() 方法</p></blockquote><p>SpringApplication 这个类应该算是 SpringBoot 框架 的“创新”产物了，原始的 Spring中并没有这个类，SpringApplication 里面封装了一套 Spring 应用的启动流程，然而这对用户完全透明，因此我们上手 SpringBoot 时感觉简洁、轻量。</p><p>一般来说默认的 SpringApplication 执行流程已经可以满足大部分需求，但是 若用户想干预这个过程，则可以通过 SpringApplication 在流程某些地方开启的 扩展点 来完成对流程的扩展，典型的扩展方案那就是使用 set 方法。<br>我们来举一个栗子，把我们天天司空见惯的 SpringBoot 应用的启动类来拆解一下写出来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringBootDemoApplication</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 这是传统SpringBoot应用的启动，一行代码搞定，内部默认做了很多事</span></span><br><span class="line"><span class="comment">// SpringApplication.run( SpringBootDemoApplication args ); </span></span><br><span class="line">SpringApplication app = <span class="keyword">new</span> SpringApplication(SpringBootDemoApplication );</span><br><span class="line">app.setXXX( ... ); <span class="comment">// 用户自定的扩展在此 ！！！</span></span><br><span class="line">app.run( args );</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一拆解后我们发现，我们也需要先构造 SpringApplication 类对象，然后调用该对象的 run() 方法。那么接下来就讲讲 SpringApplication 的构造过程 以及其 run() 方法的流程，搞清楚了这个，那么也就搞清楚了SpringBoot应用是如何运行起来的！</p><h3 id="SpringApplication-实例的初始化"><a href="#SpringApplication-实例的初始化" class="headerlink" title="SpringApplication 实例的初始化"></a>SpringApplication 实例的初始化</h3><p>首先看下SpringApplication的构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SpringApplication</span><span class="params">(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">Assert.notNull(primarySources, <span class="string">"PrimarySources must not be null"</span>);</span><br><span class="line"><span class="keyword">this</span>.primarySources = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(Arrays.asList(primarySources));</span><br><span class="line"><span class="comment">// (1) 推断应用的类型</span></span><br><span class="line"><span class="keyword">this</span>.webApplicationType = WebApplicationType.deduceFromClasspath();</span><br><span class="line"><span class="comment">// (2) 查找并加载 classpath下 META-INF/spring.factories文件中所有可用的 ApplicationContextInitializer</span></span><br><span class="line">setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));</span><br><span class="line"><span class="comment">// (3) 查找并加载 classpath下 META-INF/spring.factories文件中的所有可用的 ApplicationListener</span></span><br><span class="line">setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));</span><br><span class="line"><span class="comment">// (4) 推断并设置 main方法的定义类</span></span><br><span class="line"><span class="keyword">this</span>.mainApplicationClass = deduceMainApplicationClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>详细过程如下：</p><ul><li>（1）推断应用的类型：根据你classpath 下是否能找到对应的class文件， 推断应用类型， 优先级依次是：REACTIVE 、NONE、SERVLET(默认)。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> WebApplicationType <span class="title">deduceFromClasspath</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (ClassUtils.isPresent(WEBFLUX_INDICATOR_CLASS, <span class="keyword">null</span>) &amp;&amp; !ClassUtils.isPresent(WEBMVC_INDICATOR_CLASS, <span class="keyword">null</span>)</span><br><span class="line">&amp;&amp; !ClassUtils.isPresent(JERSEY_INDICATOR_CLASS, <span class="keyword">null</span>)) &#123;</span><br><span class="line"><span class="keyword">return</span> WebApplicationType.REACTIVE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (String className : SERVLET_INDICATOR_CLASSES) &#123;</span><br><span class="line"><span class="keyword">if</span> (!ClassUtils.isPresent(className, <span class="keyword">null</span>)) &#123;</span><br><span class="line"><span class="keyword">return</span> WebApplicationType.NONE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> WebApplicationType.SERVLET;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>（2）使用 SpringFactoriesLoader查找并加载 classpath下 <code>META-INF/spring.factories</code>文件中所有可用的 ApplicationContextInitializer</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Initializers</span><br><span class="line">org.springframework.context.ApplicationContextInitializer=\</span><br><span class="line">org.springframework.boot.autoconfigure.SharedMetadataReaderFactoryContextInitializer,\</span><br><span class="line">org.springframework.boot.autoconfigure.logging.ConditionEvaluationReportLoggingListener</span><br></pre></td></tr></table></figure><ul><li>(3) 使用 SpringFactoriesLoader查找并加载 classpath下 <code>META-INF/spring.factories</code>文件中的所有可用的 ApplicationListener</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Application Listeners</span><br><span class="line">org.springframework.context.ApplicationListener=\</span><br><span class="line">org.springframework.boot.autoconfigure.BackgroundPreinitializer</span><br></pre></td></tr></table></figure><ul><li>(4) 推断并设置main方法的定义类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Class&lt;?&gt; deduceMainApplicationClass() &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">StackTraceElement[] stackTrace = <span class="keyword">new</span> RuntimeException().getStackTrace();</span><br><span class="line"><span class="keyword">for</span> (StackTraceElement stackTraceElement : stackTrace) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="string">"main"</span>.equals(stackTraceElement.getMethodName())) &#123;</span><br><span class="line"><span class="keyword">return</span> Class.forName(stackTraceElement.getClassName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line"><span class="comment">// Swallow and continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SpringApplication-的run-方法"><a href="#SpringApplication-的run-方法" class="headerlink" title="SpringApplication 的run()方法"></a>SpringApplication 的run()方法</h3><p>先看代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">    StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">stopWatch.start();</span><br><span class="line">ConfigurableApplicationContext context = <span class="keyword">null</span>;</span><br><span class="line">Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">configureHeadlessProperty();</span><br><span class="line"><span class="comment">// 通过 SpringFactoriesLoader 加载META-INF/spring.factories文件，获取并创建 SpringApplicationRunListener对象</span></span><br><span class="line">SpringApplicationRunListeners listeners = getRunListeners(args);</span><br><span class="line"><span class="comment">// 然后由 SpringApplicationRunListener 来发出 starting 消息</span></span><br><span class="line">listeners.starting();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="comment">// 创建参数，并配置当前 SpringBoot 应用将要使用的 Environment</span></span><br><span class="line">ApplicationArguments applicationArguments = <span class="keyword">new</span> DefaultApplicationArguments(args);</span><br><span class="line"><span class="comment">// 完成之后，依然由 SpringApplicationRunListener 来发出 environmentPrepared 消息</span></span><br><span class="line">ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments);</span><br><span class="line">configureIgnoreBeanInfo(environment);</span><br><span class="line"><span class="comment">// 打印欢迎页信息</span></span><br><span class="line">Banner printedBanner = printBanner(environment);</span><br><span class="line">context = createApplicationContext();</span><br><span class="line">exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter.class,</span><br><span class="line"><span class="keyword">new</span> Class[] &#123; ConfigurableApplicationContext.class &#125;, context);</span><br><span class="line"><span class="comment">// 初始化 ApplicationContext，并设置 Environment，加载相关配置等</span></span><br><span class="line">prepareContext(context, environment, listeners, applicationArguments, printedBanner);</span><br><span class="line"><span class="comment">// 刷新context，最重要的一步，完成IOC容器注入整个过程</span></span><br><span class="line">refreshContext(context);</span><br><span class="line">afterRefresh(context, applicationArguments);</span><br><span class="line">stopWatch.stop();</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</span><br><span class="line"><span class="keyword">new</span> StartupInfoLogger(<span class="keyword">this</span>.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);</span><br><span class="line">&#125;</span><br><span class="line">listeners.started(context);</span><br><span class="line">callRunners(context, applicationArguments);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">handleRunFailure(context, ex, exceptionReporters, listeners);</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">listeners.running(context);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">handleRunFailure(context, ex, exceptionReporters, <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>流程图如下：<br><img src="/images/spring_boot_starter_pro.png" alt></p><h2 id="自动装配原理"><a href="#自动装配原理" class="headerlink" title="自动装配原理"></a>自动装配原理</h2><h3 id="自动装配过程分析"><a href="#自动装配过程分析" class="headerlink" title="自动装配过程分析"></a>自动装配过程分析</h3><p>自动装配原理得从 <code>@SpringbootApplication</code> 入手分析</p><p><img src="/images/spring_boot_application.png" alt></p><p><code>@SpringbootApplication</code>包含了<code>@SpringBootConfiguration</code>，<code>@EnableAutoConfiguration</code>，<code>@ComponentScan</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(excludeFilters = &#123;</span><br><span class="line">        <span class="meta">@Filter</span>(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span><br><span class="line">        <span class="meta">@Filter</span>(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</span><br></pre></td></tr></table></figure><ul><li><p><code>@ComponentScan</code>如果没有指定扫描包，因此它默认扫描的是与该类同级的类或者同级包下的所有类;</p></li><li><p><code>@SpringBootConfiguration</code>通过源码得知它是一个<code>@Configuration</code>;</p></li><li><p><code>@EnableAutoConfiguration</code> 一旦加上此注解，那么将会开启自动装配功能，简单点讲，Spring会试图在你的classpath下找到所有配置的Bean然后进行装配。当然装配Bean时，会根据若干个<code>@Conditional</code>定制规则来进行初始化;</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"deprecation"</span>)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import</span>(EnableAutoConfigurationImportSelector.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br><span class="line"></span><br><span class="line">    String ENABLED_OVERRIDE_PROPERTY = <span class="string">"spring.boot.enableautoconfiguration"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Exclude specific auto-configuration classes such that they will never be applied.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the classes to exclude</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Class&lt;?&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Exclude specific auto-configuration class names such that they will never be</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String[] excludeName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>根据文档注释的说明它指点我们去看<code>EnableAutoConfigurationImportSelector</code>。但是该类在SpringBoot1.5.X版本已经过时了，因此我们看一下它的父类<code>AutoConfigurationImportSelector</code>;</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AutoConfigurationImportSelector</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">DeferredImportSelector</span>, <span class="title">BeanClassLoaderAware</span>, <span class="title">ResourceLoaderAware</span>,</span></span><br><span class="line"><span class="class">        <span class="title">BeanFactoryAware</span>, <span class="title">EnvironmentAware</span>, <span class="title">Ordered</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] NO_IMPORTS = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log logger = LogFactory</span><br><span class="line">            .getLog(AutoConfigurationImportSelector.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ConfigurableListableBeanFactory beanFactory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Environment environment;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ClassLoader beanClassLoader;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ResourceLoader resourceLoader;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isEnabled(annotationMetadata)) &#123;</span><br><span class="line">            <span class="keyword">return</span> NO_IMPORTS;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 读取mata-info/spring-autoconfigure-metadata.properties元数据与元数据的相关属性</span></span><br><span class="line">            AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader</span><br><span class="line">                    .loadMetadata(<span class="keyword">this</span>.beanClassLoader);</span><br><span class="line">            AnnotationAttributes attributes = getAttributes(annotationMetadata);</span><br><span class="line">            <span class="comment">// 去 mata-info/spring.factories 文件中查询 EnableAutoConfiguration值</span></span><br><span class="line">            List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata,</span><br><span class="line">                    attributes);</span><br><span class="line">            <span class="comment">// 去除重复的配置类，若我们自己写的starter可能存在重复的</span></span><br><span class="line">            configurations = removeDuplicates(configurations);</span><br><span class="line">            configurations = sort(configurations, autoConfigurationMetadata);</span><br><span class="line">            Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);</span><br><span class="line">            checkExcludedClasses(configurations, exclusions);</span><br><span class="line">            configurations.removeAll(exclusions);</span><br><span class="line">            <span class="comment">// 根据maven导入的启动器过滤出需要导入的配置类</span></span><br><span class="line">            configurations = filter(configurations, autoConfigurationMetadata);</span><br><span class="line">            fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line">            <span class="keyword">return</span> configurations.toArray(<span class="keyword">new</span> String[configurations.size()]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isEnabled</span><span class="params">(AnnotationMetadata metadata)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先该类实现了<code>DeferredImportSelector</code>接口，这个接口继承了<code>ImportSelector</code>, 该接口主要是为了导入 <code>@Configuration</code> 的配置项，而 <code>DeferredImportSelector</code> 是延期导入，当所有的<code>@Configuration</code>都处理过后才会执行;</p><ul><li>回过头来我们看一下 <code>AutoConfigurationImportSelector</code> 的<code>selectImport</code>方法, 该方法刚开始会先判断是否进行自动装配，而后会从 <code>META-INF/spring-autoconfigure-metadata.properties</code> 读取元数据与元数据的相关属性，紧接着会调用<code>getCandidateConfigurations</code>方法：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;String&gt; <span class="title">getCandidateConfigurations</span><span class="params">(AnnotationMetadata metadata,</span></span></span><br><span class="line"><span class="function"><span class="params">            AnnotationAttributes attributes)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(</span><br><span class="line">                getSpringFactoriesLoaderFactoryClass(), getBeanClassLoader());</span><br><span class="line">        Assert.notEmpty(configurations,</span><br><span class="line">                <span class="string">"No auto configuration classes found in META-INF/spring.factories. If you "</span></span><br><span class="line">                        + <span class="string">"are using a custom packaging, make sure that file is correct."</span>);</span><br><span class="line">        <span class="keyword">return</span> configurations;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the class used by &#123;<span class="doctag">@link</span> SpringFactoriesLoader&#125; to load configuration candidates.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; getSpringFactoriesLoaderFactoryClass() &#123;</span><br><span class="line">    <span class="keyword">return</span> EnableAutoConfiguration.class;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里又遇到<code>SpringFactoryiesLoader</code>, 它会读取<code>META-INF/spring.factories</code>下的<code>EnableAutoConfiguration</code>的配置，紧接着在进行排除与过滤，进而得到需要装配的类。最后让所有配置在<code>META-INF/spring.factories</code>下的<code>AutoConfigurationImportListener</code>执行<code>AutoConfigurationImportEvent</code>事件，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fireAutoConfigurationImportEvents</span><span class="params">(List&lt;String&gt; configurations,</span></span></span><br><span class="line"><span class="function"><span class="params">            Set&lt;String&gt; exclusions)</span> </span>&#123;</span><br><span class="line">    List&lt;AutoConfigurationImportListener&gt; listeners = getAutoConfigurationImportListeners();</span><br><span class="line">    <span class="keyword">if</span> (!listeners.isEmpty()) &#123;</span><br><span class="line">        AutoConfigurationImportEvent event = <span class="keyword">new</span> AutoConfigurationImportEvent(<span class="keyword">this</span>,</span><br><span class="line">                configurations, exclusions);</span><br><span class="line">        <span class="keyword">for</span> (AutoConfigurationImportListener listener : listeners) &#123;</span><br><span class="line">            invokeAwareMethods(listener);</span><br><span class="line">            listener.onAutoConfigurationImportEvent(event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;AutoConfigurationImportListener&gt; <span class="title">getAutoConfigurationImportListeners</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> SpringFactoriesLoader.loadFactories(AutoConfigurationImportListener.class,</span><br><span class="line">            <span class="keyword">this</span>.beanClassLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>1）自动装配还是利用了 <code>SpringFactoriesLoader</code> 来加载<code>META-INF/spring.factoires</code>文件里所有配置的<code>EnableAutoConfgruation</code>，它会经过<code>exclude</code>和<code>filter</code>等操作，最终确定要装配的类</p><p>2)  处理<code>@Configuration</code>的核心还是<code>ConfigurationClassPostProcessor</code>，这个类实现了<code>BeanFactoryPostProcessor</code>, 因此当<code>AbstractApplicationContext</code>执行<code>refresh()</code>方法里的<code>invokeBeanFactoryPostProcessors(beanFactory)</code>方法时会执行自动装配</p><p><img src="/images/springboot_st1.png" alt="-w974"><br><img src="/images/springboot_st2.png" alt="-w595"></p><h2 id="自定义starter"><a href="#自定义starter" class="headerlink" title="自定义starter"></a>自定义starter</h2><h2 id="Tomcat启动流程"><a href="#Tomcat启动流程" class="headerlink" title="Tomcat启动流程"></a>Tomcat启动流程</h2><p><img src="/images/spring_boot_tomcat_st.png" alt="-w1222"></p><p><code>EmbeddedWebServerFactoryCustomizerAutoConfiguration</code> 内嵌web容器工厂自定义定制器装配类</p><p>org.springframework.context.support.AbstractApplicationContext#refresh</p><h2 id="如何扫描自定义组件"><a href="#如何扫描自定义组件" class="headerlink" title="如何扫描自定义组件"></a>如何扫描自定义组件</h2><h2 id="Conditional注解"><a href="#Conditional注解" class="headerlink" title="Conditional注解"></a>Conditional注解</h2><p>常见的注解解释：</p><ul><li><p><code>@ConditionalOnBean</code><br>匹配给定的class类型或者Bean的名字是否在SpringBeanFactory中存在</p></li><li><p><code>@ConditionalOnClass</code><br>匹配给定的class类型是否在类路径(classpath)中存在</p></li><li><p><code>@ConditionalOnExpression</code><br>匹配给定springEL表达式的值返回true时</p></li><li><p><code>@ConditionalOnJava</code><br>匹配JDK的版本，其中range属性是枚举类型有两个值可以选择 </p><ul><li>EQUAL_OR_NEWER 不小于</li><li>OLDER_THAN 小于</li></ul><p>value属性用于设置jdk版本</p></li><li><p><code>ConditionalOnMissingBean</code><br>spring上下文中不存在指定bean时</p></li><li><p><code>ConditionalOnWebApplication</code><br>在web环境下创建 </p></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/niechen/p/8306376.html" target="_blank" rel="noopener">SpringBoot学习之自动装配</a><br><a href="https://www.cnblogs.com/niechen/p/9027804.html" target="_blank" rel="noopener">深入理解SpringBoot之自动装配</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;启动流程&quot;&gt;&lt;a href=&quot;#启动流程&quot; class=&quot;headerlink&quot; title=&quot;启动流程&quot;&gt;&lt;/a&gt;启动流程&lt;/h2&gt;&lt;p&gt;启动类代码&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=
      
    
    </summary>
    
      <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
      <category term="SpringBoot" scheme="http://yoursite.com/categories/Spring/SpringBoot/"/>
    
    
      <category term="原理" scheme="http://yoursite.com/tags/%E5%8E%9F%E7%90%86/"/>
    
      <category term="SpringBoot" scheme="http://yoursite.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Netty快速入门</title>
    <link href="http://yoursite.com/2020/01/08/Netty%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2020/01/08/Netty快速入门/</id>
    <published>2020-01-08T12:20:17.000Z</published>
    <updated>2020-01-10T13:01:56.941Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-NIO-核心概念"><a href="#Java-NIO-核心概念" class="headerlink" title="Java NIO 核心概念"></a>Java NIO 核心概念</h1><hr><h2 id="Linux五种I-O模型比较"><a href="#Linux五种I-O模型比较" class="headerlink" title="Linux五种I/O模型比较"></a>Linux五种I/O模型比较</h2><p><img src="/images/linux_five_io.png" alt></p><h2 id="Socket通信模型"><a href="#Socket通信模型" class="headerlink" title="Socket通信模型"></a>Socket通信模型</h2><p><img src="/images/socket_com_model.png" alt></p><h2 id="Java-NIO-Buffer"><a href="#Java-NIO-Buffer" class="headerlink" title="Java NIO Buffer"></a>Java NIO Buffer</h2><blockquote><p>一个Buffer本质上是内存中的一块， 可以将数据写入这块内存， 从这块内存获取数据 </p></blockquote><p><code>java.nio</code> 定义了以下几个Buffer的实现:</p><p><img src="/images/java_nio_buffer.png" alt></p><p>Java NIO Buffer三大核心概念：<strong>position</strong>、<strong>limit</strong>、<strong>capacity</strong></p><ul><li><p>最好理解的当然是 <code>capacity</code>，它代表这个缓冲区的容量，一旦设定就不可以更改。比如 <code>capacity</code> 为 <code>1024</code> 的 <code>IntBuffer</code>，代表其一次可以存放 <code>1024</code> 个 <code>int</code> 类型的值。</p></li><li><p>一旦 Buffer 的容量达到 capacity，需要清空 Buffer，才能重新写入值<br><img src="/images/java_nio_pos_cap.png" alt></p></li><li><p>从写操作模式到读操作模式切换的时候（flip），<code>position</code> 都会归零，这样就可以从头开始读写了。</p></li><li><p>写操作模式下，<code>limit</code> 代表的是最大能写入的数据，这个时候 <code>limit</code> 等于 <code>capacity</code>。</p></li><li><p>写结束后，切换到读模式，此时的 <code>limit</code> 等于 Buffer 中实际的数据大小，因为 Buffer 不一定被写满了</p></li></ul><p><img src="/images/java_nio_buffer_op.png" alt></p><p><strong>DirectByteBuffer &amp; HeapByteBuffer</strong></p><table><thead><tr><th></th><th>DirectByteBuffer</th><th>HeapByteBuffer</th></tr></thead><tbody><tr><td>描述</td><td>底层存储在非JVM堆上，通过native代码操作 -神器:MaxDirectMemorySize=<size></size></td><td>标准java类，维护一份byte[]在JVM堆上</td></tr><tr><td>创建开销</td><td>大</td><td>小</td></tr><tr><td>存储位置</td><td>Native Heap</td><td>Java Heap</td></tr><tr><td>数据拷贝</td><td>无需临时缓冲区做拷贝</td><td>拷贝到临时DirectByteBuffer,但临时缓冲区使用缓存， 聚集写/发散读时没有缓存临时缓冲区</td></tr><tr><td>GC影响</td><td>每次创建或者释放的时候都调用一次System.gc()</td><td>java垃圾回收机制自动回收</td></tr></tbody></table><h2 id="JAVA-NIO-Channel"><a href="#JAVA-NIO-Channel" class="headerlink" title="JAVA NIO Channel"></a>JAVA NIO Channel</h2><p>所有的NIO操作始于通道，<strong>通道是数据来源或数据写入的目的地</strong>，<code>java.nio</code> 包中主要实现的以下几个 Channel：<br><img src="/images/java_nio_channel.png" alt></p><ul><li><strong>FileChannel</strong>：文件通道，用于文件的读和写</li><li><strong>DatagramChannel</strong>：用于 UDP 连接的接收和发送</li><li><strong>SocketChannel</strong>：把它理解为 TCP 连接通道，简单理解就是 TCP 客户端</li><li><strong>ServerSocketChannel</strong>：TCP 对应的服务端，用于监听某个端口进来的请求</li></ul><h2 id="Java-NIO-Selector"><a href="#Java-NIO-Selector" class="headerlink" title="Java NIO Selector"></a>Java NIO Selector</h2><p><img src="/images/java_nio_selector.png" alt></p><ul><li><p><code>java.nio.channels.Selector</code></p></li><li><p>支持IO多路复用的抽象实体</p></li><li><p>注册<code>Selectable Channel</code></p></li><li><p>SelectionKey —— 表示Selector和被注册的channel之间关系的一份凭证</p><ul><li>SelectionKey保存channel感兴趣的事件</li></ul></li><li><p><code>Selector.select</code> 更新所有就绪的 <code>SelectionKey</code> 的状态, 并返回就绪的channel个数</p><ul><li>迭代Selected Key集合并处理就绪channel</li></ul></li></ul><p><strong>Selector基本操作</strong></p><ul><li>创建Selector   </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Selector selector = Selector.open();</span><br></pre></td></tr></table></figure><ul><li>注册Channel到Selector</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SocketChannel channel = SocketChannel.open();</span><br><span class="line">channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">SelectionKey key = channel.register(selector, SelectionKey.OP_READ);</span><br></pre></td></tr></table></figure><ul><li>register的第二个参数是一个“关注集合”，代表关注的channel状态，有四种基础类型可供监听, 用SelectionKey中的常量表示如下：  </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SelectionKey.OP_CONNECT</span><br><span class="line">SelectionKey.OP_ACCEPT</span><br><span class="line">SelectionKey.OP_READ</span><br><span class="line">SelectionKey.OP_WRITE</span><br></pre></td></tr></table></figure><ul><li>从Selector中选择channel<br>一旦向Selector注册了一个或多个channel后，就可以调用select来获取channel, <code>select()</code>方法会返回所有处于就绪状态的channel, select方法具体如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">long</span> timeout)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">selectNow</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>select()方法的返回值是一个int，代表有多少channel处于就绪了。也就是自上一次select后有多少channel进入就绪。</p><ul><li>selectedKeys()<br>在调用select并返回了有channel就绪之后，可以通过选中的key集合来获取channel，这个操作通过调用selectedKeys()方法：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</span><br></pre></td></tr></table></figure><ul><li>Selector编程模板</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</span><br><span class="line"></span><br><span class="line">Iterator&lt;SelectionKey&gt; keyIterator = selectedKeys.iterator();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(keyIterator.hasNext()) &#123;</span><br><span class="line"></span><br><span class="line">    SelectionKey key = keyIterator.next();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(key.isAcceptable()) &#123;</span><br><span class="line">        <span class="comment">// a connection was accepted by a ServerSocketChannel.</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isConnectable()) &#123;</span><br><span class="line">        <span class="comment">// a connection was established with a remote server.</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">        <span class="comment">// a channel is ready for reading</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line">        <span class="comment">// a channel is ready for writing</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    keyIterator.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Netty核心概念"><a href="#Netty核心概念" class="headerlink" title="Netty核心概念"></a>Netty核心概念</h1><p>Netty 提供<strong>异步的、事件驱动的网络应用程序框架和工具</strong>,用以快速开发高性能、高可靠性的网络服务器和客户端程序。</p><hr><h2 id="Netty主要组件"><a href="#Netty主要组件" class="headerlink" title="Netty主要组件"></a>Netty主要组件</h2><p><img src="/images/netty_total_structure.png" alt></p><ul><li><p>Netty Server启动主要流程</p><ul><li><p>设置服务端ServerBootStrap启动参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">group(parentGroup, childGroup):</span><br><span class="line">channel(NioServerSocketChannel): 设置通道类型</span><br><span class="line">handler()：设置NioServerSocketChannel的ChannelHandlerPipeline</span><br><span class="line">childHandler(): 设置NioSocketChannel的ChannelHandlerPipeline</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>通过ServerBootStrap的bind方法启动服务端，bind方法会在parentGroup中注册NioServerScoketChannel，监听客户端的连接请求</p><ul><li>会创建一个NioServerSocketChannel实例，并将其在parentGroup中进行注册</li></ul></li></ul></li><li><p>Netty Server执行主要流程</p><ul><li><p>Client发起连接CONNECT请求，parentGroup中的NioEventLoop不断轮循是否有新的客户端请求，如果有，ACCEPT事件触发</p></li><li><p>ACCEPT事件触发后，parentGroup中NioEventLoop会通过NioServerSocketChannel获取到对应的代表客户端的NioSocketChannel，并将其注册到childGroup中</p></li><li><p>childGroup中的NioEventLoop不断检测自己管理的NioSocketChannel是否有读写事件准备好，如果有的话，调用对应的ChannelHandler进行处理</p></li></ul></li></ul><h2 id="Netty-EventLoop"><a href="#Netty-EventLoop" class="headerlink" title="Netty EventLoop"></a>Netty EventLoop</h2><p><img src="/images/netty_ev_loop.png" alt></p><p><img src="/images/netty_ev_lp_grp.png" alt></p><ul><li><p>EventLoopGroup</p><ul><li>包括多个EventLoop</li><li>多个EventLoop之间不交互</li></ul></li><li><p>EventLoop</p><ul><li>每个EventLoop对应一个线程</li><li>所有连接(channel)都将注册到一个EventLoop，并且只注册到一个，整个生命周期中都不会变化</li><li>每个EventLoop管理着多个连接(channel)</li><li>EventLoop来处理连接(Channel)上的读写事件</li></ul></li><li><p>ServerBootstrap</p><ul><li>包括2个不同类型的EventLoopGroup:<ul><li>Parent EventLoop: 负责处理Accept事件，接收请求</li><li>Child EventLoop：负责处理读写事件</li></ul></li></ul></li></ul><p><strong>EventExecutor视图</strong><br><img src="/images/event_executor_view.png" alt></p><ol><li><code>EventExecutorGroup</code>里面有一个<code>EventExecutor</code>数组，保存了多个<code>EventExecutor</code>;<ol start="2"><li><code>EventExecutorGroup</code>是不干什么事情的，当收到一个请后，他就调用<code>next()</code>获得一个它里面的<code>EventExecutor</code>，再调用这个<code>executor</code>的方法；</li><li><code>next()</code>: <code>EventExecutorChooser.next()</code>定义选择<code>EventExecutor</code>的策略；</li></ol></li></ol><h2 id="ByteBuf类型"><a href="#ByteBuf类型" class="headerlink" title="ByteBuf类型"></a>ByteBuf类型</h2><ul><li><p>根据内存的位置</p><ul><li><p>HeapByteBuf </p><ul><li>基于数组- 内部为一个字节数组 (byte array)</li><li>hasArray()返回True</li><li>array()返回其内部的数组，可以对数组进行直接操作</li></ul></li><li><p>DirectByteBuf </p><ul><li>堆外内存</li><li>具有更好的性能</li><li>创建和释放开销更大</li></ul></li></ul></li><li><p>根据是否使用内存池</p><ul><li>Pooled vs Unpooled</li></ul></li><li><p>根据是否使用Unsafe操作(Unsafe)</p><ul><li>Safe vs Unsafe</li></ul></li></ul><p><strong>复合缓冲区（CompositeByteBuf）</strong></p><ul><li>多个ByteBuf组合的视图</li><li>一个ByteBuf列表，可动态的添加和删除其中的 ByteBuf</li><li>可能既包含堆缓冲区，也包含直接缓冲区<br><img src="/images/composite_buf.png" alt></li></ul><h2 id="ByteBuf分配"><a href="#ByteBuf分配" class="headerlink" title="ByteBuf分配"></a>ByteBuf分配</h2><p>不直接通过new来创建，而是通过ByteBufAllocator来创建</p><ul><li>UnpooledByteBufAllocator</li><li>PooledByteBufAllocator<br><img src="/images/byte_buf_uml.png" alt></li></ul><p><img src="/images/byte_buf_allocator.png" alt></p><p><img src="/images/unpooled_allocator.png" alt></p><h2 id="ChannelHandler"><a href="#ChannelHandler" class="headerlink" title="ChannelHandler"></a>ChannelHandler</h2><p>业务处理核心逻辑，用户自定义, Netty 提供2个重要的 ChannelHandler 子接口：</p><ul><li>ChannelInboundHandler - 处理进站数据和所有状态更改事件</li><li>ChannelOutboundHandler - 处理出站数据，允许拦截各种操作</li></ul><p><img src="/images/netty_chan_handler.png" alt></p><p><img src="/images/netty_chanelInbound.png" alt></p><p><img src="/images/channel_outboud_hd.png" alt></p><h2 id="ChannelPipline"><a href="#ChannelPipline" class="headerlink" title="ChannelPipline"></a>ChannelPipline</h2><p>ChannelPipeline是ChannelHandler容器</p><ul><li><p>包括一系列的ChannelHandler实例,用于拦截流经一个 Channel 的入站和出站事件</p></li><li><p>每个Channel都有一个其ChannelPipeline</p></li><li><p>可以修改 ChannelPipeline 通过动态添加和删除 ChannelHandler</p></li><li><p>定义了丰富的API调用来回应入站和出站事件</p></li></ul><p><img src="/images/netty_channel_pipeline.png" alt></p><h2 id="ChannelHandlerContext"><a href="#ChannelHandlerContext" class="headerlink" title="ChannelHandlerContext"></a>ChannelHandlerContext</h2><p>ChannelHandlerContext表示 ChannelHandler 和 ChannelPipeline 之间的关联，在 ChannelHandler 添加到 ChannelPipeline 时创建<br><img src="/images/netty_channel_context.png" alt></p><h1 id="Netty线程模型"><a href="#Netty线程模型" class="headerlink" title="Netty线程模型"></a>Netty线程模型</h1><hr><h2 id="Reactor模式-Doug-Lea"><a href="#Reactor模式-Doug-Lea" class="headerlink" title="Reactor模式 - Doug Lea"></a>Reactor模式 - Doug Lea</h2><ul><li>单线程Reactor<br><img src="/images/reactor_single_thread.png" alt="-w822"></li></ul><ul><li>多线程Reactor<br><img src="/images/reactor_multi_thread.png" alt></li></ul><p>所有逻辑都在I/O线程中完成，不开启单独线程。图中对应的TheadPool是在io处理handler中额外开启的业务线程池。</p><ul><li>Multiple Reactor<br><img src="/images/reactor_multi_reactor.png" alt="-w735"></li></ul><p><img src="/images/netty_reactor.png" alt></p><h2 id="Netty与Reactor模式"><a href="#Netty与Reactor模式" class="headerlink" title="Netty与Reactor模式"></a>Netty与Reactor模式</h2><ul><li>单线程Reactor</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">ServerBootStrap bootStrap = <span class="keyword">new</span> ServerBootStrap();</span><br><span class="line">bootStrap.group(bossGroup, bossGroup); <span class="comment">// 监听和处理都由一个线程完成</span></span><br></pre></td></tr></table></figure><ul><li>多线程Reactor</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">ServerBootStrap bootStrap = <span class="keyword">new</span> ServerBootStrap();</span><br><span class="line">bootStrap.group(bossGroup, bossGroup); <span class="comment">// 监听和处理都由一个线程完成</span></span><br><span class="line"><span class="comment">// 在handler中额外使用线程池处理业务</span></span><br></pre></td></tr></table></figure><ul><li>Multiple Reactor</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">ServerBootStrap bootStrap = <span class="keyword">new</span> ServerBootStrap();</span><br><span class="line">bootStrap.group(bossGroup, workerGroup); </span><br><span class="line"><span class="comment">// 在handler中额外使用线程池处理业务</span></span><br></pre></td></tr></table></figure><h2 id="Boss-EventLoopGroup"><a href="#Boss-EventLoopGroup" class="headerlink" title="Boss EventLoopGroup"></a>Boss EventLoopGroup</h2><p><img src="/images/Boss_EventLoopGroup.png" alt></p><p><img src="/images/NioEventLoop_Creation.png" alt></p><h2 id="Worker-EventLoopGroup"><a href="#Worker-EventLoopGroup" class="headerlink" title="Worker EventLoopGroup"></a>Worker EventLoopGroup</h2><p><img src="/images/Worker_EventLoopGroup.png" alt></p><h2 id="Netty-Start-Process"><a href="#Netty-Start-Process" class="headerlink" title="Netty Start Process"></a>Netty Start Process</h2><p><img src="/images/netty_start_process.png" alt></p><h2 id="ServerBootStrap"><a href="#ServerBootStrap" class="headerlink" title="ServerBootStrap"></a>ServerBootStrap</h2><p><img src="/images/serverbootstrap.png" alt></p><h1 id="Netty编码解码"><a href="#Netty编码解码" class="headerlink" title="Netty编码解码"></a>Netty编码解码</h1><hr><h2 id="半包粘包问题"><a href="#半包粘包问题" class="headerlink" title="半包粘包问题"></a>半包粘包问题</h2><ul><li>TCP/IP协议<ul><li>面向“流”协议</li><li>MSS: Maxitum Segment Size 最大分段大小，表示TCP数据包每次能够传输的最大数据分段</li><li>发送方/接收方缓冲区 （Nagle算法）</li></ul></li></ul><p><img src="/images/netty_tcp_frame.png" alt></p><p><strong>解决思路</strong></p><ul><li><p>基本思路就是不断从TCP缓冲区中读取数据，每次读取完都需要判断是否是一个完整的数据包</p><ul><li><p>若当前读取的数据不足以拼接成一个完整的业务数据包，那就保留该数据，继续从tcp缓冲区中读取，直到得到一个完整的数据包</p><ul><li>定长</li><li>分隔符</li><li>基于长度的变长包</li></ul></li><li><p>若当前读到的数据加上已经读取的数据足够拼接成一个数据包，那就将已经读取的数据拼接上本次读取的数据，够成一个完整的业务数据包传递到业务逻辑，多余的数据仍然保留，以便和下次读到的数据尝试拼接</p></li></ul></li></ul><h2 id="常用编码解码器"><a href="#常用编码解码器" class="headerlink" title="常用编码解码器"></a>常用编码解码器</h2><p>编码解码器的作用就是将原始的字节数据与自定义的消息对象进行互相转换，目前业界主流的序列化框架有：</p><ul><li>ProtoBuf</li><li>Jboss Marshalling</li><li>Java Serialization </li></ul><p>Netty常用的自带编解码器有：</p><ul><li><p><strong>LineBasedFrameDecoder</strong>（\n, \r\n)  </p><ul><li>回车换行解码器</li><li>配合StringDecoder</li></ul></li><li><p><strong>DelimiterBasedFrameDecoder</strong></p><ul><li>分隔符解码器</li></ul></li><li><p><strong>FixedLengthFrameDecoder</strong></p><ul><li>固定长度解码器</li></ul></li><li><p><strong>LengthFieldBasedFrameDecoder</strong></p><ul><li>基于包头’<strong>不固定长度</strong>‘解码器(私有协议最常用)</li><li>参数说明<ul><li><strong>maxFrameLength</strong>：包的最大长度</li><li><strong>lengthFieldOffset</strong>：长度属性的起始位（偏移位），包中存放长度属性字段的起始位置</li><li><strong>lengthFieldLength</strong>：长度属性的长度 </li><li><strong>lengthAdjustment</strong>：长度调节值，在总长被定义为包含包头长度时，修正信息长度</li><li><strong>initialBytesToStrip</strong>：跳过的字节数，根据需要跳过lengthFieldLength个字节，以便接收端直接接受到不含“长度属性”的内容</li></ul></li></ul></li></ul><h2 id="Netty拆包的基类-ByteToMessageDecoder"><a href="#Netty拆包的基类-ByteToMessageDecoder" class="headerlink" title="Netty拆包的基类 - ByteToMessageDecoder"></a>Netty拆包的基类 - ByteToMessageDecoder</h2><ul><li><p>内部维护了一个数据累积器<code>cumulation</code>，每次读取到数据都会不断累加，然后尝试对累加到的数据进行拆包，拆成一个完整的业务数据包</p></li><li><p>每次都将读取到的数据通过内存拷贝的方式， 累积到<code>cumulation</code>中</p></li><li><p>调用子类的decode方法对累积的数据尝试进行拆包</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java-NIO-核心概念&quot;&gt;&lt;a href=&quot;#Java-NIO-核心概念&quot; class=&quot;headerlink&quot; title=&quot;Java NIO 核心概念&quot;&gt;&lt;/a&gt;Java NIO 核心概念&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;Linux五种I-O模型比较&quot;&gt;
      
    
    </summary>
    
      <category term="Netty" scheme="http://yoursite.com/categories/Netty/"/>
    
      <category term="基础" scheme="http://yoursite.com/categories/Netty/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Netty" scheme="http://yoursite.com/tags/Netty/"/>
    
      <category term="网络IO" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9CIO/"/>
    
  </entry>
  
  <entry>
    <title>Spring mvc 设计思想与体系结构</title>
    <link href="http://yoursite.com/2020/01/06/Spring-mvc-%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%E4%B8%8E%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2020/01/06/Spring-mvc-设计思想与体系结构/</id>
    <published>2020-01-06T11:22:37.000Z</published>
    <updated>2020-01-10T13:01:56.634Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、spring-mvc-设计思想与体系结构组成"><a href="#一、spring-mvc-设计思想与体系结构组成" class="headerlink" title="一、spring mvc 设计思想与体系结构组成"></a>一、spring mvc 设计思想与体系结构组成</h2><hr><h3 id="回顾servlet-与jsp-执行过程"><a href="#回顾servlet-与jsp-执行过程" class="headerlink" title="回顾servlet 与jsp 执行过程"></a>回顾servlet 与jsp 执行过程</h3><p><img src="/images/servlet_work_process.png" alt="图片"></p><p><strong>流程说明：</strong></p><ol><li>请求Servlet</li><li>处理业务逻辑</li><li>设置业务Model</li><li>forward jsp Servlet</li><li>jsp Servlet 解析封装html 返回</li></ol><p>提问：这个是一个MVC应用场景吗？</p><p>spring mvc本质上还是在使用Servlet处理，并在其基础上进行了封装简化了开发流程，提高易用性、并使用程序逻辑结构变得更清晰</p><ol><li>基于注解的URL映谢</li><li>http表单参数转换</li><li>全局统一异常处理</li><li>拦截器的实现</li></ol><h3 id="spring-mvc-执行流程"><a href="#spring-mvc-执行流程" class="headerlink" title="spring mvc 执行流程"></a>spring mvc 执行流程</h3><p><img src="/images/spring_mvc_work_pro.png" alt="图片"></p><p><strong>整个过程是如何实现的？</strong></p><ol><li>dispatchServlet 如何找到对应的Control？</li><li>如何执行调用Control 当中的业务方法？</li></ol><p>回答这些问题之前我们先来认识一下spring mvc 体系结构</p><h3 id="spring-mvc-体系结构"><a href="#spring-mvc-体系结构" class="headerlink" title="spring mvc 体系结构"></a>spring mvc 体系结构</h3><ul><li><strong>HandlerMapping</strong> <ul><li>url与控制器的映谢</li></ul></li><li><strong>HandlerAdapter</strong><ul><li>控制器执行适配器</li></ul></li><li><strong>ViewResolver</strong><ul><li>视图仓库</li></ul></li><li><strong>view</strong><ul><li>具体解析视图</li></ul></li><li><strong>HandlerExceptionResolver</strong><ul><li>异常捕捕捉器</li></ul></li><li><strong>HandlerInterceptor</strong><ul><li>拦截器</li></ul></li></ul><p><strong>体系结构UML</strong><br><img src="/images/spring_mvc_uml.png" alt="图片"></p><h2 id="二、mvc-执行流程解析"><a href="#二、mvc-执行流程解析" class="headerlink" title="二、mvc 执行流程解析"></a>二、mvc 执行流程解析</h2><hr><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><ol><li>mvc 具体执行流程</li><li>HandlerMapping详解</li><li>HandlerAdapter 详解</li><li>ViewResolver与View详解</li><li>HandlerExceptionResolver详解</li><li>HandlerInterceptor 详解</li></ol><p>mvc 各组件执行流程</p><p><img src="/images/spring_mvc_execute_pro.png" alt="图片"></p><h3 id="HandlerMapping详解"><a href="#HandlerMapping详解" class="headerlink" title="HandlerMapping详解"></a>HandlerMapping详解</h3><p>其为mvc中url路径与Control对像的映射，DispatcherServlet 就是基于此组件来寻找对应的Control，如果找不到就会报<code>Not Found mapping</code> 的异常。</p><p>HandlerMapping 接口方法<br><img src="/images/hendler_mapping_in.png" alt="图片"></p><p>HandlerMapping 接口结构<br><img src="/images/handler_mapping_uml.png" alt="图片"></p><p>目前主流的三种mapping 如下：</p><ul><li><p>BeanNameUrlHandlerMapping<br>基于ioc name 中以 <code>/</code> 开头的Bean时行 注册至映谢.</p></li><li><p>SimpleUrlHandlerMapping<br>基于手动配置 url 与control 映谢</p></li><li><p>RequestMappingHandlerMapping<br>基于<code>@RequestMapping</code>注解配置对应映谢</p></li></ul><p>演示基于 BeanNameUrlHandlerMapping  配置映谢。</p><p>编写mvc 文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--简单控制器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"/user.do"</span> <span class="attr">class</span>=<span class="string">"com.tuling.mvc.control.BeanNameControl"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>beanname control 控制器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanNameControl</span> <span class="keyword">implements</span> <span class="title">HttpRequestHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        request.getRequestDispatcher(<span class="string">"/WEB-INF/page/userView.jsp"</span>).forward(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当IOC 中实例化这些类之后 DispatcherServlet 就会通过<code>org.springframework.web.servlet.DispatcherServlet#getHandler()</code> 方法基于request查找对应Handler。 但找到对应的Handler之后我们发现他是一个Object类型，并没有实现特定接口。如何调用Handler呢？</p><h3 id="HandlerAdapter详解"><a href="#HandlerAdapter详解" class="headerlink" title="HandlerAdapter详解"></a>HandlerAdapter详解</h3><p>这里spring mvc 采用适配器模式来适配调用指定Handler，根据Handler的不同种类采用不同的Adapter, 其Handler与 HandlerAdapter 对应关系如下:</p><table><thead><tr><th align="left">Handler类别</th><th align="left">对应适配器</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">Controller</td><td align="left">SimpleControllerHandlerAdapter</td><td align="left">标准控制器，返回ModelAndView</td></tr><tr><td align="left">HttpRequestHandler</td><td align="left">HttpRequestHandlerAdapter</td><td align="left">业务自行处理 请求，不需要通过modelAndView 转到视图</td></tr><tr><td align="left">Servlet</td><td align="left">SimpleServletHandlerAdapter</td><td align="left">基于标准的servlet 处理</td></tr><tr><td align="left">HandlerMethod</td><td align="left">RequestMappingHandlerAdapter</td><td align="left">基于@requestMapping对应方法处理</td></tr></tbody></table><p>HandlerAdapter  接口方法<br><img src="/images/handler_adapter_interface.png" alt="图片"></p><p>HandlerAdapter  接口结构图<br><img src="/images/handler_adapter_uml.png" alt="图片"></p><p>演示基于Servlet 处理  SimpleServletHandlerAdapter</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置控制器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"/hello.do"</span> <span class="attr">class</span>=<span class="string">"com.tuling.mvc.control.HelloServlet"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 配置适配器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.handler.SimpleServletHandlerAdapter"</span>/&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 标准Servlet</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        resp.getWriter().println(<span class="string">"hello luban "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述例子中当IOC 中实例化这些类之后 DispatcherServlet 就会通过<br>org.springframework.web.servlet.DispatcherServlet#getHandlerAdapter() 方法查找对应handler的适配器 ，如果找不到就会报 <code>No adapter for handler</code> 。</p><h3 id="ViewResolver-与View-详解"><a href="#ViewResolver-与View-详解" class="headerlink" title="ViewResolver 与View 详解"></a>ViewResolver 与View 详解</h3><p>找到应的Adapter 之后就会基于适配器调用业务处理，处理完之后业务方会返回一个ModelAndView ，在去查找对应的视图进行处理。其在<code>org.springframework.web.servlet.DispatcherServlet#resolveViewName()</code> 中遍历 <code>viewResolvers</code> 列表查找，如果找不到就会报一个 <code>Could not resolve view with name</code>异常。</p><p><img src="/images/view_resolver_interface.png" alt="图片"></p><p>下一步就是基于<code>ViewResolver.resolveViewName()</code>获取对应View来解析生成Html并返回 。对应VIEW结构如下：<br><img src="/images/view_resolver_uml.png" alt="图片"></p><p>至此整个正向流程就已经走完了，如果此时程序处理异常 MVC 该如何处理呢？</p><h3 id="HandlerExceptionResolver详解"><a href="#HandlerExceptionResolver详解" class="headerlink" title="HandlerExceptionResolver详解"></a>HandlerExceptionResolver详解</h3><p>该组件用于指示当出现异常时 mvc 该如何处理。 dispatcherServlet 会调用<code>org.springframework.web.servlet.DispatcherServlet#processHandlerException()</code> 方法，遍历 <code>handlerExceptionResolvers</code> 处理异常，处理完成之后返回errorView 跳转到异常视图。</p><p>演示自定义异常捕捉</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleExceptionHandle</span> <span class="keyword">implements</span> <span class="title">HandlerExceptionResolver</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">resolveException</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ModelAndView(<span class="string">"error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 演示异常配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.tuling.mvc.control.SimpleExceptionHandle"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>HandlerExceptionResolver 结构<br><img src="/images/hend_exception_resolver.png" alt="图片"></p><p>除了上述组件之外 spring 中还引入了  我Interceptor 拦截器 机制，类似于Filter。</p><h3 id="HandlerInterceptor详解"><a href="#HandlerInterceptor详解" class="headerlink" title="HandlerInterceptor详解"></a>HandlerInterceptor详解</h3><p>演示HandlerInterceptor </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleHandlerInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"preHandle"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"postHandle"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"afterCompletion"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置interceptor 组件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.tuling.mvc.control.SimpleHandlerInterceptor"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其实现机制是基于 HandlerExecutionChain 分别在 doDispatch 方法中执行以下方法：</p><ul><li>preHandle ：业务处理前执行</li><li>postHandle：业务处理后（异常则不执行）</li><li>afterCompletion：视图处理后</li></ul><p>具体逻辑源码参见：<code>org.springframework.web.servlet.DispatcherServlet#doDispatch</code> 方法。</p><h2 id="三、注解配置"><a href="#三、注解配置" class="headerlink" title="三、注解配置"></a>三、注解配置</h2><hr><p>演示基于注解配置mvc mapping </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.tuling.mvc.control"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 注解驱动 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 视图仓库 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span>  <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/page/"</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">".jsp"</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"viewClass"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">value</span>=<span class="string">"org.springframework.web.servlet.view.JstlView"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注解方法</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/hello.do"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ModelAndView mv = <span class="keyword">new</span> ModelAndView(<span class="string">"userView"</span>);</span><br><span class="line">    mv.addObject(<span class="string">"name"</span>, <span class="string">"luban"</span>);</span><br><span class="line">    <span class="keyword">return</span> mv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提问 为什么基于 <code>&lt;mvc:annotation-driven/&gt;</code> 配置就能实现mvc 的整个配置了，之前所提到的 <code>handlerMapping</code> 、与 <code>handlerAdapter</code> 组件都不适用了？</p><p>只要查看以类的源就可以知晓其中原因：</p><ul><li><input disabled type="checkbox"> 认识 NamespaceHandler 接口</li><li><input disabled type="checkbox"> 查看 MvcNamespaceHandler</li><li><input disabled type="checkbox"> 查看AnnotationDrivenBeanDefinitionParser</li></ul><p><strong>结论</strong><br>在 <code>&lt;mvc:annotation-driven /&gt;</code>  对应的解析器，自动向 ioc  里面注册了两个BeanDefinition。分别是：<code>RequestMappingHandlerMapping</code> 与<code>BeanNameUrlHandlerMapping</code>.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、spring-mvc-设计思想与体系结构组成&quot;&gt;&lt;a href=&quot;#一、spring-mvc-设计思想与体系结构组成&quot; class=&quot;headerlink&quot; title=&quot;一、spring mvc 设计思想与体系结构组成&quot;&gt;&lt;/a&gt;一、spring mvc 设
      
    
    </summary>
    
      <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
      <category term="Spring Mvc" scheme="http://yoursite.com/categories/Spring/Spring-Mvc/"/>
    
    
      <category term="原理" scheme="http://yoursite.com/tags/%E5%8E%9F%E7%90%86/"/>
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring事务底层基本原理</title>
    <link href="http://yoursite.com/2020/01/03/Spring%E4%BA%8B%E5%8A%A1%E5%BA%95%E5%B1%82%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2020/01/03/Spring事务底层基本原理/</id>
    <published>2020-01-03T13:14:14.000Z</published>
    <updated>2020-01-10T13:01:56.584Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据库的事务基本特性"><a href="#数据库的事务基本特性" class="headerlink" title="数据库的事务基本特性"></a>数据库的事务基本特性</h2><p>事物是区分文件存储系统与Nosql数据库重要特性之一，其存在的意义是为了保证即使在并发情况下也能正确的执行crud操作。怎样才算是正确的呢？这时提出了事物需要保证的四个特性即ACID：</p><ul><li><p>A: 原子性(atomicity)<br>事物中各项操作，要么全做要么全不做，任何一项操作的失败都会导致整个事物的失败；</p></li><li><p>C: 一致性(consistency)<br>事物结束后系统状态是一致的；</p></li><li><p>I:  隔离性(isolation)<br>并发执行的事物彼此无法看到对方的中间状态；</p></li><li><p>D: 持久性(durability)<br>事物完成后所做的改动都会被持久化，即使发生灾难性的失败。</p></li></ul><p>在高并发的情况下，要完全保证其ACID特性是非常困难的，除非把所有的事物串行化执行，但带来的负面的影响将是性能大打折扣。很多时候我们有些业务对事物的要求是不一样的，所以数据库中设计了四种隔离级别，供用户基于业务进行选择。</p><p><img src="/images/mysql_tx_isolation.png" alt></p><ul><li><p>脏读 :<br>一个事物读取到另一事物未提交的更新数据</p></li><li><p>不可重复读 :<br>在同一事物中,多次读取同一数据返回的结果有所不同, 换句话说, 后续读取可以读到另一事物已提交的更新数据. 相反, “可重复读”在同一事物中多次读取数据时, 能够保证所读数据一样, 也就是后续读取不能读到另一事物已提交的更新数据。</p></li><li><p>幻读 :<br>查询表中一条数据如果不存在就插入一条，并发的时候却发现，里面居然有两条相同的数据。这就幻读的问题。</p></li></ul><p><strong>数据库默认隔离级别：</strong></p><ul><li>Oracle中默认级别是 Read committed</li><li>mysql 中默认级别 Repeatable read。另外要注意的是mysql 执行一条查询语句默认是一个独立的事物，所以看上去效果跟Read committed一样。</li></ul><p><strong>查看mysql 的默认隔离级别</strong>  </p><blockquote><p>SELECT @@tx_isolation</p></blockquote><h2 id="Spring对事务的支持与使用"><a href="#Spring对事务的支持与使用" class="headerlink" title="Spring对事务的支持与使用"></a>Spring对事务的支持与使用</h2><h3 id="spring-事物相关API说明"><a href="#spring-事物相关API说明" class="headerlink" title="spring 事物相关API说明"></a>spring 事物相关API说明</h3><p>spring 事物是在数据库事物的基础上进行封装扩展，其主要特性如下：</p><ul><li>支持原有的数据事物的隔离级别；</li><li>加入了事物传播的概念，提供多个事物的合并或隔离的功能；</li><li>提供声明式事物，让业务代码与事物分离，事物变得更易用；</li></ul><p>怎么样去使用Spring事物呢？spring提供了三个接口供使用事物。分别是：</p><ul><li><p><code>TransactionDefinition</code><br>事物定义</p></li><li><p><code>PlatformTransactionManager</code><br>事物管理</p></li><li><p><code>TransactionStatus</code><br>事物运行时状态</p></li></ul><p>接口结构图：</p><p><img src="/images/spring_tx_stucture.png" alt></p><h3 id="基于API实现事物"><a href="#基于API实现事物" class="headerlink" title="基于API实现事物"></a>基于API实现事物</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringTransactionExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String url = <span class="string">"jdbc:mysql://192.168.0.147:3306/luban2"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String user = <span class="string">"root"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String password = <span class="string">"123456"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">openConnection</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException, SQLException </span>&#123;</span><br><span class="line">        Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">        Connection conn = DriverManager.getConnection(<span class="string">"jdbc:mysql://192.168.0.147:3306/luban2"</span>, <span class="string">"root"</span>, <span class="string">"123456"</span>);</span><br><span class="line">        <span class="keyword">return</span> conn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> DataSource ds = <span class="keyword">new</span> DriverManagerDataSource(url, user, password);</span><br><span class="line">        <span class="keyword">final</span> TransactionTemplate template = <span class="keyword">new</span> TransactionTemplate();</span><br><span class="line">        template.setTransactionManager(<span class="keyword">new</span> DataSourceTransactionManager(ds));</span><br><span class="line">        template.execute(<span class="keyword">new</span> TransactionCallback&lt;Object&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">doInTransaction</span><span class="params">(TransactionStatus status)</span> </span>&#123;</span><br><span class="line">                Connection conn = DataSourceUtils.getConnection(ds);</span><br><span class="line">                Object savePoint = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// 插入</span></span><br><span class="line">                        PreparedStatement prepare = conn.</span><br><span class="line">                                prepareStatement(<span class="string">"insert INTO account (accountName,user,money) VALUES (?,?,?)"</span>);</span><br><span class="line">                        prepare.setString(<span class="number">1</span>, <span class="string">"111"</span>);</span><br><span class="line">                        prepare.setString(<span class="number">2</span>, <span class="string">"aaaa"</span>);</span><br><span class="line">                        prepare.setInt(<span class="number">3</span>, <span class="number">10000</span>);</span><br><span class="line">                        prepare.executeUpdate();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 设置保存点</span></span><br><span class="line">                    savePoint = status.createSavepoint();</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// 插入</span></span><br><span class="line">                        PreparedStatement prepare = conn.</span><br><span class="line">                                prepareStatement(<span class="string">"insert INTO account (accountName,user,money) VALUES (?,?,?)"</span>);</span><br><span class="line">                        prepare.setString(<span class="number">1</span>, <span class="string">"222"</span>);</span><br><span class="line">                        prepare.setString(<span class="number">2</span>, <span class="string">"bbb"</span>);</span><br><span class="line">                        prepare.setInt(<span class="number">3</span>, <span class="number">10000</span>);</span><br><span class="line">                        prepare.executeUpdate();</span><br><span class="line">                    &#125;</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// 更新</span></span><br><span class="line">                        PreparedStatement prepare = conn.</span><br><span class="line">                                prepareStatement(<span class="string">"UPDATE account SET money= money+1 where user=?"</span>);</span><br><span class="line">                        prepare.setString(<span class="number">1</span>, <span class="string">"asdflkjaf"</span>);</span><br><span class="line">                        Assert.isTrue(prepare.executeUpdate() &gt; <span class="number">0</span>, <span class="string">""</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"更新失败"</span>);</span><br><span class="line">                    <span class="keyword">if</span> (savePoint != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        status.rollbackToSavepoint(savePoint);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        status.setRollbackOnly();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="声明示事物"><a href="#声明示事物" class="headerlink" title="声明示事物"></a>声明示事物</h3><p>我们前面是通过调用API来实现对事物的控制，这非常的繁琐，与直接操作JDBC事物并没有太多的改善，所以Spring提出了声明示事物，使我们对事物的操作变得非常简单，甚至不需要关心它。</p><ul><li>配置spring.xml</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/tx/spring-tx.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/aop/spring-aop.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.tuling.service.**"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.core.JdbcTemplate"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- similarly, don't forget the PlatformTransactionManager --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"txManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- don't forget the DataSource --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DriverManagerDataSource"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://192.168.0.147/luban2"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"123456"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">"txManager"</span>&gt;</span><span class="tag">&lt;/<span class="name">tx:annotation-driven</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>编写服务类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAccount</span><span class="params">(String name, <span class="keyword">int</span> initMenoy)</span> </span>&#123;</span><br><span class="line">    String accountid = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyyMMddhhmmss"</span>).format(<span class="keyword">new</span> Date());</span><br><span class="line">    jdbcTemplate.update(<span class="string">"insert INTO account (accountName,user,money) VALUES (?,?,?)"</span>, accountid, name, initMenoy);</span><br><span class="line">    <span class="comment">// 人为报错, 触发回滚</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="事物传播机制"><a href="#事物传播机制" class="headerlink" title="事物传播机制"></a>事物传播机制</h2><table>    <tr>        <td><b>类别</b></td>         <td><b>事务传播类型</b></td>         <td><b>说明</b></td>    </tr>    <tr>        <td rowspan="3">支持当前事务</td>            <td>PROPAGATION_REQUIRED         （必须的）</td>          <td>如果当前没有事物，就新建一个事物，如果已经存在一个事物中，          加入到这个事物中。这是最常见的选择</td>      </tr>    <tr>        <td>PROPAGATION_SUPPORTS（支持）</td>          <td>支持当前事物，如果当前没有事物，就以非事物方式执行</td>      </tr>    <tr>        <td>PROPAGATION_MANDATORY（强制）</td>          <td>使用当前的事物，如果当前没有事物，就抛出异常</td>      </tr>    <tr>        <td rowspan="3">不支持当前事物</td>            <td>PROPAGATION_REQUIRES_NEW(隔离)</td>          <td>新建事物，如果当前存在事物，把当前事物挂起</td>      </tr>    <tr>        <td>PROPAGATION_NOT_SUPPORTED(不支持)</td>          <td>以非事物方式执行操作，如果当前存在事物，就把当前事物挂起</td>      </tr>    <tr>        <td>PROPAGATION_NEVER(强制非事物)</td>          <td>以非事物方式执行，如果当前存在事物，则抛出异常</td>      </tr>    <tr>        <td>嵌套事物</td>          <td>PROPAGATION_NESTED（嵌套事物）</td>          <td>如果当前存在事物，则在嵌套事物内执行。如果当前没有事物，        则执行与PROPAGATION_REQUIRED类似的操作。</td>      </tr></table><p>常用事物传播机制：</p><ul><li><p><strong>PROPAGATION_REQUIRED</strong><br>这个也是默认的传播机制；</p></li><li><p><strong>PROPAGATION_NOT_SUPPORTED</strong><br>可以用于发送提示消息，站内信、短信、邮件提示等。不属于并且不应当影响主体业务逻辑，即使发送失败也不应该对主体业务逻辑回滚；</p></li><li><p><strong>PROPAGATION_REQUIRES_NEW</strong><br>总是新启一个事物，这个传播机制适用于不受父方法事物影响的操作，比如某些业务场景下需要记录业务日志，用于异步反查，那么不管主体业务逻辑是否完成，日志都需要记录下来，不能因为主体业务逻辑报错而丢失日志；</p></li></ul><p><strong>演示常用事物的传播机制</strong></p><p>用例1:<br>创建用户时初始化一个帐户，表结构和服务类如下。</p><table><thead><tr><th>表结构</th><th>服务类</th><th>功能描述</th></tr></thead><tbody><tr><td>user</td><td>UserService</td><td>创建用户并添加账户</td></tr><tr><td>account</td><td>AccountService</td><td>添加账户</td></tr></tbody></table><p><code>UserSerivce.createUser(name)</code> 实现代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createUser</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 新增用户基本信息</span></span><br><span class="line">    jdbcTemplate.update(<span class="string">"INSERT INTO `user` (name) VALUES(?)"</span>, name);</span><br><span class="line">    <span class="comment">//调用accountService添加帐户</span></span><br><span class="line">    accountService.addAccount(name, <span class="number">10000</span>);</span><br><span class="line"> ｝</span><br></pre></td></tr></table></figure><p><code>AccountService.addAccount(name,initMoney)</code> 实现代码（方法的最后有一个异常）:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span>(propagation = Propagation.REQUIRED)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAccount</span><span class="params">(String name, <span class="keyword">int</span> initMoney)</span> </span>&#123;</span><br><span class="line">    String accountid = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyyMMddhhmmss"</span>).format(<span class="keyword">new</span> Date());</span><br><span class="line">    jdbcTemplate.update(<span class="string">"insert INTO account (accountName,user,money) VALUES (?,?,?)"</span>, accountid, name, initMenoy);</span><br><span class="line">    <span class="comment">// 出现分母为零的异常</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实验预测：</p><p><img src="/images/spring_tx_test.png" alt></p><h2 id="AOP事务底层实现原理"><a href="#AOP事务底层实现原理" class="headerlink" title="AOP事务底层实现原理"></a>AOP事务底层实现原理</h2><p>讲事物原理之前我们先来做一个实验，当场景五的环境改变，把 <code>addAccount</code> 方法移至<code>UserService</code>类下，其它配置和代码不变：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createUser</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    jdbcTemplate.update(<span class="string">"INSERT INTO `user` (name) VALUES(?)"</span>, name);</span><br><span class="line">    addAccount(name, <span class="number">10000</span>);</span><br><span class="line">    <span class="comment">// 人为报错</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional</span>(propagation = Propagation.REQUIRES_NEW)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAccount</span><span class="params">(String name, <span class="keyword">int</span> initMoney)</span> </span>&#123;</span><br><span class="line">    String accountid = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyyMMddhhmmss"</span>).format(<span class="keyword">new</span> Date());</span><br><span class="line">    jdbcTemplate.update(<span class="string">"insert INTO account (accountName,user,money) VALUES (?,?,?)"</span>, accountid, name, initMoney);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过测试我们发现得出的结果与场景五并不一至，<code>required_new</code> 没有起到其对应的作用。原因在于 <strong>spring 声明示事物使用动态代理实现</strong>，而<strong>当调用同一个类的方法时，是会不会走代理逻辑的，自然事物的配置也会失效</strong>。</p><p>通过一个动态代理的实现来模拟这种场景</p><blockquote><p>UserService.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createUser</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addAccount</span><span class="params">(String name, <span class="keyword">int</span> initMoney)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>UserServiceImpl.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String url = <span class="string">"jdbc:mysql://10.101.38.255:8036/tuling"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String user = <span class="string">"root"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String password = <span class="string">"xxxxx"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DataSource dataSource;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        dataSource = <span class="keyword">new</span> DriverManagerDataSource(url, user, password);</span><br><span class="line">        jdbcTemplate = <span class="keyword">new</span> JdbcTemplate(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createUser</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        jdbcTemplate.update(<span class="string">"INSERT INTO `user` (name) VALUES(?)"</span>, name);</span><br><span class="line">        addAccount(name, <span class="number">10000</span>);</span><br><span class="line">        <span class="comment">// 人为报错</span></span><br><span class="line">        <span class="comment">//        int i = 1 / 0;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAccount</span><span class="params">(String name, <span class="keyword">int</span> initMoney)</span> </span>&#123;</span><br><span class="line">        String accountid = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyyMMddhhmmss"</span>).format(<span class="keyword">new</span> Date());</span><br><span class="line">        jdbcTemplate.update(<span class="string">"insert INTO account (accountName,user,money) VALUES (?,?,?)"</span>, accountid, name, initMoney);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>TransactionProxy.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionProxy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> UserService userSerivce = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        UserService proxyUserService = (UserService) Proxy.newProxyInstance(TransactionProxy.class.getClassLoader(),</span><br><span class="line">                <span class="keyword">new</span> Class[] &#123;UserService.class&#125;, <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            System.out.println(<span class="string">"开启事物:"</span> + method.getName());</span><br><span class="line">                            <span class="keyword">return</span> method.invoke(userSerivce, args);</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            System.out.println(<span class="string">"关闭事物:"</span> + method.getName());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        proxyUserService.createUser(<span class="string">"luban"</span>);</span><br><span class="line">        proxyUserService.addAccount(<span class="string">"austin"</span>, <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们调用 <code>createUser</code> 方法时, 仅打印了 <code>createUser</code>  的事物开启、关闭，并没有打印<code>addAccount</code>方法的事物开启、关闭，由此可见 <code>addAccount</code>  的事物配置是失效的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;数据库的事务基本特性&quot;&gt;&lt;a href=&quot;#数据库的事务基本特性&quot; class=&quot;headerlink&quot; title=&quot;数据库的事务基本特性&quot;&gt;&lt;/a&gt;数据库的事务基本特性&lt;/h2&gt;&lt;p&gt;事物是区分文件存储系统与Nosql数据库重要特性之一，其存在的意义是为了保证
      
    
    </summary>
    
      <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
      <category term="Spring Mvc" scheme="http://yoursite.com/categories/Spring/Spring-Mvc/"/>
    
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
      <category term="事务" scheme="http://yoursite.com/tags/%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>Spring 核心组件</title>
    <link href="http://yoursite.com/2020/01/02/Spring-%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/"/>
    <id>http://yoursite.com/2020/01/02/Spring-核心组件/</id>
    <published>2020-01-02T11:38:35.000Z</published>
    <updated>2020-01-10T13:01:56.802Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实体Bean的创建"><a href="#实体Bean的创建" class="headerlink" title="实体Bean的创建"></a>实体Bean的创建</h2><h3 id="基于Class构建"><a href="#基于Class构建" class="headerlink" title="基于Class构建"></a>基于Class构建</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean class=&quot;com.tuling.spring.HelloSpring&quot;&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>这是最常规的方法，其原理是在spring底层会基于class属性通过反射进行构建。</p><h3 id="构造方法构建"><a href="#构造方法构建" class="headerlink" title="构造方法构建"></a>构造方法构建</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean class=&quot;com.tuling.spring.HelloSpring&quot;&gt;</span><br><span class="line">    &lt;constructor-arg name=&quot;name&quot; type=&quot;java.lang.String&quot; value=&quot;luban&quot;/&gt;</span><br><span class="line">    &lt;constructor-arg index=&quot;1&quot; type=&quot;java.lang.String&quot; value=&quot;sex&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>如果需要基于参数进行构建，就采用构造方法构建，其对应属性如下：<br><strong>name:</strong> 构造方法参数变量名称<br><strong>type:</strong> 参数类型<br><strong>index:</strong> 参数索引，从0开始<br><strong>value:</strong> 参数值，spring 会自动转换成参数实际类型值<br><strong>ref:</strong> 引用容器的其它对象</p><h3 id="静态工厂方法创建"><a href="#静态工厂方法创建" class="headerlink" title="静态工厂方法创建"></a>静态工厂方法创建</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.tuling.spring.HelloSpring"</span> <span class="attr">factory-method</span>=<span class="string">"build"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"type"</span> <span class="attr">type</span>=<span class="string">"java.lang.String"</span> <span class="attr">value</span>=<span class="string">"B"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果你正在对一个对象进行A/B测试 ，就可以采用静态工厂方法的方式创建，其于策略创建不同的对像或填充不同的属性。<br>该模式下必须创建一个静态工厂方法，并且方法返回该实例，spring 会调用该静态方法创建对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HelloSpring <span class="title">build</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (type.equals(<span class="string">"A"</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HelloSpring(<span class="string">"luban"</span>, <span class="string">"man"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="string">"B"</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HelloSpring(<span class="string">"diaocan"</span>, <span class="string">"woman"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"type must A or B"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="FactoryBean创建"><a href="#FactoryBean创建" class="headerlink" title="FactoryBean创建"></a>FactoryBean创建</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 返回的并不是LubanFactoryBean实例，而是被LubanFactoryBean包装的实例 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.tuling.spring.LubanFactoryBean"</span> <span class="attr">id</span>=<span class="string">"lubanFactoryBean"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>指定一个Bean工厂来创建对象，对象构建初始化完全交给该工厂来实现。配置Bean时指定该工厂类的类名。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LubanFactoryBean只是起到一层包装代理作用 </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LubanFactoryBean</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 真正创建的bean实例</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HelloSpring();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> HelloSpring.class;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Bean的基本特性"><a href="#Bean的基本特性" class="headerlink" title="Bean的基本特性"></a>Bean的基本特性</h2><h3 id="作用范围"><a href="#作用范围" class="headerlink" title="作用范围"></a>作用范围</h3><p>很多时候Bean对象是无状态的 ，而有些又是有状态的, 无状态的对象我们采用单例即可，而有状态则必须是多例的模式，通过scope即可创建</p><blockquote><p>scope=“prototype”<br>scope=“singleton”</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.tuling.spring.HelloSpring"</span> <span class="attr">scope</span>=<span class="string">"prototype"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果一个Bean设置成<code>prototype</code>我们可以 通过<code>BeanFactoryAware</code>获取 <code>BeanFactory</code>对象即可每次获取的都是新对像。</p><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>Bean对象的<strong>创建</strong>、<strong>初始化</strong>、<strong>销毁</strong>即是Bean的生命周期。通过 <code>init-method</code>、<code>destroy-method</code>属性可以分别指定期构建方法与初始方法。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.tuling.spring.HelloSpring"</span> <span class="attr">init-method</span>=<span class="string">"init"</span> <span class="attr">destroy-method</span>=<span class="string">"destroy"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果觉得麻烦，可以让Bean去实现 <code>InitializingBean.afterPropertiesSet()</code>、<code>DisposableBean.destroy()</code>方法。分别对应初始和销毁方法。</p><h3 id="加载机制"><a href="#加载机制" class="headerlink" title="加载机制"></a>加载机制</h3><p>指示Bean在何时进行加载。设置<code>lazy-init</code>即可，其值如下：</p><blockquote><p>true: 懒加载，即延迟加载<br>false: 非懒加载，容器启动时即创建对象<br>default: 默认，采用default-lazy-init中指定值，如果default-lazy-init 没指定就是false</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span></span></span><br><span class="line"><span class="tag"><span class="attr">default-lazy-init</span>=<span class="string">"true"</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>什么时候使用懒加载？</strong><br>懒加载会容器启动的更快，而非懒加载可以容器启动时更快的发现程序当中的错误 ，选择哪一个就看追求的是启动速度，还是希望更早的发现错误，一般我们会选择后者。</p><h2 id="Bean的构建过程"><a href="#Bean的构建过程" class="headerlink" title="Bean的构建过程"></a>Bean的构建过程</h2><p><code>spring.xml</code>文件中保存了我们对Bean的描述配置，<code>BeanFactory</code>会读取这些配置然后生成对应的Bean。这是我们对ioc原理的一般理解。但在深入一些我们会有更多的问题:</p><ol><li>配置信息最后是谁JAVA中哪个对象承载的？</li><li>这些承载对象是谁业读取XML文件并装载的？</li><li>这些承载对象又是保存在哪里？</li></ol><h3 id="BeanDefinition（Bean定义）"><a href="#BeanDefinition（Bean定义）" class="headerlink" title="BeanDefinition（Bean定义）"></a>BeanDefinition（Bean定义）</h3><p>ioc实现中我们在xml中描述的Bean信息最后都将保存至<code>BeanDefinition</code> （定义）对象中，其中<code>xml bean</code> 与<code>BeanDefinition</code> 是一对一的关系。</p><p><img src="/images/spring_bean_definition.png" alt></p><p>由此可见，xml  bean中设置的属性最后都会体现在BeanDefinition中。如:</p><table><thead><tr><th align="left">XML-bean</th><th align="left"><strong>BeanDefinition</strong></th></tr></thead><tbody><tr><td align="left">class</td><td align="left">beanClassName</td></tr><tr><td align="left">scope</td><td align="left">scope</td></tr><tr><td align="left">lazy-init</td><td align="left">lazyInit</td></tr><tr><td align="left">constructor-arg</td><td align="left">ConstructorArgument</td></tr><tr><td align="left">property</td><td align="left">MutablePropertyValues</td></tr><tr><td align="left">factory-method</td><td align="left">factoryMethodName</td></tr><tr><td align="left">destroy-method</td><td align="left">AbstractBeanDefinition.destroyMethodName</td></tr><tr><td align="left">init-method</td><td align="left">AbstractBeanDefinition.initMethodName</td></tr><tr><td align="left">autowire</td><td align="left">AbstractBeanDefinition.autowireMode</td></tr><tr><td align="left">id</td><td align="left"></td></tr><tr><td align="left">name</td><td align="left"></td></tr></tbody></table><p>BeanDefinition属性结构<br><img src="/images/bean_definition_property_structure.png" alt></p><h3 id="BeanDefinitionRegistry（Bean注册器）"><a href="#BeanDefinitionRegistry（Bean注册器）" class="headerlink" title="BeanDefinitionRegistry（Bean注册器）"></a>BeanDefinitionRegistry（Bean注册器）</h3><p>在上表中我们并没有看到 <code>xml bean</code> 中的 <code>id</code>  和<code>name</code>属性， 没有体现在定义中，原因是ID其作为当前Bean的存储key注册到了<code>BeanDefinitionRegistry</code> 注册器中。<code>name</code> 作为<strong>别名key</strong> 注册到了 <code>AliasRegistry</code> 注册中心。其最后都是指向其对应的<code>BeanDefinition</code>。</p><p><img src="/images/bean_definition_register.png" alt></p><h3 id="BeanDefinitionReader（Bean定义读取）"><a href="#BeanDefinitionReader（Bean定义读取）" class="headerlink" title="BeanDefinitionReader（Bean定义读取）"></a>BeanDefinitionReader（Bean定义读取）</h3><p>至此我们学习了 <code>BeanDefinition</code> 中存储了<code>Xml Bean</code>信息，而<code>BeanDefinitionRegister</code> 基于<code>ID</code>和<code>name</code> 保存了Bean的定义。接下要学习的是从<code>xml Bean</code>到<code>BeanDefinition</code>然后在注册至<code>BeanDefinitionRegister</code> 整个过程。</p><p><img src="/images/bean_definition_reader.png" alt></p><p>上图中可以看出Bean的定义是由<code>BeanDefinitionReader</code> 从xml 中读取配置并构建出 <code>BeanDefinitionReader</code>, 然后在基于别名注册到<code>BeanDefinitionRegister</code>中.</p><p>BeanDefinitionReader结构<br><img src="/images/bena_definition_read_st.png" alt></p><p>方法说明：</p><ul><li><p><strong>loadBeanDefinitions(Resource resource)</strong></p><ul><li>基于资源装载Bean定义并注册至注册器</li></ul></li><li><p><strong>int loadBeanDefinitions(String location)</strong></p><ul><li>基于资源路径装载Bean定义并注册至注册器</li></ul></li><li><p><strong>BeanDefinitionRegistry getRegistry()</strong></p><ul><li>获取注册器</li></ul></li><li><p><strong>ResourceLoader getResourceLoader()</strong></p><ul><li>获取资源装载器</li></ul></li></ul><p>BeanDefinitionReader装载过程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个简单注册器</span></span><br><span class="line">BeanDefinitionRegistry register = <span class="keyword">new</span> SimpleBeanDefinitionRegistry();</span><br><span class="line"><span class="comment">//创建bean定义读取器</span></span><br><span class="line">BeanDefinitionReader reader = <span class="keyword">new</span> XmlBeanDefinitionReader(register);</span><br><span class="line"><span class="comment">// 创建资源读取器</span></span><br><span class="line">DefaultResourceLoader resourceLoader = <span class="keyword">new</span> DefaultResourceLoader();</span><br><span class="line"><span class="comment">// 获取资源</span></span><br><span class="line">Resource xmlResource = resourceLoader.getResource(<span class="string">"spring.xml"</span>);</span><br><span class="line"><span class="comment">// 装载Bean的定义</span></span><br><span class="line">reader.loadBeanDefinitions(xmlResource);</span><br><span class="line"><span class="comment">// 打印构建的Bean 名称</span></span><br><span class="line">System.out.println(Arrays.toString(register.getBeanDefinitionNames());</span><br></pre></td></tr></table></figure><h3 id="Beanfactory-bean-工厂"><a href="#Beanfactory-bean-工厂" class="headerlink" title="Beanfactory(bean 工厂)"></a>Beanfactory(bean 工厂)</h3><p>有了Bean的定义就相当于有了产品的配方，接下来就是要把这个配方送到工厂进行生产了。在ioc当中Bean的构建是由 <code>BeanFactory</code> 负责的。其结构如下：<br><img src="/images/bean_factory.png" alt></p><p>方法说明：</p><ul><li><p><strong>getBean(String)</strong></p><ul><li>基于ID或name 获取一个Bean</li></ul></li><li><p>**<t> T getBean(Class<t> requiredType) **</t></t></p><ul><li>基于Bean的类别获取一个Bean（如果出现多个该类的实例，将会报错。但可以指定 primary=“true” 调整优先级来解决该错误 ）</li></ul></li><li><p><strong>Object getBean(String name, Object… args)</strong></p><ul><li>基于名称获取一个Bean，并覆盖默认的构造参数</li></ul></li><li><p><strong>boolean isTypeMatch(String name, Class&lt;?&gt; typeToMatch)</strong></p><ul><li>指定Bean与指定Class 是否匹配</li></ul></li></ul><p>以上方法中重点要关注getBean，当用户调用getBean的时候就会触发 Bean的创建动作:</p><p>基本BeanFactory获取一个Bean, 以下是运行时的栈信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 其反射实例化Bean</span></span><br><span class="line">java.lang.reflect.Constructor.newInstance(Unknown Source:-<span class="number">1</span>)</span><br><span class="line">BeanUtils.instantiateClass()</span><br><span class="line"><span class="comment">//基于实例化策略 实例化Bean</span></span><br><span class="line">SimpleInstantiationStrategy.instantiate()</span><br><span class="line">AbstractAutowireCapableBeanFactory.instantiateBean()</span><br><span class="line"><span class="comment">// 执行Bean的实例化方法</span></span><br><span class="line">AbstractAutowireCapableBeanFactory.createBeanInstance()</span><br><span class="line">AbstractAutowireCapableBeanFactory.doCreateBean()</span><br><span class="line"><span class="comment">// 执行Bean的创建</span></span><br><span class="line">AbstractAutowireCapableBeanFactory.createBean()</span><br><span class="line"><span class="comment">// 缓存中没有，调用指定Bean工厂创建Bean</span></span><br><span class="line">AbstractBeanFactory$<span class="number">1</span>.getObject()</span><br><span class="line"><span class="comment">// 从单例注册中心获取Bean缓存</span></span><br><span class="line">DefaultSingletonBeanRegistry.getSingleton()</span><br><span class="line">AbstractBeanFactory.doGetBean()</span><br><span class="line"><span class="comment">// 获取Bean</span></span><br><span class="line">AbstractBeanFactory.getBean()</span><br><span class="line"><span class="comment">// 调用的客户类</span></span><br><span class="line">com.tuling.spring.BeanFactoryExample.main()</span><br></pre></td></tr></table></figure><h3 id="Bean创建时序图"><a href="#Bean创建时序图" class="headerlink" title="Bean创建时序图"></a>Bean创建时序图</h3><p><img src="/images/bean_creation_process.png" alt></p><p>从调用过程可以总结出以下几点：</p><ol><li>调用 <code>BeanFactory.getBean()</code> 会触发Bean的实例化</li><li><code>DefaultSingletonBeanRegistry</code> 中缓存了单例Bean</li><li><code>Bean</code>的创建与初始化是由<code>AbstractAutowireCapableBeanFactory</code>完成的</li></ol><h2 id="BeanFactory-与-ApplicationContext区别"><a href="#BeanFactory-与-ApplicationContext区别" class="headerlink" title="BeanFactory 与 ApplicationContext区别"></a>BeanFactory 与 ApplicationContext区别</h2><p><code>BeanFactory</code> 可以去做IOC当中的大部分事情，为什么还要去定义一个ApplicationContext 呢？</p><p>ApplicationContext 结构图<br><img src="/images/bean_factory_context.png" alt></p><p>从图中可以看到 <code>ApplicationContext</code> 它由 <code>BeanFactory</code> 接口派生而来，因而提供了<code>BeanFactory</code> 所有的功能。除此之外<code>context</code>包还提供了以下的功能：</p><ol><li><code>MessageSource</code>, 提供国际化的消息访问</li><li>资源访问，如URL和文件</li><li>事件传播，实现了<code>ApplicationEventPublisher</code>接口的bean</li><li>载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的web层</li></ol><h2 id="Spring-advice执行顺序"><a href="#Spring-advice执行顺序" class="headerlink" title="Spring advice执行顺序"></a>Spring advice执行顺序</h2><p>advice执行顺序，就是拦截器链的执行顺序 </p><p><img src="/images/spring_advice.png" alt></p><ul><li><p>1、单个切面的场景，<code>around</code>开始 –&gt;  <code>before</code> –&gt; <code>aound</code>结束–&gt; <code>after</code> –&gt; <code>AfterReturning</code></p></li><li><p>2、对于多个切面的场景，可以通过 <code>@order</code>(序号)，来调整执行顺序。</p></li></ul><p>demo参考： <a href="https://blog.csdn.net/hxpjava1/article/details/55504513/" target="_blank" rel="noopener">Spring多个AOP执行先后顺序</a></p><p>源码分析：<br>前置通知拦截器： <code>MethodBeforeAdviceInterceptor#invoke</code><br>拦截器链：<code>ReflectiveMethodInvocation#proceed</code><br><code>proceed</code> 根据 <code>currentInterceptorIndex</code> 来确定当前应执行哪个拦截器，并在调用拦截器的 <code>invoke</code> 方法时，将自己作为参数传给该方法</p><p><img src="/images/spring_advive_procced.png" alt></p><p>参考资料<br><a href="https://www.coolblog.xyz/2018/06/22/Spring-AOP-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E6%8B%A6%E6%88%AA%E5%99%A8%E9%93%BE%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/" target="_blank" rel="noopener">Spring AOP 源码分析 - 拦截器链的执行过程</a><br><a href="https://blog.csdn.net/zly9923218/article/details/51348583" target="_blank" rel="noopener">Spring AOP 源码分析（生成代理对象）</a></p><h2 id="IOC-容器只存放单例bean吗"><a href="#IOC-容器只存放单例bean吗" class="headerlink" title="IOC 容器只存放单例bean吗"></a>IOC 容器只存放单例bean吗</h2><p><strong>结论：IOC 容器只存放单例bean</strong></p><p>IOC容器初始化的时候，会将所有bean初始化在 <code>singletonObjects</code> 这个<code>CurrentHashMap</code> 中， bean是单例的。</p><p>在获取bean的时候，首先会从<code>singletonObjects</code>去取值，通过debug，发现如果scope是单例，则可以获取到bean，如果scope是多例，则获取不到bean，需要 从一个叫 <code>mergedBeanDefinitions</code> 的<code>CurrentHashMap</code>中去获取bean的定义，然后再根据bean的scope去决定如何创建bean，如果<code>scope=prototype</code>，则每次都会创建一个新的实例。</p><p>猜想：IOC在初始化时，只会将 <code>scope = singleton</code>（单例）的对象进行实例化，而不会去实例化<code>scope=prototype</code>的对象（多例）；</p><p>证实：找到<code>singletonObjects.put</code>方法，debug看一下<code>singletonObjects.put</code>的前提条件是什么</p><p><strong>源码分析</strong>：<code>AbstractBeanFactory#doGetBean</code></p><p>单例的场景，直接从 <code>singletonObjects</code> 这个Map中获取bean</p><p><img src="/images/spring_get_bean_sigle.png" alt></p><p>多例的场景，发现从 <code>singletonObjects</code> 中拿不到值</p><p><img src="/images/spring_get_bean_sigle2.png" alt></p><p>接下来，发现它是从一个叫 <code>mergedBeanDefinitions</code>  的<code>HashMap</code>中获取了<code>RootBeanDefinition</code>，里面包含了bean的一些基础信息。</p><p><img src="/images/spring_get_bean_prototype.png" alt></p><p>最后根据 <code>bean的scope</code>属性,来做处理，如果作用域是单例，则直接从容器中获取，如果作用域是多例，则创建一个实例，当然，作用域还有其它，自己可以一一去验证</p><p><img src="/images/spring_get_bean_prototype2.png" alt></p><h2 id="Scope为request的bean是否会放入IOC容器"><a href="#Scope为request的bean是否会放入IOC容器" class="headerlink" title="Scope为request的bean是否会放入IOC容器"></a>Scope为request的bean是否会放入IOC容器</h2><p>这个应该和IOC没有关系，request对象只是一个参数。<br>场景分析：SpringMVC在接受一个http请求后，会根据URl去匹配具体的bean（可以这样理解：<code>bean=Map.get(url)</code>，这个map是在容器初始化的时候创建的），然后通过反射获取class实例，最终执行<code>method.invoke</code>方法的时候，会将request对象的值封装到args数组中，当然args可能还包含<strong>response对象、注解参数、非注解参数的值</strong>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;实体Bean的创建&quot;&gt;&lt;a href=&quot;#实体Bean的创建&quot; class=&quot;headerlink&quot; title=&quot;实体Bean的创建&quot;&gt;&lt;/a&gt;实体Bean的创建&lt;/h2&gt;&lt;h3 id=&quot;基于Class构建&quot;&gt;&lt;a href=&quot;#基于Class构建&quot; class
      
    
    </summary>
    
      <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
      <category term="Spring Mvc" scheme="http://yoursite.com/categories/Spring/Spring-Mvc/"/>
    
    
      <category term="基础" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Java堆默认大小</title>
    <link href="http://yoursite.com/2019/12/31/Java%E5%A0%86%E9%BB%98%E8%AE%A4%E5%A4%A7%E5%B0%8F/"/>
    <id>http://yoursite.com/2019/12/31/Java堆默认大小/</id>
    <published>2019-12-31T11:18:01.000Z</published>
    <updated>2020-01-10T13:01:56.740Z</updated>
    
    <content type="html"><![CDATA[<h2 id="PrintFlagsFinal"><a href="#PrintFlagsFinal" class="headerlink" title="PrintFlagsFinal"></a>PrintFlagsFinal</h2><blockquote><p>-XX:+PrintFlagsFinal<br>打印所有可设置的参数及它们的默认值(从JDK 6 update 21开始才可以用)</p></blockquote><p>示例：16G内存的Centos系统</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> java -XX:+PrintFlagsFinal -version  | grep -E 'HeapSize|PermSize|ThreadStackSize'</span><br><span class="line">     intx CompilerThreadStackSize                   = 0                                   &#123;pd product&#125;</span><br><span class="line">    uintx ErgoHeapSizeLimit                         = 0                                   &#123;product&#125;</span><br><span class="line">    uintx HeapSizePerGCThread                       = 87241520                            &#123;product&#125;</span><br><span class="line">    uintx InitialHeapSize                          := 264241152                           &#123;product&#125;</span><br><span class="line">    uintx LargePageHeapSizeThreshold                = 134217728                           &#123;product&#125;</span><br><span class="line">    uintx MaxHeapSize                              := 4215275520                          &#123;product&#125;</span><br><span class="line">     intx ThreadStackSize                           = 1024                                &#123;pd product&#125;</span><br><span class="line">     intx VMThreadStackSize                         = 1024                                &#123;pd product&#125;</span><br><span class="line">java version "1.8.0_152"</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_152-b16)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.152-b16, mixed mode)</span><br></pre></td></tr></table></figure><p>可以看出默认的:<br>堆最大大小(MaxHeapSize)：4215275520/(1024.0 * 1024 * 1024) = 3.93G<br>初始堆大小(InitialHeapSiz): 266338304/(1024.0 * 1024) = 254M<br>HeapSizePerGCThread: 87241520 / (1024.0 * 1024) = 83.20M</p><h2 id="PrintCommandLineFlags"><a href="#PrintCommandLineFlags" class="headerlink" title="PrintCommandLineFlags"></a>PrintCommandLineFlags</h2><blockquote><p>-XX:+PrintCommandLineFlags</p><p>打印出所有出现在命令行上的可选JVM参数。可用来了解JVM的参数设置，例如堆空间大小、垃圾收集器等。默认情况下，此选项是禁用的，并且不打印标记。</p></blockquote><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> java -XX:+PrintCommandLineFlags -version</span><br><span class="line">-XX:InitialHeapSize=263453376 -XX:MaxHeapSize=4215254016 -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseParallelGC </span><br><span class="line">java version "1.8.0_152"</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_152-b16)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.152-b16, mixed mode)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;PrintFlagsFinal&quot;&gt;&lt;a href=&quot;#PrintFlagsFinal&quot; class=&quot;headerlink&quot; title=&quot;PrintFlagsFinal&quot;&gt;&lt;/a&gt;PrintFlagsFinal&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;-XX:+
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
      <category term="JVM" scheme="http://yoursite.com/categories/Java/JVM/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Spring Bean生命周期</title>
    <link href="http://yoursite.com/2019/12/30/Spring-Bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://yoursite.com/2019/12/30/Spring-Bean生命周期/</id>
    <published>2019-12-30T11:03:22.000Z</published>
    <updated>2020-01-10T13:01:56.820Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring-Bean生命周期"><a href="#Spring-Bean生命周期" class="headerlink" title="Spring Bean生命周期"></a>Spring Bean生命周期</h1><h2 id="生命周期流程"><a href="#生命周期流程" class="headerlink" title="生命周期流程"></a>生命周期流程</h2><p>首先看下生命周期图：<br><img src="/images/spring_bean_process.png" alt></p><p>再来一张执行过程：</p><p><img src="/images/spring_bean_life_process.png" alt></p><p>Spring Bean的生命周期只有四个阶段。要彻底搞清楚Spring的生命周期，首先要把这四个阶段牢牢记住。实例化和属性赋值对应<strong>构造方法</strong>和<strong>setter方法</strong>的注入，<strong>初始化和销毁是用户能自定义扩展的两个阶段</strong>。在这四步之间穿插的各种扩展点。</p><ul><li><p>实例化 Instantiation</p></li><li><p>属性赋值 Populate</p></li><li><p>初始化 Initialization</p></li><li><p>销毁 Destruction</p></li></ul><p><code>实例化 -&gt; 属性赋值 -&gt; 初始化 -&gt; 销毁</code></p><p>主要逻辑都在<code>doCreateBean()</code>方法中，逻辑很清晰，就是顺序调用以下三个方法，这三个方法与三个生命周期阶段一一对应，非常重要，在后续扩展接口分析中也会涉及。</p><blockquote><p><code>createBeanInstance()</code> -&gt; 实例化<br><code>populateBean()</code> -&gt; 属性赋值<br><code>initializeBean()</code> -&gt; 初始化</p></blockquote><p>源码如下，能证明实例化，属性赋值和初始化这三个生命周期的存在。关于本文的Spring源码都将忽略无关部分，便于理解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 忽略了无关代码</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> @Nullable Object[] args)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Instantiate the bean.</span></span><br><span class="line">   BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line">   <span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="comment">// 实例化阶段！</span></span><br><span class="line">      instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Initialize the bean instance.</span></span><br><span class="line">   Object exposedObject = bean;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">// 属性赋值阶段！</span></span><br><span class="line">      populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">       <span class="comment">// 初始化阶段！</span></span><br><span class="line">      exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于销毁，是在容器关闭时调用的，详见<code>ConfigurableApplicationContext#close()</code></p><p>在谈生命周期之前有一点需要先明确：</p><blockquote><p>Spring 只帮我们管理单例模式 Bean 的完整生命周期，对于 prototype 的 bean ，Spring 在创建好交给使用者之后则不会再管理后续的生命周期。</p></blockquote><h2 id="AOP扩展bean生命周期"><a href="#AOP扩展bean生命周期" class="headerlink" title="AOP扩展bean生命周期"></a>AOP扩展bean生命周期</h2><p>Spring生命周期相关的常用切入方式非常多，主要有下列方式：</p><h3 id="注解方式"><a href="#注解方式" class="headerlink" title="注解方式"></a>注解方式</h3><p>在 bean 初始化时会经历几个阶段，首先可以使用注解 @PostConstruct, @PreDestroy 来在 bean 的创建和销毁阶段进行调用。</p><h3 id="两个生命周期接口InitializingBean-DisposableBean"><a href="#两个生命周期接口InitializingBean-DisposableBean" class="headerlink" title="两个生命周期接口InitializingBean, DisposableBean"></a>两个生命周期接口InitializingBean, DisposableBean</h3><p>还可以实现 <code>InitializingBean</code>, <code>DisposableBean</code> 这两个接口，也是在初始化以及销毁阶段调用。实例化和属性赋值都是Spring帮助我们做的，能够自己实现的就只有 <strong>初始化</strong> 和 <strong>销毁</strong> 两个生命周期阶段.</p><ul><li><p><strong>InitializingBean</strong><br>对应生命周期的初始化阶段，在源码的 <code>invokeInitMethods(beanName, wrappedBean, mbd)</code> 方法中调用。</p><p>  有一点需要注意，因为<code>Aware</code>方法都是执行在初始化方法之前，所以可以在初始化方法中放心大胆的使用Aware接口获取的资源，这也是我们自定义扩展Spring的常用方式。<br>  除了实现<code>InitializingBean</code>接口之外还能通过注解或者xml配置的方式指定初始化方法，至于这几种定义方式的调用顺序其实没有必要记。因为这几个方法对应的都是同一个生命周期，只是实现方式不同，我们一般只采用其中一种方式。</p></li><li><p><strong>DisposableBean</strong><br>类似于<code>InitializingBean</code>，对应生命周期的销毁阶段，以<code>ConfigurableApplicationContext#close()</code> 方法作为入口，实现是通过循环取所有实现了<code>DisposableBean</code>接口的Bean然后调用其`destroy() 方法;</p></li></ul><h3 id="自定义初始化和销毁方法"><a href="#自定义初始化和销毁方法" class="headerlink" title="自定义初始化和销毁方法"></a>自定义初始化和销毁方法</h3><p>也可以自定义方法用于在初始化、销毁阶段调用</p><h3 id="实现-Aware-接口"><a href="#实现-Aware-接口" class="headerlink" title="实现 Aware 接口"></a>实现 Aware 接口</h3><p>Aware类型的接口的作用就是让我们能够拿到Spring容器中的一些资源。基本都能够见名知意，Aware之前的名字就是可以拿到什么资源，例如<code>BeanNameAware</code>可以拿到<code>BeanName</code>，以此类推。调用时机需要注意：<strong>所有的Aware方法都是在初始化阶段之前调用的！</strong></p><p>Aware接口具体可以分为两组。如下排列顺序同样也是Aware接口的执行顺序:</p><ul><li><p>Aware Group1</p><blockquote><p>BeanNameAware</p><p>BeanClassLoaderAware</p><p>BeanFactoryAware</p></blockquote></li><li><p>Aware Group2</p><blockquote><p>EnvironmentAware</p></blockquote><p>EmbeddedValueResolverAware 实现该接口能够获取Spring EL解析器，用户的自定义注解需要支持spel表达式的时候可以使用，非常方便。</p><blockquote><p>ApplicationContextAware(ResourceLoaderAware、ApplicationEventPublisherAware、MessageSourceAware) 这几个接口可能让人有点懵，实际上这几个接口可以一起记，其返回值实质上都是当前的ApplicationContext对象，因为ApplicationContext是一个复合接口</p></blockquote></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationContext</span> <span class="keyword">extends</span> <span class="title">EnvironmentCapable</span>, <span class="title">ListableBeanFactory</span>, <span class="title">HierarchicalBeanFactory</span>,</span></span><br><span class="line"><span class="class">        <span class="title">MessageSource</span>, <span class="title">ApplicationEventPublisher</span>, <span class="title">ResourcePatternResolver</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>这里涉及一道面试题，<code>ApplicationContext</code> 和 <code>BeanFactory</code>的区别，可以从<code>ApplicationContext</code> 继承的这几个接口入手，除去 <code>BeanFactory</code> 相关的两个接口就是<code>ApplicationContext</code>独有的功能.</p><h3 id="BeanPostProcessor-InstantiationAwareBeanPostProcessor接口"><a href="#BeanPostProcessor-InstantiationAwareBeanPostProcessor接口" class="headerlink" title="BeanPostProcessor, InstantiationAwareBeanPostProcessor接口"></a>BeanPostProcessor, InstantiationAwareBeanPostProcessor接口</h3><p>增强处理器(<font color="red">容器级别</font>)，实现 BeanPostProcessor 接口，<strong>Spring 中所有 bean 在做初始化时都会调用该接口中的两个方法，</strong>， 正因为如此，这些接口的功能非常强大，Spring内部扩展也经常使用这些接口，例如自动注入以及AOP的实现都和他们有关。</p><p>这是Spring扩展中最重要的两个接口！</p><ul><li><p><code>InstantiationAwareBeanPostProcessor</code>作用于<strong>实例化阶段</strong>的前后；</p></li><li><p><code>BeanPostProcessor</code>作用于<strong>初始化阶段</strong>的前后；</p></li><li><p><code>InstantiationAwareBeanPostProcessor</code>实际上继承了 <code>BeanPostProcessor</code>接口，严格意义上来看他们是两父子;</p></li></ul><h2 id="Aware调用时机源码分析"><a href="#Aware调用时机源码分析" class="headerlink" title="Aware调用时机源码分析"></a>Aware调用时机源码分析</h2><p>详情如下，忽略了部分无关代码。代码位置就是<code>initializeBean</code>方法详情，这也说明了Aware都是在初始化阶段之前调用的！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 见名知意，初始化阶段调用的方法</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">initializeBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Object bean, @Nullable RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里调用的是Group1中的三个Bean开头的Aware</span></span><br><span class="line">        invokeAwareMethods(beanName, bean);</span><br><span class="line"></span><br><span class="line">        Object wrappedBean = bean;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 这里调用的是Group2中的几个Aware，</span></span><br><span class="line">        <span class="comment">// 而实质上这里就是前面所说的BeanPostProcessor的调用点！</span></span><br><span class="line">        <span class="comment">// 也就是说与Group1中的Aware不同，这里是通过BeanPostProcessor（ApplicationContextAwareProcessor）实现的。</span></span><br><span class="line">        wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">        <span class="comment">// 下文即将介绍的InitializingBean调用点</span></span><br><span class="line">        invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">        <span class="comment">// BeanPostProcessor的另一个调用点</span></span><br><span class="line">        wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> wrappedBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到并不是所有的Aware接口都使用同样的方式调用。</p><ul><li>Bean××Aware都是在代码中直接调用的;</li><li>ApplicationContext相关的Aware都是通过<code>BeanPostProcessor#postProcessBeforeInitialization()</code>实现的。</li></ul><p>具体流程可以看一下 <code>ApplicationContextAwareProcessor</code> 这个类的源码，就是判断当前创建的Bean是否实现了相关的Aware方法，如果实现了会调用回调方法将资源传递给Bean。</p><p>至于Spring为什么这么实现，应该没什么特殊的考量。也许和Spring的版本升级有关。基于对修改关闭，对扩展开放的原则，Spring对一些新的Aware采用了扩展的方式添加。</p><p>BeanPostProcessor的调用时机也能在这里体现，包围住 <code>invokeInitMethods</code> 方法，也就说明了在初始化阶段的前后执行。</p><p>关于Aware接口的执行顺序，其实只需要记住第一组在第二组执行之前就行了.</p><h2 id="实例Demo"><a href="#实例Demo" class="headerlink" title="实例Demo"></a>实例Demo</h2><h3 id="User-java"><a href="#User-java" class="headerlink" title="User.java"></a>User.java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Austin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2019/12/2 21:01   Mon</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span>, <span class="title">DisposableBean</span>, <span class="title">BeanNameAware</span>, <span class="title">ApplicationContextAware</span>,</span></span><br><span class="line"><span class="class">        <span class="title">BeanClassLoaderAware</span>, <span class="title">BeanFactoryAware</span>, <span class="title">EnvironmentAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义方法用于在初始化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"调用Bean的函数(initMethod)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postConstructor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"调用Bean的函数(postConstruct)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"调用Bean的函数(constructor)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"调用Bean的函数(setName/setAttribute)"</span>);</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"调用Bean的函数(preDestroy)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"调用Bean的函数(destroy())"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroyMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"调用Bean的函数(destroyMethod)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"调用Bean的函数(afterPropertiesSet)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"调用BeanNameAware的(setBeanName)函数"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"调用ApplicationContextAware的(setApplicationContext)函数"</span>);</span><br><span class="line">        <span class="keyword">this</span>.applicationContext = applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanClassLoader</span><span class="params">(ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"调用BeanClassLoaderAware的(setBeanClassLoader)函数"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanFactory</span><span class="params">(BeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"调用BeanFactoryAware的(setBeanFactory)函数"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEnvironment</span><span class="params">(Environment environment)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"调用EnvironmentAware的(setEnvironment)函数"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CustomBeanPostProcessor-java"><a href="#CustomBeanPostProcessor-java" class="headerlink" title="CustomBeanPostProcessor.java"></a>CustomBeanPostProcessor.java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Austin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2019/12/2 21:10   Mon</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">InstantiationAwareBeanPostProcessor</span>, <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实例化之前调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (beanClass == User.class)&#123;</span><br><span class="line">            System.out.println(<span class="string">"调用InstantiationAwareBeanPostProcessor的postProcessBeforeInstantiation()函数"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实例化之后调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">postProcessAfterInstantiation</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (bean.getClass() == User.class)&#123;</span><br><span class="line">            System.out.println(<span class="string">"调用InstantiationAwareBeanPostProcessor的postProcessAfterInstantiation()函数"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 预初始化，初始化之前调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (bean.getClass() == User.class) &#123;</span><br><span class="line">            System.out.println(<span class="string">"调用BeanPostProcessor的postProcessBeforeInitialization()函数"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 后初始化  bean 初始化完成调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (bean.getClass() == User.class) &#123;</span><br><span class="line">            System.out.println(<span class="string">"调用BeanPostProcessor的postProcessAfterInitialization()函数"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BootStrap-java"><a href="#BootStrap-java" class="headerlink" title="BootStrap.java"></a>BootStrap.java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Austin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2019/12/2 21:13   Mon</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BootStrap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(BootStrap.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(initMethod = <span class="string">"initMethod"</span>, destroyMethod = <span class="string">"destroyMethod"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">user</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setUsername(<span class="string">"xxxx"</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">调用InstantiationAwareBeanPostProcessor的postProcessBeforeInstantiation()函数</span><br><span class="line"></span><br><span class="line">调用Bean的函数(constructor)</span><br><span class="line">调用Bean的函数(setName/setAttribute)</span><br><span class="line"></span><br><span class="line">调用InstantiationAwareBeanPostProcessor的postProcessAfterInstantiation()函数</span><br><span class="line"></span><br><span class="line">调用BeanNameAware的(setBeanName)函数</span><br><span class="line">调用BeanClassLoaderAware的(setBeanClassLoader)函数</span><br><span class="line">调用BeanFactoryAware的(setBeanFactory)函数</span><br><span class="line"></span><br><span class="line">调用EnvironmentAware的(setEnvironment)函数</span><br><span class="line">调用ApplicationContextAware的(setApplicationContext)函数</span><br><span class="line"></span><br><span class="line">调用BeanPostProcessor的postProcessBeforeInitialization()函数</span><br><span class="line"></span><br><span class="line">调用Bean的函数(postConstruct)</span><br><span class="line">调用Bean的函数(afterPropertiesSet)</span><br><span class="line">调用Bean的函数(initMethod)</span><br><span class="line"></span><br><span class="line">调用BeanPostProcessor的postProcessAfterInitialization()函数</span><br><span class="line"></span><br><span class="line">调用Bean的函数(preDestroy)</span><br><span class="line">调用Bean的函数(destroy())</span><br><span class="line">调用Bean的函数(destroyMethod)</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Spring Bean的生命周期分为<strong>四个阶段</strong>和<strong>多个扩展点</strong>。扩展点又可以分为<strong>影响多个Bean</strong>和<strong>影响单个Bean</strong>。整理如下：</p><h3 id="四个阶段"><a href="#四个阶段" class="headerlink" title="四个阶段"></a>四个阶段</h3><ul><li>实例化 Instantiation</li><li>属性赋值 Populate</li><li>初始化 Initialization</li><li>销毁 Destruction</li></ul><h3 id="多个扩展点"><a href="#多个扩展点" class="headerlink" title="多个扩展点"></a>多个扩展点</h3><ul><li><p>影响多个Bean</p><ul><li>BeanPostProcessor</li><li>InstantiationAwareBeanPostProcessor</li></ul></li><li><p>影响单个Bean</p><ul><li><p>Aware</p><ul><li><p>Aware Group1</p><ul><li>BeanNameAware</li><li>BeanClassLoaderAware</li><li>BeanFactoryAware</li></ul></li><li><p>Aware Group2</p><ul><li>EnvironmentAware</li><li>EmbeddedValueResolverAware</li><li>ApplicationContextAware (ResourceLoaderAware、ApplicationEventPublisherAware、MessageSourceAware)</li></ul></li></ul></li><li><p>生命周期</p><ul><li>InitializingBean</li><li>DisposableBean</li></ul></li></ul></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.jianshu.com/p/1dec08d290c1" target="_blank" rel="noopener">请别再问Spring Bean的生命周期了！</a><br><a href="https://juejin.im/post/5ab1bf19f265da23771947f1" target="_blank" rel="noopener">Spring Bean 生命周期</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Spring-Bean生命周期&quot;&gt;&lt;a href=&quot;#Spring-Bean生命周期&quot; class=&quot;headerlink&quot; title=&quot;Spring Bean生命周期&quot;&gt;&lt;/a&gt;Spring Bean生命周期&lt;/h1&gt;&lt;h2 id=&quot;生命周期流程&quot;&gt;&lt;a hr
      
    
    </summary>
    
      <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
      <category term="Spring Boot" scheme="http://yoursite.com/categories/Spring/Spring-Boot/"/>
    
    
      <category term="Springboot" scheme="http://yoursite.com/tags/Springboot/"/>
    
      <category term="Bean" scheme="http://yoursite.com/tags/Bean/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis核心组件及常见问题总结</title>
    <link href="http://yoursite.com/2019/12/27/Mybatis%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E5%8F%8A%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/12/27/Mybatis核心组件及常见问题总结/</id>
    <published>2019-12-27T11:13:56.000Z</published>
    <updated>2020-01-10T13:01:56.877Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mybatis核心组件"><a href="#mybatis核心组件" class="headerlink" title="mybatis核心组件"></a>mybatis核心组件</h1><h2 id="mybatis-config-xml"><a href="#mybatis-config-xml" class="headerlink" title="mybatis-config.xml"></a>mybatis-config.xml</h2><p>XML 配置文件（configuration XML）中包含了对 MyBatis 系统的核心设置，包含获取数据库连接实例的数据源（DataSource）和决定事务作用域和控制方式的事务管理器（TransactionManager）</p><h2 id="SqlSessionFactoryBuilder"><a href="#SqlSessionFactoryBuilder" class="headerlink" title="SqlSessionFactoryBuilder"></a>SqlSessionFactoryBuilder</h2><ul><li><p>作用<br>SqlSessionFactoryBuilder通过类名就可以看出这个类的主要作用就是创建一个SqlSessionFactory，通过输入mybatis配置文件的字节流或者字符流，生成XMLConfigBuilder，XMLConfigBuilder创建一个Configuration，Configuration这个类中包含了mybatis的配置的一切信息，mybatis进行的所有操作都需要根据Configuration中的信息来进行。</p></li><li><p>作用域（Scope）和生命周期<br>可以重用 SqlSessionFactoryBuilder 来创建多个 SqlSessionFactory 实例，但是最好还是不要让其一直存在 ,以保证所有的 XML 解析资源开放给更重要的事情, 这个类可以被实例化、使用和丢弃，一旦创建了 SqlSessionFactory，就不再需要它了。因此 SqlSessionFactoryBuilder 实例的最佳作用域是方法作用域（也就是局部方法变量）</p></li></ul><h2 id="SqlSessionFactory接口"><a href="#SqlSessionFactory接口" class="headerlink" title="SqlSessionFactory接口"></a>SqlSessionFactory接口</h2><ul><li><p>概念<br>sql会话工厂，用于创建SqlSession</p></li><li><p>作用域（Scope）和生命周期<br>SqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在，没有任何理由对它进行清除或重建，最佳作用域是应用作用域。有很多方法可以做到，最简单的就是使用单例模式或者静态单例模式。</p></li><li><p>如何创建<br>使用xml构建</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String resource = <span class="string">"org/mybatis/example/mybatis-config.xml"</span>;</span><br><span class="line">InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br></pre></td></tr></table></figure><p>java代码构建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DataSource dataSource = BlogDataSourceFactory.getBlogDataSource();</span><br><span class="line">TransactionFactory transactionFactory = <span class="keyword">new</span> JdbcTransactionFactory();</span><br><span class="line">Environment environment = <span class="keyword">new</span> Environment(<span class="string">"development"</span>, transactionFactory, dataSource);</span><br><span class="line">Configuration configuration = <span class="keyword">new</span> Configuration(environment);</span><br><span class="line">configuration.addMapper(BlogMapper.class);</span><br><span class="line">SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(configuration);</span><br></pre></td></tr></table></figure><h2 id="SqlSession接口"><a href="#SqlSession接口" class="headerlink" title="SqlSession接口"></a>SqlSession接口</h2><ul><li><p>概念<br>SqlSession是MyBatis的一个重要接口，定义了数据库的增删改查以及事务管理的常用方法。SqlSession还提供了查找Mapper接口的有关方法。</p></li><li><p>作用域（Scope）和生命周期<br>每个线程都应该有它自己的 SqlSession 实例, SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域，每次收到的 HTTP请求，就可以打开一个 SqlSession，返回一个响应，就关闭它。</p></li><li><p>如何创建</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SqlSession session = sqlSessionFactory.openSession();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// do work</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Mapper接口"><a href="#Mapper接口" class="headerlink" title="Mapper接口"></a>Mapper接口</h2><ul><li><p>概念<br>承载了实际的业务逻辑，其生命周期比较短，由SqlSession创建,用于将Java对象和实际的SQL语句对应起来。Mapper接口是指程序员自行定义的一个数据操纵接口，类似于通常所说的DAO接口。跟DAO不同的地方在于Mapper接口只需要程序员定义，不需要程序员去实现，MyBatis会自动为Mapper接口创建动态代理对象。Mapper接口的方法通常与Mapper配置文件中的select、insert、update、delete等XML结点存在一一对应关系。</p></li><li><p>实现方式</p><ul><li>(1)使用XML配置文件的方式。</li><li>(2)使用注解方式。</li><li>(3)直接使用MyBatis提供的API。</li></ul></li></ul><h2 id="mybatis的优缺点"><a href="#mybatis的优缺点" class="headerlink" title="mybatis的优缺点"></a>mybatis的优缺点</h2><p><strong>优点</strong></p><ul><li><ol><li>易于上手和掌握。</li></ol></li><li><ol start="2"><li>sql写在xml里，便于统一管理和优化。</li></ol></li><li><ol start="3"><li>解除sql与程序代码的耦合。</li></ol></li><li><ol start="4"><li>提供映射标签，支持对象与数据库的orm字段关系映射</li></ol></li><li><ol start="5"><li>提供对象关系映射标签，支持对象关系组建维护</li></ol></li><li><ol start="6"><li>提供xml标签，支持编写动态sql。</li></ol></li></ul><p><strong>缺点</strong></p><ul><li><p>sql工作量很大，尤其是字段多、关联表多时，更是如此。</p></li><li><p>sql依赖于数据库，导致数据库移植性差。</p></li><li><p>由于xml里标签id必须唯一，导致DAO中方法不支持方法重载。</p></li><li><p>字段映射标签和对象关系映射标签仅仅是对映射关系的描述，具体实现仍然依赖于sql。（比如配置了一对多Collection标签，如果sql里没有join子表或查询子表的话，查询后返回的对象是不具备对象关系的，即Collection的对象为null）</p></li><li><p>DAO层过于简单，对象组装的工作量较大。</p></li><li><p>不支持级联更新、级联删除。</p></li><li><p>编写动态sql时,不方便调试，尤其逻辑复杂时。</p></li><li><p>提供的写动态sql的xml标签功能简单（连struts都比不上），编写动态sql仍然受限，且可读性低。</p></li><li><p>若不查询主键字段，容易造成查询出的对象有“覆盖”现象。</p></li><li><p>参数的数据类型支持不完善。（如参数为Date类型时，容易报没有get、set方法，需在参数上加@param）</p></li><li><p>多参数时，使用不方便，功能不够强大。（目前支持的方法有map、对象、注解@param以及默认采用012索引位的方式）</p></li><li><p>缓存使用不当，容易产生脏数据。</p></li></ul><h1 id="Mybatis常见问题"><a href="#Mybatis常见问题" class="headerlink" title="Mybatis常见问题"></a>Mybatis常见问题</h1><h2 id="传统-JDBC-的弊端"><a href="#传统-JDBC-的弊端" class="headerlink" title="传统 JDBC 的弊端"></a>传统 JDBC 的弊端</h2><ul><li><p>1、jdbc 底层没有用连接池、操作数据库需要频繁的创建和关联链接。消耗很大的资源</p></li><li><p>2、写原生的 jdbc 代码在 java 中，一旦我们要修改 sql 的话，java 需要整体编译，不利于系 统维护</p></li><li><p>3、使用 PreparedStatement 预编译的话对变量进行设置 123 数字，这样的序号不利于维护 4、返回 result 结果集也需要硬编码。</p></li></ul><h2 id="什么是Mybatis？"><a href="#什么是Mybatis？" class="headerlink" title="什么是Mybatis？"></a>什么是Mybatis？</h2><ul><li><p>1、Mybatis是一个半ORM（对象关系映射）框架，它内部封装了JDBC，开发时只需要关注SQL语句本身，不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。程序员直接编写原生态sql，可以严格控制sql执行性能，灵活度高。</p></li><li><p>2、MyBatis 可以使用 XML 或注解来配置和映射原生信息，将 POJO映射成数据库中的记录，避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。</p></li><li><p>3、通过xml 文件或注解的方式将要执行的各种 statement 配置起来，并通过java对象和 statement中sql的动态参数进行映射生成最终执行的sql语句，最后由mybatis框架执行sql并将结果映射为java对象并返回。（从执行sql到返回result的过程）。</p></li></ul><h2 id="Mybatis执行流程"><a href="#Mybatis执行流程" class="headerlink" title="Mybatis执行流程"></a>Mybatis执行流程</h2><p><img src="/images/mybatis_work_process.png" alt></p><h2 id="mybatis核心概念"><a href="#mybatis核心概念" class="headerlink" title="mybatis核心概念"></a>mybatis核心概念</h2><table><thead><tr><th>名称</th><th>意义</th></tr></thead><tbody><tr><td>Configuration</td><td>管理 mysql-config.xml全局配置关系类</td></tr><tr><td>SqlSessionFactory</td><td>Session 管理工厂接口</td></tr><tr><td>Session</td><td><code>SqlSession</code>是一个面向用户(程序员)的接口。SqlSession 中提 供了很多操作数据库的方法</td></tr><tr><td>Executor</td><td>执行器是一个接口(基本执行器、缓存执行器)  作用:SqlSession 内部通过执行器操作数据库</td></tr><tr><td>MappedStatement</td><td>底层封装对象 作用:对操作数据库存储封装，包括 <code>sql</code> 语句、输入输出参数</td></tr><tr><td>StatementHandler</td><td>具体操作数据库相关的 <code>handler</code> 接口</td></tr><tr><td>ResultSetHandler</td><td>具体操作数据库返回结果的 <code>handler</code> 接口</td></tr></tbody></table><h2 id="Mybatis-全局配置详解"><a href="#Mybatis-全局配置详解" class="headerlink" title="Mybatis 全局配置详解"></a>Mybatis 全局配置详解</h2><p> <img src="/images/mybatis_global_config.png" alt></p><h2 id="MyBatis与Hibernate有哪些不同？"><a href="#MyBatis与Hibernate有哪些不同？" class="headerlink" title="MyBatis与Hibernate有哪些不同？"></a>MyBatis与Hibernate有哪些不同？</h2><p>1、Mybatis和hibernate不同，它<strong>不完全是一个ORM框架</strong>，因为MyBatis需要程序员自己编写Sql语句。</p><p>2、<strong>Mybatis直接编写原生态sql，可以严格控制sql执行性能，灵活度高</strong>，非常适合对关系数据模型要求不高的软件开发，因为这类软件需求变化频繁，一但需求变化要求迅速输出成果。但是灵活的前提是mybatis无法做到数据库无关性，如果需要实现支持多种数据库的软件，则需要自定义多套sql映射文件，工作量大。</p><p>3、Hibernate对象/关系映射能力强，<strong>数据库无关性好</strong>，对于关系模型要求高的软件，如果用hibernate开发可以节省很多代码，提高效率。</p><h2 id="和-的区别是什么？"><a href="#和-的区别是什么？" class="headerlink" title="#{} 和 ${} 的区别是什么？"></a><code>#{}</code> 和 <code>${}</code> 的区别是什么？</h2><ul><li><p><code>#{}</code> 是<strong>预编译处理</strong>，Mybatis在处理<code>#{}</code>时，会将sql中的<code>#{}</code>替换为<code>?</code>号，调用<code>PreparedStatement</code>的<code>set</code>方法来赋值；</p></li><li><p><code>${}</code>是<strong>字符串替换</strong>，Mybatis在处理<code>${}</code>时，就是把<code>${}</code>替换成变量的值原样拼接在SQL中；</p></li><li><p>使用<code>#{}</code>可以有效的防止SQL注入，提高系统安全性</p></li></ul><h2 id="Dao接口的工作原理是什么？Dao接口里的方法能重载吗？"><a href="#Dao接口的工作原理是什么？Dao接口里的方法能重载吗？" class="headerlink" title="Dao接口的工作原理是什么？Dao接口里的方法能重载吗？"></a>Dao接口的工作原理是什么？Dao接口里的方法能重载吗？</h2><p>Dao接口即Mapper接口。接口的全限名，就是mapper映射文件中的<code>namespace</code>的值；</p><p>接口的方法名，就是映射文件中Mapper的<code>Statement</code>的<code>id</code>值；接口方法内的参数，就是传递给sql的参数。</p><p>Mapper接口是没有实现类的，当调用接口方法时，<strong>接口全限名+方法名</strong>拼接字符串作为key值，可唯一定位一个<code>MapperStatement</code>。</p><p>在Mybatis中，每一个 <code>&lt;select&gt;</code>、<code>&lt;insert&gt;</code>、<code>&lt;update&gt;</code>、<code>&lt;delete&gt;</code> 标签，都会被解析为一个<code>MapperStatement</code>对象。举例： <code>com.mybatis3.mappers.StudentDao.findStudentById</code> ，可以唯一找到<code>namespace</code>为 <code>com.mybatis3.mappers.StudentDao</code> 下面 <code>id</code> 为 <code>findStudentById</code> 的 <code>MapperStatement</code>。</p><p><strong>Mapper接口里的方法，是不能重载的</strong>，因为是使用 <strong>全限名+方法名</strong> 的保存和寻找策略。 </p><p>Mapper接口的工作原理是<strong>JDK动态代理</strong>，<strong>Mybatis运行时会使用JDK动态代理为Mapper接口生成代理对象proxy，代理对象会拦截接口方法，转而执行MapperStatement所代表的sql，然后将sql执行结果返回</strong>。</p><h2 id="Mybatis是如何进行分页的？分页插件的原理是什么？"><a href="#Mybatis是如何进行分页的？分页插件的原理是什么？" class="headerlink" title="Mybatis是如何进行分页的？分页插件的原理是什么？"></a>Mybatis是如何进行分页的？分页插件的原理是什么？</h2><p>Mybatis使用<code>RowBounds</code>对象进行分页，它是针对<code>ResultSet</code>结果集执行的<strong>内存分页，而非物理分页</strong>。可以在sql内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。</p><p>分页插件的基本原理是<strong>使用Mybatis提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql，根据dialect方言，添加对应的物理分页语句和物理分页参数.</strong></p><h2 id="Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？"><a href="#Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？" class="headerlink" title="Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？"></a>Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？</h2><p><code>Mybatis</code>仅支持<code>association</code>关联对象和<code>collection</code>关联集合对象的延迟加载，<code>association</code>指的就是一对一，<code>collection</code>指的就是一对多查询。</p><p>在Mybatis配置文件中，可以配置是否启用延迟加载<code>lazyLoadingEnabled=true|false</code>。</p><p>它的原理是，<strong>使用<code>CGLIB</code>创建目标对象的代理对象</strong>，当调用目标方法时，进入拦截器方法，比如调用<code>a.getB().getName()</code>，拦截器<code>invoke()</code>方法发现<code>a.getB()</code>是null值，那么就会单独发送事先保存好的查询关联B对象的sql，把B查询上来，然后调用<code>a.setB(b)</code>，于是a的对象b属性就有值了，接着完成<code>a.getB().getName()</code>方法的调用。这就是延迟加载的基本原理。</p><p>当然了，不光是<code>Mybatis</code>，几乎所有的包括<code>Hibernate</code>，支持延迟加载的原理都是一样的</p><h2 id="Mybatis的一级、二级缓存"><a href="#Mybatis的一级、二级缓存" class="headerlink" title="Mybatis的一级、二级缓存"></a>Mybatis的一级、二级缓存</h2><p>1）一级缓存: 基于 <code>PerpetualCache</code> 的 HashMap 本地缓存，其存储作用域为 <code>Session</code>，当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，<strong>默认打开一级缓存</strong>。</p><p>2）二级缓存与一级缓存其机制相同，默认也是采用 <code>PerpetualCache</code>，HashMap 存储，不同在于其存储作用域为 <code>Mapper(Namespace)</code>，并且可自定义存储源，如 <code>Ehcache</code>。<strong>默认不打开二级缓存</strong>，要开启二级缓存，使用二级缓存属性类需要实现<code>Serializable</code>序列化接口(可用来保存对象的状态), 可在它的映射文件中配置 <code>&lt;cache/&gt;</code> ；</p><p>3）对于缓存数据更新机制，当某一个作用域(一级缓存 Session/二级缓存Namespaces)的进行了C/U/D 操作后，默认该作用域下所有 <code>select</code> 中的缓存将被 <code>clear</code>。</p><h2 id="Mybatis都有哪些Executor执行器？"><a href="#Mybatis都有哪些Executor执行器？" class="headerlink" title="Mybatis都有哪些Executor执行器？"></a>Mybatis都有哪些Executor执行器？</h2><p>Mybatis有三种基本的Executor执行器，<code>SimpleExecutor</code>、<code>ReuseExecutor</code>、<code>BatchExecutor</code>。</p><ul><li><p><strong>SimpleExecutor</strong>：每执行一次<code>update</code>或<code>select</code>，就开启一个<code>Statement</code>对象，<strong>用完立刻关闭<code>Statement</code>对象</strong>。</p></li><li><p><strong>ReuseExecutor</strong>：执行<code>update</code>或<code>select</code>，<strong>以<code>sql</code>作为key查找<code>Statement</code>对象，存在就使用，不存在就创建，用完后，不关闭<code>Statement</code>对象，而是放置于<code>Map&lt;String, Statement&gt;</code>内，供下一次使用</strong>。简言之，就是重复使用<code>Statement</code>对象。</p></li><li><p><strong>BatchExecutor</strong>：执行<code>update</code>（没有select，JDBC批处理不支持select），将所有sql都添加到批处理中（<code>addBatch()</code>），等待统一执行（<code>executeBatch()</code>），它缓存了多个<code>Statement</code>对象，每个<code>Statement</code>对象都是<code>addBatch()</code>完毕后，等待逐一执行<code>executeBatch()</code>批处理。与JDBC批处理相同。</p></li></ul><p>作用范围：Executor的这些特点，都<strong>严格限制在SqlSession生命周期范围内</strong>。</p><h2 id="简述Mybatis的插件运行原理，以及如何编写一个插件。"><a href="#简述Mybatis的插件运行原理，以及如何编写一个插件。" class="headerlink" title="简述Mybatis的插件运行原理，以及如何编写一个插件。"></a>简述Mybatis的插件运行原理，以及如何编写一个插件。</h2><p>Mybatis仅可以编写针对： </p><ul><li><code>ParameterHandler</code></li><li><code>ResultSetHandler</code></li><li><code>StatementHandler</code></li><li><code>Executor</code>  </li></ul><p>这4种接口的插件，<strong>Mybatis使用JDK的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能</strong>，每当执行这4种接口对象的方法时，就会进入拦截方法，具体就是<code>InvocationHandler</code>的<code>invoke()</code>方法，当然，只会拦截那些你指定需要拦截的方法。</p><p>编写插件：</p><ul><li>① 实现Mybatis的<code>Interceptor</code>接口并覆写<code>intercept()</code>方法；</li><li>② 给插件编写注解，指定要拦截哪一个接口的哪些方法即可；</li><li>③ 在配置文件中配置你编写的插件。</li></ul><h2 id="如何获取自动生成的-主-键值"><a href="#如何获取自动生成的-主-键值" class="headerlink" title="如何获取自动生成的(主)键值"></a>如何获取自动生成的(主)键值</h2><p>一般插入数据的话，如果我们想要知道刚刚插入的数据的主键是多少，我们可以通过以下的方式来获取</p><p>需求：</p><blockquote><p>user对象插入到数据库后，新记录的主键要通过user对象返回，通过user获取主键值。</p></blockquote><p>解决思路：</p><p>通过<code>LAST_INSERT_ID()</code>获取刚插入记录的自增主键值，在<code>insert</code>语句执行后，执行<code>select LAST_INSERT_ID()</code> 就可以获取自增主键。</p><p>mysql:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;insert id="insertUser" parameterType="cn.itcast.mybatis.po.User"&gt;</span><br><span class="line">    &lt;selectKey keyProperty="id" order="AFTER" resultType="int"&gt;</span><br><span class="line">        <span class="keyword">select</span> <span class="keyword">LAST_INSERT_ID</span>()</span><br><span class="line">    &lt;/selectKey&gt;</span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">USER</span>(username,birthday,sex,address) <span class="keyword">VALUES</span>(<span class="comment">#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;)</span></span><br><span class="line">&lt;/<span class="keyword">insert</span>&gt;</span><br></pre></td></tr></table></figure><h2 id="Mybatis动态sql"><a href="#Mybatis动态sql" class="headerlink" title="Mybatis动态sql"></a>Mybatis动态sql</h2><ul><li><p>Mybatis动态sql可以让我们在Xml映射文件内，以标签的形式编写动态sql，完成逻辑判断和动态拼接sql的功能;</p></li><li><p>Mybatis提供了9种动态sql标签：<code>trim|where|set|foreach|if|choose|when|otherwise|bind</code>。</p></li><li><p>其执行原理为，使用<code>OGNL</code> 从 sql 参数对象中计算表达式的值，根据表达式的值动态拼接sql，以此来完成动态sql的功能;</p></li></ul><h2 id="Mybatis比IBatis比较大的几个改进"><a href="#Mybatis比IBatis比较大的几个改进" class="headerlink" title="Mybatis比IBatis比较大的几个改进"></a>Mybatis比IBatis比较大的几个改进</h2><ul><li><p>a.增加接口绑定,包括注解绑定sql和xml绑定Sql ,</p></li><li><p>b.动态sql由原来的节点配置变成OGNL表达式,</p></li><li><p>c. 在一对一,一对多的时候引进了<code>association</code>, 在一对多的时候引入了<code>collection</code>节点, 不过都是在<code>resultMap</code>里面配置</p></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.im/post/5ce25058e51d45105773e63f" target="_blank" rel="noopener">面试官都会问的Mybatis面试题</a></p><p><a href="https://segmentfault.com/a/1190000013678579" target="_blank" rel="noopener">Mybatis常见面试题</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;mybatis核心组件&quot;&gt;&lt;a href=&quot;#mybatis核心组件&quot; class=&quot;headerlink&quot; title=&quot;mybatis核心组件&quot;&gt;&lt;/a&gt;mybatis核心组件&lt;/h1&gt;&lt;h2 id=&quot;mybatis-config-xml&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="数据库中间件" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
      <category term="Mybatis" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E9%97%B4%E4%BB%B6/Mybatis/"/>
    
    
      <category term="Mybatis" scheme="http://yoursite.com/tags/Mybatis/"/>
    
  </entry>
  
  <entry>
    <title>分布式ID生成器</title>
    <link href="http://yoursite.com/2019/12/20/%E5%88%86%E5%B8%83%E5%BC%8FID%E7%94%9F%E6%88%90%E5%99%A8/"/>
    <id>http://yoursite.com/2019/12/20/分布式ID生成器/</id>
    <published>2019-12-20T12:31:12.000Z</published>
    <updated>2019-12-20T12:39:22.126Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本要求"><a href="#基本要求" class="headerlink" title="基本要求"></a>基本要求</h2><ul><li>全局唯一  </li><li>趋势递增  </li><li>效率高（生成、使用、索引）</li><li>控制并发</li></ul><h2 id="常用策略"><a href="#常用策略" class="headerlink" title="常用策略"></a>常用策略</h2><p><img src="/images/distribute_uuid.jpg" alt></p><p><img src="/images/distribute_mysql_autoincrement.jpg" alt></p><p><img src="/images/distribute_mysql_ad.jpg" alt></p><p><img src="/images/distribute_snowflower.jpg" alt></p><p><img src="/images/distribute_snow_ad.jpg" alt></p><p><img src="/images/distribute_id_redis.jpg" alt></p><p><img src="/images/distribute_redis_advantage.jpg" alt></p><p><img src="/images/distribute_id_pk.jpg" alt></p><p><img src="/images/distribute_id_topk.jpg" alt></p><h2 id="Twitter雪花算法SnowFlake"><a href="#Twitter雪花算法SnowFlake" class="headerlink" title="Twitter雪花算法SnowFlake"></a>Twitter雪花算法SnowFlake</h2><p><img src="/images/distribute_snow_flower.jpg" alt></p><ul><li><p>1) 1位，不用。二进制中最高位为1的都是负数，但是我们生成的id一般都使用整数，所以这个最高位固定是0</p></li><li><p>2) 41位，用来记录时间戳（毫秒）。</p></li><li><p>3) 41位可以表示2^41−1个数字，如果只用来表示正整数（计算机中正数包含0），可以表示的数值范围是：0 至 2^41−1，减1是因为可表示的数值范围是从0开始算的，而不是1。<br>也就是说41位可以表示2^41−1个毫秒的值，转化成单位年则是(2^41−1)/(1000∗60∗60∗24∗365)=69年</p></li><li><p>4) 10位，用来记录工作机器id。<br>可以部署在2^10=1024个节点，包括5位datacenterId和5位workerId</p></li><li><p>5) 5位（bit）可以表示的最大正整数是2^5−1=31，即可以用0、1、2、3、….31这32个数字，来表示不同的datecenterId或workerId</p></li><li><p>6) 12位，序列号，用来记录同毫秒内产生的不同id。<br>12位（bit）可以表示的最大正整数是2^12−1=4095，即可以用0、1、2、3、….4094这4095个数字，来表示同一机器同一时间截（毫秒)内产生的4095个ID序号<br>由于在Java中64bit的整数是long类型，所以在Java中SnowFlake算法生成的id就是long来存储的。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基本要求&quot;&gt;&lt;a href=&quot;#基本要求&quot; class=&quot;headerlink&quot; title=&quot;基本要求&quot;&gt;&lt;/a&gt;基本要求&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;全局唯一  &lt;/li&gt;
&lt;li&gt;趋势递增  &lt;/li&gt;
&lt;li&gt;效率高（生成、使用、索引）&lt;/li&gt;
&lt;li&gt;控
      
    
    </summary>
    
      <category term="分布式" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="分布式" scheme="http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Springboot集成mybatis自定义插件开发</title>
    <link href="http://yoursite.com/2019/12/20/Springboot%E9%9B%86%E6%88%90mybatis%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    <id>http://yoursite.com/2019/12/20/Springboot集成mybatis自定义插件开发/</id>
    <published>2019-12-20T12:14:43.000Z</published>
    <updated>2019-12-20T12:18:12.339Z</updated>
    
    <content type="html"><![CDATA[<h2 id="mybatis架构"><a href="#mybatis架构" class="headerlink" title="mybatis架构"></a>mybatis架构</h2><p><img src="/images/mybatis_structure.png" alt="Pasted Graphi"></p><h2 id="mybatis工作原理"><a href="#mybatis工作原理" class="headerlink" title="mybatis工作原理"></a>mybatis工作原理</h2><p><img src="/images/mybatis_process.jpg" alt="-w777"></p><p>执行流程：</p><ol><li>读取核心配置文件并返回InputStream流对象。 </li><li>根据InputStream流对象解析出Configuration对象，然后创建SqlSessionFactory工厂对象 </li><li>根据一系列属性从SqlSessionFactory工厂中创建SqlSession </li><li>从SqlSession中调用Executor执行数据库操作&amp;&amp;生成具体SQL指令 </li><li>对执行结果进行二次封装 </li><li>提交与事务</li></ol><h2 id="mybatis插件简介"><a href="#mybatis插件简介" class="headerlink" title="mybatis插件简介"></a>mybatis插件简介</h2><p>mybatis插件就是在执行数据库操作的时候，对于特定方法进行拦截增强，做一些额外的处理的一种方式。<br>myabtis的插件的增强原理是利用动态代理实现的，可以对数据库操作的执行类做拦截，mybatis主要操作流程如下：</p><p><img src="/images/mybatis_process.jpg" alt></p><p>mybatis中的几个操作数据库的执行类是：Executor、StatementHandler、ParameterHandler、ResultSetHandler，其中：</p><ul><li><p>Executor 是总的执行者，他就像一个大总管，用于协调管理其他执行者。</p></li><li><p>StatementHandler 拦截Sql语法构建的处理, 是用于生成Statement或者PreparedStatement的执行者，同时他会调用ParameterHandler进行对sql语句中的参数设值，设置完了之后会通过StatementHandler 去调用sql在数据库中执行，最后返回一个结果集，通过ResultSetHandler将结果集和对应的实体进行映射填充数据，之后会把结果实体返回给StatementHandler。</p></li><li><p>ParameterHandler ：拦截参数的处理 </p></li><li><p>ResultSetHandler ：拦截结果集的处理 </p></li></ul><p>所以，我们对这几个执行者进行拦截，比如对于StatementHandler 拦截，即是对于sql操作进行拦截，Mybatis自定义插件必须实现Interceptor接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">    <span class="function">Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line">    <span class="function">Object <span class="title">plugin</span><span class="params">(Object target)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>intercept方法：拦截器具体处理逻辑方法 </li><li>plugin方法：根据签名signatureMap生成动态代理对象 </li><li>setProperties方法：设置Properties属性</li></ul><p>下面就对于这个StatementHandler 进行拦截做一个分页实例。</p><h2 id="分页插件"><a href="#分页插件" class="headerlink" title="分页插件"></a>分页插件</h2><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>拦截数据sql,实现分页功能</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Austin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2019/9/1 11:37   Sun</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Intercepts</span>(<span class="meta">@Signature</span>(</span><br><span class="line">        type = StatementHandler.class,</span><br><span class="line">        method = <span class="string">"prepare"</span>,</span><br><span class="line">        args = &#123;Connection.class, Integer.class&#125;</span><br><span class="line">))</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PagePlugin</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;mybatis.page.plugin.dialect&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String dialect;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;mybatis.page.plugin.pageSqlId&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String pageSqlId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插件需要做的事情</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// 确定哪些方法需要做分页</span></span><br><span class="line">        StatementHandler statementHandler = (StatementHandler) invocation.getTarget();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取原始sql</span></span><br><span class="line">        BoundSql boundSql = statementHandler.getBoundSql();</span><br><span class="line">        String sql = boundSql.getSql();</span><br><span class="line">        System.out.println(<span class="string">"原始sql: "</span> + sql);</span><br><span class="line"></span><br><span class="line">        MetaObject metaObject = MetaObject.forObject(statementHandler,</span><br><span class="line">                SystemMetaObject.DEFAULT_OBJECT_FACTORY,</span><br><span class="line">                SystemMetaObject.DEFAULT_OBJECT_WRAPPER_FACTORY,</span><br><span class="line">                <span class="keyword">new</span> DefaultReflectorFactory());</span><br><span class="line"></span><br><span class="line">        MappedStatement mappedStatement = (MappedStatement) metaObject.getValue(<span class="string">"delegate.mappedStatement"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//        //sql语句类型 select、delete、insert、update</span></span><br><span class="line">        <span class="comment">//        String sqlCommandType = mappedStatement.getSqlCommandType().toString();</span></span><br><span class="line">        <span class="comment">// 获取mapper接口中的方法名</span></span><br><span class="line">        String mapperMethodName = mappedStatement.getId();</span><br><span class="line"></span><br><span class="line">        Object paramObj = boundSql.getParameterObject();</span><br><span class="line">        <span class="keyword">if</span> (mapperMethodName.matches(<span class="string">".*ByPage$"</span>)) &#123;</span><br><span class="line">            Map&lt;String, Object&gt; params = (Map&lt;String, Object&gt;) paramObj;</span><br><span class="line">            PageInfo pageInfo = (PageInfo) params.get(<span class="string">"page"</span>);   <span class="comment">// map.put("page", pageInfo)</span></span><br><span class="line"></span><br><span class="line">            String countSql = <span class="string">"select count(1) from ("</span> + sql + <span class="string">") temp "</span>;</span><br><span class="line">            System.out.println(<span class="string">"查询总数sql: "</span> + countSql);</span><br><span class="line"></span><br><span class="line">            Connection connection = (Connection) invocation.getArgs()[<span class="number">0</span>];</span><br><span class="line">            PreparedStatement countStatement = connection.prepareStatement(countSql);</span><br><span class="line">            ParameterHandler parameterHandler = (ParameterHandler) metaObject.getValue(<span class="string">"delegate.parameterHandler"</span>);</span><br><span class="line">            parameterHandler.setParameters(countStatement);</span><br><span class="line">            ResultSet rs = countStatement.executeQuery();</span><br><span class="line">            <span class="keyword">if</span> (rs.next()) &#123;</span><br><span class="line">                pageInfo.setTotalNumber(rs.getInt(<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            rs.close();</span><br><span class="line">            countStatement.close();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 改造sql limit count</span></span><br><span class="line">            String pageSql = <span class="keyword">this</span>.generatePageSql(sql, pageInfo);</span><br><span class="line">            System.out.println(<span class="string">"分页sql: "</span> + pageSql);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 改造后的sql放回</span></span><br><span class="line">            metaObject.setValue(<span class="string">"delegate.boundSql.sql"</span>, pageSql);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行流程提交mybatis</span></span><br><span class="line">        <span class="keyword">return</span> invocation.proceed();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">generatePageSql</span><span class="params">(String sql, PageInfo pageInfo)</span> </span>&#123;</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">if</span> (dialect.equals(<span class="string">"mysql"</span>)) &#123;</span><br><span class="line">            sb.append(sql);</span><br><span class="line">            sb.append(<span class="string">" limit "</span> + pageInfo.getStartIndex() + <span class="string">" ,"</span> + pageInfo.getTotalSelect());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">plugin</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Plugin.wrap(target, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>myabtis自定义插件只需要实现Interceptor接口即可，并且注解@Intercepts以及@Signature配置需要拦截的对象，其中</p><ul><li>type是需要拦截的对象Class，</li><li>method是对象里面的方法，</li><li>args是方法参数类型。</li></ul><h2 id="注入插件到拦截链"><a href="#注入插件到拦截链" class="headerlink" title="注入插件到拦截链"></a>注入插件到拦截链</h2><p>这里有两种方式注入</p><ul><li><p>方式一：直接注入</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Spring boot项目中只需要在拦截器类上加 @Component 注解即可。</span><br></pre></td></tr></table></figure></li><li><p>方式二：通过myabtis配置加入到拦截链中(多个拦截器时，这种方式可以控制拦截顺序）</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@MapperScan</span>(&#123;<span class="string">"com.springboot.demo.mapper"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperConfig</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//将插件加入到mybatis插件拦截链中</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ConfigurationCustomizer <span class="title">configurationCustomizer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConfigurationCustomizer() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(Configuration configuration)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//插件拦截链采用了责任链模式，执行顺序和加入连接链的顺序有关</span></span><br><span class="line">                MyPlugin myPlugin = <span class="keyword">new</span> MyPlugin();</span><br><span class="line">                <span class="comment">//设置参数，比如阈值等，可以在配置文件中配置，这里直接写死便于测试</span></span><br><span class="line">                Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">                <span class="comment">//这里设置慢查询阈值为1毫秒，便于测试</span></span><br><span class="line">                properties.setProperty(<span class="string">"time"</span>, <span class="string">"1"</span>);</span><br><span class="line">                myPlugin.setProperties(properties);</span><br><span class="line">                </span><br><span class="line">                configuration.addInterceptor(myPlugin);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;mybatis架构&quot;&gt;&lt;a href=&quot;#mybatis架构&quot; class=&quot;headerlink&quot; title=&quot;mybatis架构&quot;&gt;&lt;/a&gt;mybatis架构&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/images/mybatis_structure.png&quot; a
      
    
    </summary>
    
      <category term="数据库中间件" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
      <category term="Mybatis" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E9%97%B4%E4%BB%B6/Mybatis/"/>
    
    
      <category term="Mybatis" scheme="http://yoursite.com/tags/Mybatis/"/>
    
      <category term="Springboot" scheme="http://yoursite.com/tags/Springboot/"/>
    
  </entry>
  
  <entry>
    <title>java编译执行有第三方依赖的类</title>
    <link href="http://yoursite.com/2019/12/20/java%E7%BC%96%E8%AF%91%E6%89%A7%E8%A1%8C%E6%9C%89%E7%AC%AC%E4%B8%89%E6%96%B9%E4%BE%9D%E8%B5%96%E7%9A%84%E7%B1%BB/"/>
    <id>http://yoursite.com/2019/12/20/java编译执行有第三方依赖的类/</id>
    <published>2019-12-20T11:53:51.000Z</published>
    <updated>2019-12-20T11:54:48.749Z</updated>
    
    <content type="html"><![CDATA[<p>有时候在进行开发的过程中，需要自己写个测试类来进行某个局部功能的测试，在测试的过程中，需要引入第三方jar包或者公司其他成员的帮助类，比如说：我需要测试一个<br>net.sf.json.JSONObject解析数据的时候中文乱码问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> net.sf.json.JSONException;</span><br><span class="line"><span class="keyword">import</span> net.sf.json.JSONObject;</span><br><span class="line"><span class="keyword">import</span> net.sf.json.JsonConfig;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.URLEncoder;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by 神器 on 2017/3/29.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZyhqErrorMsgDemo</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        InputStream inputStream = <span class="keyword">null</span>;</span><br><span class="line">        InputStreamReader inputStreamReader = <span class="keyword">null</span>;</span><br><span class="line">        BufferedReader in = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            String filePath = <span class="string">"/home/1.txt"</span>;</span><br><span class="line">            File file = <span class="keyword">new</span> File(filePath);</span><br><span class="line">            String code = codeString(filePath);</span><br><span class="line">            System.out.println(<span class="string">"文件类型:"</span> + code);</span><br><span class="line">            inputStream = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">            inputStreamReader = <span class="keyword">new</span> InputStreamReader(inputStream, <span class="string">"UTF-8"</span>);</span><br><span class="line">            in = <span class="keyword">new</span> BufferedReader(inputStreamReader);</span><br><span class="line">            String firstLine = in.readLine();<span class="comment">//过滤掉首行，以便循环体从第二行（申赎明细处理结果）</span></span><br><span class="line">            String line = <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">while</span> ((line = in.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"line:=====&gt;"</span>+ line);</span><br><span class="line">                System.out.println();</span><br><span class="line">                System.out.println();</span><br><span class="line">                JSONObject jsonObject = JSONObject.fromObject(line);</span><br><span class="line">                String status = jsonObject.getString(<span class="string">"status"</span>);</span><br><span class="line">                String objectStr = jsonObject.getString(<span class="string">"content"</span>);</span><br><span class="line">                String errorMessage = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    errorMessage = jsonObject.get(<span class="string">"errorMessage"</span>).toString();</span><br><span class="line">                &#125;<span class="keyword">catch</span> (JSONException ex) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"there is no errorMessage from Zyhq holding respon file"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"errorMessage:------&gt;"</span> + errorMessage);</span><br><span class="line">            &#125;</span><br><span class="line">            in.close();</span><br><span class="line">            inputStreamReader.close();</span><br><span class="line">            inputStream.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception ex)&#123;</span><br><span class="line">            System.out.println(<span class="string">"下载文件并解析文件内容时出错"</span>+ex.getStackTrace());</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (in != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    in.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"> </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (inputStreamReader != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    inputStreamReader.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"> </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (inputStream != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    inputStream.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"> </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断文件的编码格式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fileName :file</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 文件编码格式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">codeString</span><span class="params">(String fileName)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        BufferedInputStream bin = <span class="keyword">new</span> BufferedInputStream(</span><br><span class="line">                <span class="keyword">new</span> FileInputStream(fileName));</span><br><span class="line">        <span class="keyword">int</span> p = (bin.read() &lt;&lt; <span class="number">8</span>) + bin.read();</span><br><span class="line">        String code = <span class="keyword">null</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">switch</span> (p) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xefbb</span>:</span><br><span class="line">                code = <span class="string">"UTF-8"</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xfffe</span>:</span><br><span class="line">                code = <span class="string">"Unicode"</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xfeff</span>:</span><br><span class="line">                code = <span class="string">"UTF-16BE"</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                code = <span class="string">"GBK"</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写好之后上传到服务器上，需要自己在java文件目录上传好依赖的第三方jar包，然后编译：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac -cp commons-beanutils-1.8.3.jar:commons-collections-3.2.1.jar:commons-lang-2.6.jar:commons-logging-1.2.jar:json-lib-2.4-jdk15.jar: ZyhqErrorMsgDemo.java</span><br></pre></td></tr></table></figure><p><font color="red"><strong>切记：最后一个jar包后的：后面要加上一个空格再引入自己的Java文件</strong></font></p><p>执行的命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac -cp commons-beanutils-1.8.3.jar:commons-collections-3.2.1.jar:commons-lang-2.6.jar:commons-logging-1.2.jar:json-lib-2.4-jdk15.jar: ZyhqErrorMsgDemo</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有时候在进行开发的过程中，需要自己写个测试类来进行某个局部功能的测试，在测试的过程中，需要引入第三方jar包或者公司其他成员的帮助类，比如说：我需要测试一个&lt;br&gt;net.sf.json.JSONObject解析数据的时候中文乱码问题&lt;/p&gt;
&lt;figure class=&quot;
      
    
    </summary>
    
      <category term="教程" scheme="http://yoursite.com/categories/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Java" scheme="http://yoursite.com/categories/%E6%95%99%E7%A8%8B/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="基础" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Guice使用入门</title>
    <link href="http://yoursite.com/2019/12/20/Guice%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2019/12/20/Guice使用入门/</id>
    <published>2019-12-20T11:49:15.000Z</published>
    <updated>2019-12-20T11:51:13.622Z</updated>
    
    <content type="html"><![CDATA[<p>Guice是谷歌推出的一个轻量级依赖注入框架，帮助我们解决Java项目中的依赖注入问题。如果使用过Spring的话，会了解到依赖注入是个非常方便的功能。不过假如只想在项目中使用依赖注入，那么引入Spring未免大材小用了。这时候我们可以考虑使用Guice。本文参考了Guice官方文档，详细信息可以直接查看Guice文档。</p><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>如果使用Maven的话，添加下面的依赖项。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.google.inject&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;guice&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;4.2.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><p>Guice的注入非常方便，不需要配置文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 被依赖的dao</span></span><br><span class="line"><span class="meta">@Singleton</span> <span class="comment">// 打上了这个标记说明是单例的，否则Guice每次回返回一个新的对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDao</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"dao is saying"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// service，依赖 UserDao</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">private</span> UserDao mUserDao;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mUserDao.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Start</span>  </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//这步就是我们问Guice去要对象</span></span><br><span class="line">        <span class="keyword">final</span> Injector injector = Guice.createInjector();</span><br><span class="line">        <span class="keyword">final</span> UserService userService = injector.getInstance(UserService.class);</span><br><span class="line">        userService.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果输出：</p><pre><code>dao is saying</code></pre><p>复制代码可以看到没有任何的xml配置，唯一需要做的，就是在需要注入的属性上打上<code>@inject</code>。<br>使用 <code>Guice.createInjector()</code> 启动。通常需要尽早在程序中创建注入器。这样 Guice 能够帮助您创建大部分对象.</p><p><strong>该demo中，并没有用到Module，也成功运行了，是因为之前没有涉及到接口，当只是依赖<font color="red"> 确切的实现类 </font> 的时候，Guice会自动的找到需要注入的实现类</strong></p><h2 id="依赖绑定"><a href="#依赖绑定" class="headerlink" title="依赖绑定"></a>依赖绑定</h2><h3 id="链式绑定"><a href="#链式绑定" class="headerlink" title="链式绑定"></a>链式绑定</h3><p>我们在绑定依赖的时候不仅可以将父类和子类绑定，还可以将子类和更具体的子类绑定。下面的例子中，当我们需要<code>TransactionLog</code>的时候，<code>Guice</code>最后会为我们注入<code>MySqlDatabaseTransactionLog</code>对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BillingModule</span> <span class="keyword">extends</span> <span class="title">AbstractModule</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        bind(TransactionLog.class).to(DatabaseTransactionLog.class);</span><br><span class="line">        bind(DatabaseTransactionLog.class).to(MySqlDatabaseTransactionLog.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注解绑定"><a href="#注解绑定" class="headerlink" title="注解绑定"></a>注解绑定</h3><p>当我们需要将多个同一类型的对象注入不同对象的时候，就需要使用注解区分这些依赖了。最简单的办法就是使用@Named注解进行区分。</p><p>首先需要在要注入的地方添加@Named注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealBillingService</span> <span class="keyword">implements</span> <span class="title">BillingService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Inject</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">RealBillingService</span><span class="params">(@Named(<span class="string">"Checkout"</span>)</span> CreditCardProcessor processor,</span></span><br><span class="line"><span class="function">      TransactionLog transactionLog) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>然后在绑定中添加<code>annotatedWith</code>方法指定<code>@Named中</code>指定的名称。由于编译器无法检查字符串，所以Guice官方建议我们保守地使用这种方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bind(CreditCardProcessor.class)</span><br><span class="line">    .annotatedWith(Names.named(<span class="string">"Checkout"</span>))</span><br><span class="line">    .to(CheckoutCreditCardProcessor.class);</span><br></pre></td></tr></table></figure><p>如果希望使用<strong>类型安全</strong>的方式，可以自定义注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BindingAnnotation</span> </span><br><span class="line"><span class="meta">@Target</span>(&#123; FIELD, PARAMETER, METHOD &#125;) </span><br><span class="line"><span class="meta">@Retention</span>(RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> PayPal &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在需要注入的类上应用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealBillingService</span> <span class="keyword">implements</span> <span class="title">BillingService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Inject</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">RealBillingService</span><span class="params">(@PayPal CreditCardProcessor processor,</span></span></span><br><span class="line"><span class="function"><span class="params">      TransactionLog transactionLog)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>在配置类中，使用方法也和@Named类似。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bind(CreditCardProcessor.class)</span><br><span class="line">    .annotatedWith(PayPal.class)</span><br><span class="line">    .to(PayPalCreditCardProcessor.class);</span><br></pre></td></tr></table></figure><h3 id="实例绑定"><a href="#实例绑定" class="headerlink" title="实例绑定"></a>实例绑定</h3><p>有时候需要直接注入一个对象的实例，而不是从依赖关系中解析。如果我们要注入基本类型的话只能这么做。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">bind(String.class)</span><br><span class="line">    .annotatedWith(Names.named(<span class="string">"JDBC URL"</span>))</span><br><span class="line">    .toInstance(<span class="string">"jdbc:mysql://localhost/pizza"</span>);</span><br><span class="line">    </span><br><span class="line">bind(Integer.class)</span><br><span class="line">    .annotatedWith(Names.named(<span class="string">"login timeout seconds"</span>))</span><br><span class="line">    .toInstance(<span class="number">10</span>);</span><br><span class="line">```    </span><br><span class="line">    </span><br><span class="line">如果使用`toInstance()`方法注入的实例比较复杂的话，可能会影响程序启动。这时候可以使用`<span class="meta">@Provides</span>`方法代替。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### @Provides方法</span><br><span class="line">当一个对象很复杂，无法使用简单的构造器来生成的时候，我们可以使用`<span class="meta">@Provides</span>`方法，也就是在配置类中生成一个注解了`<span class="meta">@Provides</span>`的方法。在该方法中我们可以编写任意代码来构造对象。</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BillingModule</span> <span class="keyword">extends</span> <span class="title">AbstractModule</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Provides</span></span><br><span class="line">  <span class="function">TransactionLog <span class="title">provideTransactionLog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DatabaseTransactionLog transactionLog = <span class="keyword">new</span> DatabaseTransactionLog();</span><br><span class="line">    transactionLog.setJdbcUrl(<span class="string">"jdbc:mysql://localhost/pizza"</span>);</span><br><span class="line">    transactionLog.setThreadPoolSize(<span class="number">30</span>);</span><br><span class="line">    <span class="keyword">return</span> transactionLog;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@Provides</code>方法也可以应用<code>@Named</code>和自定义注解，还可以注入其他依赖，Guice会在调用方法之前注入需要的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Provides</span> <span class="meta">@PayPal</span></span><br><span class="line"><span class="function">CreditCardProcessor <span class="title">providePayPalCreditCardProcessor</span><span class="params">(@Named(<span class="string">"PayPal API key"</span>)</span> String apiKey) </span>&#123;</span><br><span class="line">  PayPalCreditCardProcessor processor = <span class="keyword">new</span> PayPalCreditCardProcessor();</span><br><span class="line">  processor.setApiKey(apiKey);</span><br><span class="line">  <span class="keyword">return</span> processor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Provider绑定"><a href="#Provider绑定" class="headerlink" title="Provider绑定"></a>Provider绑定</h3><p>如果项目中存在多个比较复杂的对象需要构建，使用<code>@Provides</code>方法会让配置类变得比较乱。我们可以使用Guice提供的<code>Provider</code>接口将复杂的代码放到单独的类中。办法很简单，实现<code>Provider&lt;T&gt;</code>接口的<code>get</code>方法即可。在<code>Provider</code>类中，我们可以使用<code>@Inject</code>任意注入对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DatabaseTransactionLogProvider</span> <span class="keyword">implements</span> <span class="title">Provider</span>&lt;<span class="title">TransactionLog</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Connection connection;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Inject</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DatabaseTransactionLogProvider</span><span class="params">(Connection connection)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.connection = connection;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> TransactionLog <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DatabaseTransactionLog transactionLog = <span class="keyword">new</span> DatabaseTransactionLog();</span><br><span class="line">    transactionLog.setConnection(connection);</span><br><span class="line">    <span class="keyword">return</span> transactionLog;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在配置类中使用<code>toProvider</code>方法绑定到<code>Provider</code>上即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BillingModule</span> <span class="keyword">extends</span> <span class="title">AbstractModule</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    bind(TransactionLog.class)</span><br><span class="line">        .toProvider(DatabaseTransactionLogProvider.class);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>默认情况下Guice会在每次注入的时候创建一个新对象。如果希望创建一个单例依赖的话，可以在实现类上应用<code>@Singleton</code>注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Singleton</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InMemoryTransactionLog</span> <span class="keyword">implements</span> <span class="title">TransactionLog</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* everything here should be threadsafe! */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者也可以在配置类中指定。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bind(TransactionLog.class)</span><br><span class="line">    .to(InMemoryTransactionLog.class)</span><br><span class="line">    .in(Singleton.class);</span><br></pre></td></tr></table></figure><p>在<code>@Provides</code>方法中也可以指定单例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Provides</span> </span><br><span class="line"><span class="meta">@Singleton</span></span><br><span class="line"><span class="function">TransactionLog <span class="title">provideTransactionLog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果一个类型上存在多个冲突的作用域，<code>Guice</code>会使用<code>bind()</code>方法中指定的作用域。如果不想使用注解的作用域，可以在<code>bind()</code>方法中将对象绑定为<code>Scopes.NO_SCOPE</code>。</p><p>Guice和它的扩展提供了很多作用域，有单例<code>Singleton</code>，Session作用域<code>SessionScoped</code>，Request请求作用域<code>RequestScoped</code>等等。我们可以根据需要选择合适的作用域。</p><p>参考：<br><a href="https://juejin.im/post/5a375e156fb9a0452a3c6b96" target="_blank" rel="noopener">Google-Guice入门教程</a></p><p><a href="https://www.jianshu.com/p/a648322dc680" target="_blank" rel="noopener">Guice 快速入门</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Guice是谷歌推出的一个轻量级依赖注入框架，帮助我们解决Java项目中的依赖注入问题。如果使用过Spring的话，会了解到依赖注入是个非常方便的功能。不过假如只想在项目中使用依赖注入，那么引入Spring未免大材小用了。这时候我们可以考虑使用Guice。本文参考了Guic
      
    
    </summary>
    
      <category term="教程" scheme="http://yoursite.com/categories/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Guice" scheme="http://yoursite.com/categories/%E6%95%99%E7%A8%8B/Guice/"/>
    
    
      <category term="教程" scheme="http://yoursite.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Guice" scheme="http://yoursite.com/tags/Guice/"/>
    
  </entry>
  
  <entry>
    <title>Kafka进阶-基本原理</title>
    <link href="http://yoursite.com/2019/12/20/Kafka%E8%BF%9B%E9%98%B6-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2019/12/20/Kafka进阶-基本原理/</id>
    <published>2019-12-20T11:34:19.000Z</published>
    <updated>2019-12-20T11:45:27.290Z</updated>
    
    <content type="html"><![CDATA[<h2 id="集群架构图"><a href="#集群架构图" class="headerlink" title="集群架构图"></a>集群架构图</h2><p><img src="/images/kafka_cluster_architecture.png" alt="kafka_cluster_architecture"></p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul><li><p>日志收集：一个公司可以用Kafka可以收集各种服务的log，通过kafka以统一接口服务的方式开放给各种consumer，例如hadoop、Hbase、Solr等。</p></li><li><p>消息系统：解耦和生产者和消费者、缓存消息等。</p></li><li><p>用户活动跟踪：Kafka经常被用来记录web用户或者app用户的各种活动，如浏览网页、搜索、点击等活动，这些活动信息被各个服务器发布到kafka的topic中，然后订阅者通过订阅这些topic来做实时的监控分析，或者装载到hadoop、数据仓库中做离线分析和挖掘。</p></li><li><p>运营指标：Kafka也经常用来记录运营监控数据。包括收集各种分布式应用的数据，生产各种操作的集中反馈，比如报警和报告。</p></li><li><p>流式处理：比如spark streaming和storm</p></li><li><p>事件源</p></li></ul><h2 id="如何做到高吞吐、低延迟"><a href="#如何做到高吞吐、低延迟" class="headerlink" title="如何做到高吞吐、低延迟"></a>如何做到高吞吐、低延迟</h2><p>Kafka写数据的大致方式：<strong>先写操作系统的页缓存（Page Cache）,然后由操作系统自行决定何时刷到磁盘</strong>。</p><p>因此 Kafka 达到高吞吐、低延迟的原因主要有以下4点：</p><ul><li><p><strong>页缓存是在内存中分配的</strong>，所以消息写入的速度很快。</p></li><li><p>Kafka不必和底层的文件系统进行交互，所有<strong>繁琐的I/O操作都由操作系统来处理</strong>。</p></li><li><p>Kafka采用<strong>追加写的方式，避免了磁盘随机写操作</strong>。</p></li><li><p><strong>使用以Sendfile为代表的零拷贝技术</strong>提高了读取数据的效率。</p></li></ul><blockquote><p>PS: 使用页缓存而非堆内存还有一个好处，就是当Kafka broker的进程崩溃时，堆内存的数据会丢失，但是<strong>页缓存的数据依然存在</strong>，重启Kafka broker后可以继续提供服务。</p></blockquote><h2 id="Producer工作流程"><a href="#Producer工作流程" class="headerlink" title="Producer工作流程"></a>Producer工作流程</h2><p><img src="/images/kafka_producer_process.jpg" alt></p><h3 id="序列化消息-amp-amp-计算partition"><a href="#序列化消息-amp-amp-计算partition" class="headerlink" title="序列化消息 &amp;&amp; 计算partition"></a>序列化消息 &amp;&amp; 计算partition</h3><p>根据key和value的配置对消息进行序列化,然后计算partition：  </p><ul><li><p>ProducerRecord对象中如果指定了partition，就使用这个partition;</p></li><li><p>否则根据key和topic的partition数目取余;</p></li><li><p>如果key也没有的话就随机生成一个counter，使用这个counter来和partition数目取余。这个counter每次使用的时候递增。</p></li></ul><h3 id="发送到batch-amp-amp-唤醒Sender线程"><a href="#发送到batch-amp-amp-唤醒Sender线程" class="headerlink" title="发送到batch &amp;&amp; 唤醒Sender线程"></a>发送到batch &amp;&amp; 唤醒Sender线程</h3><p>根据topic-partition获取对应的<code>batchs（Dueue&lt;ProducerBatch&gt;）</code>，然后将消息append到batch中. 如果有batch满了则唤醒Sender线程。队列的操作是加锁执行，所以batch内消息是有序的，后续的Sender操作为异步操作。  </p><h3 id="Sender把消息有序发到broker（tp-replia-leader）"><a href="#Sender把消息有序发到broker（tp-replia-leader）" class="headerlink" title="Sender把消息有序发到broker（tp replia leader）"></a>Sender把消息有序发到broker（tp replia leader）</h3><p><strong>确定tp relica leader 所在的broker</strong></p><ul><li><p>Kafka中每台broker都保存了kafka集群的<code>metadata</code>信息，metadata信息里包括了每个topic的所有partition的信息: <code>leader</code>, <code>leader_epoch</code>, <code>controller_epoch</code>, <code>isr</code>, <code>replicas</code>等; Kafka客户端从任一broker都可以获取到需要的metadata信息; sender线程通过metadata信息可以知道tp leader的brokerId</p></li><li><p>producer也保存了metada信息，同时根据metadata更新策略（定期更新<code>metadata.max.age.ms</code>、失效检测，强制更新)：检查到metadata失效以后，调用<code>metadata.requestUpdate()</code>强制更新</p></li></ul><p><strong>幂等性发送</strong><br>为实现Producer的幂等性，Kafka引入了<code>Producer ID</code>（即PID）和<code>Sequence Number</code>。<strong>对于每个PID，该Producer发送消息的每个&lt;Topic, Partition&gt;都对应一个单调递增的Sequence Number</strong>。同样，Broker端也会为每个&lt;PID, Topic, Partition&gt;维护一个序号，并且每Commit一条消息时将其对应序号递增。对于接收的每条消息，如果其序号比Broker维护的序号）大一，则Broker会接受它，否则将其丢弃：  </p><ul><li><p>如果消息序号比Broker维护的序号差值比一大，说明中间有数据尚未写入，即乱序，此时Broker拒绝该消息，Producer抛出<code>InvalidSequenceNumber</code></p></li><li><p>如果消息序号小于等于Broker维护的序号，说明该消息已被保存，即为重复消息，Broker直接丢弃该消息，Producer抛出<code>DuplicateSequenceNumber</code></p></li></ul><h3 id="Sender处理broker发来的produce-response"><a href="#Sender处理broker发来的produce-response" class="headerlink" title="Sender处理broker发来的produce response"></a>Sender处理broker发来的produce response</h3><p>一旦broker处理完Sender的produce请求，就会发送produce response给Sender，此时producer将执行我们为send()设置的回调函数。至此producer的send执行完毕。   </p><h2 id="Consumer工作流程"><a href="#Consumer工作流程" class="headerlink" title="Consumer工作流程"></a>Consumer工作流程</h2><h3 id="Poll消息"><a href="#Poll消息" class="headerlink" title="Poll消息"></a>Poll消息</h3><p><img src="/images/kafka_consumer_poll.jpg" alt></p><ul><li><p>消费者通过fetch线程拉消息（单线程）</p></li><li><p>消费者通过心跳线程来与broker发送心跳。超时会认为挂掉</p></li><li><p>每个<code>consumer group</code>在<code>broker</code>上都有一个<code>coordnator</code>来管理，消费者加入和退出，以及消费消息的位移都由<code>coordnator</code>处理。</p></li></ul><h3 id="位移管理"><a href="#位移管理" class="headerlink" title="位移管理"></a>位移管理</h3><p>consumer的消息位移代表了当前group对topic-partition的消费进度，consumer宕机重启后可以继续从该offset开始消费。</p><p>在kafka0.8之前，位移信息存放在zookeeper上，由于zookeeper不适合高并发的读写，新版本Kafka把位移信息当成消息，发往 <strong><em>__consumers_offsets</em></strong> 这个 topic 所在的 broker，<strong><em>__consumers_offsets</em></strong> 默认有50个分区。<br>消息的key 是 <code>groupId+topic_partition</code>, value 是<code>offset</code>.<br><img src="/images/kafka_weiyi_manage.jpg" alt="-w887"></p><h3 id="Kafka-Group状态"><a href="#Kafka-Group状态" class="headerlink" title="Kafka Group状态"></a>Kafka Group状态</h3><p><img src="/images/kafka_group_status.jpg" alt></p><ul><li><p><strong>Empty</strong>：初始状态，Group 没有任何成员，如果所有的 offsets 都过期的话就会变成 Dead</p></li><li><p><strong>PreparingRebalance</strong>：Group 正在准备进行 Rebalance</p></li><li><p><strong>AwaitingSync</strong>：Group 正在等待 group leader 的分配方案</p></li><li><p><strong>Stable</strong>：稳定的状态（Group is stable）；</p></li><li><p><strong>Dead</strong>： Group 内已经没有成员，并且它的 Metadata 已经被移除</p></li></ul><h3 id="重平衡Reblance"><a href="#重平衡Reblance" class="headerlink" title="重平衡Reblance"></a>重平衡Reblance</h3><p>当一些原因导致consumer对partition消费不再均匀时，kafka 会自动执行rebalance，使得consumer对partition的消费再次平衡。</p><p>什么时候发生rebalance？：</p><ul><li><p>组订阅topic数变更</p></li><li><p>topic partition数变更</p></li><li><p>consumer成员变更</p></li></ul><h4 id="Reblance过程"><a href="#Reblance过程" class="headerlink" title="Reblance过程"></a>Reblance过程</h4><ul><li><p><strong>举例1 consumer被检测为崩溃引起的rebalance</strong><br>比如心跳线程在 <code>timeout</code> 时间内没和 <code>broker</code> 发送心跳，此时 <code>coordinator</code> 认为该group应该进行rebalance。接下来其他consumer发来fetch请求后，coordinator将回复他们进行rebalance通知。当consumer成员收到请求后，只有leader会根据分配策略进行分配，然后把各自的分配结果返回给coordinator。 这个时候只有consumer leader返回的是实质数据，其他返回的都为空。收到分配方法后，coordinator将会把分配策略同步给各consumer.</p></li><li><p><strong>举例2 consumer加入引起的rebalance</strong></p><ul><li><p>使用 <strong>join</strong> 协议，表示有consumer 要加入到group中<br><img src="/images/kafka_rebalance_join.jpg" alt></p></li><li><p>使用 <strong>sync</strong> 协议，根据分配规则进行分配<br><img src="/images/kafka_rebalance_sync.jpg" alt></p></li></ul></li></ul><h3 id="Rebalance机制存在的问题"><a href="#Rebalance机制存在的问题" class="headerlink" title="Rebalance机制存在的问题"></a>Rebalance机制存在的问题</h3><p>在大型系统中，一个topic可能对应数百个consumer实例。 </p><ul><li><p>这些consumer陆续加入到一个空消费组将导致多次的rebalance； </p></li><li><p>此外consumer 实例启动的时间不可控，很有可能超出coordinator确定的rebalance timeout(即max.poll.interval.ms)，将会再次触发rebalance，而每次rebalance的代价又相当地大，因为很多状态都需要在rebalance前被持久化，而在rebalance后被重新初始化</p><h3 id="新版本改进"><a href="#新版本改进" class="headerlink" title="新版本改进"></a>新版本改进</h3><p>通过延迟进入 <code>PreparingRebalance</code> 状态减少 rebalance 次数<br><img src="/images/kafka_preparing_rebalance.jpg" alt></p><p>  新版本新增了 <code>group.initial.rebalance.delay.ms</code> 参数。<strong>空消费组接受到成员加入请求时，不立即转化到 <code>PreparingRebalance</code> 状态来开启rebalance。当时间超过<code>group.initial.rebalance.delay.ms</code>后，再把group状态改为PreparingRebalance（开启rebalance）</strong>。</p><p>  <strong>实现机制是在coordinator底层新增一个group状态：<code>InitialRebalance</code></strong>。假设此时有多个consumer陆续启动，那么group状态先转化为 <code>InitialRebalance</code>，待<code>group.initial.rebalance.delay.ms</code> 时间后，再转换为<code>PreparingRebalance</code>（开启rebalance）.</p></li></ul><h3 id="消息传输一致"><a href="#消息传输一致" class="headerlink" title="消息传输一致"></a>消息传输一致</h3><p>Kafka提供3种消息传输一致性语义：最多1次，最少1次，恰好1次。</p><ul><li><p><strong>at most once</strong>: 消费者fetch消息, 然后保存offset,然后处理消息; 当client保存offset之后,但是在消息处理过程中consumer进程失效(crash), 导致部分消息未能继续处理.那么此后可能其他consumer会接管,但是因为offset已经提前保存,那么新的consumer将不能fetch到offset之前的消息(尽管它们尚没有被处理), 这就是”at most once”.** 可能会出现数据丢失情况;**</p></li><li><p><strong>at least once</strong>: 消费者fetch消息, 然后处理消息, 然后保存offset. 如果消息处理成功之后, 但是在保存offset阶段zookeeper异常或者consumer失效,导致保存offset操作未能执行成功, 这就导致接下来再次fetch时可能获得上次已经处理过的消息,这就是”at least once”.<strong>可能会重传数据，有可能出现数据被重复处理的情况;</strong></p></li><li><p><strong>exactly once</strong>：并不是指真正只传输1次，只不过有一个机制。确保不会出现“数据被重复处理”和“数据丢失”的情况。消费者的场景中可以采取以下方案来得到“恰好1次”的一致性语义：</p><blockquote><p> 最少1次 ＋ 消费者的输出中额外增加已处理消息最大编号：由于已处理消息最大编号的存在，不会出现重复处理消息的情况</p></blockquote></li></ul><h2 id="Broker设计原理"><a href="#Broker设计原理" class="headerlink" title="Broker设计原理"></a>Broker设计原理</h2><p>Broker 是Kafka 集群中的节点。负责处理生产者发送过来的消息，消费者消费的请求。以及集群节点的管理等。</p><h3 id="broker消息存储"><a href="#broker消息存储" class="headerlink" title="broker消息存储"></a>broker消息存储</h3><ul><li><p>Kafka的消息<strong>以二进制的方式紧凑地存储</strong>，节省了很大空间</p></li><li><p>此外<strong>消息存在 ByteBuffer 而不是堆</strong>，这样broker进程挂掉时，数据不会丢失，同时避免了gc问题</p></li><li><p>通过<strong>零拷贝和顺序寻址</strong>，让消息存储和读取速度都非常快</p></li><li><p>处理fetch请求的时候<strong>通过 zero-copy 加快速度</strong></p></li></ul><h3 id="broker状态数据"><a href="#broker状态数据" class="headerlink" title="broker状态数据"></a>broker状态数据</h3><p>broker设计中，每台机器都保存了相同的状态数据。主要包括以下：</p><ul><li><p>Controller所在的broker ID，即保存了当前集群中controller是哪台broker;</p></li><li><p>集群中所有broker的信息：比如每台broker的ID、机架信息以及配置的若干组连接信息</p></li><li><p>集群中所有节点的信息：严格来说，它和上一个有些重复，不过此项是按照<strong>broker ID</strong>和<strong>监听器类型</strong>进行分组的。 对于超大集群来说，使用这一项缓存可以快速地定位和查找给定节点信息，而无需遍历上一项中的内容，算是一个优化吧</p></li><li><p>集群中所有分区的信息：所谓分区信息指的是<strong>分区的leader、ISR和AR信息以及当前处于offline状态的副本集合</strong>。 这部分数据按照 topic-partitionID 进行分组，可以快速地查找到每个分区的当前状态。（注：AR表示assigned replicas，即创建topic时为该分区分配的副本集合）</p></li></ul><h3 id="broker负载均衡"><a href="#broker负载均衡" class="headerlink" title="broker负载均衡"></a>broker负载均衡</h3><ul><li><p><strong>分区数量负载</strong>：各台broker的partition数量应该均匀<br>partition Replica分配算法如下：</p><ul><li><p>将所有Broker（假设共n个Broker）和待分配的Partition排序;</p></li><li><p>将第i个Partition分配到第（i mod n）个Broker上</p></li><li><p>将第i个Partition的第j个Replica分配到第（(i + j) mod n）个Broker上</p></li></ul></li></ul><ul><li><strong>容量大小负载</strong>：每台broker的硬盘占用大小应该均匀<br>在kafka1.1之前，Kafka能够保证各台broker上partition数量均匀，但由于每个partition内的消息数不同，可能存在不同硬盘之间内存占用差异大的情况。在Kafka1.1中增加了<strong>副本跨路径迁移功能</strong> <code>kafka-reassign-partitions.sh</code>，我们可以结合它和监控系统，实现自动化的负载均衡</li></ul><h2 id="Kafaka重要参数"><a href="#Kafaka重要参数" class="headerlink" title="Kafaka重要参数"></a>Kafaka重要参数</h2><ul><li><p>acks  </p><blockquote><p>producer收到多少broker的答复才算真的发送成功<br>acks = 0 : 不接收发送结果<br>acks = all 或者 -1: 表示发送消息时，不仅要写入本地日志，还要等待所有副本写入成功。<br>acks = 1: 写入本地日志即可，是上述二者的折衷方案，也是默认值。</p></blockquote></li><li><p>retries  </p><blockquote><p>默认为 0，即不重试，立即失败。<br>一个大于 0 的值，表示重试次数。</p></blockquote></li><li><p>buffer.memory</p><blockquote><p>指定 producer 端用于缓存消息的缓冲区的大小，默认 32M；<br>适当提升该参数值，可以增加一定的吞吐量, 但是batch太大会增大延迟，可搭配linger_ms参数使用</p></blockquote></li><li><p>linger_ms</p><blockquote><p>如果batch太大，或者producer qps不高，batch添加的会很慢，我们可以强制在linger_ms时间后发送batch数据</p></blockquote></li><li><p>batch.size</p><blockquote><p>producer 会将发送分区的多条数据封装在一个 batch 中进行发送，这里的参数指的就是 batch 的大小。<br>该参数值过小的话，会降低吞吐量，过大的话，会带来较大的内存压力。<br>默认为 16K，建议合理增加该值。</p></blockquote></li></ul><h2 id="丢失数据的场景及解决方案"><a href="#丢失数据的场景及解决方案" class="headerlink" title="丢失数据的场景及解决方案"></a>丢失数据的场景及解决方案</h2><h3 id="consumer端"><a href="#consumer端" class="headerlink" title="consumer端"></a>consumer端</h3><p>不是严格意义的丢失，其实只是漏消费了。<br>设置了 <code>auto.commit.enable=true</code> ，当 consumer fetch 了一些数据但还没有完全处理掉的时候，刚好到 commit interval 触发了提交 offset 操作，接着 consumer 挂掉。这时已经fetch的数据还没有处理完成但已经被commit掉，因此没有机会再次被处理，数据丢失。</p><p><strong>解决方案：</strong><br><code>enable.auto.commit=false</code> 关闭自动提交位移，在消息被完整处理之后再手动提交位移</p><h3 id="producer端"><a href="#producer端" class="headerlink" title="producer端"></a>producer端</h3><p>I/O 线程发送消息之前，producer 崩溃， 则 producer 的内存缓冲区的数据将丢失</p><p><strong>解决方案：</strong></p><ul><li><p>同步发送，性能差，不推荐。</p></li><li><p>仍然异步发送，通过“无消息丢失配置”（来自胡夕的《Apache Kafka 实战》）极大降低丢失的可能性：</p><ul><li><p><code>block.on.buffer.full = true</code> 尽管该参数在0.9.0.0已经被标记为“deprecated”，但鉴于它的含义非常直观，所以这里还是显式设置它为true，<strong>使得producer将一直等待缓冲区直至其变为可用。否则如果producer生产速度过快耗尽了缓冲区，producer将抛出异常</strong></p></li><li><p><code>acks=all</code> 很好理解，所有follower都响应了才认为消息提交成功，即”committed”</p></li><li><p><code>retries = MAX</code> 无限重试，直到你意识到出现了问题:)</p></li><li><p><code>max.in.flight.requests.per.connection = 1</code> 限制客户端在单个连接上能够发送的未响应请求的个数。设置此值是1表示kafka broker在响应请求之前client不能再向同一个broker发送请求。注意：<strong>设置此参数是为了避免消息乱序</strong></p></li><li><p>使用<code>KafkaProducer.send(record, callback)</code>而不是<code>send(record)</code>方法 自定义回调逻辑处理消息发送失败</p></li><li><p>callback逻辑中最好显式关闭<code>producer：close(0)</code> 注意：设置此参数是为了避免消息乱序</p></li><li><p><code>unclean.leader.election.enable=false</code> 关闭unclean leader选举，即<strong>不允许非ISR中的副本被选举为leader，以避免数据丢失</strong></p></li><li><p><code>replication.factor &gt;= 3</code> 这个完全是个人建议了，参考了Hadoop及业界通用的三备份原则</p></li><li><p><code>min.insync.replicas &gt; 1</code> 消息至少要被写入到这么多副本才算成功，也是提升数据持久性的一个参数。与acks配合使用</p></li><li><p>保证<code>replication.factor &gt; min.insync.replicas</code> 如果两者相等，当一个副本挂掉了分区也就没法正常工作了。通常设置<code>replication.factor = min.insync.replicas + 1</code> 即可</p></li></ul></li></ul><h2 id="如何选择Partiton的数量"><a href="#如何选择Partiton的数量" class="headerlink" title="如何选择Partiton的数量"></a>如何选择Partiton的数量</h2><ul><li><p>在创建 Topic 的时候可以指定 Partiton 数量，也可以在创建完后手动修改。但 <strong>Partiton 数量只能增加不能减少</strong>。中途增加 Partiton，<strong>partition里面的message不会重新进行分配，原来的partition里面的message数据不会变</strong>，新加的这个partition刚开始是空的，随后进入这个topic的message就会重新参与所有partition的load balance。</p></li><li><p>Partition 的数量直接决定了该 Topic 的并发处理能力。但也并不是越多越好。<strong>Partition 的数量对消息延迟性会产生影响</strong>。</p></li><li><p>一般建议选择 <strong>Broker Num * Consumer Num</strong>，这样<strong>平均每个 Consumer 会同时读取 Broker 数目个 Partition</strong> ， 这些 Partition 压力可以平摊到每台 Broker 上</p></li></ul><h2 id="controller的职责"><a href="#controller的职责" class="headerlink" title="controller的职责"></a>controller的职责</h2><p>在 kafka 集群中，某个 broker 会被选举承担特殊的角色，即<strong>控制器（controller)</strong>，用于<strong>管理和协调 kafka 集群</strong>，具体职责如下：</p><ul><li><p>管理副本和分区的状态</p></li><li><p>更新集群元数据信息</p></li><li><p>创建、删除 topic</p></li><li><p>分区重分配</p></li><li><p>leader 副本选举</p></li><li><p>topic 分区扩展</p></li><li><p>broker 加入、退出集群</p></li><li><p>受控关闭</p></li><li><p>controller leader选举</p></li></ul><h2 id="节点异常情形"><a href="#节点异常情形" class="headerlink" title="节点异常情形"></a>节点异常情形</h2><h3 id="leader挂了（leader-failover）"><a href="#leader挂了（leader-failover）" class="headerlink" title="leader挂了（leader failover）"></a>leader挂了（leader failover）</h3><p>当 leader 挂了之后，controller 默认会从 <strong><em>ISR</em></strong> 中选择一个 replica 作为 leader 继续工作，条件是<strong>新 leader 必须有挂掉 leader 的所有数据</strong>。</p><p>如果为了系统的可用性，而容忍降低数据的一致性的话，可以将 <code>unclean.leader.election.enable = true</code>，开启 kafka 的<strong>“脏 leader 选举”</strong>。当 ISR 中没有 replica，则选一个幸存的replica作为leader 继续响应请求，如此操作提高了 Kafka 的分区容忍度，但是数据一致性降低了。</p><h3 id="broker挂了（broker-failover）"><a href="#broker挂了（broker-failover）" class="headerlink" title="broker挂了（broker failover）"></a>broker挂了（broker failover）</h3><p>broker上面有很多 partition 和多个 leader 。因此至少需要处理如下内容：</p><ul><li><p>更新该 broker 上所有 follower 的状态</p></li><li><p>重新给 leader 在该 broker 上的 partition 选举 leader</p></li><li><p>选举完成后，要更新 partition 的状态，比如谁是 leader 等</p></li></ul><p>kafka 集群启动后，所有的 broker 都会被 controller 监控，一旦有 broker 宕机，<strong>ZK 的监听机制会通知到 controller</strong>， controller 拿到挂掉 broker 中所有的 partition，以及它上面的存在的 leader，然后从 partition的 <strong><em>ISR</em></strong> 中选择一个 follower 作为 leader，更改 partition 的 follower 和 leader 状态。</p><h3 id="controller挂了（controller-failover）"><a href="#controller挂了（controller-failover）" class="headerlink" title="controller挂了（controller failover）"></a>controller挂了（controller failover）</h3><ul><li><p>由于每个 broker 都会在 zookeeper 的 “/controller” 节点注册 watcher，当 controller 宕机时 zookeeper 中的临时节点消失，所有存活的 broker 收到 fire 的通知</p></li><li><p>存活的 broker 收到 fire 的通知后，每个 broker 都尝试创建新的 controller path，只有一个竞选成功并当选为 controller。</p></li></ul><h2 id="Zookeeper在Kafka中作用"><a href="#Zookeeper在Kafka中作用" class="headerlink" title="Zookeeper在Kafka中作用"></a>Zookeeper在Kafka中作用</h2><ul><li><p>管理 broker 与 consumer 的动态加入与离开。（Producer 不需要管理，随便一台计算机都可以作为Producer 向 Kakfa Broker 发消息）</p></li><li><p>触发负载均衡，当 broker 或 consumer 加入或离开时会触发负载均衡算法，使得一个 consumer group 内的多个 consumer 的消费负载平衡。（因为一个 comsumer 消费一个或多个partition，一个 partition 只能被一个 consumer 消费）</p></li><li><p>维护消费关系及每个 partition 的消费信息</p></li></ul><h2 id="Page-Cache带来的好处"><a href="#Page-Cache带来的好处" class="headerlink" title="Page Cache带来的好处"></a>Page Cache带来的好处</h2><p>Linux 总会把系统中还没被应用使用的内存挪来给 Page Cache，在命令行输入<code>free</code>，或者 <code>cat /proc/meminfo</code> ，“Cached”的部分就是 Page Cache。</p><p>Page Cache 中每个文件是一棵 <strong>Radix 树</strong>（又称 PAT 位树, 一种多叉搜索树），节点由 <strong><em>4k</em></strong> 大小的 Page 组成，可以通过文件的偏移量（如 0x1110001）快速定位到某个Page。</p><p>当写操作发生时，它只是将数据写入 Page Cache 中，并将该页置上 dirty 标志。</p><p>当读操作发生时，它会<strong>首先在 Page Cache 中查找，如果有就直接返回，没有的话就会从磁盘读取文件写入 Page Cache 再读取</strong>。</p><p>可见，<strong>只要生产者与消费者的速度相差不大，消费者会直接读取之前生产者写入Page Cache的数据，大家在内存里完成接力，根本没有磁盘访问</strong>。</p><p>而比起在内存中维护一份消息数据的传统做法，这<strong>既不会重复浪费一倍的内存，Page Cache 又不需要 GC</strong> （可以放心使用60G内存了），而且<strong>即使 Kafka 重启了，Page Cache 还依然在</strong>。</p><p>参考：<br>[1] <a href="https://zhuanlan.zhihu.com/p/65512721" target="_blank" rel="noopener">Kafka常见问题 [知乎]</a><br>[2] <a href="https://mp.weixin.qq.com/s/zxPz_aFEMrshApZQ727h4g" target="_blank" rel="noopener">Kafka系统设计开篇</a><br>[3] <a href="https://blog.csdn.net/u013573133/article/details/48142677" target="_blank" rel="noopener">Kafka史上最详细原理总结</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;集群架构图&quot;&gt;&lt;a href=&quot;#集群架构图&quot; class=&quot;headerlink&quot; title=&quot;集群架构图&quot;&gt;&lt;/a&gt;集群架构图&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/images/kafka_cluster_architecture.png&quot; alt=&quot;kaf
      
    
    </summary>
    
      <category term="中间件" scheme="http://yoursite.com/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
      <category term="Kafka" scheme="http://yoursite.com/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/Kafka/"/>
    
    
      <category term="kafka" scheme="http://yoursite.com/tags/kafka/"/>
    
      <category term="基本原理" scheme="http://yoursite.com/tags/%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Mysql锁机制</title>
    <link href="http://yoursite.com/2019/12/20/Mysql%E9%94%81%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2019/12/20/Mysql锁机制/</id>
    <published>2019-12-20T11:23:50.000Z</published>
    <updated>2019-12-20T12:03:52.269Z</updated>
    
    <content type="html"><![CDATA[<h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><p>MySQL/InnoDB的加锁，一直是一个常见的话题。例如，数据库如果有高并发请求，如何保证数据完整性？产生死锁问题如何排查并解决？下面是不同锁等级的区别</p><ul><li><p><strong>表级锁</strong><br>开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高 ，并发度最低。</p></li><li><p><strong>页面锁</strong><br>开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</p></li><li><p><strong>行级锁</strong><br>开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</p></li></ul><p>查看数据库支持的存储引擎：</p><blockquote><p>SHOW ENGINES</p></blockquote><p><img src="/images/msyql_lock_transaction.jpg" alt></p><h2 id="InnoDB存储引擎"><a href="#InnoDB存储引擎" class="headerlink" title="InnoDB存储引擎"></a>InnoDB存储引擎</h2><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>用数据版本（Version）记录机制实现，这是乐观锁最常用的一种实现方式。</p><p>何谓数据版本？</p><p>即为数据增加一个版本标识，一般是通过为数据库表增加一个数字类型的 “version” 字段来实现。</p><ul><li><p>当读取数据时，将version字段的值一同读出，数据每更新一次，对此version值加1。</p></li><li><p>当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的version值进行比对，如果数据库表当前版本号与第一次取出来的version值相等，则予以更新，否则认为是过期数据。</p></li></ul><p>举例：<br>1、数据库表三个字段，分别是id、value、version</p><blockquote><p>select id,value,version from TABLE where id = #{id}</p></blockquote><p>2、每次更新表中的value字段时，为了防止发生冲突，需要这样操作</p><blockquote><p>update TABLE<br>set value=2,version=version+1<br>where id=#{id} and version=#{version}</p></blockquote><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>悲观锁就是在操作数据时，认为此操作会出现数据冲突，所以<strong>在进行每次操作时都要通过获取锁才能进行对相同数据的操作</strong>，这点跟java中的synchronized很相似，所以悲观锁需要耗费较多的时间。</p><p>另外与乐观锁相对应的，<strong>悲观锁是由数据库自己实现</strong>了的，要用的时候，我们直接调用数据库的相关语句就可以了。</p><p>说到这里，由悲观锁涉及到的另外两个锁概念就出来了，它们就是共享锁与排它锁。共享锁和排它锁是悲观锁的不同的实现，它俩都属于悲观锁的范畴。</p><h4 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h4><p>共享锁又称读锁 (read lock)，是读操作创建的锁。其他用户可以并发读取数据，但任何事务都不能对数据进行修改（获取数据上的排他锁），直到已释放所有共享锁。当如果事务对读锁进行修改操作，很可能会造成死锁。如下图所示。<br><img src="/images/mysql_share_lock.jpg" alt></p><p><strong>如果事务T对数据A加上共享锁后，则其他事务只能对A再加共享锁，不能加排他锁</strong>。获得共享锁的事务只能读数据，不能修改数据。</p><p>在查询语句后面增加 <code>LOCK IN SHARE MODE</code>，Mysql会<strong>对查询结果中的每行都加共享锁</strong>，当没有其他线程对查询结果集中的任何一行使用排他锁时，可以成功申请共享锁，否则会被阻塞。 其他线程也可以读取使用了共享锁的表，而且这些线程读取的是同一个版本的数据。</p><p>加上共享锁后，对于<code>update</code>，<code>insert</code>，<code>delete</code>语句会自动加排它锁。</p><h4 id="排它锁"><a href="#排它锁" class="headerlink" title="排它锁"></a>排它锁</h4><p>排他锁<code>Exclusive Lock</code>（也叫writer lock）又称写锁。</p><p>名词解释：若某个事物对某一行加上了排他锁，<strong>只能这个事务对其进行读写，在此事务结束之前，其他事务不能对其进行加任何锁</strong>，其他进程可以读取, 不能进行写操作，需等待其释放。</p><p>若事务 1 对数据对象A加上X锁，事务 1 可以读A也可以修改A，其他事务不能再对A加任何锁，直到事物 1 释放A上的锁。这保证了其他事务在事物 1 释放A上的锁之前不能再读取和修改A。<strong>排它锁会阻塞所有的排它锁和共享锁.</strong></p><p>读取为什么要加读锁呢？</p><blockquote><p>防止数据在被读取的时候被别的线程加上写锁。</p></blockquote><p>排他锁使用方式：在需要执行的语句后面加上<code>for update</code>就可以了</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">status</span> <span class="keyword">from</span> <span class="keyword">TABLE</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure><p>排他锁，也称写锁，独占锁，当前写操作没有完成前，它会阻断其他写锁和读锁。<br><img src="/images/mysql_exclusive_lock.jpg" alt></p><p>排他锁之所以能阻止<code>update</code>,<code>delete</code>等操作是因为<code>update</code>，<code>delete</code>操作会自动加排他锁，<br>也就是说<strong>即使加了排他锁也无法阻止<code>select</code>操作</strong>。而<code>select XXX for update</code> 语法可以对<code>select</code>操作加上排他锁。 所以为了防止更新丢失可以在<code>select</code>时加上<code>for update</code>加锁, 这样就可以阻止其余事务的<code>select for update</code> <strong>(但注意无法阻止select)</strong>.</p><p>要使用排他锁，我们必须关闭mysql数据库的自动提交属性，因为MySQL默认使用autocommit模式，也就是说，当你执行一个更新操作后，MySQL会立刻将结果进行提交。</p><h3 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h3><p>多个事务操作同一行数据时，后来的事务处于阻塞等待状态。这样可以避免了脏读等数据一致性的问题。后来的事务可以操作其他行数据，解决了表锁高并发性能低的问题。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Transaction-A</span></span><br><span class="line">mysql&gt; set autocommit = 0;</span><br><span class="line">mysql&gt; update innodb_lock set v='1001' where id=1;</span><br><span class="line">mysql&gt; commit;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Transaction-B</span></span><br><span class="line">mysql&gt; update innodb_lock set v='2001' where id=2;</span><br><span class="line">Query OK, 1 row affected (0.37 sec)</span><br><span class="line">mysql&gt; update innodb_lock set v='1002' where id=1;  ## 被事务A阻塞</span><br><span class="line">Query OK, 1 row affected (37.51 sec)</span><br></pre></td></tr></table></figure><p>现实：<strong>当执行批量修改数据脚本的时候，行锁升级为表锁</strong>。其他对订单的操作都处于等待中，，，</p><p>原因：<strong>InnoDB只有在通过索引条件检索数据时使用行级锁，否则使用表锁</strong>！ 而模拟操作正是通过id去作为检索条件，而id又是MySQL自动创建的唯一索引，所以才忽略了行锁变表锁的情况</p><p><strong>总结</strong>：<font color="red"><strong>InnoDB的行锁是针对索引加的锁，不是针对记录加的锁。并且该索引不能失效，否则都会从行锁升级为表锁。</strong></font></p><ul><li><p>行锁的劣势<br>开销大；加锁慢；会出现死锁</p></li><li><p>行锁的优势<br>锁的粒度小，发生锁冲突的概率低；处理并发的能力强</p></li><li><p>加锁的方式<br>自动加锁。对于<code>UPDATE</code>、<code>DELETE</code>和<code>INSERT</code>语句，InnoDB会自动给涉及数据集加排他锁；对于普通SELECT语句，InnoDB不会加任何锁；当然我们也可以显示的加锁：</p></li></ul><p>从上面的案例看出，行锁变表锁似乎是一个坑，可MySQL没有这么无聊给你挖坑。这是因为MySQL有自己的执行计划。</p><p>当你需要更新一张较大表的大部分甚至全表的数据时。而你又傻乎乎地用索引作为检索条件。一不小心开启了行锁(没毛病啊！保证数据的一致性！)。可MySQL却认为大量对一张表使用行锁，会导致事务执行效率低，从而可能造成其他事务长时间锁等待和更多的锁冲突问题，性能严重下降。所以MySQL会将行锁升级为表锁，即实际上并没有使用索引。</p><p>我们仔细想想也能理解，既然整张表的大部分数据都要更新数据，在一行一行地加锁效率则更低。其实我们可以通过<code>explain</code>命令查看MySQL的执行计划，你会发现key为null。表明MySQL实际上并没有使用索引，行锁升级为表锁也和上面的结论一致。</p><p>注意：<strong>行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁</strong>。</p><p>行锁根据锁定范围又分为间隙锁、临键锁和记录锁。<br><img src="/images/mysql_lock_partition.jpg" alt></p><h4 id="临健锁"><a href="#临健锁" class="headerlink" title="临健锁"></a>临健锁</h4><p>当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的临键锁（Next-Key锁）。<br><img src="/images/mysql_next_key_lock.jpg" alt></p><p>危害(坑)：若执行的条件是范围过大，则InnoDB会将整个范围内所有的索引键值全部锁定，很容易对性能造成影响。</p><h4 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h4><p><img src="/images/mysql_gap_lock.jpg" alt></p><h4 id="记录锁"><a href="#记录锁" class="headerlink" title="记录锁"></a>记录锁</h4><p><img src="/images/mysql_record_lock.jpg" alt><br>记录锁在锁定非主键索引时，也会一并锁定主键；</p><h3 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h3><p>Innodb 的行锁是在有索引的情况下，没有索引的表是锁定全表的。</p><p>在Innodb引擎中既支持行锁也支持表锁，那么什么时候会锁住整张表，什么时候只锁住一行呢？</p><blockquote><p>只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！</p></blockquote><p>在实际应用中，要特别注意InnoDB行锁的这一特性，不然的话，可能导致大量的锁冲突，从而影响并发性能。</p><p>行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁。</p><p>行级锁的缺点是：<strong>由于需要请求大量的锁资源，所以速度慢，内存消耗大。</strong></p><h3 id="死锁（Deadlock）"><a href="#死锁（Deadlock）" class="headerlink" title="死锁（Deadlock）"></a>死锁（Deadlock）</h3><p>所谓死锁：是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。由于资源占用是互斥的，当某个进程提出申请资源后，使得有关进程在无外力协助下，永远分配不到必需的资源而无法继续运行，这就产生了一种特殊现象死锁。</p><p>解除正在死锁的状态有两种方法：<br><strong>第一种：</strong></p><ul><li><p>1、查询是否锁表  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">OPEN</span> <span class="keyword">TABLES</span> <span class="keyword">where</span> In_use &gt; <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li><li><p>2、查询进程（如果您有SUPER权限，您可以看到所有线程。否则，您只能看到您自己的线程）  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">processlist</span></span><br></pre></td></tr></table></figure></li><li><p>3、杀死进程id（就是上面命令的id列）   </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">kill</span> <span class="keyword">id</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>第二种：</strong></p><ul><li>1、查看当前的事务  </li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> INFORMATION_SCHEMA.INNODB_TRX;</span><br></pre></td></tr></table></figure><ul><li><p>2、查看当前锁定的事务  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> INFORMATION_SCHEMA.INNODB_LOCKS;</span><br></pre></td></tr></table></figure></li><li><p>3、查看当前等锁的事务  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> INFORMATION_SCHEMA.INNODB_LOCK_WAITS;</span><br></pre></td></tr></table></figure></li><li><p>4、杀死进程  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">kill</span> 进程<span class="keyword">ID</span></span><br></pre></td></tr></table></figure></li></ul><p>产生死锁的四个必要条件：</p><ul><li>互斥条件：一个资源每次只能被一个进程使用。</li><li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li><li>不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。</li><li>循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</li></ul><p>如果系统资源充足，进程的资源请求都能够得到满足，死锁出现的可能性就很低，否则就会因争夺有限的资源而陷入死锁。其次，进程运行推进顺序与速度不同，也可能产生死锁。虽然不能完全避免死锁，但可以使死锁的数量减至最少。将死锁减至最少可以增加事务的吞吐量并减少系统开销，因为只有很少的事务回滚，而回滚会取消事务执行的所有工作。由于死锁时回滚的操作由应用程序重新提交。</p><p>下列方法有助于最大限度地降低死锁：</p><ul><li>按同一顺序访问对象。</li><li>避免事务中的用户交互。</li><li>保持事务简短并在一个批处理中。</li><li>使用低隔离级别。</li><li>使用绑定连接。</li></ul><h2 id="MyISAM存储引擎"><a href="#MyISAM存储引擎" class="headerlink" title="MyISAM存储引擎"></a>MyISAM存储引擎</h2><p>InnoDB和MyISAM的最大不同点有两个：</p><ul><li>InnoDB支持事务(transaction)；MyISAM不支持事务</li><li>Innodb默认采用行锁， MyISAM是默认采用表锁。</li></ul><p><strong>MyISAM不适合高并发</strong></p><h3 id="共享读锁"><a href="#共享读锁" class="headerlink" title="共享读锁"></a>共享读锁</h3><p>对MyISAM表的读操作（加读锁），不会阻塞其他进程对同一表的读操作，但会阻塞对同一表的写操作。只有当读锁释放后，才能执行其他进程的写操作。在锁释放前不能读其他表。<br><img src="/images/mysql_myisam_share_lock.jpg" alt></p><h3 id="独占写锁"><a href="#独占写锁" class="headerlink" title="独占写锁"></a>独占写锁</h3><p>对MyISAM表的写操作（加写锁）<strong>，会阻塞其他进程对同一表的读和写操作，只有当写锁释放后，才会执行其他进程的读写操作。</strong>在锁释放前不能写其他表。<br><img src="/images/mysql_myisam_exclusive_lock.jpg" alt></p><p><strong>总结：</strong></p><ul><li><p>表锁，读锁会阻塞写，不会阻塞读。而写锁则会把读写都阻塞。</p></li><li><p>表锁的加锁/解锁方式：MyISAM在执行查询语句(SELECT)前,会<strong>自动给涉及的所有表加读锁</strong>,在执行更新操作 (<code>UPDATE</code>、<code>DELETE</code>、<code>INSERT</code>等)前，会自动给涉及的表加写锁，这个过程并不需要用户干预，因此，用户一般不需要直接用LOCK TABLE命令给MyISAM表显式加锁。</p></li></ul><p>如果用户想要显示的加锁可以使用以下命令：<br><strong>锁定表</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LOCK</span> <span class="keyword">TABLES</span> tbl_name &#123;<span class="keyword">READ</span> | WRITE&#125;,[ tbl_name &#123;<span class="keyword">READ</span> | WRITE&#125;,…]</span><br></pre></td></tr></table></figure><p><strong>解锁表</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UNLOCK</span> <span class="keyword">TABLES</span></span><br></pre></td></tr></table></figure><p>在用 <code>LOCK TABLES</code> 给表显式加表锁时, 必须同时取得所有涉及到表的锁。</p><p>在执行 <code>LOCK TABLES</code> 后，只能访问显式加锁的这些表，不能访问未加锁的表;</p><p><strong>如果加的是读锁，那么只能执行查询操作，而不能执行更新操作。</strong></p><p>在自动加锁的情况下也基本如此，MyISAM 总是一次获得 SQL 语句所需要的全部锁。这也正是 MyISAM 表不会出现死锁(Deadlock Free)的原因。</p><p>对表test_table增加读锁：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LOCK</span> <span class="keyword">TABLES</span> test_table <span class="keyword">READ</span> </span><br><span class="line"><span class="keyword">UNLOCK</span> test_table</span><br></pre></td></tr></table></figure><p>对表test_table增加写锁</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LOCK</span> <span class="keyword">TABLES</span> test_table WRITE</span><br><span class="line"><span class="keyword">UNLOCK</span> test_table</span><br></pre></td></tr></table></figure><p>当使用 <code>LOCK TABLES</code> 时，不仅需要一次锁定用到的所有表,而且,同一个表在 SQL 语句中出现多少次，就要通过与 SQL 语句中相同的别名锁定多少次，否则也会出错！<br>比如如下SQL语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> a.first_name,b.first_name, <span class="keyword">from</span> actor a,actor b <span class="keyword">where</span> a.first_name = b.first_name;</span><br></pre></td></tr></table></figure><p>该Sql语句中，<code>actor</code>表以别名的方式出现了两次，分别是<code>a</code>,<code>b</code>，这时如果要在该Sql执行之前加锁就要使用以下Sql:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lock</span> <span class="keyword">table</span> actor <span class="keyword">as</span> a <span class="keyword">read</span>, actor <span class="keyword">as</span> b <span class="keyword">read</span>;</span><br></pre></td></tr></table></figure><h3 id="并发插入"><a href="#并发插入" class="headerlink" title="并发插入"></a>并发插入</h3><p>上文说到过 MyISAM 表的读和写是串行的, 但这是就总体而言的。在一定条件下,MyISAM表也支持查询和插入操作的并发进行。 MyISAM存储引擎有一个系统变量<code>concurrent_insert</code>,专门用以控制其并发插入的行为,其值分别可以为0、1或2。</p><blockquote><p>0: 不允许并发插入;<br>1: 如果MyISAM表中没有空洞(即表的中间没有被删除的行), MyISAM允许在一个进程读表的同时,另一个进程从表尾插入记录。这也是MySQL 的默认设置;<br>2: 无论MyISAM表中有没有空洞, 都允许在表尾并发插入记录;</p></blockquote><p>可以利用MyISAM存储引擎的并发插入特性,来解决应用中对同一表查询和插入的锁争用。</p><h3 id="MyISAM的锁调度"><a href="#MyISAM的锁调度" class="headerlink" title="MyISAM的锁调度"></a>MyISAM的锁调度</h3><p>MyISAM 存储引擎的读锁和写锁是互斥的，读写操作是串行的。那么，一个进程请求某个 MyISAM 表的读锁，同时另一个进程也请求同一表的写锁，MySQL 如何处理呢?</p><p><strong>答案是<font color="red">写进程</font>先获得锁。</strong></p><p>不仅如此，即使读请求先到锁等待队列，写请求后到，写锁也会插到读锁请求之前！这是因为 MySQL 认为写请求一般比读请求要重要。这也正是 MyISAM 表不太适合于有大量更新操作和查询操作应用的原因，因为大量的更新操作会造成查询操作很难获得读锁，从而可能永远阻塞。这种情况有时可能会变得非常糟糕！</p><p>幸好我们可以通过一些设置来调节 MyISAM 的调度行为。</p><p>通过指定启动参数<code>low-priority-updates</code>，使MyISAM引擎默认给予读请求以优先的权利。</p><ul><li><p>通过执行命令<code>SET LOWPRIORITYUPDATES=1</code>, 使该连接发出的更新请求优先级降低。</p></li><li><p>通过指定<code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>语句的<code>LOW_PRIORITY</code>属性, 降低该语句的优先级。</p></li><li><p>另外, MySQL也供了一种折衷的办法来调节读写冲突, 即给系统参数<code>max_write_lock_count</code> 设置一个合适的值, 当一个表的读锁达到这个值后, MySQL就暂时将写请求的优先级降低, 给读进程一定获得锁的机会。</p></li></ul><p><strong>总结</strong></p><ul><li><p>MySQL的MyISAM引擎支持表级锁。</p></li><li><p>表级锁分为两种：共享读锁、互斥写锁。这两种锁都是阻塞锁。</p></li><li><p>可以在读锁上增加读锁，不能在读锁上增加写锁。在写锁上不能增加写锁。</p></li><li><p>默认情况下，MySql在执行查询语句之前会加读锁，在执行更新语句之前会执行写锁。</p></li><li><p>如果想要显示的加锁/解锁的花可以使用LOCK TABLES和UNLOCK来进行。</p></li><li><p>在使用LOCK TABLES之后，在解锁之前，不能操作未加锁的表。</p></li><li><p>在加锁时，如果显示的指明是要增加读锁，那么在解锁之前，只能进行读操作，不能执行写操作。</p></li><li><p>如果一次Sql语句要操作的表以别名的方式多次出现，那么就要在加锁时都指明要加锁的表的别名。</p></li><li><p>MyISAM存储引擎有一个系统变量<code>concurrent_insert</code>, 专门用以控制其并发插入的行为,其值分别可以为0、1或2。</p></li><li><p>由于读锁和写锁互斥，那么在调度过程中，默认情况下，MySql会本着写锁优先的原则。可以通过<code>low-priority-updates</code>来设置。</p></li></ul><h2 id="利用锁实现事务"><a href="#利用锁实现事务" class="headerlink" title="利用锁实现事务"></a>利用锁实现事务</h2><h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h3><p>修改加上排他锁，那么其他事务就无法读取到正在修改的数据行；<br><img src="/images/mysql_tx_read.png" alt></p><h3 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h3><p>查询加上读锁，则其他事务就无法修改；<br><img src="/images/mysql_tx_repeated_read.jpg" alt></p><h3 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h3><p>范围查询会通过间隙锁使其他事务无法插入范围数据，这不会出现幻读；<br><img src="/images/mysql_tx_huandu.jpg" alt></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.im/post/5b82e0196fb9a019f47d1823#heading-10" target="_blank" rel="noopener">全面了解mysql锁机制（InnoDB）与问题排查</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;总览&quot;&gt;&lt;a href=&quot;#总览&quot; class=&quot;headerlink&quot; title=&quot;总览&quot;&gt;&lt;/a&gt;总览&lt;/h2&gt;&lt;p&gt;MySQL/InnoDB的加锁，一直是一个常见的话题。例如，数据库如果有高并发请求，如何保证数据完整性？产生死锁问题如何排查并解决？下面是不
      
    
    </summary>
    
      <category term="Mysql" scheme="http://yoursite.com/categories/Mysql/"/>
    
      <category term="锁机制" scheme="http://yoursite.com/categories/Mysql/%E9%94%81%E6%9C%BA%E5%88%B6/"/>
    
    
      <category term="Mysql" scheme="http://yoursite.com/tags/Mysql/"/>
    
      <category term="锁" scheme="http://yoursite.com/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>Redis底层数据结构</title>
    <link href="http://yoursite.com/2019/12/20/Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2019/12/20/Redis底层数据结构/</id>
    <published>2019-12-20T11:07:50.000Z</published>
    <updated>2020-01-10T13:01:56.841Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/redis_logo.png" alt></p><h2 id="5种基本数据类型"><a href="#5种基本数据类型" class="headerlink" title="5种基本数据类型"></a>5种基本数据类型</h2><p><img src="/images/redis_five_data_structure.png" alt></p><p>对于每种数据结构，实际上都有自己底层的 <strong>内部编码</strong> 实现，而且是多种实现。这样 Redis 会在合适的 场景 选择合适的 内部编码，如图所示：<br><img src="/images/redis_structure_basic.png" alt></p><p>可以看到，每种 数据结构 都有 两种以上 的 内部编码实现。例如 <code>list</code> 数据结构 包含了 <code>linkedlist</code> 和 <code>ziplist</code> 两种 内部编码。同时有些 内部编码，例如 <code>ziplist</code>，可以作为多种外部数据结构的内部实现，可以通过 <code>object encoding</code> 命令查询内部编码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; object encoding hello</span><br><span class="line">"embstr"</span><br><span class="line">127.0.0.1:6379&gt; object encoding mylist</span><br><span class="line">"quicklist"</span><br></pre></td></tr></table></figure><p>Redis 这样设计有两个好处：</p><ul><li><p>其一：可以改进内部编码，而对外的数据结构和命令没有影响。例如：Redis3.2 提供的 <code>quicklist</code>，结合了 <code>ziplist</code> 和 <code>linkedlist</code> 两者的优势，为 <code>列表类型</code> 提供了一种更加高效的内部编码实现。</p></li><li><p>其二：不同内部编码可以在不同场景下发挥各自的优势。例如 <code>ziplist</code> 比较节省内存，但是在列表元素比较多的情况下，性能会有所下降，这时候Redis会根据配置，将列表类型的内部实现 转换为<code>linkedlist</code>。</p></li></ul><h2 id="String底层结构"><a href="#String底层结构" class="headerlink" title="String底层结构"></a>String底层结构</h2><p>字符串类型是Redis最基础的数据结构。字符串类型的值实际可以是字符串（<strong>简单</strong> 和 <strong>复杂</strong> 的字符串，例如 JSON、XML）、数字（整数、浮点数），甚至是 二进制（图片、音频、视频），但是值最大不能超过 <code>512MB</code>。</p><p>字符串类型的内部编码有 3 种：</p><ul><li><p><strong>int</strong>：8个字节的长整型。</p></li><li><p><strong>embstr</strong>：小于等于39个字节的字符串。</p></li><li><p><strong>raw</strong>：大于39个字节的字符串。</p></li></ul><p>Redis 会根据当前值的 <strong>类型</strong> 和 <strong>长度</strong> 决定使用哪种内部编码实现。</p><h2 id="Hash底层结构"><a href="#Hash底层结构" class="headerlink" title="Hash底层结构"></a>Hash底层结构</h2><p>大部分编程语言都提供了哈希（hash）类型，它们的叫法可能是 <strong>哈希</strong>、<strong>字典</strong>、<strong>关联数组</strong>。在 Redis 中，哈希类型是指键值本身又是一个键值对结构。</p><h3 id="压缩列表-ziplist"><a href="#压缩列表-ziplist" class="headerlink" title="压缩列表(ziplist)"></a>压缩列表(ziplist)</h3><p>当哈希类型元素个数 小于 <code>hash-max-ziplist-entries</code> 配置（默认 512 个）、同时所有值都小于 <code>hash-max-ziplist-value</code> 配置（默认 64 字节）时，Redis会使用<code>ziplist</code> 作为哈希的内部实现，<code>ziplist</code>使用<strong>更加紧凑的结构实现多个元素的连续存储</strong>，所以在节省内存方面比<code>hashtable</code>更加优秀.</p><h3 id="哈希表-hashtable"><a href="#哈希表-hashtable" class="headerlink" title="哈希表(hashtable)"></a>哈希表(hashtable)</h3><p>当哈希类型无法满足 <code>ziplist</code> 的条件时，Redis会使用<code>hashtable</code>作为哈希的内部实现，因为此时 <code>ziplist</code> 的 <strong>读写效率</strong> 会下降，而 <code>hashtable</code> 的读写时间复杂度为 O(1)。</p><p>下面的示例演示了哈希类型的内部编码，以及相应的变化。</p><p>当field个数比较少，且没有大的value时，内部编码为<code>ziplist</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hmset hashkey f1 v1 f2 v2</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; object encoding hashkey</span><br><span class="line">"ziplist"</span><br></pre></td></tr></table></figure><p>当有value大于64字节时，内部编码会由 <code>ziplist</code> 变为 <code>hashtable</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hset hashkey f3 "one string is bigger than 64 byte...忽略..."</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; object encoding hashkey</span><br><span class="line">"hashtable"</span><br></pre></td></tr></table></figure><p>当field个数超过 512，内部编码也会由 <code>ziplist</code> 变为<code>hashtable</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hmset hashkey f1 v1 f2 v2 f3 v3 ... f513 v513</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; object encoding hashkey</span><br><span class="line">"hashtable"</span><br></pre></td></tr></table></figure><h2 id="List底层结构"><a href="#List底层结构" class="headerlink" title="List底层结构"></a>List底层结构</h2><p>列表（list）类型是用来存储多个有序的字符串。在Redis中，可以对列表的<strong>两端</strong>进行 <strong>插入</strong>（push）和 <strong>弹出</strong>（pop）操作，还可以获取 <strong>指定范围</strong> 的 <strong>元素列表</strong>、获取 <strong>指定索引下标</strong> 的 <strong>元素</strong> 等， 一个列表最多可以存储 <code>2^32 - 1</code> 个元素。</p><p>列表是一种比较灵活的数据结构，它可以充当 <strong>栈</strong> 和 <strong>队列</strong> 的角色，在实际开发上有很多应用场景。</p><p>列表类型的内部编码有两种：</p><ul><li><p><strong>ziplist</strong>（压缩列表）<br>当列表的元素个数小于 <code>list-max-ziplist-entries</code> 配置（默认 <code>512</code> 个），同时列表中 每个元素的值都小于  <code>list-max-ziplist-value</code> 配置时（默认 <code>64字节</code>），Redis会选用 <code>ziplist</code>来作为列表的内部实现来减少内存的使用。</p></li><li><p><strong>linkedlist</strong>（链表）<br>当列表类型无法满足<code>ziplist</code>的条件时， Redis会使用 <code>linkedlist</code> 作为列表的内部实现。</p></li></ul><h2 id="Set底层结构"><a href="#Set底层结构" class="headerlink" title="Set底层结构"></a>Set底层结构</h2><p>集合（set）类型也是用来保存多个字符串元素，但和列表类型不一样的是，<strong>集合中不允许有重复元素，并且集合中的元素是无序的，不能通过索引下标获取元素</strong>， 一个集合最多可以存储 <code>2^32 - 1</code> 个元素。</p><p>集合类型的内部编码有两种：</p><ul><li><strong>intset</strong>（整数集合）<br>当集合中的元素都是整数且元素个数小于 <code>set-max-intset-entries</code> 配置（默认 <code>512个</code>）时，Redis会选用 <code>intset</code> 来作为集合的内部实现，从而减少内存的使用。</li></ul><ul><li><strong>hashtable</strong>（哈希表）<br>当集合类型无法满足<code>intset</code>的条件时，Redis会使用<code>hashtable</code>作为集合的内部实现。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.im/post/5b76e732f265da4376203849" target="_blank" rel="noopener">深入剖析Redis系列(一) - Redis入门简介与主从搭建</a></p><p><a href="https://juejin.im/post/5b7d226a6fb9a01a1e01ff64#heading-7" target="_blank" rel="noopener">深入剖析Redis系列(二) - Redis哨兵模式与高可用集群</a></p><p><a href="https://juejin.im/post/5b8fc5536fb9a05d2d01fb11" target="_blank" rel="noopener">深入剖析Redis系列(三) - Redis集群模式搭建与原理详解</a></p><p><a href="https://juejin.im/post/5bb01064e51d453eb93d8028" target="_blank" rel="noopener">深入剖析Redis系列(四) - Redis数据结构与全局命令概述</a></p><p><a href="https://juejin.im/post/5bbc9d03f265da0ab915e3b5" target="_blank" rel="noopener">深入剖析Redis系列(五) - Redis数据结构之字符串</a></p><p><a href="https://juejin.im/post/5bcb3b066fb9a05d1c14c712" target="_blank" rel="noopener">深入剖析Redis系列(七) - Redis数据结构之列表</a></p><p><a href="https://juejin.im/post/5be455d75188250e8601b3e0#heading-23" target="_blank" rel="noopener">深入剖析Redis系列(八) - Redis数据结构之集合</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/redis_logo.png&quot; alt&gt;&lt;/p&gt;
&lt;h2 id=&quot;5种基本数据类型&quot;&gt;&lt;a href=&quot;#5种基本数据类型&quot; class=&quot;headerlink&quot; title=&quot;5种基本数据类型&quot;&gt;&lt;/a&gt;5种基本数据类型&lt;/h2&gt;&lt;p&gt;
      
    
    </summary>
    
      <category term="中间件" scheme="http://yoursite.com/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
      <category term="Redis" scheme="http://yoursite.com/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
      <category term="原理" scheme="http://yoursite.com/tags/%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>TCP TIME_WAIT状态</title>
    <link href="http://yoursite.com/2019/12/18/TCP-TIME-WAIT%E7%8A%B6%E6%80%81/"/>
    <id>http://yoursite.com/2019/12/18/TCP-TIME-WAIT状态/</id>
    <published>2019-12-18T10:57:17.000Z</published>
    <updated>2020-01-10T13:01:56.863Z</updated>
    
    <content type="html"><![CDATA[<p><strong>TIME_WAIT</strong>状态是TCP连接中<strong>主动关闭连接</strong>的一方会进入的状态，在发出最后一个ACK包之后，主动关闭方进入<strong>TIME_WAIT</strong>状态，从而确保:</p><ul><li>ACK包到达对端</li><li>等待网络中之前迷路的数据包完全消失，防止端口被复用的时候收到迷路包从而出现收包错误</li></ul><p><strong>TIME_WAIT</strong>状态会持续<strong>2MSL</strong>（max segment lifetime）的时间，一般1分钟到4分钟。在这段时间内端口不能被重新分配使用。</p><p><strong>TIME_WAIT</strong>并不会占用过多的系统资源，但是可以通过修改内核参数<code>/etc/sysctl.conf</code>来限制<strong>TIME_WAIT</strong>数量。</p><h3 id="四次挥手过程"><a href="#四次挥手过程" class="headerlink" title="四次挥手过程"></a>四次挥手过程</h3><p>先来了解TCP四次挥手的过程：</p><p><img src="/images/tcp_ip_3_handshake.png" alt></p><ul><li><p>第一次：主机 1（可以是客户端，也可以是服务器端），设置 <strong>Sequence Number</strong> 和 <strong>Acknowledgment Number</strong>，向主机 2 发送一个 <strong>FIN</strong> 报文段；此时，主机1进入 <strong>FIN_WAIT_1</strong> 状态；这表示主机 1 没有数据要发送给主机 2 了； </p></li><li><p>第二次：主机 2 收到了主机 1 发送的 <strong>FIN</strong> 报文段，向主机 1 回一个 <strong>ACK</strong> 报文段，<strong>Acknowledgment Number</strong> 为 <strong>Sequence Number</strong> 加 1 ；主机 1 进入 <strong>FIN_WAIT_2</strong> 状态；主机 2 告诉主机 1，我“同意”你的关闭请求；</p></li><li><p>第三次：主机 2 向主机 1 发送FIN报文段，请求关闭连接，同时主机 2 进入<strong>LAST_ACK</strong> 状态；</p></li><li><p>第四次：主机 1 收到主机 2 发送的 <strong>FIN报文段</strong>，向主机2发送 <strong>ACK</strong> 报文段，然后主机1进入 <strong>TIME_WAIT</strong> 状态；主机 2 收到主机 1 的<strong>ACK</strong>报文段以后，就关闭连接；此时，主机1等待 <strong>2 * MSL</strong> 后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。</p></li></ul><p><strong>注：</strong> <strong>MSL</strong>是指<code>Max Segment Lifetime</code>，即<strong>一个IP数据包能在网络中生存的最长时间</strong>，超过这个时间，IP数据包将在网络中消失。每种TCP协议的实现方法均要指定一个合适的MSL值，如RFC1122给出的建议值为2分钟，又如Berkeley体系的TCP实现通常选择30秒作为MSL值。这意味着<strong>TIME_WAIT</strong>的典型持续时间为<code>1-4</code>分钟。</p><h3 id="TCP四次挥手过程中通信双方状态解析"><a href="#TCP四次挥手过程中通信双方状态解析" class="headerlink" title="TCP四次挥手过程中通信双方状态解析"></a>TCP四次挥手过程中通信双方状态解析</h3><ul><li><p><strong>FIN_WAIT_1</strong><br>其实<strong>FIN_WAIT_1</strong>和<strong>FIN_WAIT_2</strong>状态的真正含义都是表示等待对方的<strong>FIN</strong>报文。而这两种状态的区别是：</p><ul><li><strong>FIN_WAIT_1</strong>状态实际上是当<strong>SOCKET</strong>在<strong>ESTABLISHED</strong>状态时，它想主动关闭连接，向对方发送了<strong>FIN</strong>报文，此时该<strong>SOCKET</strong>即进入到<strong>FIN_WAIT_1</strong>状态。而当对方回应ACK报文后，则进入到<strong>FIN_WAIT_2</strong>状态，当然在实际的正常情况下，无论对方何种情况下，都应该马上回应ACK报文，所以<strong>FIN_WAIT_1状态一般是比较难见到的</strong>，而<strong>FIN_WAIT_2</strong>状态还有时常常可以用<strong>netstat</strong>看到。（主动方）</li></ul></li><li><p><strong>FIN_WAIT_2</strong><br>实际上<strong>FIN_WAIT_2</strong>状态下的<strong>SOCKET</strong>，表示<strong>半连接</strong>，也即有一方要求close连接，但另外还告诉对方，我暂时还有点数据需要传送给你(ACK信息)，稍后再关闭连接。（主动方）</p></li><li><p><strong>CLOSE_WAIT</strong><br>表示在等待关闭。当对方<strong>close</strong>一个<strong>SOCKET</strong>后发送<strong>FIN</strong>报文给你，你自然会回应一个<strong>ACK</strong>报文给对方，此时则进入到<strong>CLOSE_WAIT</strong>状态。接下来呢，实际上你真正需要考虑的事情是察看你是否还有数据发送给对方，如果没有的话，那么你也就可以 <strong>close</strong>这个<strong>SOCKET</strong>，发送<strong>FIN</strong>报文给对方，也即关闭连接。所以你在<strong>CLOSE_WAIT</strong>状态下，需要完成的事情是等待你去关闭连接。（被动方）</p></li><li><p><strong>LAST_ACK</strong><br>被动关闭一方在发送<strong>FIN</strong>报文后，最后等待对方的<strong>ACK</strong>报文。当收到ACK报文后，也即可以进入到<strong>CLOSED</strong>状态了。（被动方）</p></li><li><p><strong>TIME_WAIT</strong><br>表示收到了对方的<strong>FIN</strong>报文，并发送出了<strong>ACK</strong>报文，就等<strong>2MSL</strong>后即可回到<strong>CLOSED</strong>状态了。如果<strong>FIN</strong> WAIT1状态下，收到了对方同时带<strong>FIN</strong>标志和<strong>ACK</strong>标志的报文时，可以直接进入到<strong>TIME_WAIT</strong>状态，而无须经过<strong>FIN_WAIT_2</strong>状态。（主动方）</p></li><li><p><strong>CLOSED</strong><br>表示SOCKET连接已中断</p></li></ul><h3 id="为什么会有TIME-WAIT状态"><a href="#为什么会有TIME-WAIT状态" class="headerlink" title="为什么会有TIME_WAIT状态"></a>为什么会有TIME_WAIT状态</h3><ul><li><p><strong>可靠地实现TCP全双工连接的可靠终止</strong><br>TCP协议在关闭连接的四次握手过程中，<strong>最终ACK是由主动关闭连接的一端发出的</strong>，如果这个<strong>ACK</strong>丢失，被动方将重发最终的<strong>FIN</strong>，因此主机1就必须维护状态信息<strong>TIME_WAIT</strong> 允许它发送最终的ACK。如果主机1不维持<strong>TIME_WAIT</strong>的状态，而是处于<strong>CLOSED</strong>状态，那么主机1将响应<strong>RST</strong>（reset）数据包，主机2收到后将此数据报解释成一个异常（Java中会抛出<code>connection reset</code>的SocketException）。因而，要实现TCP全双工连接的正常终止，必须处理终止过程中四个数据包任何一个分节丢失的情况，主动关闭连接的主机1必须维持TIME_WAIT的状态。</p></li><li><p><strong>保证此次连接的重复数据段从网络中消失</strong><br>TCP数据包可能由于路由器异常而“迷路”，在“迷路”期间，TCP发送端可能因确认超时而重发这个分节，“迷路”的分节在路由器恢复正常后也会被发送到最终的目的地，这个迟到的“迷路”数据包到达时可能会引起问题。在关闭“前一个连接”之后，马上又建立起一个相同的IP和端口之间的“新连接”，这会导致“前一个连接”的迷路重复分组在“前一个连接”终止后到达，从而被“新连接”接收到了。</p><p>  为了避免以上情况，TCP/IP协议不允许处于TIME_WAIT状态的连接启动一个新的可用连接，因为TIME_WAIT状态持续2MSL，这就可以<strong>保证当成功建立一个新TCP连接的时候，来自旧连接重复分组已经在网络中消失</strong>。</p></li></ul><h3 id="出现太多TIME-WAIT危害"><a href="#出现太多TIME-WAIT危害" class="headerlink" title="出现太多TIME_WAIT危害"></a>出现太多TIME_WAIT危害</h3><blockquote><p>在<strong>高并发短连接的TCP服务器</strong>上，当服务器处理完请求后会立刻按照主动正常关闭连接。这个场景下，会出现大量socket处于<strong>TIMEWAIT</strong>状态。如果客户端的并发量持续很高，此时部分客户端就会显示连接不上。</p></blockquote><p>解释下这个场景。主动正常关闭TCP连接，都会出现<strong>TIMEWAIT</strong>。为什么我们要关注这个高并发短连接呢？有两个方面需要注意：</p><ul><li><p>① 高并发可以让服务器在短时间范围内同时占用大量端口，而端口有个0~65535的范围，并不是很多，刨除系统和其他服务要用的，剩下的就更少了。</p></li><li><p>② 在这个场景中，短连接表示“业务处理+传输数据的时间 远远小于 <strong>TIMEWAIT</strong>超时的时间”的连接。 这里有个相对长短的概念，比如，取一个web页面，1秒钟的http短连接处理完业务，在关闭连接之后，这个业务用过的端口会停留在<strong>TIMEWAIT</strong>状态几分钟，而这几分钟，其他HTTP请求来临的时候是无法占用此端口的。单用这个业务计算服务器的利用率会发现，服务器干正经事的时间和端口（资源）被挂着无法被使用的时间的比例是 <code>1 ：几百</code>，服务器资源严重浪费。</p></li></ul><p>说个题外话，从这个意义出发来考虑服务器性能调优的话，长连接业务的服务就不需要考虑<strong>TIMEWAIT</strong>状态。同时，假如你对服务器业务场景非常熟悉，你会发现，在实际业务场景中，一般长连接对应的业务的并发量并不会很高.</p><p>综合这两个方面，<strong>持续的到达一定量的高并发短连接，会使服务器因端口资源不足而拒绝为一部分客户服务</strong>。</p><h3 id="TIME-WAIT太多怎么解决"><a href="#TIME-WAIT太多怎么解决" class="headerlink" title="TIME_WAIT太多怎么解决"></a>TIME_WAIT太多怎么解决</h3><p>修改<code>/etc/sysctl.conf</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 表示开启重用</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭；</span></span><br><span class="line">net.ipv4.tcp_tw_reuse = 1  </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> net.ipv4.tcp_timestamps 开启时，net.ipv4.tcp_tw_recycle开启才能生效</span></span><br><span class="line">net.ipv4.tcp_tw_recycle = 1 </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭</span></span><br><span class="line">net.ipv4.tcp_timestamps = 1     </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 用来设置保持在FIN_WAIT_2状态的时间</span></span><br><span class="line">net.ipv4.tcp_fin_timeout = 2</span><br></pre></td></tr></table></figure><p>保存后<code>sysctl -p</code>生效</p><h3 id="地址reuse问题"><a href="#地址reuse问题" class="headerlink" title="地址reuse问题"></a>地址reuse问题</h3><p>在写一个unix server程序时，经常需要在命令行重启它，绝大多数时候工作正常，但是某些时候会抛出异常 <code>bind: address already in use</code>，于是重启失败。</p><p>上面这个就是地址reuse问题，就是由于<strong>TIME_WAIT</strong>状态产生的，我们有以下方案来解决这个问题：</p><h4 id="SO-REUSEADDR"><a href="#SO-REUSEADDR" class="headerlink" title="SO_REUSEADDR"></a>SO_REUSEADDR</h4><p>这个socket选项通知内核：<strong>如果端口忙，但TCP状态位于TIME_WAIT，可以重用端口</strong>。</p><blockquote><p>一个socket由相关五元组构成: <strong>协议、本地地址、本地端口、远程地址、远程端口</strong>。<strong>SO_REUSEADDR仅仅表示可以重用本地本地地址、本地端口，整个相关五元组还是唯一确定的</strong>。所以，重启后的服务程序有可能收到非期望数据。必须慎重使用SO_REUSEADDR选项。</p></blockquote><p><strong>一般来说，一个端口释放后会等待两分钟之后才能再被使用，SO_REUSEADDR是让端口释放后立即就可以被再次使用。</strong></p><p><strong>SO_REUSEADDR</strong>用于对TCP处于<strong>TIME_WAIT</strong>状态下的socket，才可以重复绑定使用。server程序总是应该在调用bind()之前设置SO_REUSEADDR选项。先调用close()的一方会进入TIME_WAIT状态。</p><p>SO_REUSEADDR允许启动一个监听服务器并捆绑其众所周知端口，即使以前建立的将此端口用做他们的本地端口的连接仍存在。这通常是重启监听服务器时出现，若不设置此选项，则bind时将出错。</p><h4 id="SO-LINGER"><a href="#SO-LINGER" class="headerlink" title="SO_LINGER"></a>SO_LINGER</h4><p>Linux网络编程中，socket的选项很多。其中几个比较重要的选项就包括SO_LINGER。</p><p>在默认情况下,当调用close()关闭socket的使用，close()会立即返回,但是,如果<code>send buffer</code>中还有数据，系统会试着先把<code>send buffer</code>中的数据发送出去，SO_LINGER选项则是用来修改这种默认操作的。</p><p>SO_LINGER是一个socket选项，可以通过<code>set sockopt API</code>进行设置，使用起来比较简单，但其实现机制比较复杂，且字面意思上比较难理解。SO_LINGER的值用如下数据结构表示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">linger</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l_onoff <span class="comment">//0 = off, nonzero = on(开关)</span></span><br><span class="line">    <span class="keyword">int</span> l_linger <span class="comment">//linger time(延迟时间)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其取值和处理如下：</p><ul><li><p>设置 l_onoff 为0，则该选项关闭，l_linger的值被忽略，等于内核缺省情况，close()调用会立即返回给调用者，如果可能将会传输任何未发送的数据；</p></li><li><p>设置 l_onoff 为非0，l_linger为0，当调用close()的时候,TCP连接会立即断开。send buffer中未被发送的数据将被丢弃，并向对方发送一个RST信息。值得注意的是，由于这种方式，不是以4次握手方式结束TCP连接，所以，TCP连接将不会进入TIME_WAIT状态，这样会导致新建立的可能和旧连接的数据造成混乱。这种关闭方式称为“强制”或“失效”关闭。通常会看到 <code>Connection reset by peer</code> 之类的错误；</p></li><li><p>设置 l_onoff 为非0，l_linger为非0，在这种情况下，会使得close()返回得到延迟。调用close()去关闭socket的时候，内核将会延迟。也就是说，如果send buffer中还有数据尚未发送，该进程将会被休眠直到一下任何一种情况发生：</p><blockquote><p>a. send buffer中的所有数据都被发送并且得到对方TCP的应答消息；</p><p>b.延迟时间消耗完。在延迟时间被消耗完之后，send buffer中的所有数据都将会被丢弃。这种关闭称为“优雅的”关闭。</p></blockquote></li></ul><p>因此，<strong>在正常情况下，在socket调用close()之前设置SO_LINGER超时为0都不是个好的选择</strong>。但也有些情况下需要使用SO_LINGER：</p><ul><li><p>如果server返回无效数据或者超时时，<strong>SO_LINGER有助于避免卡在CLOSE_WAIT或TIME_WAIT的状态</strong>；</p></li><li><p>如果必须启动有数千个客户端连接的app，则可以考虑设置SO_LINGER，从而<strong>避免数千个socket处于TIME_WAIT状态，从而减少可用端口在服务重启后，新客户端连接受到的影响</strong>；</p></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过上面的讨论，我们知道<strong>TIME_WAIT</strong>状态是友好的，并不是多余的。TCP要保证在所有可能的情况下使得所有的数据都能够正确送达。当你关闭一个socket时，主动关闭一端的socket将进入TIME_WAIT状态，而被动关闭的一方则进入CLOSED状态，这的确能够保证所有的数据都被传送。</p><p>当一个socket关闭的时候，是通过两端四次挥手完成的，当一端调用close()时，就说明本端没有数据要传送了，这好像看来在挥手完成以后，socket就可以处于CLOSED状态了，其实不然，原因是这样安排状态有两个问题：</p><ul><li>第一，我们没有任何机制保证最后的一个ACK能够正常传输；</li><li>第二，网络仍然可能有残余的数据包，我们也必须能够正常处理。</li></ul><p>TIME_WAIT状态就是为了解决这两个问题而生的。服务端为了解决这个TIME_WAIT问题，可选的方式有3种：</p><ul><li>保证由客户端主动发起关闭</li><li>关闭的时候使用RST方式（set SO_LINGER）</li><li>对处于TIME_WAIT状态的TPC允许重用（set SO_REUSEADDR）</li></ul><p>参考：<br><a href="https://blog.yangx.site/2018/07/03/tcp-ip-time-wait/" target="_blank" rel="noopener">TCP/IP中TIME_WAIT状态详解</a><br><a href="https://blog.51cto.com/11859650/1917938" target="_blank" rel="noopener">TCP——-为什么会有TIME_WAIT状态 ?</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;TIME_WAIT&lt;/strong&gt;状态是TCP连接中&lt;strong&gt;主动关闭连接&lt;/strong&gt;的一方会进入的状态，在发出最后一个ACK包之后，主动关闭方进入&lt;strong&gt;TIME_WAIT&lt;/strong&gt;状态，从而确保:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
      
    
    </summary>
    
      <category term="网络" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="Tcp" scheme="http://yoursite.com/tags/Tcp/"/>
    
      <category term="Http" scheme="http://yoursite.com/tags/Http/"/>
    
  </entry>
  
  <entry>
    <title>JVM基础 - 入门篇</title>
    <link href="http://yoursite.com/2019/12/13/JVM%E5%9F%BA%E7%A1%80-%E5%85%A5%E9%97%A8%E7%AF%87/"/>
    <id>http://yoursite.com/2019/12/13/JVM基础-入门篇/</id>
    <published>2019-12-13T08:15:47.000Z</published>
    <updated>2019-12-20T11:07:55.179Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JDK体系结构"><a href="#JDK体系结构" class="headerlink" title="JDK体系结构"></a>JDK体系结构</h1><p><img src="/images/jdk_structure.jpg" alt></p><h1 id="JVM内存模型"><a href="#JVM内存模型" class="headerlink" title="JVM内存模型"></a>JVM内存模型</h1><p>一张图描述JVM内存模型<br><img src="/images/jvm_structure.png" alt></p><p>JVM包括两个子系统和两个组件：</p><h2 id="两个子系统"><a href="#两个子系统" class="headerlink" title="两个子系统"></a>两个子系统</h2><ul><li><p><strong>ClassLoader（类装载）</strong><br>根据给定的全限定名类名(如：java.lang.Object)来装载 class文件 到 <strong>运行时数据区</strong> 中的 <strong>方法区</strong>。程序中可以继承 <code>java.lang.ClassLoader</code> 类来实现自己的ClassLoader。</p></li><li><p><strong>ExecutionEngine（执行引擎）</strong><br>执行classes中的指令。任何JVM <code>specification</code>实现(JDK)的核心都是Execution engine，不同的JDK例如Sun的JDK和IBM的JDK好坏主要就取决于他们各自实现的Execution engine的好坏。</p></li></ul><h2 id="两个组件"><a href="#两个组件" class="headerlink" title="两个组件"></a>两个组件</h2><ul><li><p><strong>Native Interface(本地接口)</strong><br>与native libraries交互，是其它编程语言交互的接口。当调用native方法的时候，就进入了一个全新的并且不再受虚拟机限制的世界，所以也很容易出现JVM无法控制的native heap OutOfMemory。</p></li><li><p><strong>Runtime Data Area（运行时数据区）</strong><br>这就是我们常说的JVM的内存。主要分为五个部分：</p><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>有时候也成为<strong>永久代</strong>，该区域是被<strong>线程共享</strong>的。</p></li><li><p>作用<br>方法区主要用来存储已被虚拟机加载的<strong>类的信息</strong>、<strong>常量</strong>、<strong>静态变量</strong> 和 <strong>即时编译器(JIT)编译后的代码</strong> 等数据.</p></li><li><p>GC<br>在该区内很少发生垃圾回收，但是并不代表不发生GC，在这里进行的GC主要是 <strong>对方法区里的常量池和对类型的卸载</strong>，但<strong>回收效率很低</strong>，当方法区无法满足内存需求时，会报 <strong>OOM</strong> 异常；</p></li></ul><p>方法区里有一个<strong>运行时常量池</strong>，用于存放<strong>静态编译产生的字面量和符号引用</strong>。该常量池具有动态性，也就是说常量并不一定是编译时确定，<strong>运行时生成的常量也会存在这个常量池</strong>中。</p><blockquote><p><strong>方法区和元数据区是不同jdk版本对JVM协议的不同实现；</strong></p></blockquote><h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><p>虚拟机栈也就是我们平常所称的栈内存, 它为java方法服务，每个方法在执行的时候都会创建一个栈帧，用于存储<strong>局部变量表</strong>、<strong>操作数栈</strong>、<strong>动态链接</strong> 和 <strong>方法出口</strong>等信息。<br><img src="/images/jvm_thread_stack.png" alt="-w728"></p><ul><li><p><strong>虚拟机栈</strong><br>是线程私有的，它的<strong>生命周期与线程相同</strong>。每个方法从调用到执行过程，就对应着栈桢在虚拟机栈中从入栈到出栈的过程。</p></li><li><p><strong>栈桢</strong><br>虚拟机栈由多个栈桢（Stack Frame）组成。一个线程会执行一个或多个方法，一个方法对应一个栈桢。</p></li><li><p><strong>局部变量表</strong><br>局部变量表里存储的是<strong>基本数据类型</strong>、<strong>returnAddress类型</strong>（指向一条字节码指令的地址）和<strong>对象引用</strong>，这个对象引用有可能是指向对象起始地址的一个指针，也有可能是代表对象的句柄或者与对象相关联的位置。<strong>局部变量所需的内存空间在编译器间确定</strong>。</p></li><li><p><strong>操作数栈</strong><br>操作数栈的作用主要用来<strong>存储运算结果以及运算的操作数</strong>，它不同于局部变量表通过索引来访问，而是<strong>压栈和出栈的方式</strong></p></li></ul><p>每个栈帧都包含一个指向运行时常量池中<strong>该栈帧所属方法的引用</strong>，持有这个引用是为了<strong>支持方法调用过程中的动态连接</strong>. 动态链接就是<strong>将常量池中的符号引用在运行期转化为直接引用</strong>。</p><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>本地方法栈和虚拟机栈类似，虚拟机栈是为虚拟机执行Java方法而准备的，而本地方法栈为虚拟机执行Native本地方法而准备的。</p><h3 id="堆（Heap）"><a href="#堆（Heap）" class="headerlink" title="堆（Heap）"></a>堆（Heap）</h3><p>Java堆是所有线程所共享的一块内存。</p><p>在虚拟机启动时创建，几乎所有的对象实例、数组都在这里存放，对于大多数应用来说，堆是JVM管理的内存中最大的一块区域，也是最容易发生OOM的区域，因此该区域经常发生垃圾回收操作。</p><p>大多数JVM都会将堆实现为大小可扩展的，通过-Xmx、-Xms等参数控制。</p><p><img src="/images/eden_survior.jpg" alt></p><p>新生的对象默认放在Eden区, Eden区满了会触发minor GC/yong GC;</p><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>占用内存空间小，字节码解释器工作时通过改变这个计数值可以<strong>选取下一条需要执行的字节码指令</strong>，<strong>分支、循环、跳转、异常处理和线程恢复</strong>等功能都需要依赖这个计数器完成。该内存区域是唯一一个java虚拟机规范没有规定任何OOM情况的区域。</p><h1 id="JVM内存快照示例"><a href="#JVM内存快照示例" class="headerlink" title="JVM内存快照示例"></a>JVM内存快照示例</h1><p>基于上述原理，现在写一个简单的代码来举例描述下具体各个区域是怎么分配的。</p><blockquote><p>Math.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Math</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> initData = <span class="number">666</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> c = (a + b) * <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Math math = <span class="keyword">new</span> Math();</span><br><span class="line">        <span class="keyword">int</span> result = math.compute();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>javap是jdk自带的一个工具在jdk安装目录的/bin下面可以找到，可以对代码反编译，也可以查看java编译器生成的字节码，对代码的执行过程进行分析，了解jvm内部的工作。</p></blockquote><p>通过以下指令可以得到Java字节码指令：</p><blockquote><p>javac Math.java<br>javap -c Math.class &gt; Math.txt</p></blockquote><p>Math.txt(为了便于编译，Math.txt中去掉了User相关内容)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">Compiled from <span class="string">"Math.java"</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Math</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> initData;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> User user  = <span class="keyword">new</span> User();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Math</span><span class="params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       1: invokespecial #1     // Method java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compute</span><span class="params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: iconst_1</span><br><span class="line">       <span class="number">1</span>: istore_1</span><br><span class="line">       <span class="number">2</span>: iconst_2</span><br><span class="line">       <span class="number">3</span>: istore_2</span><br><span class="line">       <span class="number">4</span>: iload_1</span><br><span class="line">       <span class="number">5</span>: iload_2</span><br><span class="line">       <span class="number">6</span>: iadd</span><br><span class="line">       <span class="number">7</span>: bipush        <span class="number">10</span>  </span><br><span class="line">       <span class="number">9</span>: imul</span><br><span class="line">      <span class="number">10</span>: istore_3</span><br><span class="line">      <span class="number">11</span>: iload_3</span><br><span class="line">      <span class="number">12</span>: ireturn</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       0: new           #2      // class Math</span><br><span class="line">       <span class="number">3</span>: dup </span><br><span class="line">       4: invokespecial #3      // Method "&lt;init&gt;":()V</span><br><span class="line">       <span class="number">7</span>: astore_1</span><br><span class="line">       <span class="number">8</span>: aload_1</span><br><span class="line">       9: invokevirtual #4      // Method compute:()I</span><br><span class="line">      <span class="number">12</span>: istore_2</span><br><span class="line">      13: getstatic     #5      // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">      <span class="number">16</span>: iload_2</span><br><span class="line">      17: invokevirtual #6      // Method java/io/PrintStream.println:(I)V</span><br><span class="line">      <span class="number">20</span>: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过查询<a href="https://gist.github.com/pwxcoo/d8b321c24ccf031c3ee94ff36bc857d4" target="_blank" rel="noopener">javap 字节码指令集</a>，可以看到每一步操作:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">栈和局部变量操作 </span><br><span class="line">将常量压入栈的指令 </span><br><span class="line">aconst_null 将<span class="keyword">null</span>对象引用压入栈 </span><br><span class="line">iconst_m1 将<span class="keyword">int</span>类型常量-<span class="number">1</span>压入栈 </span><br><span class="line">iconst_0 将<span class="keyword">int</span>类型常量<span class="number">0</span>压入栈 </span><br><span class="line">iconst_1 将<span class="keyword">int</span>类型常量<span class="number">1</span>压入栈 </span><br><span class="line">iconst_2 将<span class="keyword">int</span>类型常量<span class="number">2</span>压入栈 </span><br><span class="line">iconst_3 将<span class="keyword">int</span>类型常量<span class="number">3</span>压入栈 </span><br><span class="line">iconst_4 将<span class="keyword">int</span>类型常量<span class="number">4</span>压入栈 </span><br><span class="line">iconst_5 将<span class="keyword">int</span>类型常量<span class="number">5</span>压入栈 </span><br><span class="line">lconst_0 将<span class="keyword">long</span>类型常量<span class="number">0</span>压入栈 </span><br><span class="line">lconst_1 将<span class="keyword">long</span>类型常量<span class="number">1</span>压入栈 </span><br><span class="line">fconst_0 将<span class="keyword">float</span>类型常量<span class="number">0</span>压入栈 </span><br><span class="line">fconst_1 将<span class="keyword">float</span>类型常量<span class="number">1</span>压入栈 </span><br><span class="line">dconst_0 将<span class="keyword">double</span>类型常量<span class="number">0</span>压入栈 </span><br><span class="line">dconst_1 将<span class="keyword">double</span>类型常量<span class="number">1</span>压入栈 </span><br><span class="line">bipush 将一个<span class="number">8</span>位带符号整数压入栈 </span><br><span class="line">sipush 将<span class="number">16</span>位带符号整数压入栈 </span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>此时内存区域如下图所示：</p><p><img src="/images/jvm_math_snapshot.png" alt></p><h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><p><strong>Minor GC和Full GC区别</strong></p><ul><li>Minor GC/Young GC: 指新生代发生的垃圾收集动作，Minor GC非常频繁，回收速度一般比较快；</li><li>Major GC/Full GC: 一般会回收老年代，年轻代，方法区（永久区）的垃圾，Major GC的速度一般会比Minor GC慢10倍以上。</li></ul><h2 id="什么时候回收"><a href="#什么时候回收" class="headerlink" title="什么时候回收"></a>什么时候回收</h2><ul><li><p>Minor GC触发条件<br>当Eden区满时，触发Minor GC。</p></li><li><p>Full GC触发条件</p><ul><li><p>（1）调用System.gc时，系统建议执行Full GC，但是不必然执行</p></li><li><p>（2）老年代空间不足</p></li><li><p>（3）方法区空间不足</p></li><li><p>（4）通过Minor GC后进入老年代的平均大小大于老年代的可用内存</p></li><li><p>（5）由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小、</p><h2 id="怎么回收"><a href="#怎么回收" class="headerlink" title="怎么回收"></a>怎么回收</h2><p>从GC的底层机制可以看出，对于可以搜索到的对象进行复制操作，对于搜索不到的对象，<strong>调用finalize()方法进行释放</strong>。</p></li></ul></li></ul><p>具体过程：当GC线程启动时，会通过可达性分析法把Eden区和From Space区的存活对象复制到To Space区，然后把Eden Space和From Space区的对象释放掉。当GC轮训扫描To Space区一定次数后，把依然存活的对象复制到老年代，然后释放To Space区的对象。</p><p>对于用可达性分析法搜索不到的对象，GC并不一定会回收该对象。要完全回收一个对象，至少需要经过<strong>两次标记的过程</strong>。</p><ul><li><p>第一次标记<br>对于一个没有其他引用的对象，筛选该对象是否有必要执行finalize()方法，如果没有执行必要，则意味可直接回收。（筛选依据：是否复写或执行过finalize()方法；因为finalize方法只能被执行一次）。</p></li><li><p>第二次标记<br>如果被筛选判定位有必要执行，则会放入FQueue队列，并自动创建一个低优先级的finalize线程来执行释放操作。如果在一个对象释放前被其他对象引用，则该对象会被移除FQueue队列。</p></li></ul><h2 id="JVM内存分配与回收策略"><a href="#JVM内存分配与回收策略" class="headerlink" title="JVM内存分配与回收策略"></a>JVM内存分配与回收策略</h2><h3 id="对象优先在Eden区分配"><a href="#对象优先在Eden区分配" class="headerlink" title="对象优先在Eden区分配"></a>对象优先在Eden区分配</h3><p>大多数情况下，对象在新生代中Eden区分配，当Eden区没有足够空间时，虚拟机将发起一次Minor GC.</p><h3 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h3><ul><li><p>既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须识别哪些对象应该放在新生代，哪些需要放在老年代。为了做到这一点，虚拟机给每个对象一个对象年龄（Age）计数器。</p></li><li><p>如果对象在Eden区出生并经过一次minor gc后仍然存活，并且大小能被Survivor容纳的话，将会移动到另一个Survivor区，并将对象年龄设为1。对象在Survivor中每熬过一次minor gc，年龄就增1岁，当增加到一定大小（默认为15岁），就会晋升到老年代。对象晋升到老年代的年龄阈值可以通过<code>-XX:MaxTenuringThreshold</code>来设置。</p></li></ul><h3 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h3><ul><li><p>大对象就是需要大量连续内存空间的对象，比如：长字符串、数组</p></li><li><p>JVM参数<code>-神器:PretenureSizeThreshold</code>可以设置大对象的大小，如果对象超过了设置大小，在创建时就会直接进入老年代，不会进入年轻代，这个参数只在<strong>Serial</strong>和<strong>ParNew</strong>两个收集器下有效</p></li><li><p>例如 <code>-神器:PretenureSizeThreshold=1000000 -XX:+UseSerialGC</code></p></li><li><p>这么做的目的：<strong>避免为大对象分配内存时的复制操作而降低效率</strong>；</p></li></ul><h3 id="对象动态年龄判断"><a href="#对象动态年龄判断" class="headerlink" title="对象动态年龄判断"></a>对象动态年龄判断</h3><ul><li><p>当前放置对象的Survivor区域里（另一块Survivor为空），一批对象的总大小大于这块Survivor区域内存大小的50%，那么此时大于这批对象年龄最大值的对象，就可以直接提前进入老年代了；</p></li><li><p>例如Survivor区域里现有一批对象：<code>年龄为1对象 + 年龄为2对象 + ... +  年龄为n对象</code> 所占空间总和超过了Survivor区总大小的50%，此时就会把年龄大于n的对象提前放入老年代；</p></li></ul><h3 id="老年代空间分配担保机制"><a href="#老年代空间分配担保机制" class="headerlink" title="老年代空间分配担保机制"></a>老年代空间分配担保机制</h3><p>年轻代每次Minor gc之前，JVM都会计算下老年代剩余可用空间：</p><ul><li><p>如果老年代剩余可用空间小于年轻代里现有的所有对象的大小之和（包括垃圾对象），就会看一个 <code>-神器:-HandlePromotionFailure</code> （JDK1.8默认就设置了）的参数是否配置了，如果有这个参数，就会看看老年代的可用内存大小，是否大于之前每次minor gc后进入老年代的对象平均大小；</p></li><li><p>如果上一步结果是小于或者没有设置该参数，JVM就会发起一次Full GC，对老年代和年轻代一起进行垃圾回收；</p></li><li><p>如果上一步结果是大于该参数，正常进行Minor GC;当然如果Minor GC后，剩余存活对象里需要移动到老年代的总大小超过了老年代可用空间，还是会触发Full GC;</p></li><li><p>如果回收完还是没有足够空间存放新建的对象，就会发生 <strong>OOM</strong>；</p></li></ul><p><img src="/images/jvm_fenpei_danbao.jpg" alt></p><h2 id="垃圾对象判断"><a href="#垃圾对象判断" class="headerlink" title="垃圾对象判断"></a>垃圾对象判断</h2><p>如何判断一个对象是否可以被回收，常见的做法有两种：</p><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>给对象头中添加一个引用计数器，每当有一个地方引用它，就给它的计数器+1；当引用失效，计数器就-1；只要计数器为0，就表示当前对象没有被使用，可以被回收。</p><ul><li><p><strong>优点</strong><br>引用计数收集器可以很快的执行，交织在程序运行中。对程序需要不被长时间打断的实时环境比较有利。</p></li><li><p><strong>缺点</strong><br>无法检测出循环引用。如父对象有一个对子对象的引用，子对象反过来引用父对象。这样，他们的引用计数永远不可能为0.</p></li></ul><p>Java的引用类型一般分为四种：</p><ul><li><p><strong>强引用</strong><br>普通的变量引用；</p></li><li><p><strong>软引用</strong><br>将对象用SoftReference软引用类型的对象包裹，正常情况下不会被回收，但是GC做完之后发现释放不出空间存放新对象，就会把这些软引用的对象回收掉。软引用可用来实现对内存敏感度不高的高速缓存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> SoftReference&lt;User&gt;  user = <span class="keyword">new</span> SoftReference&lt;User&gt;(<span class="keyword">new</span> User());</span><br></pre></td></tr></table></figure></li><li><p><strong>弱引用</strong><br>将对象用WeakReference弱引用类型的对象包裹，弱引用跟没引用差不多，GC会直接回收掉，很少用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> WeakReference&lt;User&gt; user = <span class="keyword">new</span> WeakReference&lt;User&gt;(<span class="keyword">new</span> User());</span><br></pre></td></tr></table></figure></li><li><p><strong>虚引用</strong><br>也成为幽灵引用或者幻影引用，它是最弱的一种引用关系，几乎不用。</p></li></ul><h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>这个算法的基本思想是通过一系列被称为”GC Roots”的对象作为起始点，从这些节点向下搜索，找到的对象都标记为非垃圾对象，剩余的都为垃圾对象；</p><p><strong>GC Roots:</strong> <font color="red">线程栈的本地变量、静态属性、常量、本地方法栈的变量等</font>；</p><p><strong>finalize()方法最终判定对象是否存活</strong><br>即使在可达性分析算法中不可达的对象，也并非是 『<strong>非死不可</strong>』，标记完之后只是暂时处于 『<strong>缓刑</strong>』 阶段，要真正宣告一个对象死亡，至少要经历再次标记过程。</p><p>标记的前提是：<strong>对象在进行可达性分析之后发现没有与任何GC Roots相连的引用链</strong>。</p><ul><li><p>第一次标记并进行一次筛选<br>对象如果没有覆盖<code>finalize()</code>方法，将会直接被回收；</p></li><li><p>第二次标记<br>如果这个对象覆盖了<code>finalize()</code>方法，只要在该方法中重新与引用链上的任何一个对象建立了关联，就可以拯救自己，不会被回收。</p></li></ul><p><strong>如何判断一个类是无用类：</strong><br>类需要同时满足下面3个条件才能算是 <strong>无用类</strong>：</p><ul><li><p>该类所有的实例都已经被回收，也就是堆中不存在该类的任何实例；</p></li><li><p>加载该类的ClassLoader已经被回收；</p></li><li><p>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法；</p></li></ul><h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><p>常用的垃圾回收算法有：标记-清除算法、复制算法、标记-整理算法、分代收集算法。目前主流的JVM（HotSpot）采用的是分代收集算法。</p><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>标记-清除算法采用从根集合进行扫描，对存活的对象对象标记，标记完毕后，再扫描整个空间中未被标记的对象，进行回收。标记-清除算法不需要进行对象的移动，并且仅对不存活的对象进行处理，在<strong>存活对象比较多的情况下极为高效</strong>，但由于标记-清除算法直接回收不存活的对象，因此会<strong>造成内存碎片</strong>。<br><img src="/images/jvm_mark_swep.jpg" alt></p><h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p><img src="/images/jvm_copy.jpg" alt></p><h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><p><img src="/images/jvm_mark_zhengli.jpg" alt></p><h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p><img src="/images/jvm_fendai_collection.jpg" alt></p><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p><img src="/images/java_gc_collectors.png" alt></p><h3 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h3><p><img src="/images/java_gc_serial.jpg" alt></p><h3 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h3><p><img src="/images/java_gc_parnew.jpg" alt></p><h3 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h3><p><img src="/images/java_gc_scavenge.jpg" alt></p><h3 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h3><p><img src="/images/java_gc_cms-collec.jpg" alt></p><p><img src="/images/java_cms_advantage.jpg" alt></p><p><img src="/images/java_cms_parameter.jpg" alt></p><h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h3><p><img src="/images/java_gc_g1.jpg" alt></p><p><img src="/images/java_gc_g1_process.jpg" alt></p><p><img src="/images/java_gc_g1_class.jpg" alt></p><h1 id="JVM优化"><a href="#JVM优化" class="headerlink" title="JVM优化"></a>JVM优化</h1><h2 id="能否对JVM调优，让其几乎不发生Full-GC"><a href="#能否对JVM调优，让其几乎不发生Full-GC" class="headerlink" title="能否对JVM调优，让其几乎不发生Full GC?"></a>能否对JVM调优，让其几乎不发生Full GC?</h2><p>评估对象大小和生命周期，调整年轻代大小和Eden/Survivor区比例，保证minor gc就能够回收基本所有对象，避免对象因为过大或年龄太大进入老年代。<br><img src="/images/jvm_full_gc_optimize.jpg" alt></p><p>需要放入survivor区的对象大于survivor区大小的50%时，会触发担保机制，直接放入老年代；</p><h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><p><a href="https://juejin.im/post/5df5c76ee51d45581634f256?utm_source=gold_browser_extension" target="_blank" rel="noopener">【搞定Jvm面试】Java 内存区域揭秘附常见面试题解析</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JDK体系结构&quot;&gt;&lt;a href=&quot;#JDK体系结构&quot; class=&quot;headerlink&quot; title=&quot;JDK体系结构&quot;&gt;&lt;/a&gt;JDK体系结构&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/images/jdk_structure.jpg&quot; alt&gt;&lt;/p&gt;
&lt;h1 
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
      <category term="JVM" scheme="http://yoursite.com/categories/Java/JVM/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Jvm" scheme="http://yoursite.com/tags/Jvm/"/>
    
  </entry>
  
</feed>
