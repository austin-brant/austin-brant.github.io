<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Austin Brant</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-12-06T12:50:53.518Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Austin Brant</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis数据结构及常见使用场景</title>
    <link href="http://yoursite.com/2019/12/06/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%B8%B8%E8%A7%81%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <id>http://yoursite.com/2019/12/06/Redis数据结构及常见使用场景/</id>
    <published>2019-12-06T12:25:19.000Z</published>
    <updated>2019-12-06T12:50:53.518Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis基础数据类型及使用场景"><a href="#Redis基础数据类型及使用场景" class="headerlink" title="Redis基础数据类型及使用场景"></a>Redis基础数据类型及使用场景</h2><p><img src="/images/redis_basitc_data_structure.jpg" alt></p><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p><img src="/images/redis_string_basic_op.jpg" alt></p><p><img src="/images/redis_string_basic_caculate.jpg" alt></p><ul><li><p>缓存功能：String字符串是最常用的数据类型，不仅仅是Redis，各个语言都是最基本类型，因此，利用Redis作为缓存，配合其它数据库作为存储层，利用Redis支持高并发的特点，可以大大加快系统的读写速度、以及降低后端数据库的压力。</p></li><li><p>计数器：许多系统都会使用Redis作为系统的实时计数器，可以快速实现计数和查询的功能。而且最终的数据结果可以按照特定的时间落地到数据库或者其它存储介质当中进行永久保存。</p></li><li><p>共享用户Session：用户重新刷新一次界面，可能需要访问一下数据进行重新登录，或者访问页面缓存Cookie，但是可以利用Redis将用户的Session集中管理，在这种模式只需要保证Redis的高可用，每次用户Session的更新和获取都可以快速完成。大大提高效率。</p></li></ul><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p><img src="/images/redis_hash_basic_op.jpg" alt></p><p><img src="/images/redis_hash_basic_cache.jpg" alt></p><p><img src="/images/redis_hash_elec_strore.jpg" alt></p><p>这个是类似 Map 的一种结构，这个一般就是可以将结构化的数据，比如一个对象（前提是这个对象没嵌套其他的对象）给缓存在 Redis 里，然后每次读写缓存的时候，可以就操作 Hash 里的某个字段。<br>但是这个的场景其实还是多少单一了一些，因为现在很多对象都是比较复杂的，比如你的商品对象可能里面就包含了很多属性，其中也有对象。我自己使用的场景用得不是那么多。</p><p><img src="/images/redis_hash_advantage.jpg" alt></p><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>List 是有序列表，这个还是可以玩儿出很多花样的。</p><p><img src="/images/redis_list_basic_op.jpg" alt></p><p><img src="/images/redis_list_stack.jpg" alt></p><ul><li>比如可以通过 List 存储一些<strong>列表型的数据结构</strong>，类似粉丝列表、文章的评论列表之类的东西。<br>比如可以通过 <code>lrange</code> 命令，读取某个闭区间内的元素，可以基于 List 实现<code>分页查询</code>，这个是很棒的一个功能，基于 Redis 实现简单的高性能分页，可以做类似微博那种下拉不断分页的东西，性能高，就一页一页走。</li></ul><p>比如可以搞个简单的消息队列，从 List 头怼进去，从 List 屁股那里弄出来。List本身就是我们在开发过程中比较常用的数据结构了，热点数据更不用说了。</p><ul><li><p>消息队列：Redis的链表结构，可以轻松实现阻塞队列，可以使用<strong>左进右出的命令</strong>组成来完成队列的设计。比如：数据的生产者可以通过<code>Lpush</code>命令从左边插入数据，多个数据消费者，可以使用<code>BRpop</code>命令阻塞的“抢”列表尾部的数据。</p></li><li><p>文章列表或者数据分页展示的应用。<br>比如，我们常用的博客网站的文章列表，当用户量越来越多时，而且每一个用户都有自己的文章列表，而且当文章多时，都需要分页展示，这时可以考虑使用Redis的列表，列表不但有序同时还支持按照范围内获取元素，可以完美解决分页查询功能。大大提高查询效率。</p></li></ul><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>Set 是无序集合，会自动去重的那种。</p><p><img src="/images/redis_set_basic_op.jpg" alt></p><p><img src="/images/redis_set_basic_weixin.jpg" alt></p><p><img src="/images/redis_set_basic_weibo.jpg" alt></p><p><img src="/images/redis_set_basic_weibo_guanzhu.jpg" alt></p><ul><li><p><strong>去重：</strong> 直接基于 Set 将系统里需要去重的数据扔进去，自动就给去重了，如果你需要对一些数据进行快速的全局去重，你当然也可以基于 JVM 内存里的 HashSet 进行去重，但是如果你的某个系统部署在多台机器上呢？得基于Redis进行全局的 Set 去重。</p></li><li><p>可以基于 Set 玩 <strong>交集、并集、差集</strong> 的操作。比如交集吧，我们可以把两个人的好友列表整一个交集，看看俩人的共同好友是谁？对吧。反正这些场景比较多，因为对比很快，操作也简单，两个查询一个Set搞定。</p></li></ul><h3 id="Sorted-Set"><a href="#Sorted-Set" class="headerlink" title="Sorted Set"></a>Sorted Set</h3><p>Sorted set 是排序的 Set，<strong>去重并可以排序</strong>，写进去的时候给一个分数，自动根据分数排序。</p><p>有序集合的使用场景与集合类似，但是set集合不是自动有序的，而<strong>Sorted set可以利用分数进行成员间的排序，而且是插入时就排序好</strong>。所以当你需要一个有序且不重复的集合列表时，就可以选择Sorted set数据结构作为选择方案。</p><p><img src="/images/redis_sorted_weibo.jpg" alt></p><ul><li><p>排行榜：有序集合经典使用场景。例如视频网站需要对用户上传的视频做排行榜，榜单维护可能是多方面：按照时间、按照播放量、按照获得的赞数等。</p></li><li><p>用<code>Sorted Sets</code>来做带权重的队列，比如普通消息的score为1，重要消息的score为2，然后工作线程可以选择按score的倒序来获取工作任务。让重要的任务优先执行。</p></li></ul><h3 id="Redis更多应用场景"><a href="#Redis更多应用场景" class="headerlink" title="Redis更多应用场景"></a>Redis更多应用场景</h3><p><img src="/images/redis_more_yingyong.jpg" alt></p><p><img src="/images/redis_collect_elec.jpg" alt></p><h2 id="Redis-和-Memcached-区别"><a href="#Redis-和-Memcached-区别" class="headerlink" title="Redis 和 Memcached 区别"></a>Redis 和 Memcached 区别</h2><h3 id="Memcache"><a href="#Memcache" class="headerlink" title="Memcache"></a>Memcache</h3><p>先来看看 MC 的特点：</p><ul><li><p>MC 处理请求时使用<code>多线程异步IO</code> 的方式，可以合理利用 CPU 多核的优势，性能非常优秀；</p></li><li><p>MC 功能简单，使用内存存储数据；</p></li><li><p>MC 的内存结构以及钙化问题；</p></li><li><p>MC 对缓存的数据可以设置失效期，过期后的数据会被清除；</p></li><li><p>失效的策略采用延迟失效，就是当再次使用数据时检查是否失效；</p></li><li><p>当容量存满时，会对缓存中的数据进行剔除，剔除时除了会对过期 key 进行清理，还会按 LRU 策略对数据进行剔除。</p></li></ul><p>另外，使用 MC 有一些限制，这些限制在现在的互联网场景下很致命，成为大家选择Redis、MongoDB的重要原因：</p><ul><li><p>key 不能超过 250 个字节；</p></li><li><p>value 不能超过 1M 字节；</p></li><li><p>key 的最大失效时间是 30 天；</p></li><li><p>只支持 K-V 结构，不提供持久化和主从同步功能。</p></li></ul><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><p>简单说一下 Redis 的特点，方便和 Memcache 比较。</p><ul><li><p>与 MC 不同的是，Redis 采用单线程模式处理请求。这样做的原因有 2 个：</p><ul><li><p>一个是因为采用了非阻塞的异步事件处理机制；</p></li><li><p>另一个是缓存数据都是内存操作 IO 时间不会太长，单线程可以避免线程上下文切换产生的代价。</p></li></ul></li><li><p>Redis 支持持久化，所以 Redis 不仅仅可以用作缓存，也可以用作 NoSQL 数据库。</p></li><li><p>相比 MC，Redis 还有一个非常大的优势，就是除了 K-V 之外，还支持复杂的数据结构，例如 list、set、sorted set、hash 等。</p></li><li><p>Redis 提供主从同步机制，以及原生支持集群模式，能够提供高可用服务, 在 redis3.x 版本中，便能支持 Cluster 模式; 而 Memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据。</p></li></ul><h3 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h3><p>由于 Redis 只使用单核，而 Memcached 可以使用多核，所以<strong>平均每一个核上 Redis 在存储小数据时比 Memcached 性能更高。而在 100k 以上的数据中，Memcached 性能要高于 Redi</strong>s，虽然 Redis 最近也在存储大数据的性能上进行优化，但是比起 Remcached，还是稍有逊色。</p><h2 id="Redis-线程模型"><a href="#Redis-线程模型" class="headerlink" title="Redis 线程模型"></a>Redis 线程模型</h2><p>Redis 内部使用 <strong>文件事件处理器</strong> <code>file event handler</code>，这个文件事件处理器是单线程的，所以 Redis 才叫做单线程的模型。它<strong>采用 IO 多路复用机制同时监听多个 Socket</strong>，根据 Socket 上的事件来选择对应的事件处理器进行处理。</p><p>文件事件处理器的结构包含 4 个部分：</p><ul><li>多个 Socket</li><li>IO 多路复用程序</li><li>文件事件分派器</li><li>事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）</li></ul><p>多个 Socket 可能会并发产生不同的操作，每个操作对应不同的文件事件，但是 IO 多路复用程序会监听多个 Socket，会将 Socket 产生的事件放入队列中排队，事件分派器每次从队列中取出一个事件，把该事件交给对应的事件处理器进行处理。</p><h2 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h2><h3 id="Bitmap"><a href="#Bitmap" class="headerlink" title="Bitmap"></a>Bitmap</h3><p>位图是支持按 bit 位来存储信息，可以用来实现 <code>布隆过滤器（BloomFilter）</code>；</p><h3 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h3><p>供不精确的去重计数功能，比较适合用来做大规模数据的去重统计，例如统计 UV；</p><h3 id="Geospatial"><a href="#Geospatial" class="headerlink" title="Geospatial"></a>Geospatial</h3><p>可以用来保存地理位置，并作<code>位置距离计算</code>或者<code>根据半径计算位置</code>等。有没有想过用Redis来实现附近的人？或者计算最优地图路径？</p><h3 id="pub-sub"><a href="#pub-sub" class="headerlink" title="pub/sub"></a>pub/sub</h3><p>功能是订阅发布功能，可以用作简单的消息队列。 </p><h3 id="Pipeline"><a href="#Pipeline" class="headerlink" title="Pipeline"></a>Pipeline</h3><p>可以批量执行一组指令，一次性返回全部结果，可以减少频繁的请求应答。</p><h3 id="Lua"><a href="#Lua" class="headerlink" title="Lua"></a>Lua</h3><p>Redis 支持提交 Lua 脚本来执行一系列的功能, 利用他的原子性。</p><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>最后一个功能是事务，但 Redis 提供的不是严格的事务，Redis 只保证串行执行命令，并且能保证全部执行，但是执行命令失败时并不会回滚，而是会继续执行下去。</p><h2 id="Redis集群"><a href="#Redis集群" class="headerlink" title="Redis集群"></a>Redis集群</h2><p><img src="/images/redis_cluster_crc_ms.jpg" alt></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1]<a href="https://juejin.im/post/5db66ed9e51d452a2f15d833" target="_blank" rel="noopener">《吊打面试官》系列-Redis基础</a><br>[2]<a href="https://juejin.im/post/5dbef8306fb9a0203f6fa3e2" target="_blank" rel="noopener">《吊打面试官》系列-缓存雪崩、击穿、穿透</a><br>[3]<a href="https://juejin.im/post/5dc3a9fbf265da4d3c072eab" target="_blank" rel="noopener">《吊打面试官》系列-Redis哨兵、持久化、主从、手撕LRU</a><br>[4]<a href="https://juejin.im/post/5dc850b4e51d452c2308ee27" target="_blank" rel="noopener">《吊打面试官》系列-Redis终章凛冬将至、FPX新王登基</a><br>[5]<a href="https://juejin.im/post/5dd09f5af265da0be72aacbd" target="_blank" rel="noopener">《吊打面试官》系列-秒杀系统设计</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Redis基础数据类型及使用场景&quot;&gt;&lt;a href=&quot;#Redis基础数据类型及使用场景&quot; class=&quot;headerlink&quot; title=&quot;Redis基础数据类型及使用场景&quot;&gt;&lt;/a&gt;Redis基础数据类型及使用场景&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/ima
      
    
    </summary>
    
      <category term="中间件" scheme="http://yoursite.com/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
      <category term="Redis" scheme="http://yoursite.com/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="入门" scheme="http://yoursite.com/tags/%E5%85%A5%E9%97%A8/"/>
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Tomcat系统架构[转载]</title>
    <link href="http://yoursite.com/2019/12/06/Tomcat%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84-%E8%BD%AC%E8%BD%BD/"/>
    <id>http://yoursite.com/2019/12/06/Tomcat系统架构-转载/</id>
    <published>2019-12-06T12:09:24.000Z</published>
    <updated>2019-12-06T12:23:08.857Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Tomcat顶层架构"><a href="#Tomcat顶层架构" class="headerlink" title="Tomcat顶层架构"></a>Tomcat顶层架构</h2><p>先上一张Tomcat的顶层结构图，如下<br><img src="/images/tomcat_structure.jpg" alt></p><p>简化清晰版<br><img src="/images/tomcat_stucture2.jpg" alt></p><ul><li><p>Tomcat中最顶层的容器是Server，代表着整个服务器，从上图中可以看出，一个Server可以包含至少一个Service，用于具体提供服务。</p></li><li><p>Service主要包含两个部分：<strong>Connector</strong>和<strong>Container</strong>。从上图中可以看出 Tomcat 的心脏就是这两个组件，他们的作用如下：</p><ul><li><p>Connector用于<strong>处理连接相关的事情，并提供Socket与Request和Response相关的转化</strong>; </p></li><li><p>Container用于<strong>封装和管理Servlet，以及具体处理Request请求</strong>；</p></li></ul></li></ul><p><font color="red"><strong>一个Tomcat中只有一个Server，一个Server可以包含多个Service，一个Service只有一个Container，但是可以有多个Connectors，这是因为一个服务可以有多个连接，如同时提供Http和Https链接，也可以提供向相同协议不同端口的连接</strong></font></p><p>示意图如下（Engine、Host、Context下边会说到）：<br><img src="/images/engine_host_context.jpg" alt></p><p>多个 Connector 和一个 Container 就形成了一个 Service，有了 Service 就可以对外提供服务了，但是 Service 还要一个生存的环境，必须要有人能够给它生命、掌握其生死大权，那就非 Server 莫属了！所以<strong>整个 Tomcat 的生命周期由 Server 控制</strong>。</p><p>另外，上述的包含关系或者说是父子关系，都可以在tomcat的conf目录下的<code>server.xml</code>配置文件中看出，如下是删除了注释内容之后的一个完整的<code>server.xml</code>配置文件（Tomcat版本为8.0）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version='1.0' encoding='utf-8'?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Server</span> <span class="attr">port</span>=<span class="string">"8005"</span> <span class="attr">shutdown</span>=<span class="string">"SHUTDOWN"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.startup.VersionLoggerListener"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.core.AprLifecycleListener"</span> <span class="attr">SSLEngine</span>=<span class="string">"on"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.core.JreMemoryLeakPreventionListener"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.mbeans.GlobalResourcesLifecycleListener"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.core.ThreadLocalLeakPreventionListener"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">GlobalNamingResources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Resource</span> <span class="attr">name</span>=<span class="string">"UserDatabase"</span> <span class="attr">auth</span>=<span class="string">"Container"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">type</span>=<span class="string">"org.apache.catalina.UserDatabase"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">description</span>=<span class="string">"User database that can be updated and saved"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">factory</span>=<span class="string">"org.apache.catalina.users.MemoryUserDatabaseFactory"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">pathname</span>=<span class="string">"conf/tomcat-users.xml"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">GlobalNamingResources</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">Service</span> <span class="attr">name</span>=<span class="string">"Catalina"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8060"</span> <span class="attr">protocol</span>=<span class="string">"HTTP/1.1"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">connectionTimeout</span>=<span class="string">"20000"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">redirectPort</span>=<span class="string">"8443"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8009"</span> <span class="attr">protocol</span>=<span class="string">"AJP/1.3"</span> <span class="attr">redirectPort</span>=<span class="string">"8443"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Engine</span> <span class="attr">name</span>=<span class="string">"Catalina"</span> <span class="attr">defaultHost</span>=<span class="string">"localhost"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Realm</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.realm.LockOutRealm"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Realm</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.realm.UserDatabaseRealm"</span> <span class="attr">resourceName</span>=<span class="string">"UserDatabase"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">Realm</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">Host</span> <span class="attr">name</span>=<span class="string">"localhost"</span>  <span class="attr">appBase</span>=<span class="string">"webapps"</span> <span class="attr">unpackWARs</span>=<span class="string">"true"</span> <span class="attr">autoDeploy</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Context</span> <span class="attr">path</span>=<span class="string">""</span> <span class="attr">docBase</span>=<span class="string">"/xxx/target/bigdata-web"</span> </span></span><br><span class="line"><span class="tag">                    <span class="attr">debug</span>=<span class="string">"0"</span> <span class="attr">reloadable</span>=<span class="string">"true"</span> <span class="attr">crossContext</span>=<span class="string">"true"</span> <span class="attr">allowLinking</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">Valve</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.valves.AccessLogValve"</span> <span class="attr">directory</span>=<span class="string">"logs"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">prefix</span>=<span class="string">"localhost_access_log"</span> <span class="attr">suffix</span>=<span class="string">".txt"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">pattern</span>=<span class="string">"%h %l %u %t &amp;quot;%r&amp;quot; %s %b"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">Host</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Engine</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">Service</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Server</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上边的配置文件，还可以通过下边的一张结构图更清楚的理解：</p><p><img src="/images/web_xml.jpg" alt></p><p>Server标签设置的端口号为8005，shutdown=”SHUTDOWN” ，表示在8005端口监听“SHUTDOWN”命令，如果接收到了就会关闭Tomcat。一个Server有一个Service，当然还可以进行配置。Service左边的内容都属于Container的，Service下边是多个Connector。</p><h2 id="Tomcat顶层架构小结"><a href="#Tomcat顶层架构小结" class="headerlink" title="Tomcat顶层架构小结"></a>Tomcat顶层架构小结</h2><ul><li><p>（1）Tomcat中只有一个Server，一个Server可以有多个Service，一个Service可以有多个Connector和一个Container；</p></li><li><p>（2） Server掌管着整个Tomcat的生死大权；</p></li><li><p>（4）Service 是对外提供服务的；</p></li><li><p>（5）Connector用于接受请求并将请求封装成Request和Response来具体处理；</p></li><li><p>（6）Container用于封装和管理Servlet，以及具体处理request请求；</p></li></ul><p>以上是整个Tomcat顶层的分层架构和各个组件之间的关系以及作用，但对于绝大多数的开发人员来说Server和Service对我们来说确实很远，而我们开发中绝大部分进行配置的内容是属于Connector和Container的，所以接下来介绍一下<strong>Connector</strong>和<strong>Container</strong>。</p><h2 id="Connector和Container的微妙关系"><a href="#Connector和Container的微妙关系" class="headerlink" title="Connector和Container的微妙关系"></a>Connector和Container的微妙关系</h2><p><img src="/images/connector_container.jpg" alt="-w578"></p><p>由上述内容我们大致可以知道一个请求发送到Tomcat之后，首先经过<strong>Service</strong>然后会交给我们的<strong>Connector</strong>，<strong>Connector</strong>用于接收请求并将接收的请求封装为Request和Response来具体处理，Request和Response封装完之后再交由Container进行处理，Container处理完请求之后再返回给Connector，最后在由Connector通过Socket将处理的结果返回给客户端，这样整个请求的就处理完了！</p><p>Connector最底层使用的是Socket来进行连接的，Request和Response是按照HTTP协议来封装的，所以Connector同时需要实现TCP/IP协议和HTTP协议！</p><p>Tomcat既然处理请求，那么肯定需要先接收到这个请求，接收请求这个东西我们首先就需要看一下Connector！</p><h2 id="Connector架构分析"><a href="#Connector架构分析" class="headerlink" title="Connector架构分析"></a>Connector架构分析</h2><p>Connector用于接受请求并将请求封装成Request和Response，然后交给Container进行处理，Container处理完之后在交给Connector返回给客户端。</p><p>因此，我们可以把Connector分为四个方面进行理解：</p><blockquote><p>（1）Connector如何接受请求的？<br>（2）如何将请求封装成Request和Response的？<br>（3）封装完之后的Request和Response如何交给Container进行处理的？<br>（4）Container处理完之后如何交给Connector并返回给客户端的？</p></blockquote><p>首先看一下Connector的结构图，如下所示：</p><p> <img src="/images/connector_structure.jpg" alt></p><p><strong>Connector</strong>就是使用<strong>ProtocolHandler</strong>来处理请求的，不同的<strong>ProtocolHandler</strong>代表不同的连接类型，比如：<strong>Http11Protocol</strong>使用的是普通Socket来连接的，<strong>Http11NioProtocol</strong>使用的是NioSocket来连接的。</p><p>其中ProtocolHandler由包含了三个部件：<strong>Endpoint</strong>、<strong>Processor</strong>、<strong>Adapter</strong>。</p><ul><li><p><strong>Endpoint</strong> 用来处理底层Socket的网络连接</p><ul><li><p>Endpoint由于是处理底层的Socket网络连接，因此Endpoint是用来实现<strong>TCP/IP</strong>协议的</p></li><li><p>Endpoint 的抽象实现<code>AbstractEndpoint</code>里面定义的 <code>Acceptor</code> 和 <code>AsyncTimeout</code> 两个内部类和一个 <code>Handler</code> 接口。</p><blockquote><p><code>Acceptor</code>用于监听请求<br><code>AsyncTimeout</code>用于检查异步Request的超时<br><code>Handler</code> 用于处理接收到的Socket，在内部调用Processor进行处理</p></blockquote></li></ul></li><li><p><strong>Processor</strong> 用于将Endpoint接收到的Socket封装成Request</p><ul><li>Processor用来实现<strong>HTTP</strong>协议的</li></ul></li><li><p><strong>Adapter</strong> 用于将Request交给Container进行具体的处理</p><ul><li>Adapter将请求适配到Servlet容器进行具体的处理</li></ul></li></ul><p>至此，我们应该很轻松的回答（1）（2）（3）的问题了，但是（4）还是不知道，那么我们就来看一下Container是如何进行处理的以及处理完之后是如何将处理完的结果返回给Connector的？</p><h2 id="Container架构分析"><a href="#Container架构分析" class="headerlink" title="Container架构分析"></a>Container架构分析</h2><p>Container用于封装和管理Servlet，以及具体处理Request请求，在Connector内部包含了4个子容器，结构图如下：</p><p><img src="/images/container_structure.jpg" alt></p><p>4个子容器的作用分别是：</p><ul><li><p><strong>Engine</strong>：引擎，用来管理多个站点，一个Service最多只能有一个Engine；</p></li><li><p><strong>Host</strong>：代表一个站点，也可以叫虚拟主机，通过配置Host就可以添加站点；</p></li><li><p><strong>Context</strong>：代表一个应用程序，对应着平时开发的一套程序，或者一个 <code>WEB-INF</code> 目录以及下面的 <code>web.xml</code> 文件；</p></li><li><p><strong>Wrapper</strong>：每一Wrapper封装着一个Servlet；</p></li></ul><p>下面找一个Tomcat的文件目录对照一下，如下图所示：<br><img src="/images/tomcat_deploy_folder.jpg" alt></p><p><strong>Context和Host的区别</strong></p><p><strong>Context</strong>表示一个应用，<strong>Tomcat中默认的配置下 webapps 下的每一个文件夹目录都是一个<code>Context</code></strong>，其中ROOT目录中存放着主应用，其他目录存放着子应用，而<strong>整个 webapps 就是一个Host站点</strong>。</p><p>我们访问应用Context的时候，如果是<code>ROOT</code>下的则直接使用域名就可以访问，例如：<a href="http://www.ledouit.com" target="_blank" rel="noopener">www.ledouit.com</a>.</p><p>如果是Host（webapps）下的其他应用，则可以使用 <a href="http://www.ledouit.com/docs" target="_blank" rel="noopener">www.ledouit.com/docs</a> 进行访问，当然默认指定的根应用（ROOT）是可以进行设定的，只不过Host站点下默认的主应用是ROOT目录下的。</p><p>看到这里我们知道Container是什么，但是还是不知道Container是如何进行处理的以及处理完之后是如何将处理完的结果返回给Connector的？别急！下边就开始探讨一下Container是如何进行处理的！</p><h2 id="Container如何处理请求的"><a href="#Container如何处理请求的" class="headerlink" title="Container如何处理请求的"></a>Container如何处理请求的</h2><p>Container处理请求是使用 <strong>Pipeline-Valve</strong> 管道来处理的！（Valve是阀门之意）</p><p><strong>Pipeline-Valve</strong> 是<strong>责任链模式</strong>，责任链模式是指在一个请求处理的过程中有很多处理者依次对请求进行处理，每个处理者负责做自己相应的处理，处理完之后将处理后的请求返回，再让下一个处理着继续处理。但是！Pipeline-Valve使用的责任链模式和普通的责任链模式有些不同！区别主要有以下两点：</p><ul><li><p>每个Pipeline都有特定的Valve，而且是在管道的最后一个执行，这个Valve叫做 <strong>BaseValve</strong>，<strong>BaseValve是不可删除的</strong>；</p></li><li><p>在上层容器的管道的BaseValve中会调用下层容器的管道。</p></li></ul><p>我们知道 Container 包含四个子容器，而这四个子容器对应的 BaseValve 分别是：</p><blockquote><p><strong>StandardEngineValve</strong>、<strong>StandardHostValve</strong>、<strong>StandardContextValve</strong>、<strong>StandardWrapperValve</strong></p></blockquote><p>Pipeline的处理流程图如下（图D）：<br><img src="/images/tomcat_pipeline_valve.jpg" alt></p><p>（1）Connector在接收到请求后会首先调用最顶层容器的Pipeline来处理，这里的最顶层容器的Pipeline就是<strong>EnginePipeline</strong>（Engine的管道）；</p><p>（2）在Engine的管道中依次会执行EngineValve1、EngineValve2等等，最后会执行StandardEngineValve，在StandardEngineValve中会调用Host管道，然后再依次执行Host的HostValve1、HostValve2等，最后在执行StandardHostValve，然后再依次调用Context的管道和Wrapper的管道，最后执行到StandardWrapperValve。</p><p>（3）当执行到StandardWrapperValve的时候，会在 <strong>StandardWrapperValve中创建FilterChain</strong>，并调用其doFilter方法来处理请求，这个FilterChain包含着我们配置的与请求相匹配的Filter和Servlet，其<strong>doFilter方法会依次调用所有的Filter的doFilter方法和Servlet的service方法</strong>，这样请求就得到了处理！</p><p>（4）当所有的Pipeline-Valve都执行完之后，并且处理完了具体的请求，这个时候就可以将返回的结果交给Connector了，Connector在通过Socket的方式将结果返回给客户端。</p><h2 id="Servlet生命周期"><a href="#Servlet生命周期" class="headerlink" title="Servlet生命周期"></a>Servlet生命周期</h2><p><img src="/images/servlet_lifecycle.png" alt></p><h2 id="Tomcat优化"><a href="#Tomcat优化" class="headerlink" title="Tomcat优化"></a>Tomcat优化</h2><p>不要保留无用对象</p><ul><li>web.xml中无用标签应该删掉；</li><li>server.xml中无用标签也需要删掉；</li></ul><p>原文链接： <a href="https://blog.csdn.net/xlgen157387/article/details/79006434" target="_blank" rel="noopener">四张图带你了解Tomcat系统架构–让面试官颤抖的Tomcat回答系列</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Tomcat顶层架构&quot;&gt;&lt;a href=&quot;#Tomcat顶层架构&quot; class=&quot;headerlink&quot; title=&quot;Tomcat顶层架构&quot;&gt;&lt;/a&gt;Tomcat顶层架构&lt;/h2&gt;&lt;p&gt;先上一张Tomcat的顶层结构图，如下&lt;br&gt;&lt;img src=&quot;/imag
      
    
    </summary>
    
      <category term="Web" scheme="http://yoursite.com/categories/Web/"/>
    
      <category term="Tomcat" scheme="http://yoursite.com/categories/Web/Tomcat/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Web" scheme="http://yoursite.com/tags/Web/"/>
    
      <category term="Tomcat" scheme="http://yoursite.com/tags/Tomcat/"/>
    
  </entry>
  
  <entry>
    <title>Java动态代理</title>
    <link href="http://yoursite.com/2019/11/29/Java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    <id>http://yoursite.com/2019/11/29/Java动态代理/</id>
    <published>2019-11-29T09:04:34.000Z</published>
    <updated>2019-11-29T09:13:55.882Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是代理"><a href="#什么是代理" class="headerlink" title="什么是代理"></a>什么是代理</h2><p>我们大家都知道微商代理，简单地说就是代替厂家卖商品，厂家“委托”代理为其销售商品。关于微商代理，首先我们从他们那里买东西时通常不知道背后的厂家究竟是谁，也就是说，“委托者”对我们来说是不可见的;其次，微商代理主要以朋友圈的人为目标客户，这就相当于为厂家做了一次对客户群体的“过滤”。我们把微商代理和厂家进一步抽象，前者可抽象为代理类，后者可抽象为委托类(被代理类)。通过使用代理，通常有两个优点，并且能够分别与我们提到的微商代理的两个特点对应起来：</p><ul><li><p>优点一：可以隐藏委托类的实现;</p></li><li><p>优点二：可以实现客户与委托类间的解耦，在不修改委托类代码的情况下能够做一些额外的处理。</p></li></ul><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>代理模式：给某一个对象提供一个代理，并由代理对象来控制对真实对象的访问。代理模式是一种结构型设计模式。</p><p>代理模式角色分为 3 种：</p><ul><li><p>Subject（抽象主题角色）：定义代理类和真实主题的公共对外方法，也是代理类代理真实主题的方法；</p></li><li><p>RealSubject（真实主题角色）：真正实现业务逻辑的类；</p></li><li><p>Proxy（代理主题角色）：用来代理和封装真实主题；</p></li></ul><p>代理模式的结构比较简单，其核心是代理类，为了让客户端能够一致性地对待真实对象和代理对象，在代理模式中引入了抽象层</p><p><img src="/images/proxy_model_dynamic.png" alt></p><p>如果根据字节码的创建时机来分类，可以分为静态代理和动态代理：</p><ul><li><p>静态代理<br>就是在程序运行前就已经存在代理类的字节码文件，代理类和真实主题角色的关系在运行前就确定了。</p></li><li><p>动态代理<br>源码是在程序运行期间由JVM根据反射等机制动态的生成，所以在运行前并不存在代理类的字节码文件。</p></li></ul><h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><p>我们先通过实例来学习静态代理，然后理解静态代理的缺点，再来学习本文的主角：动态代理</p><p>编写一个接口 UserService ，以及该接口的一个实现类 UserServiceImpl：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">()</span></span>;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"查询 selectById"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"更新 update"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将通过静态代理对 UserServiceImpl 进行功能增强，在调用 select 和 update 之前记录一些日志。写一个代理类 UserServiceProxy，代理类需要实现 UserService</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceProxy</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> UserService target; <span class="comment">// 被代理的对象</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserServiceProxy</span><span class="params">(UserService target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        before();</span><br><span class="line">        target.select();    <span class="comment">// 这里才实际调用真实主题角色的方法</span></span><br><span class="line">        after();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        before();</span><br><span class="line">        target.update();    <span class="comment">// 这里才实际调用真实主题角色的方法</span></span><br><span class="line">        after();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;     <span class="comment">// 在执行方法之前执行</span></span><br><span class="line">        System.out.printf(<span class="string">"log start time [%s] \n"</span>, <span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;      <span class="comment">// 在执行方法之后执行</span></span><br><span class="line">        System.out.printf(<span class="string">"log end time [%s] \n"</span>, <span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        UserService userServiceImpl = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line">        UserService proxy = <span class="keyword">new</span> UserServiceProxy(userServiceImpl);</span><br><span class="line"></span><br><span class="line">        proxy.select();</span><br><span class="line">        proxy.update();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">log start time [Thu Dec 20 14:13:25 CST 2018] </span><br><span class="line">查询 selectById</span><br><span class="line">log end time [Thu Dec 20 14:13:25 CST 2018] </span><br><span class="line">log start time [Thu Dec 20 14:13:25 CST 2018] </span><br><span class="line">更新 update</span><br><span class="line">log end time [Thu Dec 20 14:13:25 CST 2018]</span><br></pre></td></tr></table></figure><p>通过静态代理，我们达到了功能增强的目的，而且没有侵入原代码，这是静态代理的一个优点。</p><h3 id="静态代理缺点"><a href="#静态代理缺点" class="headerlink" title="静态代理缺点"></a>静态代理缺点</h3><p>虽然静态代理实现简单，且不侵入原代码，但是，当场景稍微复杂一些的时候，静态代理的缺点也会暴露出来。</p><ul><li><p>1、 当需要代理多个类的时候，由于代理对象要实现与目标对象一致的接口，有两种方式：</p><ul><li><p>只维护一个代理类，由这个代理类实现多个接口，但是这样就导致<strong>代理类过于庞大</strong>;</p></li><li><p>新建多个代理类，每个目标对象对应一个代理类，但是这样会<strong>产生过多的代理类</strong>;</p></li></ul></li><li><p>2、 当接口需要增加、删除、修改方法的时候，目标对象与代理类都要同时修改，<strong>不易维护</strong>。</p></li></ul><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><h3 id="生成原理"><a href="#生成原理" class="headerlink" title="生成原理"></a>生成原理</h3><p>Java虚拟机类加载过程主要分为五个阶段：<code>加载</code>、<code>验证</code>、<code>准备</code>、<code>解析</code>、`初始化。其中加载阶段需要完成以下3件事情：</p><ul><li><p>通过一个类的全限定名来获取定义此类的二进制字节流</p></li><li><p>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</p></li><li><p>在内存中生成一个代表这个类的 <code>java.lang.Class</code> 对象，作为方法区这个类的各种数据访问入口</p></li></ul><p>由于虚拟机规范对这3点要求并不具体，所以实际的实现是非常灵活的，关于第1点，获取类的二进制字节流（class字节码）就有很多途径：</p><ul><li><p>从ZIP包获取，这是JAR、EAR、WAR等格式的基础</p></li><li><p>从网络中获取，典型的应用是 Applet</p></li><li><p>运行时计算生成，这种场景使用最多的是<strong>动态代理技术</strong>，在 <code>java.lang.reflect.Proxy</code> 类中，就是用了 <code>ProxyGenerator.generateProxyClass</code>来为特定接口生成形式为 <code>*$Proxy</code> 的代理类的二进制字节流</p></li><li><p>由其它文件生成，典型应用是JSP，即由JSP文件生成对应的Class类</p></li><li><p>从数据库中获取等等</p></li></ul><p>所以，动态代理就是想办法，根据接口或目标对象，计算出代理类的字节码，然后再加载到JVM中使用。但是如何计算？如何生成？情况也许比想象的复杂得多，我们需要借助现有的方案。</p><h3 id="常见的字节码操作类库"><a href="#常见的字节码操作类库" class="headerlink" title="常见的字节码操作类库"></a>常见的字节码操作类库</h3><blockquote><p>这里有一些介绍：java-source.net/open-source…</p></blockquote><ul><li><p>Apache BCEL (Byte Code Engineering Library)：是Java classworking广泛使用的一种框架，它可以深入到JVM汇编语言进行类操作的细节。</p></li><li><p>ObjectWeb ASM：是一个Java字节码操作框架。它可以用于直接以二进制形式动态生成stub根类或其他代理类，或者在加载时动态修改类。</p></li><li><p>CGLIB(Code Generation Library)：是一个功能强大，高性能和高质量的代码生成库，用于扩展JAVA类并在运行时实现接口。</p></li><li><p>Javassist：是Java的加载时反射系统，它是一个用于在Java中编辑字节码的类库; 它使Java程序能够在运行时定义新类，并在JVM加载之前修改类文件。 </p></li></ul><p>为了让生成的代理类与目标对象（真实主题角色）保持一致性，从现在开始将介绍以下两种最常见的方式：</p><blockquote><p>通过实现接口的方式 -&gt; JDK动态代理<br>通过继承类的方式 -&gt; CGLIB动态代理</p></blockquote><p>注：使用ASM对使用者要求比较高，使用Javassist会比较麻烦</p><h3 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h3><p>JDK动态代理主要涉及两个类：<code>java.lang.reflect.Proxy</code> 和<code>java.lang.reflect.InvocationHandler</code>，我们仍然通过案例来学习.</p><p>编写一个调用逻辑处理器 LogHandler 类，提供日志增强功能，并实现 InvocationHandler 接口；在 LogHandler 中维护一个目标对象，这个对象是被代理的对象（真实主题角色）；在 invoke 方法中编写方法调用的逻辑处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    Object target;  <span class="comment">// 被代理的对象，实际的方法执行者</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LogHandler</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        before();</span><br><span class="line">        <span class="comment">// 调用 target 的 method 方法</span></span><br><span class="line">        Object result = method.invoke(target, args);  </span><br><span class="line">        after();</span><br><span class="line">        <span class="keyword">return</span> result;  <span class="comment">// 返回方法的执行结果</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用invoke方法之前执行</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">"log start time [%s] \n"</span>, <span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用invoke方法之后执行</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">"log end time [%s] \n"</span>, <span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写客户端，获取动态生成的代理类的对象须借助 Proxy 类的 newProxyInstance 方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> proxy.UserService;</span><br><span class="line"><span class="keyword">import</span> proxy.UserServiceImpl;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserClientJdkDynamic</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IllegalAccessException, InstantiationException </span>&#123;</span><br><span class="line">        <span class="comment">// 设置变量可以保存动态代理类，默认名称以 $Proxy0 格式命名</span></span><br><span class="line">        <span class="comment">// System.getProperties().setProperty("sun.misc.ProxyGenerator.saveGeneratedFiles", "true");</span></span><br><span class="line">        <span class="comment">// 1. 创建被代理的对象，UserService接口的实现类</span></span><br><span class="line">        UserServiceImpl userServiceImpl = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 获取对应的 ClassLoader</span></span><br><span class="line">        ClassLoader classLoader = userServiceImpl.getClass().getClassLoader();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 获取所有接口的Class，这里的UserServiceImpl只实现了一个接口UserService，</span></span><br><span class="line">        Class[] interfaces = userServiceImpl.getClass().getInterfaces();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 4. 创建一个将传给代理类的调用请求处理器，处理所有的代理对象上的方法调用</span></span><br><span class="line">        <span class="comment">//     这里创建的是一个自定义的日志处理器，须传入实际的执行对象 userServiceImpl</span></span><br><span class="line">        InvocationHandler logHandler = <span class="keyword">new</span> LogHandler(userServiceImpl);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">   5.根据上面提供的信息，创建代理对象 在这个过程中，</span></span><br><span class="line"><span class="comment">               a.JDK会通过根据传入的参数信息动态地在内存中创建和.class 文件等同的字节码</span></span><br><span class="line"><span class="comment">               b.然后根据相应的字节码转换成对应的class，</span></span><br><span class="line"><span class="comment">               c.然后调用newInstance()创建代理实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">        UserService proxy = (UserService) Proxy.newProxyInstance(classLoader, interfaces, logHandler);</span><br><span class="line">        <span class="comment">// 调用代理的方法</span></span><br><span class="line">        proxy.select();</span><br><span class="line">        proxy.update();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 6. 保存JDK动态代理生成的代理类，类名保存为 UserServiceProxy</span></span><br><span class="line">        ProxyUtils.generateClassFile(userServiceImpl.getClass(), <span class="string">"UserServiceProxy2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">log start time [Thu Dec 20 16:55:19 CST 2018] </span><br><span class="line">查询 selectById</span><br><span class="line">log end time [Thu Dec 20 16:55:19 CST 2018] </span><br><span class="line">log start time [Thu Dec 20 16:55:19 CST 2018] </span><br><span class="line">更新 update</span><br><span class="line">log end time [Thu Dec 20 16:55:19 CST 2018]</span><br></pre></td></tr></table></figure><h4 id="InvocationHandler和Proxy核心方法介绍"><a href="#InvocationHandler和Proxy核心方法介绍" class="headerlink" title="InvocationHandler和Proxy核心方法介绍"></a>InvocationHandler和Proxy核心方法介绍</h4><h5 id="java-lang-reflect-InvocationHandler"><a href="#java-lang-reflect-InvocationHandler" class="headerlink" title="java.lang.reflect.InvocationHandler"></a>java.lang.reflect.InvocationHandler</h5><p><code>Object invoke(Object proxy, Method method, Object[] args)</code>  定义了代理对象调用方法时希望执行的动作，用于集中处理在动态代理类对象上的方法调用</p><h5 id="java-lang-reflect-Proxy"><a href="#java-lang-reflect-Proxy" class="headerlink" title="java.lang.reflect.Proxy"></a>java.lang.reflect.Proxy</h5><p><code>static InvocationHandler getInvocationHandler(Object proxy)</code>  用于获取指定代理对象所关联的调用处理器</p><p><code>static Class&lt;?&gt; getProxyClass(ClassLoader loader, Class&lt;?&gt;... interfaces)</code> 返回指定接口的代理类</p><p><code>static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</code>   构造实现指定接口的代理类的一个新实例，所有方法会调用给定处理器对象的 invoke 方法</p><p><code>static boolean isProxyClass(Class&lt;?&gt; cl)</code>  返回 cl 是否为一个代理类</p><h4 id="代理类"><a href="#代理类" class="headerlink" title="代理类"></a>代理类</h4><p>JDK自动生成的代理类到底长什么样子呢？借助上面第6步操作，可以把代理类保存下来一探究竟， target 的类路径下找到 UserServiceProxy2.class，双击后IDEA的反编译插件会将该二进制class文件转变成java文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line"><span class="keyword">import</span> proxy.UserService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceProxy2</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m4;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserServiceProxy2</span><span class="params">(InvocationHandler var1)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object var1)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="comment">// 省略...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="comment">// 省略...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m4, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="comment">// 省略...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m3, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            m1 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"equals"</span>, Class.forName(<span class="string">"java.lang.Object"</span>));</span><br><span class="line">            m2 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"toString"</span>);</span><br><span class="line">            m4 = Class.forName(<span class="string">"proxy.UserService"</span>).getMethod(<span class="string">"select"</span>);</span><br><span class="line">            m0 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"hashCode"</span>);</span><br><span class="line">            m3 = Class.forName(<span class="string">"proxy.UserService"</span>).getMethod(<span class="string">"update"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError(var2.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoClassDefFoundError(var3.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 UserServiceProxy 的代码中我们可以发现：</p><ul><li><p><code>UserServiceProxy2</code> 继承了 <code>Proxy</code> 类，并且实现了被代理的所有接口，以及equals、hashCode、toString等方法</p></li><li><p>由于<code>UserServiceProxy2</code>继承了 <code>Proxy</code> 类，所以每个代理类都会关联一个 <code>InvocationHandler</code> 方法调用处理器</p></li><li><p>类和所有方法都被 <code>public final</code> 修饰，所以代理类只可被使用，不可以再被继承</p></li><li><p>每个方法都有一个 <code>Method</code> 对象来描述，<code>Method</code> 对象在<code>static</code>静态代码块中创建，以 <code>m+</code> 数字 的格式命名</p></li><li><p>调用方法的时候通过 <code>super.h.invoke(this, m1, (Object[])null)</code> 调用，其中的 <code>super.h.invoke</code> 实际上是在创建代理的时候传递给 <code>Proxy.newProxyInstance</code> 的 <code>LogHandler</code> 对象，它继承 <code>InvocationHandler</code> 类，负责实际的调用处理逻辑</p></li></ul><p>而 LogHandler 的 invoke 方法接收到 method、args 等参数后，进行一些处理，然后通过反射让被代理的对象 target 执行方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    before();</span><br><span class="line">    <span class="comment">// 调用 target 的 method 方法</span></span><br><span class="line">    Object result = method.invoke(target, args);            </span><br><span class="line">    after();</span><br><span class="line">    <span class="keyword">return</span> result;  <span class="comment">// 返回方法的执行结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JDK动态代理执行方法调用的过程简图如下：</p><p><img src="/images/dynamic_process.png" alt></p><h3 id="CGLIB动态代理"><a href="#CGLIB动态代理" class="headerlink" title="CGLIB动态代理"></a>CGLIB动态代理</h3><p>maven引入CGLIB包，然后编写一个UserDao类，它没有接口，只有两个方法，select() 和 update()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"UserDao 查询 selectById"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"UserDao 更新 update"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写一个 LogInterceptor ，继承了 MethodInterceptor，用于方法的拦截回调</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object target;  <span class="comment">//目标类</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LogInterceptor</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回代理对象</span></span><br><span class="line"><span class="comment">     * 具体实现，暂时先不追究。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">createProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);  <span class="comment">// 回调函数  拦截器</span></span><br><span class="line">        <span class="comment">// 设置代理对象的父类,可以看到代理对象是目标对象的子类。所以这个接口类就可以省略了</span></span><br><span class="line">        enhancer.setSuperclass(<span class="keyword">this</span>.target.getClass());</span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> object      表示要进行增强的对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method      表示拦截的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> objects     数组表示参数列表，基本数据类型需要传入其包装类型，如int--&gt;Integer、long-Long、double--&gt;Double</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> methodProxy 表示对方法的代理，invokeSuper方法表示对被代理对象方法的调用</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 执行结果</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object object, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        before();</span><br><span class="line">        <span class="comment">// 注意这里是调用 invokeSuper 而不是 invoke，否则死循环，</span></span><br><span class="line">        <span class="comment">// methodProxy.invokesuper执行的是原始类的方法，method.invoke执行的是子类的方法</span></span><br><span class="line">        Object result = methodProxy.invokeSuper(object, objects);</span><br><span class="line">        after();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(String.format(<span class="string">"log start time [%s] "</span>, <span class="keyword">new</span> Date()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(String.format(<span class="string">"log end time [%s] "</span>, <span class="keyword">new</span> Date()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//目标对象</span></span><br><span class="line">        UserDao userDao = <span class="keyword">new</span> UserDao();</span><br><span class="line">        LogInterceptor interceptor = <span class="keyword">new</span> LogInterceptor(userDao);</span><br><span class="line">        <span class="comment">// 代理对象，调用cglib系统方法自动生成</span></span><br><span class="line">        <span class="comment">// 注意：代理类是目标类的子类。</span></span><br><span class="line">        UserDao proxy = (UserDao) interceptor.createProxy();</span><br><span class="line">        proxy.select();</span><br><span class="line">        proxy.update();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">log start time [Fri Nov 29 10:51:17 CST 2019] </span><br><span class="line">UserDao 查询 selectById</span><br><span class="line">log end time [Fri Nov 29 10:51:17 CST 2019] </span><br><span class="line">log start time [Fri Nov 29 10:51:17 CST 2019] </span><br><span class="line">UserDao 更新 update</span><br><span class="line">log end time [Fri Nov 29 10:51:17 CST 2019]</span><br></pre></td></tr></table></figure><p><strong>CGLIB 创建动态代理类的模式是：</strong></p><ul><li><p>查找目标类上的所有非final 的public类型的方法定义；</p></li><li><p>将这些方法的定义转换成字节码；</p></li><li><p>将组成的字节码转换成相应的代理的class对象；</p></li><li><p>实现 <code>MethodInterceptor</code> 接口，用来处理对代理类上所有方法的请求</p></li></ul><h3 id="JDK与CGLIB动态代理对比"><a href="#JDK与CGLIB动态代理对比" class="headerlink" title="JDK与CGLIB动态代理对比"></a>JDK与CGLIB动态代理对比</h3><ul><li><p>JDK动态代理：基于<font color="red">Java反射机制</font>实现，必须要<font color="red">实现了接口</font>的业务类才能用这种办法生成代理对象。</p></li><li><p>Cglib动态代理：基于<font color="red">ASM机制</font>实现，通过<font color="red">生成业务类的子类</font>作为代理类。</p></li></ul><p><strong>JDK动态代理优势</strong></p><ul><li><p>最小化依赖关系，减少依赖意味着简化开发和维护，JDK 本身的支持，可能比 cglib 更加可靠。</p></li><li><p>平滑进行 JDK 版本升级，而字节码类库通常需要进行更新以保证在新版 Java 上能够使用。</p></li><li><p>代码实现简单。</p></li></ul><p><strong>基于类似 cglib 框架的优势</strong></p><ul><li>无需实现接口，达到代理类无侵入</li><li>只操作我们关心的类，而不必为其他相关类增加工作量。</li><li>高性能</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://juejin.im/post/5c1ca8df6fb9a049b347f55c" target="_blank" rel="noopener">Java 动态代理详解</a></p><p>[2] <a href="https://juejin.im/post/5ad3e6b36fb9a028ba1fee6a" target="_blank" rel="noopener">Java动态代理</a></p><p>[3] <a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&mid=2247483785&idx=1&sn=f696c8c49cb7ecce9818247683482a1c&chksm=e9c2ed84deb564925172b2dd78d307d4dc345fa313d3e44f01e84fa22ac5561b37aec5cbd5b4&scene=0#rd" target="_blank" rel="noopener">Java反射机制详解</a></p><p>[4] <a href="https://blog.csdn.net/lovejj1994/article/details/78080124" target="_blank" rel="noopener">从代理模式再出发！Proxy.newProxyInstance的秘密</a></p><p>[5] <a href="https://blog.csdn.net/yhl_jxy/article/details/80586785" target="_blank" rel="noopener">JDK动态代理实现原理(jdk8)</a></p><h2 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h2><p>文中代码： <a href="https://github.com/austin-brant/dynamic-proxy-demo" target="_blank" rel="noopener">https://github.com/austin-brant/dynamic-proxy-demo</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是代理&quot;&gt;&lt;a href=&quot;#什么是代理&quot; class=&quot;headerlink&quot; title=&quot;什么是代理&quot;&gt;&lt;/a&gt;什么是代理&lt;/h2&gt;&lt;p&gt;我们大家都知道微商代理，简单地说就是代替厂家卖商品，厂家“委托”代理为其销售商品。关于微商代理，首先我们从他们那里买
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
      <category term="基础" scheme="http://yoursite.com/categories/Java/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="基础" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>布隆过滤器(Bloom Filter)</title>
    <link href="http://yoursite.com/2019/11/27/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8-Bloom-Filter/"/>
    <id>http://yoursite.com/2019/11/27/布隆过滤器-Bloom-Filter/</id>
    <published>2019-11-27T02:35:39.000Z</published>
    <updated>2019-11-29T09:27:20.987Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>布隆过滤器（英语：Bloom Filter）是1970年由一个叫布隆的小伙子提出的。它实际上是一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。</p><ul><li>优点： 空间效率和查询时间都远远超过一般的算法</li><li>缺点： 有一定的误识别率和删除困难。</li></ul><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>布隆过滤器的原理是，当一个元素被加入集合时，通过 <code>K</code> 个散列函数将这个元素映射成一个位数组中的 <code>K</code> 个点，把它们置为1。检索时，我们只要看看这些点是不是都是1就（大约）知道集合中有没有它了：</p><ul><li>如果这些点有任何一个0，则被检元素一定不在；</li><li>如果都是1，则被检元素很可能在</li></ul><p>这就是布隆过滤器的基本思想。</p><p>Bloom Filter跟单哈希函数Bit-Map不同之处在于：<strong>Bloom Filter使用了k个哈希函数，每个字符串跟k个bit对应</strong>。从而降低了冲突的概率。<br><img src="/images/bloom_theory.jpg" alt></p><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p><img src="/images/cache_strike.jpg" alt></p><blockquote><p>每次查询都会直接打到DB</p></blockquote><p>简而言之，言而简之就是我们先把我们数据库的数据都加载到我们的过滤器中，比如数据库的id现在有：1、2、3</p><p>那就用id：1 为例子, 他在上图中经过三次hash之后，把三次原本值0的地方改为1<br>下次数据进来查询的时候如果id的值是1，那么我就把1拿去三次hash 发现三次hash的值，跟上面的三个位置完全一样，那就能证明过滤器中有1的, 反之如果不一样就说明不存在了</p><p>那应用的场景在哪里呢？一般我们都会用来<strong>防止缓存击穿</strong></p><p>简单来说就是你数据库的id都是1开始然后自增的，那我知道你接口是通过id查询的，我就拿负数去查询，这个时候，会发现缓存里面没这个数据，我又去数据库查也没有，一个请求这样，100个，1000个，10000个呢？你的DB基本上就扛不住了，如果在缓存里面加上这个，是不是就不存在了，你判断没这个数据就不去查了，直接return一个数据为空不就好了嘛。</p><h2 id="Bloom-Filter缺点"><a href="#Bloom-Filter缺点" class="headerlink" title="Bloom Filter缺点"></a>Bloom Filter缺点</h2><p>bloom filter之所以能做到在时间和空间上的效率比较高，是因为<strong>牺牲了判断的准确率、删除的便利性</strong></p><ul><li><p>存在误判，可能要查到的元素并没有在容器中，但是hash之后得到的k个位置上值都是1。如果bloom filter中存储的是黑名单，那么可以通过建立一个白名单来存储可能会误判的元素。</p></li><li><p>删除困难。一个放入容器的元素映射到bit数组的k个位置上是1，删除的时候不能简单的直接置为0，可能会影响其他元素的判断。可以采用<a href="http://wiki.corp.qunar.com/confluence/download/attachments/199003276/US9740797.pdf?version=1&modificationDate=1526538500000&api=v2" target="_blank" rel="noopener">Counting Bloom Filter</a></p></li></ul><h2 id="Guava本地实现"><a href="#Guava本地实现" class="headerlink" title="Guava本地实现"></a>Guava本地实现</h2><p>布隆过滤器有许多实现与优化，<code>Guava</code>中就提供了一种<code>Bloom Filter</code>的实现。</p><ul><li><p>在<strong>使用</strong>bloom filter时，绕不过的两点是<font color="red"><strong>预估数据量n</strong></font> 以及 <font color="red"><strong>期望的误判率fpp</strong></font>，</p></li><li><p>在实现bloom filter时，绕不过的两点就是<font color="red"><strong>hash函数的选取</strong></font> 以及 <font color="red"><strong>bit数组的大小</strong></font>。</p></li></ul><p>对于一个确定的场景，我们预估要存的数据量为n，期望的误判率为fpp，然后需要计算我们需要的Bit数组的大小m，以及hash函数的个数k，并选择hash函数</p><h3 id="Bit数组大小选择"><a href="#Bit数组大小选择" class="headerlink" title="Bit数组大小选择"></a>Bit数组大小选择</h3><p>根据预估数据量n以及误判率fpp，bit数组大小的m的计算方式：<br><img src="/images/bloom_array_calculate.jpg" alt="-w665"></p><h3 id="哈希函数选择"><a href="#哈希函数选择" class="headerlink" title="哈希函数选择"></a>哈希函数选择</h3><p>​由预估数据量n以及bit数组长度m，可以得到一个hash函数的个数k：<br>​<br>​<img src="/images/bloom_hash_num.jpg" alt><br>​<br>​哈希函数的选择对性能的影响应该是很大的，一个好的哈希函数要能<strong>近似等概率的将字符串映射到各个Bit</strong>。选择k个不同的哈希函数比较麻烦，一种简单的方法是选择一个哈希函数，然后送入k个不同的参数。</p><p>哈希函数个数k、位数组大小m、加入的字符串数量n的关系可以参考<a href="http://pages.cs.wisc.edu/~cao/papers/summary-cache/node8.html" target="_blank" rel="noopener">Bloom Filters - the math，Bloom_filter-wikipedia</a></p><p>要使用BloomFilter，需要引入guava包：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;com.google.guava&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;guava&lt;/artifactId&gt;</span><br><span class="line">           &lt;version&gt;23.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>测试分两步：</p><p>1、往过滤器中放一百万个数，然后去验证这一百万个数是否能通过过滤器</p><p>2、另外找一万个数，去检验漏网之鱼的数量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试布隆过滤器(可用于redis缓存穿透)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 敖丙</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBloomFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> total = <span class="number">1000000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> BloomFilter&lt;Integer&gt; bf = BloomFilter.create(Funnels.integerFunnel(), total);</span><br><span class="line"><span class="comment">//    private static BloomFilter&lt;Integer&gt; bf = BloomFilter.create(Funnels.integerFunnel(), total, 0.001);</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化1000000条数据到过滤器中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; total; i++) &#123;</span><br><span class="line">            bf.put(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 匹配已在过滤器中的值，是否有匹配不上的</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; total; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!bf.mightContain(i)) &#123;</span><br><span class="line">                System.out.println(<span class="string">"有坏人逃脱了~~~"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 匹配不在过滤器中的10000个值，有多少匹配出来</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = total; i &lt; total + <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bf.mightContain(i)) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"误伤的数量："</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/images/bloom_320.jpg" alt></p><p>运行结果表示，遍历这一百万个在过滤器中的数时，都被识别出来了。一万个不在过滤器中的数，误伤了320个，错误率是0.03左右。</p><p>看下BloomFilter的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">BloomFilter&lt;T&gt; <span class="title">create</span><span class="params">(Funnel&lt;? <span class="keyword">super</span> T&gt; funnel, <span class="keyword">int</span> expectedInsertions)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> create(funnel, (<span class="keyword">long</span>) expectedInsertions);</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">BloomFilter&lt;T&gt; <span class="title">create</span><span class="params">(Funnel&lt;? <span class="keyword">super</span> T&gt; funnel, <span class="keyword">long</span> expectedInsertions)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> create(funnel, expectedInsertions, <span class="number">0.03</span>); <span class="comment">// FYI, for 3%, we always get 5 hash functions</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">BloomFilter&lt;T&gt; <span class="title">create</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      Funnel&lt;? <span class="keyword">super</span> T&gt; funnel, <span class="keyword">long</span> expectedInsertions, <span class="keyword">double</span> fpp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> create(funnel, expectedInsertions, fpp, BloomFilterStrategies.MURMUR128_MITZ_64);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &lt;T&gt; <span class="function">BloomFilter&lt;T&gt; <span class="title">create</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  Funnel&lt;? <span class="keyword">super</span> T&gt; funnel, <span class="keyword">long</span> expectedInsertions, <span class="keyword">double</span> fpp, Strategy strategy)</span> </span>&#123;</span><br><span class="line"> ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BloomFilter一共四个create方法，不过最终都是走向第四个。看一下每个参数的含义：</p><ul><li><p>funnel：数据类型(一般是调用Funnels工具类中的)</p></li><li><p>expectedInsertions：期望插入的值的个数</p></li><li><p>fpp 错误率(默认值为0.03)</p></li><li><p>strategy 哈希算法(我也不懂啥意思)Bloom Filter的应用</p></li></ul><p>在最后一个create方法中，设置一个断点：</p><p><img src="/images/bloom_inteceptor.jpg" alt></p><p>上面的numBits，表示存一百万个int类型数字，需要的位数为7298440，700多万位。理论上存一百万个数，一个int是4字节32位，需要481000000=3200万位。如果使用HashMap去存，按HashMap50%的存储效率，需要6400万位。可以看出BloomFilter的存储空间很小，只有HashMap的1/10左右</p><p>上面的numHashFunctions，表示需要5个函数去存这些数字</p><p>使用第三个create方法，我们设置下错误率：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> BloomFilter&lt;Integer&gt; bf = BloomFilter.create(Funnels.integerFunnel(), total, <span class="number">0.0003</span>);</span><br></pre></td></tr></table></figure><p>再运行看看：</p><p><img src="/images/bloom_error_4.jpg" alt></p><p>此时误伤的数量为4，错误率为0.04%左右。<br><img src="/images/bloom_bit_num.jpg" alt></p><p>当错误率设为0.0003时，所需要的位数为16883499，1600万位，需要12个函数<br>和上面对比可以看出，<strong>错误率越大，所需空间和时间越小，错误率越小，所需空间和时间越大</strong>。</p><h2 id="Redis实现"><a href="#Redis实现" class="headerlink" title="Redis实现"></a>Redis实现</h2><h3 id="RedisBloom实现"><a href="#RedisBloom实现" class="headerlink" title="RedisBloom实现"></a>RedisBloom实现</h3><p>Redis的布隆过滤器不是原生自带的，而是要通过module加载进去。Redis在4.0的版本中加入了module功能。</p><ul><li><code>RedisBloom github</code> 主页地址： <a href="https://github.com/RedisBloom/RedisBloom" target="_blank" rel="noopener">https://github.com/RedisBloom/RedisBloom</a></li><li><code>RedisBloom客户端</code> 主页地址： <a href="https://github.com/RedisBloom/JRedisBloom" target="_blank" rel="noopener">https://github.com/RedisBloom/JRedisBloom</a></li></ul><p>上面有docker一键启动命令，可以很方便地实验。也有几种主流语言的客户端库的链接，比如Java语言的JReBloom。</p><p>RedisBloom模块还实现了<strong>布谷鸟过滤器</strong>，它算是对布隆过滤器的增强版。解决了布隆过滤器的一些比较明显的缺点，比如：不能删除元素，不能计数等。除此之外，布谷鸟过滤器不用使用多个hash函数，所以查询性能更高。除此之外，在相同的误判率下，布谷鸟过滤器的空间利用率要明显高于布隆，空间上大概能节省40%多。</p><ul><li>安装Rebloom插件</li></ul><p>1 下载并编译</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> git://github.com/RedisLabsModules/rebloom</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> rebloom</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make</span></span><br></pre></td></tr></table></figure><p>将Rebloom加载到Redis中，在redis.conf里面添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loadmodule /path/to/rebloom.so</span><br></pre></td></tr></table></figure><p>命令操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BF.ADD bloom redis</span><br><span class="line">BF.EXISTS bloom redis</span><br><span class="line">BF.EXISTS bloom nonxist</span><br></pre></td></tr></table></figure><p>命令行加载rebloom插件,并且设定每个bloomfilter key的容量和错误率：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/redis-4.0.11</span><br><span class="line"><span class="meta">#</span><span class="bash"> 容量100万, 容错率万分之一</span></span><br><span class="line">./src/redis-server redis.conf --loadmodule /usr/rebloom/rebloom.so INITIAL_SIZE 1000000 ERROR_RATE 0.0001</span><br></pre></td></tr></table></figure><ul><li>java-lua版操作(java代码不提供了，自己把脚本执行就行)</li></ul><blockquote><p>bloomFilterAdd.lua</p></blockquote><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> bloomName = KEYS[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">local</span> value = KEYS[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">-- bloomFilter</span></span><br><span class="line"><span class="keyword">local</span> result_1 = redis.call(<span class="string">'BF.ADD'</span>, bloomName, value)</span><br><span class="line"><span class="keyword">return</span> result_1</span><br></pre></td></tr></table></figure><blockquote><p>bloomFilterExist.lua</p></blockquote><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> bloomName = KEYS[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">local</span> value = KEYS[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">-- bloomFilter</span></span><br><span class="line"><span class="keyword">local</span> result_1 = redis.call(<span class="string">'BF.EXISTS'</span>, bloomName, value)</span><br><span class="line"><span class="keyword">return</span> result_1</span><br></pre></td></tr></table></figure><h3 id="Bitmap简单实现-原理版"><a href="#Bitmap简单实现-原理版" class="headerlink" title="Bitmap简单实现-原理版"></a>Bitmap简单实现-原理版</h3><p>Bitmap不是一个确切的数据类型，而是基于String类型定义的一系列面向位操作的方法。因为String是二进制安全的并且它们的最大长度是512MB，</p><p>所以String类型很合适去作为一个2^32 长度的位数组。</p><p>位操作方法可以被分为两组：<br>一、对单一位的操作，比如设置某一位为1或0，或者得到这一位的值；<br>二、对一组位的操作，比方说计算一定范围内的1的个数（比如计数）</p><p>bitmap一个最大的优势是它通常能在存储信息的时候节省大量空间。比方说一个用增量ID来辨别用户的系统，可以用仅仅512MB的空间来标识40亿个用户是否想要接受通知。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BloomFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> size = Math.pow(<span class="number">2</span>, <span class="number">32</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第一次加载的时候将数据加载到redis中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">saveDataToRedis</span><span class="params">(Jedis jedis)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; baseList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        baseList.add(<span class="string">"000"</span>);</span><br><span class="line">        baseList.add(<span class="string">"111"</span>);</span><br><span class="line">        baseList.add(<span class="string">"222"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; baseList.size(); i++) &#123;</span><br><span class="line">            <span class="comment">// 只做一次hash，实际中会计算多个hash位置，降低误差率</span></span><br><span class="line">            <span class="keyword">long</span> index = hashIndex(baseList.get(i)); </span><br><span class="line">            jedis.setbit(<span class="string">"orderId"</span>, index, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">hashIndex</span><span class="params">(String target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.abs((<span class="keyword">long</span>) (target.hashCode() % size));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断传入的数据是否在redis中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkEleIsContainBloomFilter</span><span class="params">(String target, Jedis jedis)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> index = hashIndex(target);</span><br><span class="line">        System.out.println(<span class="string">"index: "</span> + index + <span class="string">" size: "</span> + size);</span><br><span class="line">        <span class="keyword">boolean</span> checkResult = jedis.getbit(<span class="string">"orderId"</span>, index);</span><br><span class="line">        <span class="keyword">return</span> checkResult;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取redis链接</span></span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"xxxx"</span>, <span class="number">6379</span>);</span><br><span class="line">        jedis.auth(<span class="string">"xxxxx"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一次运行的时候调用，只运行一次</span></span><br><span class="line">        saveDataToRedis(jedis);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取比较后的值</span></span><br><span class="line">        System.out.println(checkEleIsContainBloomFilter(<span class="string">"000"</span>, jedis));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//释放redis链接</span></span><br><span class="line">        jedis.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常见应用场景"><a href="#常见应用场景" class="headerlink" title="常见应用场景"></a>常见应用场景</h2><ul><li><p>cerberus在收集监控数据的时候, 有的系统的监控项量会很大, 需要检查一个监控项的名字是否已经被记录到db过了, 如果没有的话就需要写入db.</p></li><li><p>爬虫过滤已抓到的url就不再抓，可用bloom filter过滤</p></li><li><p>垃圾邮件过滤。如果用哈希表，每存储一亿个 email地址，就需要 1.6GB的内存（用哈希表实现的具体办法是将每一个 email地址对应成一个八字节的信息指纹，然后将这些信息指纹存入哈希表，由于哈希表的存储效率一般只有 50%，因此一个 email地址需要占用十六个字节。一亿个地址大约要 1.6GB，即十六亿字节的内存）。因此存贮几十亿个邮件地址可能需要上百 GB的内存。而Bloom Filter只需要哈希表 1/8到 1/4 的大小就能解决同样的问题。</p></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1]  <a href="https://juejin.im/post/5db69365518825645656c0de" target="_blank" rel="noopener">Redis-避免缓存穿透的利器之BloomFilter</a></p><p>[2]  <a href="https://blog.csdn.net/sssbbbryj/article/details/84990589" target="_blank" rel="noopener">Java redis 模拟布隆过滤器</a></p><p>[3]  <a href="https://juejin.im/post/5d9c57485188257377312f0c" target="_blank" rel="noopener">redis-分布式布隆过滤器（Bloom Filter）详解（初版）</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;p&gt;布隆过滤器（英语：Bloom Filter）是1970年由一个叫布隆的小伙子提出的。它实际上是一个很长的二进制向量和一系列随机映射函数。布隆
      
    
    </summary>
    
      <category term="基础知识" scheme="http://yoursite.com/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="Bloom" scheme="http://yoursite.com/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Bloom/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
      <category term="布隆过滤器" scheme="http://yoursite.com/tags/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
    
      <category term="Bloom" scheme="http://yoursite.com/tags/Bloom/"/>
    
  </entry>
  
  <entry>
    <title>Redis过期键处理策略</title>
    <link href="http://yoursite.com/2019/11/22/Redis%E8%BF%87%E6%9C%9F%E9%94%AE%E5%A4%84%E7%90%86%E7%AD%96%E7%95%A5/"/>
    <id>http://yoursite.com/2019/11/22/Redis过期键处理策略/</id>
    <published>2019-11-22T09:44:56.000Z</published>
    <updated>2019-11-22T09:51:04.373Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis-Expire-Key基础"><a href="#Redis-Expire-Key基础" class="headerlink" title="Redis Expire Key基础"></a>Redis Expire Key基础</h2><p>redis数据库在数据库服务器中使用了 <code>redisDb</code> 数据结构，结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span></span><br><span class="line">     dict *dict;            <span class="comment">/* 键空间 key space */</span></span><br><span class="line">     dict *expires;         <span class="comment">/* 过期字典 */</span></span><br><span class="line">     dict *blocking_keys;   <span class="comment">/* Keys with clients waiting for data (BLPOP) */</span></span><br><span class="line">     dict *ready_keys;      <span class="comment">/* Blocked keys that received a PUSH */</span></span><br><span class="line">     dict *watched_keys;    <span class="comment">/* WATCHED keys for MULTI/EXEC CAS */</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">evictionPoolEntry</span> *<span class="title">eviction_pool</span>;</span> <span class="comment">/* Eviction pool of keys */</span></span><br><span class="line">     <span class="keyword">int</span> id;                <span class="comment">/* Database ID */</span></span><br><span class="line">     <span class="keyword">long</span> <span class="keyword">long</span> avg_ttl;     <span class="comment">/* Average TTL, just for stats */</span></span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure><p>其中:</p><ul><li><p><strong>键空间(<code>key space</code>):</strong><br>dict字典用来保存数据库中的所有键值对</p></li><li><p><strong>过期字典(<code>expires</code>):</strong><br>保存数据库中所有键的过期时间，过期时间用UNIX时间戳表示，且值为long long整数</p></li></ul><h3 id="设置过期时间命令"><a href="#设置过期时间命令" class="headerlink" title="设置过期时间命令"></a>设置过期时间命令</h3><ul><li><p><code>EXPIRE &lt;key&gt; &lt;ttl&gt;</code> 命令用于将键key的过期时间设置为ttl秒之后</p></li><li><p><code>PEXPIRE &lt;key&gt; &lt;ttl&gt;</code> 命令用于将键key的过期时间设置为ttl毫秒之后</p></li><li><p><code>EXPIREAT &lt;key&gt; &lt;timesramp&gt;</code> 命令用于将key的过期时间设置为timrestamp所指定的秒数时间戳</p></li><li><p><code>PEXPIREAT &lt;key&gt; &lt;timesramp&gt;</code> 命令用于将key的过期时间设置为timrestamp所指定的毫秒数时间戳</p></li></ul><p>设置过期时间：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; set Ccww   5 2 0  </span><br><span class="line">ok  </span><br><span class="line">redis&gt; expire Ccww 5  </span><br><span class="line">ok</span><br></pre></td></tr></table></figure><p>使用redisDb结构存储数据图表示：</p><p><img src="/images/redis_redisDb.jpg" alt></p><h3 id="过期时间保存以及判定"><a href="#过期时间保存以及判定" class="headerlink" title="过期时间保存以及判定"></a>过期时间保存以及判定</h3><p>过期键的判定，其实通过过期字典进行判定，步骤：</p><ul><li><p>检查给定键是否存在于过期字典，如果存在，取出键的过期时间</p></li><li><p>通过判断当前UNIX时间戳是否大于键的过期时间，是的话，键已过期，相反则键未过期。</p></li></ul><h2 id="过期键删除策略"><a href="#过期键删除策略" class="headerlink" title="过期键删除策略"></a>过期键删除策略</h2><h3 id="定时删除"><a href="#定时删除" class="headerlink" title="定时删除"></a>定时删除</h3><p>在设置键的过期时间的同时，创建一个定时任务，当键达到过期时间时，立即执行对键的删除操作.</p><ul><li><p>优点<br>对内存友好，定时删除策略可以保证过期键会尽可能快地被删除，并释放国期间所占用的内存</p></li><li><p>缺点<br>对cpu时间不友好，在过期键比较多时，删除任务会占用很大一部分cpu时间，在内存不紧张但cpu时间紧张的情况下，将cpu时间用在删除和当前任务无关的过期键上，影响服务器的响应时间和吞吐量</p></li></ul><h3 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h3><p>放任键过期不管，但在每次从键空间获取键时，都检查取得的键是否过期，如果过期的话，就删除该键，如果没有过期，就返回该键</p><ul><li><p>优点<br>对cpu时间友好，在每次从键空间获取键时进行过期键检查并是否删除，删除目标也仅限当前处理的键，这个策略不会在其他无关的删除任务上花费任何cpu时间。</p></li><li><p>缺点<br>对内存不友好，过期键过期也可能不会被删除，导致所占的内存也不会释放。甚至可能会出现内存泄露的现象，当存在很多过期键，而这些过期键又没有被访问到，这会可能导致它们会一直保存在内存中，造成内存泄露。</p></li></ul><h3 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a>定期删除</h3><p>由于定时删除会占用太多cpu时间，影响服务器的响应时间和吞吐量, 而惰性删除浪费太多内存，有内存泄露的危险，所以出现一种整合和折中这两种策略的定期删除策略:</p><blockquote><ol><li><p>定期删除策略每隔一段时间执行一次删除过期键操作，并通过<strong>限制删除操作执行的时长和频率</strong>来减少删除操作对CPU时间的影响;</p></li><li><p>至于要删除多少过期键，以及要检查多少个数据库，则由算法决定；</p></li><li><p>定时删除策略有效地减少了因为过期键带来的内存浪费;</p></li></ol></blockquote><p><strong>定时删除策略难点就是确定删除操作执行的时长和频率：</strong></p><ul><li>删除操作执行得太频繁。或者执行时间太长，定期删除策略就会退化成为定时删除策略，以至于将cpu时间过多地消耗在删除过期键上。  </li><li>相反，则与惰性删除策略一样，出现浪费内存的情况。</li></ul><p>所以使用定期删除策略，需要根据服务器的情况合理地设置删除操作的执行时长和执行频率。</p><h2 id="过期键删除策略实现"><a href="#过期键删除策略实现" class="headerlink" title="过期键删除策略实现"></a>过期键删除策略实现</h2><p>  Redis服务器结合惰性删除和定期删除两种策略一起使用，通过这两种策略之间的配合使用，使得服务器可以在合理使用CPU时间和浪费内存空间取得平衡点。  </p><h3 id="惰性删除策略的实现"><a href="#惰性删除策略的实现" class="headerlink" title="惰性删除策略的实现"></a>惰性删除策略的实现</h3><p>  Redis在执行任何读写命令时都会先找到这个key，惰性删除就作为一个切入点放在查找key之前，如果key过期了就删除这个key。<br>  <img src="/images/redis_key_delete.jpg" alt></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">robj *<span class="title">lookupKeyRead</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123;</span><br><span class="line">          robj *val;</span><br><span class="line"> expireIfNeeded(db,key); <span class="comment">// 切入点</span></span><br><span class="line"> val = lookupKey(db,key);</span><br><span class="line"> <span class="keyword">if</span> (val == <span class="literal">NULL</span>)</span><br><span class="line">  server.stat_keyspace_misses++;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line">  server.stat_keyspace_hits++;</span><br><span class="line"> <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过expireIfNeeded函数对输入键进行检查是否删除:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">expireIfNeeded</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123;</span><br><span class="line">     <span class="comment">/* 取出键的过期时间 */</span></span><br><span class="line">    <span class="keyword">mstime_t</span> when = getExpire(db,key);</span><br><span class="line">    <span class="keyword">mstime_t</span> now;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">/* 没有过期时间返回0*/</span></span><br><span class="line">    <span class="keyword">if</span> (when &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* No expire for this key */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 服务器loading时*/</span></span><br><span class="line">    <span class="keyword">if</span> (server.loading) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 根据一定规则获取当前时间*/</span></span><br><span class="line">    now = server.lua_caller ? server.lua_time_start : mstime();</span><br><span class="line">    <span class="comment">/* 如果当前的是从(Slave)服务器</span></span><br><span class="line"><span class="comment">     * 0 认为key为无效</span></span><br><span class="line"><span class="comment">     * 1 if we think the key is expired at this time. </span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">if</span> (server.masterhost != <span class="literal">NULL</span>) <span class="keyword">return</span> now &gt; when;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* key未过期，返回 0 */</span></span><br><span class="line">    <span class="keyword">if</span> (now &lt;= when) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* 删除键 */</span></span><br><span class="line">    server.stat_expiredkeys++;</span><br><span class="line">    propagateExpire(db,key,server.lazyfree_lazy_expire);</span><br><span class="line">    notifyKeyspaceEvent(NOTIFY_EXPIRED,</span><br><span class="line">        <span class="string">"expired"</span>,key,db-&gt;id);</span><br><span class="line">    <span class="keyword">return</span> server.lazyfree_lazy_expire ? dbAsyncDelete(db,key) :</span><br><span class="line">                                         dbSyncDelete(db,key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="定期删除策略的实现"><a href="#定期删除策略的实现" class="headerlink" title="定期删除策略的实现"></a>定期删除策略的实现</h3><p>  key的定期删除会在Redis的周期性执行任务（<code>serverCron</code>，默认每100ms执行一次）中进行，而且是发生Redis的<code>master</code>节点，因为slave节点会通过主节点的DEL命令同步过来达到删除key的目的。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; dbs_per_call; j++) &#123;</span><br><span class="line"> <span class="keyword">int</span> expired;</span><br><span class="line"> redisDb *db = server.db+(current_db % server.dbnum);</span><br><span class="line"> </span><br><span class="line"> current_db++;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/* 超过25％的key已过期，则继续. */</span></span><br><span class="line"> <span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> num, slots;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> now, ttl_sum;</span><br><span class="line">  <span class="keyword">int</span> ttl_samples;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* 如果该db没有设置过期key，则继续看下个db*/</span></span><br><span class="line">  <span class="keyword">if</span> ((num = dictSize(db-&gt;expires)) == <span class="number">0</span>) &#123;</span><br><span class="line">   db-&gt;avg_ttl = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  slots = dictSlots(db-&gt;expires);</span><br><span class="line">  now = mstime();</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/*但少于1%时，需要调整字典大小*/</span></span><br><span class="line">  <span class="keyword">if</span> (num &amp;&amp; slots &gt; DICT_HT_INITIAL_SIZE &amp;&amp;</span><br><span class="line">   (num*<span class="number">100</span>/slots &lt; <span class="number">1</span>)) <span class="keyword">break</span>;</span><br><span class="line"> </span><br><span class="line">  expired = <span class="number">0</span>;</span><br><span class="line">  ttl_sum = <span class="number">0</span>;</span><br><span class="line">  ttl_samples = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (num &gt; ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP)</span><br><span class="line">   num = ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP;<span class="comment">// 20</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">while</span> (num--) &#123;</span><br><span class="line">   dictEntry *de;</span><br><span class="line">   <span class="keyword">long</span> <span class="keyword">long</span> ttl;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">if</span> ((de = dictGetRandomKey(db-&gt;expires)) == <span class="literal">NULL</span>) <span class="keyword">break</span>;</span><br><span class="line">   ttl = dictGetSignedIntegerVal(de)-now;</span><br><span class="line">   <span class="keyword">if</span> (activeExpireCycleTryExpire(db,de,now)) expired++;</span><br><span class="line">   <span class="keyword">if</span> (ttl &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/* We want the average TTL of keys yet not expired. */</span></span><br><span class="line">    ttl_sum += ttl;</span><br><span class="line">    ttl_samples++;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Update the average TTL stats for this database. */</span></span><br><span class="line">  <span class="keyword">if</span> (ttl_samples) &#123;</span><br><span class="line">   <span class="keyword">long</span> <span class="keyword">long</span> avg_ttl = ttl_sum/ttl_samples;</span><br><span class="line"> </span><br><span class="line">   /样本获取移动平均值 */</span><br><span class="line">   <span class="keyword">if</span> (db-&gt;avg_ttl == <span class="number">0</span>) db-&gt;avg_ttl = avg_ttl;</span><br><span class="line">   db-&gt;avg_ttl = (db-&gt;avg_ttl/<span class="number">50</span>)*<span class="number">49</span> + (avg_ttl/<span class="number">50</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  iteration++;</span><br><span class="line">  <span class="keyword">if</span> ((iteration &amp; <span class="number">0xf</span>) == <span class="number">0</span>) &#123; <span class="comment">/* 每迭代16次检查一次 */</span></span><br><span class="line">   <span class="keyword">long</span> <span class="keyword">long</span> elapsed = ustime()-start;</span><br><span class="line"> </span><br><span class="line">   latencyAddSampleIfNeeded(<span class="string">"expire-cycle"</span>,elapsed/<span class="number">1000</span>);</span><br><span class="line">   <span class="keyword">if</span> (elapsed &gt; timelimit) timelimit_exit = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="comment">/* 超过时间限制则退出*/</span></span><br><span class="line">  <span class="keyword">if</span> (timelimit_exit) <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">/* 在当前db中，如果少于25%的key过期，则停止继续删除过期key */</span></span><br><span class="line"> &#125; <span class="keyword">while</span> (expired &gt; ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP/<span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color="red"><strong>依次遍历每个db（默认配置数是16），针对每个db，每次循环随机选择20个（ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP）key判断是否过期，如果一轮所选的key少于25%过期，则终止迭代</strong></font>，此外<strong>在迭代过程中如果超过了一定的时间限制</strong>则终止过期删除这一过程。</p><h2 id="Redis采用的过期策略"><a href="#Redis采用的过期策略" class="headerlink" title="Redis采用的过期策略"></a>Redis采用的过期策略</h2><p>redis 过期策略是：定期删除 + 惰性删除</p><p>假设 redis 里放了 10w 个 key，都设置了过期时间，你每隔几百毫秒，就检查 10w 个 key，那 redis 基本上就死了，cpu 负载会很高的，消耗在你的检查过期 key 上了。所以，这里可不是每隔 100ms 就遍历所有的设置过期时间的 key，那样就是一场性能上的灾难。<strong>实际上 redis 是每隔 100ms 随机抽取一些 key 来检查和删除的</strong>。</p><p>但是问题是，定期删除可能会导致很多过期 key 到了时间并没有被删除掉，那咋整呢？所以就需要结合<strong>惰性删除</strong>。</p><p>但是实际上这还是有问题的，如果定期删除漏掉了很多过期 key，然后你也没及时去查，也就没走惰性删除，此时会怎么样？如果大量过期 key 堆积在内存里，导致 redis 内存块耗尽了，咋整？</p><p>答案是：<strong>走内存淘汰机制</strong></p><h3 id="内存淘汰机制"><a href="#内存淘汰机制" class="headerlink" title="内存淘汰机制"></a>内存淘汰机制</h3><p>redis 内存淘汰机制有以下几个：</p><ul><li><p><strong>noeviction</strong>   当内存不足以容纳新写入数据时，新写入操作会报错，这个一般没人用吧，实在是太恶心了</p></li><li><p><strong>allkeys-lru</strong>  当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）；</p></li><li><p><strong>allkeys-random</strong>  当内存不足以容纳新写入数据时，在键空间中，随机移除某个 key，这个一般没人用吧，为啥要随机，肯定是把最近最少使用的 key 给干掉啊；</p></li><li><p><strong>volatile-lru</strong> 当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的 key（这个一般不太合适）；</p></li><li><p><strong>volatile-random</strong> 当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key；</p></li><li><p><strong>volatile-ttl</strong>  当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的 key 优先移除；</p></li></ul><p><strong>设置方式：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config set maxmemory-policy volatile-lru</span><br></pre></td></tr></table></figure><h2 id="AOF、RDB和复制功能对过期键的处理"><a href="#AOF、RDB和复制功能对过期键的处理" class="headerlink" title="AOF、RDB和复制功能对过期键的处理"></a>AOF、RDB和复制功能对过期键的处理</h2><h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><ul><li><p><strong>生成RDB文件</strong><br>程序会数据库中的键进行检查，已过期的键不会保存到新创建的RDB文件中</p></li><li><p><strong>载入RDB文件</strong></p><ul><li>主服务载入RDB文件，会对文件中保存的键进行检查会忽略过期键加载未过期键</li><li>从服务器载入RDB文件，会加载文件所保存的所有键（过期和未过期的），但从主服务器同步数据同时会清空从服务器的数据库。</li></ul></li></ul><h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><ul><li><p><strong>AOF文件写入</strong><br>当过期键被删除后，会在AOF文件增加一条DEL命令，来显式地记录该键已被删除。</p></li><li><p><strong>AOF重写</strong><br>已过期的键不会保存到重写的AOF文件中</p></li></ul><h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><p> 当服务器运行在复制模式下时，<strong>从服务器的过期键删除动作由主服务器控制的</strong>，这样的好处主要为了保持主从服务器数据一致性：</p><ul><li><p>主服务器在删除一个过期键之后，会显式地向所有的从服务器发送一个DEL命令，告知从服务器删除这个过期键；</p></li><li><p>从服务器在执行客户端发送的读取命令时，即使碰到过期键也不会将过期键删除，不作任何处理。<strong>只有接收到主服务器 DEL命令后，从服务器进行删除处理</strong>。</p></li></ul><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p>[1] <a href="https://juejin.im/post/5da7144ff265da5ba532b753?utm_source=gold_browser_extension" target="_blank" rel="noopener">当遇到美女面试官之如何理解Redis的Expire Key(过期键)</a></p><p>[2] <a href="https://juejin.im/post/5d8bf523e51d4577ff0d9e8c" target="_blank" rel="noopener">Redis的过期策略及内存淘汰机制</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Redis-Expire-Key基础&quot;&gt;&lt;a href=&quot;#Redis-Expire-Key基础&quot; class=&quot;headerlink&quot; title=&quot;Redis Expire Key基础&quot;&gt;&lt;/a&gt;Redis Expire Key基础&lt;/h2&gt;&lt;p&gt;redis数
      
    
    </summary>
    
      <category term="中间件" scheme="http://yoursite.com/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
      <category term="Redis" scheme="http://yoursite.com/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="入门" scheme="http://yoursite.com/tags/%E5%85%A5%E9%97%A8/"/>
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Netty性能优化</title>
    <link href="http://yoursite.com/2019/11/20/Netty%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2019/11/20/Netty性能优化/</id>
    <published>2019-11-20T12:12:30.000Z</published>
    <updated>2019-11-20T12:17:03.884Z</updated>
    
    <content type="html"><![CDATA[<h2 id="共享Handler"><a href="#共享Handler" class="headerlink" title="共享Handler"></a>共享Handler</h2><p>代码：<a href="https://github.com/austin-brant/netty-im" target="_blank" rel="noopener">https://github.com/austin-brant/netty-im</a></p><p>在使用 Netty 完成了一个 IM 系统的核心功能之后，我们再来仔细看一下服务端</p><blockquote><p>NettyServer.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">serverBootstrap</span><br><span class="line">.childHandler(<span class="keyword">new</span> ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(NioSocketChannel ch)</span> </span>&#123;</span><br><span class="line">        ch.pipeline().addLast(<span class="keyword">new</span> Spliter());</span><br><span class="line">        ch.pipeline().addLast(<span class="keyword">new</span> PacketDecoder());</span><br><span class="line">        ch.pipeline().addLast(<span class="keyword">new</span> LoginRequestHandler());</span><br><span class="line">        ch.pipeline().addLast(<span class="keyword">new</span> AuthHandler());</span><br><span class="line">        ch.pipeline().addLast(<span class="keyword">new</span> MessageRequestHandler());</span><br><span class="line">        ch.pipeline().addLast(<span class="keyword">new</span> CreateGroupRequestHandler());</span><br><span class="line">        ch.pipeline().addLast(<span class="keyword">new</span> JoinGroupRequestHandler());</span><br><span class="line">        ch.pipeline().addLast(<span class="keyword">new</span> QuitGroupRequestHandler());</span><br><span class="line">        ch.pipeline().addLast(<span class="keyword">new</span> ListGroupMembersRequestHandler());</span><br><span class="line">        ch.pipeline().addLast(<span class="keyword">new</span> GroupMessageRequestHandler());</span><br><span class="line">        ch.pipeline().addLast(<span class="keyword">new</span> LogoutRequestHandler());</span><br><span class="line">        ch.pipeline().addLast(<span class="keyword">new</span> PacketEncoder());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol><li><p>我们看到，服务端的 pipeline 链里面已经有 12 个 handler，其中，与指令相关的 handler 有 9 个。</p></li><li><p>Netty 在这里的逻辑是：<strong>每次有新连接到来的时候，都会调用 ChannelInitializer 的 initChannel() 方法，然后这里 9 个指令相关的 handler 都会被 new 一次</strong>。</p></li><li><p>其实这里的每一个指令 handler，他们内部都是没有成员变量的，也就是说是无状态的，我们完全可以使用单例模式，即调用 pipeline().addLast() 方法的时候，都直接使用单例，不需要每次都 new，提高效率，也避免了创建很多小的对象。</p></li></ol><p>比如，我们拿 LoginRequestHandler 举例，来看一下如何改造</p><blockquote><p>LoginRequestHandler.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 加上注解标识，表明该 handler 是可以多个 channel 共享的</span></span><br><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginRequestHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">LoginRequestPacket</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 构造单例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> LoginRequestHandler INSTANCE = <span class="keyword">new</span> LoginRequestHandler();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">LoginRequestHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>首先，非常重要的一点，如果一个 handler 要被多个 channel 进行共享，必须要加上 <strong><code>@ChannelHandler.Sharable</code></strong> 显示地告诉 Netty，这个 handler 是支持多个 channel 共享的，否则会报错，读者可以自行尝试一下。</p></li><li><p>然后，我们仿照 Netty 源码里面单例模式的写法，构造一个单例模式的类。</p></li></ol><p>接着，我们在服务端的代理里面就可以这么写</p><blockquote><p>NettyServer.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">serverBootstrap</span><br><span class="line">        .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(NioSocketChannel ch)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// ...单例模式，多个 channel 共享同一个 handler</span></span><br><span class="line">                ch.pipeline().addLast(LoginRequestHandler.INSTANCE);</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p>这样的话，每来一次新的连接，添加 handler 的时候就不需要每次都 new 了。</p><h2 id="压缩-handler-合并编解码器"><a href="#压缩-handler-合并编解码器" class="headerlink" title="压缩 handler - 合并编解码器"></a>压缩 handler - 合并编解码器</h2><p>当我们改造完了之后，我们再来看一下服务端代码</p><blockquote><p>NettyServer.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">serverBootstrap</span><br><span class="line">        .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(NioSocketChannel ch)</span> </span>&#123;</span><br><span class="line">                ch.pipeline().addLast(<span class="keyword">new</span> Spliter());</span><br><span class="line">                ch.pipeline().addLast(<span class="keyword">new</span> PacketDecoder());</span><br><span class="line">                ch.pipeline().addLast(LoginRequestHandler.INSTANCE);</span><br><span class="line">                ch.pipeline().addLast(AuthHandler.INSTANCE);</span><br><span class="line">                ch.pipeline().addLast(MessageRequestHandler.INSTANCE);</span><br><span class="line">                ch.pipeline().addLast(CreateGroupRequestHandler.INSTANCE);</span><br><span class="line">                ch.pipeline().addLast(JoinGroupRequestHandler.INSTANCE);</span><br><span class="line">                ch.pipeline().addLast(QuitGroupRequestHandler.INSTANCE);</span><br><span class="line">                ch.pipeline().addLast(ListGroupMembersRequestHandler.INSTANCE);</span><br><span class="line">                ch.pipeline().addLast(GroupMessageRequestHandler.INSTANCE);</span><br><span class="line">                ch.pipeline().addLast(LogoutRequestHandler.INSTANCE);</span><br><span class="line">                ch.pipeline().addLast(<span class="keyword">new</span> PacketEncoder());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p>pipeline 中第一个 handler - <code>Spliter</code>，我们是无法改动它的，因为他<strong>内部实现是与每个 channel 有关，每个 Spliter 需要维持每个 channel 当前读到的数据，也就是说他是有状态的</strong>。 而 PacketDecoder 与 PacketEncoder 我们是可以继续改造的，Netty 内部提供了一个类，叫做 <code>MessageToMessageCodec</code>，使用它可以让我们的编解码操作放到一个类里面去实现，首先我们定义一个 PacketCodecHandler:</p><blockquote><p>PacketCodecHandler.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PacketCodecHandler</span> <span class="keyword">extends</span> <span class="title">MessageToMessageCodec</span>&lt;<span class="title">ByteBuf</span>, <span class="title">Packet</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> PacketCodecHandler INSTANCE = <span class="keyword">new</span> PacketCodecHandler();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">PacketCodecHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf byteBuf, List&lt;Object&gt; out)</span> </span>&#123;</span><br><span class="line">        out.add(PacketCodec.INSTANCE.decode(byteBuf));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext ctx, Packet packet, List&lt;Object&gt; out)</span> </span>&#123;</span><br><span class="line">        ByteBuf byteBuf = ctx.channel().alloc().ioBuffer();</span><br><span class="line">        PacketCodec.INSTANCE.encode(byteBuf, packet);</span><br><span class="line">        out.add(byteBuf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>首先，这里 PacketCodecHandler，他是一个无状态的 handler，因此，同样可以使用单例模式来实现。</p></li><li><p>需要实现 decode() 和 encode() 方法，decode 是将二进制数据 ByteBuf 转换为 java 对象 Packet，而 encode 操作是一个相反的过程，在 encode() 方法里面，我们调用了 channel 的 内存分配器手工分配了 ByteBuf。</p></li></ol><p>接着，PacketDecoder 和 PacketEncoder都可以删掉，我们的 server 端代码就成了如下的样子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">serverBootstrap</span><br><span class="line">        .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(NioSocketChannel ch)</span> </span>&#123;</span><br><span class="line">                ch.pipeline().addLast(<span class="keyword">new</span> Spliter());</span><br><span class="line">                ch.pipeline().addLast(PacketCodecHandler.INSTANCE);</span><br><span class="line">                ch.pipeline().addLast(LoginRequestHandler.INSTANCE);</span><br><span class="line">                ch.pipeline().addLast(AuthHandler.INSTANCE);</span><br><span class="line">                ch.pipeline().addLast(MessageRequestHandler.INSTANCE);</span><br><span class="line">                ch.pipeline().addLast(CreateGroupRequestHandler.INSTANCE);</span><br><span class="line">                ch.pipeline().addLast(JoinGroupRequestHandler.INSTANCE);</span><br><span class="line">                ch.pipeline().addLast(QuitGroupRequestHandler.INSTANCE);</span><br><span class="line">                ch.pipeline().addLast(ListGroupMembersRequestHandler.INSTANCE);</span><br><span class="line">                ch.pipeline().addLast(GroupMessageRequestHandler.INSTANCE);</span><br><span class="line">                ch.pipeline().addLast(LogoutRequestHandler.INSTANCE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p>可以看到，除了拆包器，所有的 handler 都写成了单例，当然，如果你的 handler 里有与 channel 相关成员变量，那就不要写成单例的，不过，<font color="red"><strong>其实所有的状态都可以绑定在 channel 的属性上，依然是可以改造成单例模式</strong>。</font></p><h2 id="缩短事件传播路径"><a href="#缩短事件传播路径" class="headerlink" title="缩短事件传播路径"></a>缩短事件传播路径</h2><p>如果我们再仔细观察我们的服务端代码，发现，我们的 pipeline 链中，绝大部分都是与指令相关的 handler，我们把这些 handler 编排在一起，是为了逻辑简洁，但是随着指令相关的 handler 越来越多，handler 链越来越长，在事件传播过程中性能损耗会被逐渐放大，因为解码器解出来的每个 Packet 对象都要在每个 handler 上经过一遍，我们接下来来看一下如何缩短这个事件传播的路径。</p><h2 id="压缩handler-合并平行handler"><a href="#压缩handler-合并平行handler" class="headerlink" title="压缩handler - 合并平行handler"></a>压缩handler - 合并平行handler</h2><p>对我们这个应用程序来说，每次 decode 出来一个指令对象之后，其实只会在一个指令 handler 上进行处理，因此，我们其实可以把这么多的指令 handler 压缩为一个 handler，我们来看一下如何实现</p><p>我们定义一个 IMHandler，实现如下：</p><blockquote><p>IMHandler.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IMHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">Packet</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> IMHandler INSTANCE = <span class="keyword">new</span> IMHandler();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Byte, SimpleChannelInboundHandler&lt;? extends Packet&gt;&gt; handlerMap;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">IMHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        handlerMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        handlerMap.put(MESSAGE_REQUEST, MessageRequestHandler.INSTANCE);</span><br><span class="line">        handlerMap.put(CREATE_GROUP_REQUEST, CreateGroupRequestHandler.INSTANCE);</span><br><span class="line">        handlerMap.put(JOIN_GROUP_REQUEST, JoinGroupRequestHandler.INSTANCE);</span><br><span class="line">        handlerMap.put(QUIT_GROUP_REQUEST, QuitGroupRequestHandler.INSTANCE);</span><br><span class="line">        handlerMap.put(LIST_GROUP_MEMBERS_REQUEST, ListGroupMembersRequestHandler.INSTANCE);</span><br><span class="line">        handlerMap.put(GROUP_MESSAGE_REQUEST, GroupMessageRequestHandler.INSTANCE);</span><br><span class="line">        handlerMap.put(LOGOUT_REQUEST, LogoutRequestHandler.INSTANCE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, Packet packet)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        handlerMap.get(packet.getCommand()).channelRead(ctx, packet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>首先，IMHandler 是无状态的，依然是可以写成一个单例模式的类。</li><li>我们定义一个 map，存放指令到各个指令处理器的映射。</li><li><strong>每次回调到 IMHandler 的 <code>channelRead0()</code> 方法的时候，我们通过指令找到具体的 handler，然后调用指令 handler 的 <code>channelRead</code>，他内部会做指令类型转换，最终调用到每个指令 handler 的 <code>channelRead0()</code> 方法。</strong></li></ol><p>接下来，我们来看一下，如此压缩之后，我们的服务端代码</p><blockquote><p>NettyServer.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">serverBootstrap</span><br><span class="line">        .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(NioSocketChannel ch)</span> </span>&#123;</span><br><span class="line">                ch.pipeline().addLast(<span class="keyword">new</span> Spliter());</span><br><span class="line">                ch.pipeline().addLast(PacketCodecHandler.INSTANCE);</span><br><span class="line">                ch.pipeline().addLast(LoginRequestHandler.INSTANCE);</span><br><span class="line">                ch.pipeline().addLast(AuthHandler.INSTANCE);</span><br><span class="line">                ch.pipeline().addLast(IMHandler.INSTANCE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p>可以看到，现在，我们服务端的代码已经变得很清爽了，所有的平行指令处理 handler，我们都压缩到了一个 <code>IMHandler</code>，并且 <code>IMHandler</code> 和指令 handler 均为单例模式，在单机十几万甚至几十万的连接情况下，性能能得到一定程度的提升，创建的对象也大大减少了。</p><p>当然，如果你对性能要求没这么高，大可不必搞得这么复杂，还是按照我们前面小节的方式来实现即可，比如，我们的客户端多数情况下是单连接的，其实并不需要搞得如此复杂，还是保持原样即可。</p><h3 id="更改事件传播源"><a href="#更改事件传播源" class="headerlink" title="更改事件传播源"></a>更改事件传播源</h3><p>另外，关于缩短事件传播路径，除了压缩 handler，还有一个就是，如果你的 <code>outBound</code> 类型的 handler 较多，在写数据的时候能用 <code>ctx.writeAndFlush()</code> 就用这个方法。</p><blockquote><p>ctx.writeAndFlush() 事件传播路径</p></blockquote><p><code>ctx.writeAndFlush()</code> 是从 pipeline 链中的 <strong>当前节点开始往前找到第一个 outBound 类型的 handler 把对象往前进行传播</strong>，如果这个对象确认不需要经过其他 outBound 类型的 handler 处理，就使用这个方法。</p><p><img src="/images/netty_broadcast.png" alt></p><p>如上图，在某个 <code>inBound</code> 类型的 handler 处理完逻辑之后，调用 <code>ctx.writeAndFlush()</code> 可以直接一口气把对象送到 codec 中编码，然后写出去。</p><blockquote><p>ctx.channel().writeAndFlush() 事件传播路径</p></blockquote><p><code>ctx.channel().writeAndFlush()</code> 是 <font color="red"><strong>从<code>pipeline</code>链中的最后一个<code>outBound</code>类型的 <code>handler</code>开始，把对象往前进行传播</strong></font>，如果你确认当前创建的对象需要经过后面的 outBound 类型的 handler，那么就调用此方法。</p><p><img src="/images/netty_broadcast_writeflush.png" alt></p><p>如上图，在某个 <code>inBound</code> 类型的 handler 处理完逻辑之后，调用 <code>ctx.channel().writeAndFlush()</code>，对象会从最后一个 outBound 类型的 handler 开始，逐个往前进行传播，路径是要比 <code>ctx.writeAndFlush()</code> 要长的。</p><p>由此可见，在我们的应用程序中，当我们没有改造编解码之前，我们必须调用 <code>ctx.channel().writeAndFlush()</code>, 而经过改造之后，我们的编码器（既属于 inBound, 又属于 outBound 类型的 handler）已处于 pipeline 的最前面，因此，可以大胆使用 <code>ctx.writeAndFlush()</code>。</p><h2 id="减少阻塞主线程的操作"><a href="#减少阻塞主线程的操作" class="headerlink" title="减少阻塞主线程的操作"></a>减少阻塞主线程的操作</h2><p>通常我们的应用程序会涉及到数据库或者网络，比如以下这个例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, T packet)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. balabala 一些逻辑</span></span><br><span class="line">    <span class="comment">// 2. 数据库或者网络等一些耗时的操作</span></span><br><span class="line">    <span class="comment">// 3. writeAndFlush()</span></span><br><span class="line">    <span class="comment">// 4. balabala 其他的逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到，在 <code>channelRead0()</code> 这个方法里面，第二个过程中，我们有一些耗时的操作，这个时候，我们万万不能将这个操作直接就在这个方法中处理了，为什么？</p><p>默认情况下，Netty 在启动的时候会开启 <font color="red"><strong>2 倍的 cpu 核数个 NIO 线程</strong></font>，而通常情况下我们单机会有几万或者十几万的连接，因此，一条 NIO 线程会管理着几千或几万个连接，在传播事件的过程中，单条 NIO 线程的处理逻辑可以抽象成以下一个步骤，我们就拿 <code>channelRead0()</code> 举例</p><blockquote><p>单个 NIO 线程执行的抽象逻辑</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Channel&gt; channelList = 已有数据可读的 channel</span><br><span class="line"><span class="keyword">for</span> (Channel channel in channelist) &#123;</span><br><span class="line">   <span class="keyword">for</span> (ChannelHandler handler in channel.pipeline()) &#123;</span><br><span class="line">       handler.channelRead0();</span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的抽象逻辑中可以看到，其中<strong>只要有一个 channel 的一个 handler 中的 channelRead0() 方法阻塞了 NIO 线程，最终都会拖慢绑定在该 NIO 线程上的其他所有的 channel</strong>，当然，这里抽象的逻辑已经做了简化，想了解细节可以参考我关于 Netty 中 NIO 线程（即 reactor 线程）文章的分析， <a href="https://www.jianshu.com/p/0d0eece6d467" target="_blank" rel="noopener">「netty 源码分析之揭开 reactor 线程的面纱（一）」</a>， <a href="https://www.jianshu.com/p/467a9b41833e" target="_blank" rel="noopener">「netty 源码分析之揭开 reactor 线程的面纱（二）」</a>， <a href="https://www.jianshu.com/p/58fad8e42379" target="_blank" rel="noopener">「netty 源码分析之揭开 reactor 线程的面纱（三）」</a>。</p><p>而我们需要怎么做？对于耗时的操作，我们需要把这些耗时的操作丢到我们的业务线程池中去处理，下面是解决方案的伪代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ThreadPool threadPool = xxx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, T packet)</span> </span>&#123;</span><br><span class="line">    threadPool.submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="comment">// 1. balabala 一些逻辑</span></span><br><span class="line">        <span class="comment">// 2. 数据库或者网络等一些耗时的操作</span></span><br><span class="line">        <span class="comment">// 3. writeAndFlush()</span></span><br><span class="line">        <span class="comment">// 4. balabala 其他的逻辑</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，就可以避免一些耗时的操作影响 Netty 的 NIO 线程，从而影响其他的 channel。</p><h2 id="如何准确统计处理时长"><a href="#如何准确统计处理时长" class="headerlink" title="如何准确统计处理时长"></a>如何准确统计处理时长</h2><p>通常，应用程序都有统计某个操作响应时间的需求，比如，基于我们上面的栗子，我们会这么做</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, T packet)</span> </span>&#123;</span><br><span class="line">    threadPool.submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 1. balabala 一些逻辑</span></span><br><span class="line">        <span class="comment">// 2. 数据库或者网络等一些耗时的操作</span></span><br><span class="line">        <span class="comment">// 3. writeAndFlush()</span></span><br><span class="line">        <span class="comment">// 4. balabala 其他的逻辑</span></span><br><span class="line">        <span class="keyword">long</span> time =  System.currentTimeMillis() - begin;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种做法其实是不推荐的，为什么？</p><p>因为 writeAndFlush() 这个方法如果在非NIO线程（这里，我们其实是在业务线程中调用了该方法）中执行，它是一个异步的操作，调用之后，其实是会立即返回的，剩下的所有的操作，都是 Netty 内部有一个任务队列异步执行的，想了解底层细节的可以阅读一下我的这篇文章 <a href="https://www.jianshu.com/p/feaeaab2ce56" target="_blank" rel="noopener">「netty 源码分析之 writeAndFlush 全解析」</a>. 因此，这里的 writeAndFlush() 执行完毕之后，并不能代表相关的逻辑，比如事件传播、编码等逻辑执行完毕，只是表示 Netty 接收了这个任务，那么如何才能判断 writeAndFlush() 执行完毕呢？我们可以这么做</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, T packet)</span> </span>&#123;</span><br><span class="line">    threadPool.submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 1. balabala 一些逻辑</span></span><br><span class="line">        <span class="comment">// 2. 数据库或者网络等一些耗时的操作</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. writeAndFlush</span></span><br><span class="line">        xxx.writeAndFlush().addListener(future -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (future.isDone()) &#123;</span><br><span class="line">                <span class="comment">// 4. balabala 其他的逻辑</span></span><br><span class="line">                <span class="keyword">long</span> time =  System.currentTimeMillis() - begin;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>writeAndFlush()</code> 方法会返回一个 <code>ChannelFuture</code> 对象，我们给这个对象添加一个监听器，然后在回调方法里面，我们可以监听这个方法执行的结果，进而再执行其他逻辑，最后统计耗时，这样统计出来的耗时才是最准确的。</p><p>最后，需要提出的一点就是，Netty 里面很多方法都是异步的操作，在业务线程中如果要统计这部分操作的时间，都需要使用监听器回调的方式来统计耗时，如果在 NIO 线程中调用，就不需要这么干。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>摘自：<a href="https://juejin.im/book/5b4bc28bf265da0f60130116" target="_blank" rel="noopener">Netty 入门与实战：仿写微信 IM 即时通讯系统</a></p><p>参考文章：<br>[1] <a href="https://www.jianshu.com/p/0d0eece6d467" target="_blank" rel="noopener">netty 源码分析之揭开 reactor 线程的面纱（一）</a><br>[2] <a href="https://www.jianshu.com/p/467a9b41833e" target="_blank" rel="noopener">netty 源码分析之揭开 reactor 线程的面纱（二）</a><br>[3] <a href="https://www.jianshu.com/p/58fad8e42379" target="_blank" rel="noopener">netty 源码分析之揭开 reactor 线程的面纱（三）</a><br>[4] <a href="https://www.jianshu.com/p/feaeaab2ce56" target="_blank" rel="noopener">netty 源码分析之 writeAndFlush 全解析</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;共享Handler&quot;&gt;&lt;a href=&quot;#共享Handler&quot; class=&quot;headerlink&quot; title=&quot;共享Handler&quot;&gt;&lt;/a&gt;共享Handler&lt;/h2&gt;&lt;p&gt;代码：&lt;a href=&quot;https://github.com/austin-bran
      
    
    </summary>
    
      <category term="Netty" scheme="http://yoursite.com/categories/Netty/"/>
    
      <category term="基础" scheme="http://yoursite.com/categories/Netty/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Netty" scheme="http://yoursite.com/tags/Netty/"/>
    
      <category term="网络IO" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9CIO/"/>
    
  </entry>
  
  <entry>
    <title>Netty心跳与空闲检测</title>
    <link href="http://yoursite.com/2019/11/15/Netty%E5%BF%83%E8%B7%B3%E4%B8%8E%E7%A9%BA%E9%97%B2%E6%A3%80%E6%B5%8B/"/>
    <id>http://yoursite.com/2019/11/15/Netty心跳与空闲检测/</id>
    <published>2019-11-15T12:08:56.000Z</published>
    <updated>2019-11-20T12:20:20.579Z</updated>
    
    <content type="html"><![CDATA[<p>代码：<a href="https://github.com/austin-brant/netty-im" target="_blank" rel="noopener">https://github.com/austin-brant/netty-im</a></p><h2 id="网络问题"><a href="#网络问题" class="headerlink" title="网络问题"></a>网络问题</h2><p>下图是网络应用程序普遍会遇到的一个问题：连接假死<br><img src="/images/netty_jiasi.jpg" alt></p><p>连接假死的现象是：</p><blockquote><p>在某一端（服务端或者客户端）看来，底层的 TCP 连接已经断开了，但是应用程序并没有捕获到，因此会认为这条连接仍然是存在的，从 TCP 层面来说，只有收到四次握手数据包或者一个 RST 数据包，连接的状态才表示已断开。</p></blockquote><p>连接假死会带来以下两大问题:</p><ul><li><p>对于服务端来说，因为每条连接都会耗费 cpu 和内存资源，大量假死的连接会逐渐耗光服务器的资源，最终导致性能逐渐下降，程序奔溃。</p></li><li><p>对于客户端来说，连接假死会造成发送数据超时，影响用户体验。</p></li></ul><p>通常，连接假死由以下几个原因造成的</p><ul><li><p>应用程序出现线程堵塞，无法进行数据的读写。</p></li><li><p>客户端或者服务端网络相关的设备出现故障，比如网卡，机房故障。</p></li><li><p>公网丢包。公网环境相对内网而言，非常容易出现丢包，网络抖动等现象，如果在一段时间内用户接入的网络连续出现丢包现象，那么对客户端来说数据一直发送不出去，而服务端也是一直收不到客户端来的数据，连接就一直耗着。</p></li></ul><p>如果我们的应用是面向用户的，那么公网丢包这个问题出现的概率是非常大的。对于内网来说，内网丢包，抖动也是会有一定的概率发生。一旦出现此类问题，客户端和服务端都会受到影响，接下来，我们分别从服务端和客户端的角度来解决连接假死的问题。</p><h2 id="服务端空闲检测"><a href="#服务端空闲检测" class="headerlink" title="服务端空闲检测"></a>服务端空闲检测</h2><p>对于服务端来说，客户端的连接如果出现假死，那么服务端将无法收到客户端的数据，也就是说，如果能一直收到客户端发来的数据，那么可以说明这条连接还是活的，因此，服务端对于连接假死的应对策略就是空闲检测。</p><p>何为空闲检测？</p><blockquote><p>空闲检测指的是每隔一段时间，检测这段时间内是否有数据读写，简化一下，我们的服务端只需要检测一段时间内，是否收到过客户端发来的数据即可，Netty 自带的 IdleStateHandler 就可以实现这个功能。</p></blockquote><p>接下来，我们写一个类继承自 IdleStateHandler，来定义检测到假死连接之后的逻辑。</p><blockquote><p>IMIdleStateHandler.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IMIdleStateHandler</span> <span class="keyword">extends</span> <span class="title">IdleStateHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> READER_IDLE_TIME = <span class="number">15</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IMIdleStateHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(READER_IDLE_TIME, <span class="number">0</span>, <span class="number">0</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelIdle</span><span class="params">(ChannelHandlerContext ctx, IdleStateEvent evt)</span> </span>&#123;</span><br><span class="line">        System.out.println(READER_IDLE_TIME + <span class="string">"秒内未读到数据，关闭连接"</span>);</span><br><span class="line">        ctx.channel().close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>首先，我们观察一下 <code>IMIdleStateHandler</code> 的构造函数，他调用父类 <code>IdleStateHandler</code>的构造函数，有四个参数，其中:</p><ul><li><p>第一个表示读空闲时间，指的是在这段时间内如果没有数据读到，就表示连接假死；</p></li><li><p>第二个是写空闲时间，指的是 在这段时间如果没有写数据，就表示连接假死；</p></li><li><p>第三个参数是读写空闲时间，表示在这段时间内如果没有产生数据读或者写，就表示连接假死。写空闲和读写空闲为0，表示我们不关心者两类条件；</p></li><li><p>最后一个参数表示时间单位。在我们的例子中，表示的是：如果 15 秒内没有读到数据，就表示连接假死。</p></li></ul></li><li><p>连接假死之后会回调 <code>channelIdle()</code> 方法，我们这个方法里面打印消息，并手动关闭连接。</p></li></ol><p>接下来，我们把这个 handler 插入到服务端 pipeline 的最前面</p><blockquote><p>NettyServer.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">serverBootstrap</span><br><span class="line">        .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(NioSocketChannel ch)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 空闲检测</span></span><br><span class="line">                ch.pipeline().addLast(<span class="keyword">new</span> IMIdleStateHandler());</span><br><span class="line">                ch.pipeline().addLast(<span class="keyword">new</span> Spliter());</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p>为什么要插入到最前面？</p><blockquote><p>因为如果插入到最后面的话，如果这条连接读到了数据，但是在 <code>inBound</code> 传播的过程中出错了或者数据处理完完毕就不往后传递了（我们的应用程序属于这类），那么最终 <code>IMIdleStateHandler</code> 就不会读到数据，最终导致误判。</p></blockquote><p>服务端的空闲检测时间完毕之后，接下来我们再思考一下，在一段时间之内没有读到客户端的数据，是否一定能判断连接假死呢？并不能，如果在这段时间之内客户端确实是没有发送数据过来，但是连接是 ok 的，那么这个时候服务端也是不能关闭这条连接的，为了防止服务端误判，我们还需要在客户端做点什么。</p><h2 id="客户端定时发送心跳"><a href="#客户端定时发送心跳" class="headerlink" title="客户端定时发送心跳"></a>客户端定时发送心跳</h2><p>服务端在一段时间内没有收到客户端的数据，这个现象产生的原因可以分为以下两种：</p><ul><li>连接假死。</li><li>非假死状态下确实没有发送数据。</li></ul><p>我们只需要排除掉第二种可能性，那么连接自然就是假死的。要排查第二种情况，我们可以在客户端定期发送数据到服务端，通常这个数据包称为心跳数据包，接下来，我们定义一个 handler，定期发送心跳给服务端</p><blockquote><p>HeartBeatTimerHandler.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeartBeatTimerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HEARTBEAT_INTERVAL = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        scheduleSendHeartBeat(ctx);</span><br><span class="line">        <span class="keyword">super</span>.channelActive(ctx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scheduleSendHeartBeat</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">        ctx.executor().scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (ctx.channel().isActive()) &#123;</span><br><span class="line">                System.out.println(<span class="string">"发送心跳信息 : "</span> + <span class="keyword">new</span> Date());</span><br><span class="line">                ctx.writeAndFlush(<span class="keyword">new</span> HeartBeatRequestPacket());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">0</span>, HEARTBEAT_INTERVAL, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ctx.executor()</code> 返回的是当前的 <code>channel</code> 绑定的 NIO 线程，不理解没关系，只要记住就行，然后，NIO线程有一个方法，schedule()，类似 jdk 的延时任务机制，可以隔一段时间之后执行一个任务，而我们这边是实现了每隔 5 秒，向服务端发送一个心跳数据包，这个时间段通常要比服务端的空闲检测时间的一半要短一些，我们这里直接定义为空闲检测时间的三分之一，主要是为了排除公网偶发的秒级抖动。</p><p>实际在生产环境中，我们的发送心跳间隔时间和空闲检测时间可以略长一些，可以设置为几分钟级别，具体应用可以具体对待，没有强制的规定。</p><p>我们上面其实解决了服务端的空闲检测问题，服务端这个时候是能够在一定时间段之内关掉假死的连接，释放连接的资源了，但是对于客户端来说，我们也需要检测到假死的连接。</p><h2 id="服务端回复心跳与客户端空闲检测"><a href="#服务端回复心跳与客户端空闲检测" class="headerlink" title="服务端回复心跳与客户端空闲检测"></a>服务端回复心跳与客户端空闲检测</h2><p>客户端的空闲检测其实和服务端一样，依旧是在客户端 pipeline 的最前方插入 IMIdleStateHandler</p><blockquote><p>NettyClient.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">bootstrap.handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 空闲检测</span></span><br><span class="line">                ch.pipeline().addLast(<span class="keyword">new</span> IMIdleStateHandler());</span><br><span class="line">                ch.pipeline().addLast(<span class="keyword">new</span> Spliter());</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>然后为了排除是否是因为服务端在非假死状态下确实没有发送数据，<strong>服务端也要定期发送心跳给客户端</strong>。</p><p>而其实在前面我们已经实现了客户端向服务端定期发送心跳，服务端这边其实只要在收到心跳之后回复客户端，给客户端发送一个心跳响应包即可。如果在一段时间之内客户端没有收到服务端发来的数据，也可以判定这条连接为假死状态。</p><p>因此，服务端的 pipeline 中需要再加上如下一个 handler - <code>HeartBeatRequestHandler</code>，<strong>由于这个 handler 的处理其实是无需登录的</strong>，所以，我们将该 handler 放置在 AuthHandler 前面</p><blockquote><p>NettyServer.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">serverBootstrap</span><br><span class="line">                ch.pipeline().addLast(<span class="keyword">new</span> IMIdleStateHandler());</span><br><span class="line">                ch.pipeline().addLast(<span class="keyword">new</span> Spliter());</span><br><span class="line">                ch.pipeline().addLast(PacketCodecHandler.INSTANCE);</span><br><span class="line">                ch.pipeline().addLast(LoginRequestHandler.INSTANCE);</span><br><span class="line">                <span class="comment">// 加在这里</span></span><br><span class="line">                ch.pipeline().addLast(HeartBeatRequestHandler.INSTANCE);</span><br><span class="line">                ch.pipeline().addLast(AuthHandler.INSTANCE);</span><br><span class="line">                ch.pipeline().addLast(IMHandler.INSTANCE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p><code>HeartBeatRequestHandler</code> 相应的实现为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeartBeatRequestHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">HeartBeatRequestPacket</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> HeartBeatRequestHandler INSTANCE = <span class="keyword">new</span> HeartBeatRequestHandler();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HeartBeatRequestHandler</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, HeartBeatRequestPacket requestPacket)</span> </span>&#123;</span><br><span class="line">        ctx.writeAndFlush(<span class="keyword">new</span> HeartBeatResponsePacket());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现非常简单，只是简单地回复一个 <code>HeartBeatResponsePacket</code> 数据包。客户端在检测到假死连接之后，断开连接，然后可以有一定的策略去重连，重新登录等等。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>首先讨论了连接假死相关的现象以及产生的原因</p></li><li><p>要处理假死问题首先我们要实现客户端与服务端定期发送心跳，在这里，其实服务端只需要对客户端的定时心跳包进行回复</p></li><li><p>客户端与服务端如果都需要检测假死，那么直接在 pipeline 的最前方插入一个自定义 <code>IdleStateHandler</code>，在 <code>channelIdle()</code> 方法里面自定义连接假死之后的逻辑</p></li><li><p>通常空闲检测时间要比发送心跳的时间的两倍要长一些，这也是为了排除偶发的公网抖动，防止误判</p></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>摘自：<a href="https://juejin.im/book/5b4bc28bf265da0f60130116" target="_blank" rel="noopener">Netty 入门与实战：仿写微信 IM 即时通讯系统</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;代码：&lt;a href=&quot;https://github.com/austin-brant/netty-im&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/austin-brant/netty-im&lt;/a&gt;&lt;/p&gt;
&lt;h2
      
    
    </summary>
    
      <category term="Netty" scheme="http://yoursite.com/categories/Netty/"/>
    
      <category term="基础" scheme="http://yoursite.com/categories/Netty/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Netty" scheme="http://yoursite.com/tags/Netty/"/>
    
      <category term="网络IO" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9CIO/"/>
    
  </entry>
  
  <entry>
    <title>Netty ChannelHandler生命周期</title>
    <link href="http://yoursite.com/2019/11/14/Netty-ChannelHandler%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://yoursite.com/2019/11/14/Netty-ChannelHandler生命周期/</id>
    <published>2019-11-14T11:18:09.000Z</published>
    <updated>2019-11-20T12:20:18.440Z</updated>
    
    <content type="html"><![CDATA[<p>ChannelHandler有很多回调方法，这些回调方法的执行是有顺序的，而这个执行顺序可以称为 ChannelHandler 的生命周期。</p><p> 代码：<a href="https://github.com/austin-brant/netty-im" target="_blank" rel="noopener">https://github.com/austin-brant/netty-im</a></p><h2 id="生命周期详解"><a href="#生命周期详解" class="headerlink" title="生命周期详解"></a>生命周期详解</h2><p>对于服务端应用程序来说，我们这里讨论 ChannelHandler 更多的指的是 ChannelInboundHandler，在本小节，我们基于 ChannelInboundHandlerAdapter，自定义了一个 handler:  LifeCyCleTestHandler</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LifeCyCleTestHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerAdded</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"逻辑处理器被添加：handlerAdded()"</span>);</span><br><span class="line">        <span class="keyword">super</span>.handlerAdded(ctx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRegistered</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"channel 绑定到线程(NioEventLoop)：channelRegistered()"</span>);</span><br><span class="line">        <span class="keyword">super</span>.channelRegistered(ctx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"channel 准备就绪：channelActive()"</span>);</span><br><span class="line">        <span class="keyword">super</span>.channelActive(ctx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"channel 有数据可读：channelRead()"</span>);</span><br><span class="line">        <span class="keyword">super</span>.channelRead(ctx, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"channel 某次数据读完：channelReadComplete()"</span>);</span><br><span class="line">        <span class="keyword">super</span>.channelReadComplete(ctx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"channel 被关闭：channelInactive()"</span>);</span><br><span class="line">        <span class="keyword">super</span>.channelInactive(ctx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelUnregistered</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"channel 取消线程(NioEventLoop) 的绑定: channelUnregistered()"</span>);</span><br><span class="line">        <span class="keyword">super</span>.channelUnregistered(ctx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerRemoved</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"逻辑处理器被移除：handlerRemoved()"</span>);</span><br><span class="line">        <span class="keyword">super</span>.handlerRemoved(ctx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码可以看到，我们在每个方法被调用的时候都会打印一段文字，然后把这个事件继续往下传播。最后，我们把这个 handler 添加到构建的 pipeline 中.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前面代码略</span></span><br><span class="line">.childHandler(<span class="keyword">new</span> ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(NioSocketChannel ch)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 添加到第一个</span></span><br><span class="line">        ch.pipeline().addLast(<span class="keyword">new</span> LifeCyCleTestHandler());</span><br><span class="line">        ch.pipeline().addLast(<span class="keyword">new</span> PacketDecoder());</span><br><span class="line">        ch.pipeline().addLast(<span class="keyword">new</span> LoginRequestHandler());</span><br><span class="line">        ch.pipeline().addLast(<span class="keyword">new</span> MessageRequestHandler());</span><br><span class="line">        ch.pipeline().addLast(<span class="keyword">new</span> PacketEncoder());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>接着，我们先运行 NettyServer.java，然后再运行 NettyClient.java，这个时候，Server 端 控制台的输出为<br><img src="/images/netty_server_handler_life.jpg" alt></p><p>可以看到 ChannelHandler 回调方法的执行顺序为</p><blockquote><p>handlerAdded() -&gt; channelRegistered() -&gt; channelActive() -&gt; channelRead() -&gt; channelReadComplete()</p></blockquote><p>下面，我们来逐个解释一下每个回调方法的含义</p><ul><li><p>handlerAdded()<br>指的是当检测到新连接之后，调用 ch.pipeline().addLast(new LifeCyCleTestHandler()); 之后的回调，表示在当前的 channel 中，已经成功添加了一个 handler 处理器。</p></li><li><p>channelRegistered()<br>这个回调方法，表示当前的 channel 的所有的逻辑处理已经和某个 NIO 线程建立了绑定关系，类似我们在Netty 是什么？这小节中 BIO 编程中，accept 到新的连接，然后创建一个线程来处理这条连接的读写，只不过 Netty 里面是使用了线程池的方式，只需要从线程池里面去抓一个线程绑定在这个 channel 上即可，这里的 NIO 线程通常指的是 NioEventLoop,不理解没关系，后面我们还会讲到。</p></li><li><p>channelActive()<br>当 channel 的所有的业务逻辑链准备完毕（也就是说 channel 的 pipeline 中已经添加完所有的 handler）以及绑定好一个 NIO 线程之后，这条连接算是真正激活了，接下来就会回调到此方法。</p></li><li><p>channelRead()<br>客户端向服务端发来数据，每次都会回调此方法，表示有数据可读。</p></li><li><p>channelReadComplete()<br>服务端每次读完一次完整的数据之后，回调该方法，表示数据读取完毕。</p></li></ul><p>接下来，我们再把客户端关闭，这个时候对于服务端来说，其实就是 channel 被关闭， </p><p><img src="/images/netty_channel_close.jpg" alt></p><p>ChannelHandler 回调方法的执行顺序为</p><blockquote><p>channelInactive() -&gt; channelUnregistered() -&gt; handlerRemoved()</p></blockquote><p>这里的回调方法的执行顺序是新连接建立时候的逆操作，下面我们还是来解释一下每个方法的含义:</p><ul><li><p>channelInactive(): 表面这条连接已经被关闭了，这条连接在 TCP 层面已经不再是 ESTABLISH 状态了</p></li><li><p>channelUnregistered(): 既然连接已经被关闭，那么与这条连接绑定的线程就不需要对这条连接负责了，这个回调就表明与这条连接对应的 NIO 线程移除掉对这条连接的处理</p></li><li><p>handlerRemoved()：最后，我们给这条连接上添加的所有的业务逻辑处理器都给移除掉。</p></li></ul><p>最后，我们用一幅图来标识 ChannelHandler 的生命周期</p><p><img src="/images/netty_handler_lifecycle.png" alt></p><h2 id="ChannelHandler-生命周期各回调方法用法举例"><a href="#ChannelHandler-生命周期各回调方法用法举例" class="headerlink" title="ChannelHandler 生命周期各回调方法用法举例"></a>ChannelHandler 生命周期各回调方法用法举例</h2><p>Netty 对于一条连接的在各个不同状态下回调方法的定义还是蛮细致的，这个好处就在于我们能够基于这个机制写出扩展性较好的应用程序。</p><h3 id="ChannelInitializer-的实现原理"><a href="#ChannelInitializer-的实现原理" class="headerlink" title="ChannelInitializer 的实现原理"></a>ChannelInitializer 的实现原理</h3><p>仔细翻看一下我们的服务端启动代码，我们在给新连接定义 handler 的时候，其实只是通过 childHandler() 方法给新连接设置了一个 handler，这个 handler 就是 ChannelInitializer，而在 ChannelInitializer 的 initChannel() 方法里面，我们通过拿到 channel 对应的 pipeline，然后往里面塞 handler</p><blockquote><p>NettyServer.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.childHandler(<span class="keyword">new</span> ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(NioSocketChannel ch)</span> </span>&#123;</span><br><span class="line">        ch.pipeline().addLast(<span class="keyword">new</span> LifeCyCleTestHandler());</span><br><span class="line">        ch.pipeline().addLast(<span class="keyword">new</span> PacketDecoder());</span><br><span class="line">        ch.pipeline().addLast(<span class="keyword">new</span> LoginRequestHandler());</span><br><span class="line">        ch.pipeline().addLast(<span class="keyword">new</span> MessageRequestHandler());</span><br><span class="line">        ch.pipeline().addLast(<span class="keyword">new</span> PacketEncoder());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这里的 ChannelInitializer 其实就利用了 Netty 的 handler 生命周期中 channelRegistered() 与 handlerAdded() 两个特性，我们简单翻一翻 ChannelInitializer 这个类的源代码：</p><blockquote><p>ChannelInitializer.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(C ch)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">channelRegistered</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    initChannel(ctx);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerAdded</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (ctx.channel().isRegistered()) &#123;</span><br><span class="line">        initChannel(ctx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">initChannel</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initMap.putIfAbsent(ctx, Boolean.TRUE) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        initChannel((C) ctx.channel());</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，我把非重点代码略去，逻辑会更加清晰一些</p><ul><li><p>ChannelInitializer 定义了一个抽象的方法 initChannel()，这个抽象方法由我们自行实现，我们在服务端启动的流程里面的实现逻辑就是往 pipeline 里面塞我们的 handler 链</p></li><li><p>handlerAdded() 和 channelRegistered() 方法，都会尝试去调用 initChannel() 方法，initChannel() 使用 putIfAbsent() 来防止 initChannel() 被调用多次</p></li><li><p>如果你 debug 了 ChannelInitializer 的上述两个方法，你会发现，在 handlerAdded() 方法被调用的时候，channel 其实已经和某个线程绑定上了，所以，就我们的应用程序来说，这里的 channelRegistered() 其实是多余的，那为什么这里还要尝试调用一次呢？ 猜测应该是担心我们自己写了个类继承自 ChannelInitializer，然后覆盖掉了 handlerAdded() 方法，这样即使覆盖掉，在 channelRegistered() 方法里面还有机会再调一次 initChannel()，把我们自定义的 handler 都添加到 pipeline 中去。</p></li></ul><h3 id="handlerAdded-与-handlerRemoved"><a href="#handlerAdded-与-handlerRemoved" class="headerlink" title="handlerAdded() 与 handlerRemoved()"></a>handlerAdded() 与 handlerRemoved()</h3><p>这两个方法通常可以用在一些资源的申请和释放</p><h3 id="channelActive-与-channelInActive"><a href="#channelActive-与-channelInActive" class="headerlink" title="channelActive() 与 channelInActive()"></a>channelActive() 与 channelInActive()</h3><p>对我们的应用程序来说，这两个方法表明的含义是 TCP 连接的建立与释放，通常我们在这两个回调里面统计单机的连接数，channelActive() 被调用，连接数加一，channelInActive() 被调用，连接数减一</p><p>另外，我们也可以在 channelActive() 方法中，实现对客户端连接 ip 黑白名单的过滤，具体这里就不展开了</p><h3 id="channelRead"><a href="#channelRead" class="headerlink" title="channelRead()"></a>channelRead()</h3><p>我们在前面小节讲拆包粘包原理，服务端根据自定义协议来进行拆包，其实就是在这个方法里面，每次读到一定的数据，都会累加到一个容器里面，然后判断是否能够拆出来一个完整的数据包，如果够的话就拆了之后，往下进行传递，这里就不过多展开，感兴趣的同学可以阅读一下: <a href="https://www.jianshu.com/p/dc26e944da95" target="_blank" rel="noopener">netty源码分析之拆包器的奥秘</a></p><h3 id="channelReadComplete"><a href="#channelReadComplete" class="headerlink" title="channelReadComplete()"></a>channelReadComplete()</h3><p>每次向客户端写数据的时候，都通过 writeAndFlush() 的方法写并刷新到底层，其实这种方式不是特别高效，我们可以在之前调用 writeAndFlush() 的地方都调用 write() 方法，然后在这个方面里面调用 ctx.channel().flush() 方法，相当于一个批量刷新的机制，当然，如果你对性能要求没那么高，writeAndFlush() 足矣。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>摘自：<a href="https://juejin.im/book/5b4bc28bf265da0f60130116" target="_blank" rel="noopener">Netty 入门与实战：仿写微信 IM 即时通讯系统</a></p><p>参考：<br><a href="https://www.jianshu.com/p/dc26e944da95" target="_blank" rel="noopener">netty源码分析之拆包器的奥秘</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ChannelHandler有很多回调方法，这些回调方法的执行是有顺序的，而这个执行顺序可以称为 ChannelHandler 的生命周期。&lt;/p&gt;
&lt;p&gt; 代码：&lt;a href=&quot;https://github.com/austin-brant/netty-im&quot; targ
      
    
    </summary>
    
      <category term="Netty" scheme="http://yoursite.com/categories/Netty/"/>
    
      <category term="基础" scheme="http://yoursite.com/categories/Netty/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Netty" scheme="http://yoursite.com/tags/Netty/"/>
    
      <category term="网络IO" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9CIO/"/>
    
  </entry>
  
  <entry>
    <title>Netty数据传输载体ByteBuf简介</title>
    <link href="http://yoursite.com/2019/11/12/Netty%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E8%BD%BD%E4%BD%93ByteBuf%E7%AE%80%E4%BB%8B/"/>
    <id>http://yoursite.com/2019/11/12/Netty数据传输载体ByteBuf简介/</id>
    <published>2019-11-12T11:39:55.000Z</published>
    <updated>2019-11-20T12:20:20.620Z</updated>
    
    <content type="html"><![CDATA[<p>代码：<a href="https://github.com/austin-brant/netty-im" target="_blank" rel="noopener">https://github.com/austin-brant/netty-im</a></p><h2 id="ByteBuf结构"><a href="#ByteBuf结构" class="headerlink" title="ByteBuf结构"></a>ByteBuf结构</h2><p>首先，我们先来了解一下 ByteBuf 的结构<br><img src="/images/netty_bytebuf.png" alt></p><p>以上就是一个 ByteBuf 的结构图，从上面这幅图可以看到</p><ul><li><p>ByteBuf 是一个字节容器，容器里面的的数据分为三个部分:</p><ul><li><p>第一个部分是已经丢弃的字节，这部分数据是无效的；</p></li><li><p>第二部分是可读字节，这部分数据是 ByteBuf 的主体数据， 从 ByteBuf 里面读取的数据都来自这一部分;最后一部分的数据是可写字节，所有写到 ByteBuf 的数据都会写到这一段。</p></li><li><p>第三部分虚线表示的是该 ByteBuf 最多还能扩容多少容量</p></li></ul></li><li><p>以上三段内容是被两个指针给划分出来的，从左到右，依次是<code>读指针（readerIndex）</code>、<code>写指针（writerIndex）</code>，然后还有一个变量 <code>capacity</code>，表示 ByteBuf 底层内存的总容量;</p></li><li><p>从 ByteBuf 中每读取一个字节，readerIndex 自增1，ByteBuf 里面总共有 <code>writerIndex-readerIndex</code> 个字节可读, 由此可以推论出当 <code>readerIndex</code> 与 <code>writerIndex</code> 相等的时候，ByteBuf 不可读</p></li><li><p>写数据是从 <code>writerIndex</code> 指向的部分开始写，每写一个字节，<code>writerIndex</code> 自增1，直到增到 <code>capacity</code>，这个时候，表示 ByteBuf 已经不可写了</p></li><li><p>ByteBuf 里面其实还有一个参数 <code>maxCapacity</code>，当向 ByteBuf 写数据的时候，如果容量不足，那么这个时候可以进行扩容，直到 capacity 扩容到 maxCapacity，超过 maxCapacity 就会报错</p></li></ul><p>Netty使用ByteBuf这个数据结构可以有效地区分可读数据和可写数据，读写之间相互没有冲突，当然，ByteBuf只是对二进制数据的抽象, Netty关于数据读写只认ByteBuf，下面，我们就来学习一下 ByteBuf 常用的 API.</p><h2 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h2><h3 id="容量-API"><a href="#容量-API" class="headerlink" title="容量 API"></a>容量 API</h3><pre><code>capacity()</code></pre><p>表示 ByteBuf 底层占用了多少字节的内存（包括丢弃的字节、可读字节、可写字节），不同的底层实现机制有不同的计算方式，后面我们讲 ByteBuf 的分类的时候会讲到</p><pre><code>maxCapacity()</code></pre><p>表示 ByteBuf 底层最大能够占用多少字节的内存，当向 ByteBuf 中写数据的时候，如果发现容量不足，则进行扩容，直到扩容到 maxCapacity，超过这个数，就抛异常</p><pre><code>readableBytes() 与 isReadable()</code></pre><p>readableBytes() 表示 ByteBuf 当前可读的字节数，它的值等于 writerIndex-readerIndex，如果两者相等，则不可读，isReadable() 方法返回 false</p><pre><code>writableBytes()、 isWritable() 与 maxWritableBytes()</code></pre><p>writableBytes() 表示 ByteBuf 当前可写的字节数，它的值等于 capacity - writerIndex，如果两者相等，则表示不可写，isWritable() 返回 false，但是这个时候，并不代表不能往 ByteBuf 中写数据了， 如果发现往 ByteBuf 中写数据写不进去的话，Netty 会自动扩容 ByteBuf，直到扩容到底层的内存大小为 maxCapacity，而 maxWritableBytes() 就表示可写的最大字节数，它的值等于 maxCapacity - writerIndex。</p><h3 id="读写指针相关的API"><a href="#读写指针相关的API" class="headerlink" title="读写指针相关的API"></a>读写指针相关的API</h3><pre><code>readerIndex() 与 readerIndex(int)</code></pre><p>前者表示返回当前的读指针 readerIndex, 后者表示设置读指针</p><pre><code>writeIndex() 与 writeIndex(int)</code></pre><p>前者表示返回当前的写指针 writerIndex, 后者表示设置写指针</p><pre><code>markReaderIndex() 与 resetReaderIndex()</code></pre><p>前者表示把当前的读指针保存起来，后者表示把当前的读指针恢复到之前保存的值，下面两段代码是等价的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码片段1</span></span><br><span class="line"><span class="keyword">int</span> readerIndex = buffer.readerIndex();</span><br><span class="line"><span class="comment">// .. 其他操作</span></span><br><span class="line">buffer.readerIndex(readerIndex);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 代码片段二</span></span><br><span class="line">buffer.markReaderIndex();</span><br><span class="line"><span class="comment">// .. 其他操作</span></span><br><span class="line">buffer.resetReaderIndex();</span><br></pre></td></tr></table></figure><p>希望大家多多使用代码片段二这种方式，不需要自己定义变量，无论 buffer 当作参数传递到哪里，调用 resetReaderIndex() 都可以恢复到之前的状态，在解析自定义协议的数据包的时候非常常见，推荐大家使用这一对API.</p><pre><code>markWriterIndex() 与 resetWriterIndex()</code></pre><p>这一对 API 的作用与上述一对 API 类似，这里不再赘述.</p><h3 id="读写API"><a href="#读写API" class="headerlink" title="读写API"></a>读写API</h3><p>本质上，关于ByteBuf的读写都可以看作从指针开始的地方开始读写数据</p><pre><code>writeBytes(byte[] src) 与 buffer.readBytes(byte[] dst)</code></pre><p>writeBytes() 表示把字节数组 src 里面的数据全部写到 ByteBuf，而 readBytes() 指的是把 ByteBuf 里面的数据全部读取到 dst，这里 dst 字节数组的大小通常等于 readableBytes()，而 src 字节数组大小的长度通常小于等于 writableBytes()</p><pre><code>writeByte(byte b) 与 buffer.readByte()</code></pre><p>writeByte() 表示往 ByteBuf 中写一个字节，而 buffer.readByte() 表示从 ByteBuf 中读取一个字节，类似的 API 还有 <code>writeBoolean()</code>、<code>writeChar()</code>、<code>writeShort()</code>、<code>writeInt()</code>、<code>writeLong()</code>、<code>writeFloat()</code>、<code>writeDouble()</code> 与 <code>readBoolean()</code>、<code>readChar()</code>、<code>readShort()</code>、<code>readInt()</code>、<code>readLong()</code>、<code>readFloat()</code>、<code>readDouble()</code> 这里就不一一赘述.</p><p>与读写 API 类似的 API 还有 <code>getBytes</code>、<code>getByte()</code> 与 <code>setBytes()</code>、<code>setByte()</code> 系列，唯一的区别就是 <font color="red"><strong>get/set 不会改变读写指针，而 read/write 会改变读写指针</strong></font>，这点在解析数据的时候千万要注意</p><pre><code>release() 与 retain()</code></pre><p>由于 Netty 使用了堆外内存，而堆外内存是不被 jvm 直接管理的，也就是说申请到的内存无法被垃圾回收器直接回收，所以需要我们手动回收。有点类似于c语言里面，申请到的内存必须手工释放，否则会造成内存泄漏。</p><p>Netty 的 ByteBuf 是通过 <strong>引用计数</strong> 的方式管理的，如果一个 ByteBuf 没有地方被引用到，需要回收底层内存。默认情况下，<strong>当创建完一个 ByteBuf，它的引用为1，然后每次调用 retain() 方法， 它的引用就加一， release() 方法原理是将引用计数减一</strong>，减完之后如果发现引用计数为0，则直接回收 ByteBuf 底层的内存。</p><pre><code>slice()、duplicate()、copy()</code></pre><p>这三个方法通常情况会放到一起比较，这三者的返回值都是一个新的 ByteBuf 对象</p><ul><li><p>slice() 方法从原始 ByteBuf 中截取一段，这段数据是从 readerIndex 到 writeIndex，同时，返回的新的 ByteBuf 的最大容量 maxCapacity 为原始 ByteBuf 的 <code>readableBytes()</code></p></li><li><p>duplicate() 方法把整个 ByteBuf 都截取出来，包括所有的数据，指针信息</p></li><li><p>slice() 方法与 duplicate() 方法比较：</p><ul><li><p><strong>相同点：</strong> <strong>底层内存以及引用计数与原始的 ByteBuf 共享</strong>，也就是说经过 slice() 或者 duplicate() 返回的 ByteBuf 调用 write 系列方法都会影响到 原始的 ByteBuf，但是它们都<strong>维持着与原始 ByteBuf 相同的内存引用计数和不同的读写指针</strong></p></li><li><p><strong>不同点：</strong>slice() 只截取从 readerIndex 到 writerIndex 之间的数据，它返回的 ByteBuf 的最大容量被限制到 原始 ByteBuf 的 readableBytes(), 而 duplicate() 是把整个 ByteBuf 都与原始的 ByteBuf 共享</p></li></ul></li><li><p>slice() 方法与 duplicate() 方法不会拷贝数据，它们只是通过改变读写指针来改变读写的行为，而 copy() 会直接从原始的 ByteBuf 中拷贝所有的信息，包括读写指针以及底层对应的数据，因此， <strong>copy() 返回的 ByteBuf 中写数据不会影响到原始的 ByteBuf</strong></p></li><li><p>slice() 和 duplicate() 不会改变 ByteBuf 的引用计数，所以原始的 ByteBuf 调用 release() 之后发现引用计数为零，就开始释放内存，调用这两个方法返回的 ByteBuf 也会被释放，这个时候如果再对它们进行读写，就会报错。因此，我们可以通过调用一次 retain() 方法 来增加引用，表示它们对应的底层的内存多了一次引用，引用计数为2，在释放内存的时候，需要调用两次 release() 方法，将引用计数降到零，才会释放内存</p></li><li><p>这三个方法均维护着自己的读写指针，与原始的 ByteBuf 的读写指针无关，相互之间不受影响</p></li></ul><blockquote><p>retainedSlice() 与 retainedDuplicate()</p></blockquote><p>它们的作用是在截取内存片段的同时，增加内存的引用计数，分别与下面两段代码等价</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// retainedSlice 等价于</span></span><br><span class="line">slice().retain();</span><br><span class="line"></span><br><span class="line"><span class="comment">// retainedDuplicate() 等价于</span></span><br><span class="line">duplicate().retain()</span><br></pre></td></tr></table></figure><p>使用到 slice 和 duplicate 方法的时候，千万要理清 <strong>内存共享，引用计数共享，读写指针不共享</strong> 几个概念，下面举两个常见的易犯错的例子</p><ul><li>多次释放</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Buffer buffer = xxx;</span><br><span class="line">doWith(buffer);</span><br><span class="line"><span class="comment">// 一次释放</span></span><br><span class="line">buffer.release();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWith</span><span class="params">(Bytebuf buffer)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...    </span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 没有增加引用计数</span></span><br><span class="line">    Buffer slice = buffer.slice();</span><br><span class="line">    </span><br><span class="line">    foo(slice);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(ByteBuf buffer)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// read from buffer</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重复释放</span></span><br><span class="line">    buffer.release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 doWith 有的时候是用户自定义的方法，有的时候是 Netty 的回调方法，比如 channelRead() 等等</p><ul><li>不释放造成内存泄漏</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Buffer buffer = xxx;</span><br><span class="line">doWith(buffer);</span><br><span class="line"><span class="comment">// 引用计数为2，调用 release 方法之后，引用计数为1，无法释放内存 </span></span><br><span class="line">buffer.release();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWith</span><span class="params">(Bytebuf buffer)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...       </span></span><br><span class="line">    <span class="comment">// 增加引用计数</span></span><br><span class="line">    Buffer slice = buffer.retainedSlice();</span><br><span class="line">    foo(slice);</span><br><span class="line">    <span class="comment">// 没有调用 release</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(ByteBuf buffer)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// read from buffer</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想要避免以上两种情况发生，大家只需要记得一点，在一个函数体里面，只要增加了引用计数（包括 ByteBuf 的创建和手动调用 retain() 方法），就必须调用 release() 方法.</p><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p>了解了以上 API 之后，最后我们使用上述 API 来 写一个简单的 demo。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteBufTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ByteBuf buffer = ByteBufAllocator.DEFAULT.buffer(<span class="number">9</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        print(<span class="string">"allocate ByteBuf(9, 100)"</span>, buffer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// write 方法改变写指针，写完之后写指针未到 capacity 的时候，buffer 仍然可写</span></span><br><span class="line">        buffer.writeBytes(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;);</span><br><span class="line">        print(<span class="string">"writeBytes(1,2,3,4)"</span>, buffer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// write 方法改变写指针，写完之后写指针未到 capacity 的时候，buffer 仍然可写, 写完 int 类型之后，写指针增加4</span></span><br><span class="line">        buffer.writeInt(<span class="number">12</span>);</span><br><span class="line">        print(<span class="string">"writeInt(12)"</span>, buffer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// write 方法改变写指针, 写完之后写指针等于 capacity 的时候，buffer 不可写</span></span><br><span class="line">        buffer.writeBytes(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">5</span>&#125;);</span><br><span class="line">        print(<span class="string">"writeBytes(5)"</span>, buffer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// write 方法改变写指针，写的时候发现 buffer 不可写则开始扩容，扩容之后 capacity 随即改变</span></span><br><span class="line">        buffer.writeBytes(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">6</span>&#125;);</span><br><span class="line">        print(<span class="string">"writeBytes(6)"</span>, buffer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// get 方法不改变读写指针</span></span><br><span class="line">        System.out.println(<span class="string">"getByte(3) return: "</span> + buffer.getByte(<span class="number">3</span>));</span><br><span class="line">        System.out.println(<span class="string">"getShort(3) return: "</span> + buffer.getShort(<span class="number">3</span>));</span><br><span class="line">        System.out.println(<span class="string">"getInt(3) return: "</span> + buffer.getInt(<span class="number">3</span>));</span><br><span class="line">        print(<span class="string">"getByte()"</span>, buffer);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// set 方法不改变读写指针</span></span><br><span class="line">        buffer.setByte(buffer.readableBytes() + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        print(<span class="string">"setByte()"</span>, buffer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// read 方法改变读指针</span></span><br><span class="line">        <span class="keyword">byte</span>[] dst = <span class="keyword">new</span> <span class="keyword">byte</span>[buffer.readableBytes()];</span><br><span class="line">        buffer.readBytes(dst);</span><br><span class="line">        print(<span class="string">"readBytes("</span> + dst.length + <span class="string">")"</span>, buffer);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String action, ByteBuf buffer)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"after ==========="</span> + action + <span class="string">"============"</span>);</span><br><span class="line">        System.out.println(<span class="string">"capacity(): "</span> + buffer.capacity());</span><br><span class="line">        System.out.println(<span class="string">"maxCapacity(): "</span> + buffer.maxCapacity());</span><br><span class="line">        System.out.println(<span class="string">"readerIndex(): "</span> + buffer.readerIndex());</span><br><span class="line">        System.out.println(<span class="string">"readableBytes(): "</span> + buffer.readableBytes());</span><br><span class="line">        System.out.println(<span class="string">"isReadable(): "</span> + buffer.isReadable());</span><br><span class="line">        System.out.println(<span class="string">"writerIndex(): "</span> + buffer.writerIndex());</span><br><span class="line">        System.out.println(<span class="string">"writableBytes(): "</span> + buffer.writableBytes());</span><br><span class="line">        System.out.println(<span class="string">"isWritable(): "</span> + buffer.isWritable());</span><br><span class="line">        System.out.println(<span class="string">"maxWritableBytes(): "</span> + buffer.maxWritableBytes());</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">after ===========allocate ByteBuf(9, 100)============</span><br><span class="line">capacity(): 9</span><br><span class="line">maxCapacity(): 100</span><br><span class="line">readerIndex(): 0</span><br><span class="line">readableBytes(): 0</span><br><span class="line">isReadable(): false</span><br><span class="line">writerIndex(): 0</span><br><span class="line">writableBytes(): 9</span><br><span class="line">isWritable(): true</span><br><span class="line">maxWritableBytes(): 100</span><br><span class="line"></span><br><span class="line">after ===========writeBytes(1,2,3,4)============</span><br><span class="line">capacity(): 9</span><br><span class="line">maxCapacity(): 100</span><br><span class="line">readerIndex(): 0</span><br><span class="line">readableBytes(): 4</span><br><span class="line">isReadable(): true</span><br><span class="line">writerIndex(): 4</span><br><span class="line">writableBytes(): 5</span><br><span class="line">isWritable(): true</span><br><span class="line">maxWritableBytes(): 96</span><br><span class="line"></span><br><span class="line">after ===========writeInt(12)============</span><br><span class="line">capacity(): 9</span><br><span class="line">maxCapacity(): 100</span><br><span class="line">readerIndex(): 0</span><br><span class="line">readableBytes(): 8</span><br><span class="line">isReadable(): true</span><br><span class="line">writerIndex(): 8</span><br><span class="line">writableBytes(): 1</span><br><span class="line">isWritable(): true</span><br><span class="line">maxWritableBytes(): 92</span><br><span class="line"></span><br><span class="line">after ===========writeBytes(5)============</span><br><span class="line">capacity(): 9</span><br><span class="line">maxCapacity(): 100</span><br><span class="line">readerIndex(): 0</span><br><span class="line">readableBytes(): 9</span><br><span class="line">isReadable(): true</span><br><span class="line">writerIndex(): 9</span><br><span class="line">writableBytes(): 0</span><br><span class="line">isWritable(): false</span><br><span class="line">maxWritableBytes(): 91</span><br><span class="line"></span><br><span class="line">after ===========writeBytes(6)============</span><br><span class="line">capacity(): 64</span><br><span class="line">maxCapacity(): 100</span><br><span class="line">readerIndex(): 0</span><br><span class="line">readableBytes(): 10</span><br><span class="line">isReadable(): true</span><br><span class="line">writerIndex(): 10</span><br><span class="line">writableBytes(): 54</span><br><span class="line">isWritable(): true</span><br><span class="line">maxWritableBytes(): 90</span><br><span class="line"></span><br><span class="line">getByte(3) return: 4</span><br><span class="line">getShort(3) return: 1024</span><br><span class="line">getInt(3) return: 67108864</span><br><span class="line">after ===========getByte()============</span><br><span class="line">capacity(): 64</span><br><span class="line">maxCapacity(): 100</span><br><span class="line">readerIndex(): 0</span><br><span class="line">readableBytes(): 10</span><br><span class="line">isReadable(): true</span><br><span class="line">writerIndex(): 10</span><br><span class="line">writableBytes(): 54</span><br><span class="line">isWritable(): true</span><br><span class="line">maxWritableBytes(): 90</span><br><span class="line"></span><br><span class="line">after ===========setByte()============</span><br><span class="line">capacity(): 64</span><br><span class="line">maxCapacity(): 100</span><br><span class="line">readerIndex(): 0</span><br><span class="line">readableBytes(): 10</span><br><span class="line">isReadable(): true</span><br><span class="line">writerIndex(): 10</span><br><span class="line">writableBytes(): 54</span><br><span class="line">isWritable(): true</span><br><span class="line">maxWritableBytes(): 90</span><br><span class="line"></span><br><span class="line">after ===========readBytes(10)============</span><br><span class="line">capacity(): 64</span><br><span class="line">maxCapacity(): 100</span><br><span class="line">readerIndex(): 10</span><br><span class="line">readableBytes(): 0</span><br><span class="line">isReadable(): false</span><br><span class="line">writerIndex(): 10</span><br><span class="line">writableBytes(): 54</span><br><span class="line">isWritable(): true</span><br><span class="line">maxWritableBytes(): 90</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>Netty 对二进制数据的抽象 ByteBuf 的结构，本质原理就是，它引用了一段内存，这段内存可以是堆内也可以是堆外的，然后用引用计数来控制这段内存是否需要被释放，使用读写指针来控制对 ByteBuf 的读写，可以理解为是外观模式的一种使用</p></li><li><p>基于读写指针和容量、最大可扩容容量，衍生出一系列的读写方法，要注意 read/write 与 get/set 的区别</p></li><li><p>多个 ByteBuf 可以引用同一段内存，通过引用计数来控制内存的释放，遵循谁 retain() 谁 release() 的原则</p></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[转载] <a href="https://juejin.im/book/5b4bc28bf265da0f60130116/section/5b6a1a9cf265da0f87595521" target="_blank" rel="noopener">数据传输载体 ByteBuf 介绍</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;代码：&lt;a href=&quot;https://github.com/austin-brant/netty-im&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/austin-brant/netty-im&lt;/a&gt;&lt;/p&gt;
&lt;h2
      
    
    </summary>
    
      <category term="Netty" scheme="http://yoursite.com/categories/Netty/"/>
    
      <category term="基础" scheme="http://yoursite.com/categories/Netty/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Netty" scheme="http://yoursite.com/tags/Netty/"/>
    
      <category term="网络IO" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9CIO/"/>
    
  </entry>
  
  <entry>
    <title>Mysql性能分析工具</title>
    <link href="http://yoursite.com/2019/10/09/Mysql%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/"/>
    <id>http://yoursite.com/2019/10/09/Mysql性能分析工具/</id>
    <published>2019-10-09T06:47:36.000Z</published>
    <updated>2019-10-09T07:29:07.357Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>MySQL 提供了一个 EXPLAIN 命令, 它可以对 <font color="red"><strong>SELECT</strong></font> 语句进行分析, 并输出 <font color="red"><strong>SELECT</strong></font> 执行的详细信息, 以供开发人员针对性优化.</p><p>EXPLAIN 命令用法十分简单, 在 SELECT 语句前加上 Explain 就可以了, 例如:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">from</span> user_info <span class="keyword">WHERE</span> <span class="keyword">id</span> &lt; <span class="number">300</span>;</span><br></pre></td></tr></table></figure><h2 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `user_info` (</span><br><span class="line">  `id` bigint(20) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `name` varchar(50) NOT NULL DEFAULT &apos;&apos;,</span><br><span class="line">  `age` int(11) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  KEY `name_index` (`name`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;</span><br><span class="line"></span><br><span class="line">INSERT INTO user_info (name, age) VALUES (&apos;xys&apos;, 20);</span><br><span class="line">INSERT INTO user_info (name, age) VALUES (&apos;a&apos;, 21);</span><br><span class="line">INSERT INTO user_info (name, age) VALUES (&apos;b&apos;, 23);</span><br><span class="line">INSERT INTO user_info (name, age) VALUES (&apos;c&apos;, 50);</span><br><span class="line">INSERT INTO user_info (name, age) VALUES (&apos;d&apos;, 15);</span><br><span class="line">INSERT INTO user_info (name, age) VALUES (&apos;e&apos;, 20);</span><br><span class="line">INSERT INTO user_info (name, age) VALUES (&apos;f&apos;, 21);</span><br><span class="line">INSERT INTO user_info (name, age) VALUES (&apos;g&apos;, 23);</span><br><span class="line">INSERT INTO user_info (name, age) VALUES (&apos;h&apos;, 50);</span><br><span class="line">INSERT INTO user_info (name, age) VALUES (&apos;i&apos;, 15);</span><br><span class="line"></span><br><span class="line">CREATE TABLE `order_info` (</span><br><span class="line">  `id` bigint(20) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `user_id` bigint(20) DEFAULT NULL,</span><br><span class="line">  `product_name` varchar(50) NOT NULL DEFAULT &apos;&apos;,</span><br><span class="line">  `productor` varchar(30) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  KEY `user_product_detail_index` (`user_id`,`product_name`,`productor`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;</span><br><span class="line"></span><br><span class="line">INSERT INTO order_info (user_id, product_name, productor) VALUES (1, &apos;p1&apos;, &apos;WHH&apos;);</span><br><span class="line">INSERT INTO order_info (user_id, product_name, productor) VALUES (1, &apos;p2&apos;, &apos;WL&apos;);</span><br><span class="line">INSERT INTO order_info (user_id, product_name, productor) VALUES (1, &apos;p1&apos;, &apos;DX&apos;);</span><br><span class="line">INSERT INTO order_info (user_id, product_name, productor) VALUES (2, &apos;p1&apos;, &apos;WHH&apos;);</span><br><span class="line">INSERT INTO order_info (user_id, product_name, productor) VALUES (2, &apos;p5&apos;, &apos;WL&apos;);</span><br><span class="line">INSERT INTO order_info (user_id, product_name, productor) VALUES (3, &apos;p3&apos;, &apos;MA&apos;);</span><br><span class="line">INSERT INTO order_info (user_id, product_name, productor) VALUES (4, &apos;p1&apos;, &apos;WHH&apos;);</span><br><span class="line">INSERT INTO order_info (user_id, product_name, productor) VALUES (6, &apos;p1&apos;, &apos;WHH&apos;);</span><br><span class="line">INSERT INTO order_info (user_id, product_name, productor) VALUES (9, &apos;p8&apos;, &apos;TE&apos;);</span><br></pre></td></tr></table></figure><h2 id="EXPLAIN-输出格式"><a href="#EXPLAIN-输出格式" class="headerlink" title="EXPLAIN 输出格式"></a>EXPLAIN 输出格式</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from user_info where id = 2;</span><br><span class="line">+<span class="comment">----+-------------+-----------+-------+---------------+---------+---------+-------+------+-------+</span></span><br><span class="line">| id | select_type | table     | type  | possible_keys | key     | key_len | ref   | rows | Extra |</span><br><span class="line">+<span class="comment">----+-------------+-----------+-------+---------------+---------+---------+-------+------+-------+</span></span><br><span class="line">|  1 | SIMPLE      | user_info | const | PRIMARY       | PRIMARY | 8       | const |    1 |       |</span><br><span class="line">+<span class="comment">----+-------------+-----------+-------+---------------+---------+---------+-------+------+-------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>各列的含义如下:</p><ul><li><p><strong>id</strong>: SELECT 查询的标识符. 每个 SELECT 都会自动分配一个唯一的标识符.</p></li><li><p><strong>select_type</strong>: SELECT 查询的类型.</p></li><li><p><strong>table</strong>: 表示查询涉及的表或衍生表</p></li><li><p><em>partitions</em>: 匹配的分区</p></li><li><p><strong>type</strong>: join 类型</p></li><li><p><strong>possible_keys</strong>: 表示 MySQL 在查询时, 能够使用到的索引. 注意, 即使有些索引在 possible_keys 中出现, 但是并不表示此索引会真正地被 MySQL 使用到. MySQL 在查询时具体使用了哪些索引, 由 key 字段决定.</p></li><li><p><strong>key</strong>: 此次查询中真正使用到的索引.</p></li><li><p><strong>ref</strong>: 哪个字段或常数与 key 一起被使用</p></li><li><p><strong>rows</strong>: MySQL查询优化器根据统计信息, 估算SQL要查找到结果集需要扫描读取的数据行数.<br>这个值非常直观显示 SQL 的效率好坏, 原则上 rows 越少越好.</p></li><li><p><em>filtered</em>: 表示此查询条件所过滤的数据的百分比</p></li><li><p><strong>extra</strong>: 额外的信息</p></li></ul><h2 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h2><h3 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h3><p>select_type 表示了查询的类型, 它的常用取值有:</p><ul><li><p>SIMPLE, 表示此查询不包含 UNION 查询或子查询</p></li><li><p>PRIMARY, 表示此查询是最外层的查询</p></li><li><p>UNION, 表示此查询是 UNION 的第二个或随后的查询</p></li><li><p>DEPENDENT UNION, UNION 中的第二个或后面的查询语句, 取决于外面的查询</p></li><li><p>UNION RESULT, UNION 的结果</p></li><li><p>SUBQUERY, 子查询中的第一个 SELECT</p></li><li><p>DEPENDENT SUBQUERY: 子查询中的第一个 SELECT, 取决于外面的查询. 即子查询依赖于外层查询的结果.</p></li></ul><p>最常见的查询类别应该是 SIMPLE 了, 比如当我们的查询没有子查询, 也没有 UNION 查询时, 那么通常就是 SIMPLE 类型, 例如:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from user_info where id = 2;</span><br><span class="line">+<span class="comment">----+-------------+-----------+-------+---------------+---------+---------+-------+------+-------+</span></span><br><span class="line">| id | select_type | table     | type  | possible_keys | key     | key_len | ref   | rows | Extra |</span><br><span class="line">+<span class="comment">----+-------------+-----------+-------+---------------+---------+---------+-------+------+-------+</span></span><br><span class="line">|  1 | SIMPLE      | user_info | const | PRIMARY       | PRIMARY | 8       | const |    1 |       |</span><br><span class="line">+<span class="comment">----+-------------+-----------+-------+---------------+---------+---------+-------+------+-------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>如果我们使用了 UNION 查询, 那么 EXPLAIN 输出 的结果类似如下:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN (SELECT * FROM user_info  WHERE id IN (1, 2, 3)) UNION (SELECT * FROM user_info WHERE id IN (3, 4, 5));</span><br><span class="line">+<span class="comment">----+--------------+------------+-------+---------------+---------+---------+------+------+-------------+</span></span><br><span class="line">| id | select_type  | table      | type  | possible_keys | key     | key_len | ref  | rows | Extra       |</span><br><span class="line">+<span class="comment">----+--------------+------------+-------+---------------+---------+---------+------+------+-------------+</span></span><br><span class="line">|  1 | PRIMARY      | user_info  | range | PRIMARY       | PRIMARY | 8       | NULL |    3 | Using where |</span><br><span class="line">|  2 | UNION        | user_info  | range | PRIMARY       | PRIMARY | 8       | NULL |    3 | Using where |</span><br><span class="line">| NULL | UNION RESULT | &lt;union1,2&gt; | ALL   | NULL   | NULL    | NULL    | NULL | NULL   |             |</span><br><span class="line">+<span class="comment">----+--------------+------------+-------+---------------+---------+---------+------+------+-------------+</span></span><br><span class="line">3 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p>type 字段比较重要, 它提供了判断查询是否高效的重要依据依据. 通过 type 字段, 我们判断此次查询是 <strong>全表扫描</strong> 还是 <strong>索引扫描</strong> 等.</p><p>type 常用类型取值有:</p><ul><li><p><strong>system</strong>: 表中只有一条数据. 这个类型是特殊的 const 类型.</p></li><li><p><strong>const</strong>: 针对主键或唯一索引的等值查询扫描, 最多只返回一行数据. const 查询速度非常快, 因为它仅仅读取一次即可.<br>例如下面的这个查询, 它使用了主键索引, 因此 type 就是 const 类型的.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from user_info where id = 2;</span><br><span class="line">+<span class="comment">----+-------------+-----------+-------+---------------+---------+---------+-------+------+-------+</span></span><br><span class="line">| id | select_type | table     | type  | possible_keys | key     | key_len | ref   | rows | Extra |</span><br><span class="line">+<span class="comment">----+-------------+-----------+-------+---------------+---------+---------+-------+------+-------+</span></span><br><span class="line">|  1 | SIMPLE      | user_info | const | PRIMARY       | PRIMARY | 8       | const |    1 |       |</span><br><span class="line">+<span class="comment">----+-------------+-----------+-------+---------------+---------+---------+-------+------+-------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></li><li><p><strong>eq_ref</strong>: 此类型通常出现在多表的 join 查询, 表示对于前表的每一个结果, 都只能匹配到后表的一行结果. 并且查询的比较操作通常是 =, 查询效率较高. 例如:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM user_info, order_info WHERE user_info.id = order_info.user_id;</span><br><span class="line">+<span class="comment">----+-------------+------------+--------+---------------------------+---------------------------+---------+-------------------------+------+-------------+</span></span><br><span class="line">| id | select_type | table      | type   | possible_keys             | key                       | key_len | ref                     | rows | Extra       |</span><br><span class="line">+<span class="comment">----+-------------+------------+--------+---------------------------+---------------------------+---------+-------------------------+------+-------------+</span></span><br><span class="line">|  1 | SIMPLE      | order_info | index  | user_product_detail_index | user_product_detail_index | 254     | NULL                    |    9 | Using index |</span><br><span class="line">|  1 | SIMPLE      | user_info  | eq_ref | PRIMARY                   | PRIMARY                   | 8       | test.order_info.user_id |    1 |             |</span><br><span class="line">+<span class="comment">----+-------------+------------+--------+---------------------------+---------------------------+---------+-------------------------+------+-------------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></li><li><p><strong>ref</strong>: 此类型通常出现在多表的 join 查询, 针对于非唯一或非主键索引, 或者是使用了 <strong>最左前缀</strong> 规则索引的查询.<br>例如下面这个例子中, 就使用到了 ref 类型的查询:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM user_info, order_info WHERE user_info.id = order_info.user_id AND order_info.user_id = 5; </span><br><span class="line">+<span class="comment">----+-------------+------------+-------+---------------------------+---------------------------+---------+-------+------+--------------------------+</span></span><br><span class="line">| id | select_type | table      | type  | possible_keys             | key                       | key_len | ref   | rows | Extra                    |</span><br><span class="line">+<span class="comment">----+-------------+------------+-------+---------------------------+---------------------------+---------+-------+------+--------------------------+</span></span><br><span class="line">|  1 | SIMPLE      | user_info  | const | PRIMARY                   | PRIMARY                   | 8       | const |    1 |                          |</span><br><span class="line">|  1 | SIMPLE      | order_info | ref   | user_product_detail_index | user_product_detail_index | 9       | const |    1 | Using where; Using index |</span><br><span class="line">+<span class="comment">----+-------------+------------+-------+---------------------------+---------------------------+---------+-------+------+--------------------------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure></li><li><p><strong>range</strong>: 表示使用索引范围查询, 通过索引字段范围获取表中部分数据记录. 这个类型通常出现在 =, &lt;&gt;, &gt;, &gt;=, &lt;, &lt;=, IS NULL, &lt;=&gt;, BETWEEN, IN() 操作中.</p><p>  当 type 是 range 时, 那么 EXPLAIN 输出的 ref 字段为 NULL, 并且 key_len 字段是此次查询中使用到的索引的最长的那个.</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    mysql&gt; EXPLAIN SELECT * FROM user_info WHERE id BETWEEN 2 AND 8;</span><br><span class="line">+<span class="comment">----+-------------+-----------+-------+---------------+---------+---------+------+------+-------------+</span></span><br><span class="line">| id | select_type | table     | type  | possible_keys | key     | key_len | ref  | rows | Extra       |</span><br><span class="line">+<span class="comment">----+-------------+-----------+-------+---------------+---------+---------+------+------+-------------+</span></span><br><span class="line">|  1 | SIMPLE      | user_info | range | PRIMARY       | PRIMARY | 8       | NULL |    7 | Using where |</span><br><span class="line">+<span class="comment">----+-------------+-----------+-------+---------------+---------+---------+------+------+-------------+</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p><strong>index</strong>: 表示全索引扫描(full index scan), 和 ALL 类型类似, 只不过 ALL 类型是全表扫描, 而 index 类型则仅仅扫描所有的索引, 而不扫描数据.</p><p>  index 类型通常出现在: 所要查询的数据直接在索引树中就可以获取到, 而不需要扫描数据. 当是这种情况时, Extra 字段 会显示 <strong>Using index</strong>.例如:</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    mysql&gt; EXPLAIN SELECT name FROM  user_info;</span><br><span class="line">+<span class="comment">----+-------------+-----------+-------+---------------+------------+---------+------+------+-------------+</span></span><br><span class="line">| id | select_type | table     | type  | possible_keys | key        | key_len | ref  | rows | Extra       |</span><br><span class="line">+<span class="comment">----+-------------+-----------+-------+---------------+------------+---------+------+------+-------------+</span></span><br><span class="line">|  1 | SIMPLE      | user_info | index | NULL          | name_index | 152     | NULL |   10 | Using index |</span><br><span class="line">+<span class="comment">----+-------------+-----------+-------+---------------+------------+---------+------+------+-------------+</span></span><br></pre></td></tr></table></figure><p>  上面的例子中, 我们查询的 name 字段恰好是一个索引, 因此我们直接从索引中获取数据就可以满足查询的需求了, 而不需要查询表中的数据. 因此这样的情况下, type 的值是 index, 并且 Extra 的值是 Using index.</p></li><li><p><strong>ALL</strong>: 表示全表扫描, 这个类型的查询是性能最差的查询之一. 通常来说, 我们的查询不应该出现 ALL 类型的查询, 因为这样的查询在数据量大的情况下, 对数据库的性能是巨大的灾难. 如一个查询是 ALL 类型查询, 那么一般来说可以对相应的字段添加索引来避免.</p><p>  下面是一个全表扫描的例子, 可以看到, 在全表扫描时, possible_keys 和 key 字段都是 NULL, 表示没有使用到索引, 并且 rows 十分巨大, 因此整个查询效率是十分低下的.</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    mysql&gt; EXPLAIN SELECT age FROM  user_info WHERE age = 20;</span><br><span class="line">+<span class="comment">----+-------------+-----------+------+---------------+------+---------+------+------+-------------+</span></span><br><span class="line">| id | select_type | table     | type | possible_keys | key  | key_len | ref  | rows | Extra       |</span><br><span class="line">+<span class="comment">----+-------------+-----------+------+---------------+------+---------+------+------+-------------+</span></span><br><span class="line">|  1 | SIMPLE      | user_info | ALL  | NULL          | NULL | NULL    | NULL |   10 | Using where |</span><br><span class="line">+<span class="comment">----+-------------+-----------+------+---------------+------+---------+------+------+-------------+</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>type 类型的性能比较</strong></p><p>通常来说, 不同的 type 类型的性能关系如下:</p><blockquote><p>ALL &lt; index &lt; range ~ index_merge &lt; ref &lt; eq_ref &lt; const &lt; system</p></blockquote><p>ALL 类型因为是全表扫描, 因此在相同的查询条件下, 它是速度最慢的.</p><p>而 index 类型的查询虽然不是全表扫描, 但是它扫描了所有的索引, 因此比 ALL 类型的稍快.</p><p>后面的几种类型都是利用了索引来查询数据, 因此可以过滤部分或大部分数据, 因此查询效率就比较高了.</p><h3 id="key-len"><a href="#key-len" class="headerlink" title="key_len"></a>key_len</h3><p>表示查询优化器使用了索引的字节数. 这个字段可以评估组合索引是否完全被使用, 或只有最左部分字段被使用到.<br>key_len 的计算规则如下:</p><ul><li><p>字符串</p><ul><li><p>char(n): n字节长度</p></li><li><p>varchar(n): 如果是 utf8 编码, 则是 (3n + 2) 字节; 如果是 utf8mb4 编码, 则是 (4n + 2） 字节.</p></li></ul></li><li><p>数值类型:</p><ul><li><p>TINYINT: 1字节</p></li><li><p>SMALLINT: 2字节</p></li><li><p>MEDIUMINT: 3字节</p></li><li><p>INT: 4字节</p></li><li><p>BIGINT: 8字节</p></li></ul></li><li><p>时间类型</p><ul><li><p>DATE: 3字节</p></li><li><p>TIMESTAMP: 4字节</p></li><li><p>DATETIME: 8字节</p></li></ul></li><li><p>字段属性: NULL 属性 占用一个字节. 如果一个字段是 NOT NULL 的, 则没有此属性.</p></li></ul><p>我们来举两个简单的例子:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM order_info WHERE user_id &lt; 3 AND product_name = 'p1' AND productor = 'WHH';</span><br><span class="line">+<span class="comment">----+-------------+------------+-------+---------------------------+---------------------------+---------+------+------+--------------------------+</span></span><br><span class="line">| id | select_type | table      | type  | possible_keys             | key                       | key_len | ref  | rows | Extra                    |</span><br><span class="line">+<span class="comment">----+-------------+------------+-------+---------------------------+---------------------------+---------+------+------+--------------------------+</span></span><br><span class="line">|  1 | SIMPLE      | order_info | range | user_product_detail_index | user_product_detail_index | 9       | NULL |    4 | Using where; Using index |</span><br><span class="line">+<span class="comment">----+-------------+------------+-------+---------------------------+---------------------------+---------+------+------+--------------------------+</span></span><br></pre></td></tr></table></figure><p>上面的例子是从表 order_info 中查询指定的内容, 而我们从此表的建表语句中可以知道, 表 order_info 有一个联合索引:</p><blockquote><p>KEY <code>user_product_detail_index</code> (<code>user_id</code>, <code>product_name</code>, <code>productor</code>)</p></blockquote><p>不过此查询语句 <code>WHERE user_id &lt; 3 AND product_name = &#39;p1&#39; AND productor = &#39;WHH&#39;</code> 中, 因为先进行 user_id 的范围查询, 而根据 最左前缀匹配 原则, 当遇到范围查询时, 就停止索引的匹配, 因此实际上我们使用到的索引的字段只有 <code>user_id</code>, 因此在 EXPLAIN 中, 显示的 key_len 为 9. </p><p>因为 user_id 字段是 BIGINT, 占用 8 字节, 而 NULL 属性占用一个字节, 因此总共是 9 个字节. 若我们将user_id 字段改为 BIGINT(20) NOT NULL DEFAULT ‘0’, 则 key_length 应该是8.</p><p>上面因为 最左前缀匹配 原则, 我们的查询仅仅使用到了联合索引的 user_id 字段, 因此效率不算高.</p><p>接下来我们来看一下下一个例子:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM order_info WHERE user_id = 1 AND product_name = 'p1';</span><br><span class="line">+<span class="comment">----+-------------+------------+------+---------------------------+---------------------------+---------+-------------+------+--------------------------+</span></span><br><span class="line">| id | select_type | table      | type | possible_keys             | key                       | key_len | ref         | rows | Extra                    |</span><br><span class="line">+<span class="comment">----+-------------+------------+------+---------------------------+---------------------------+---------+-------------+------+--------------------------+</span></span><br><span class="line">|  1 | SIMPLE      | order_info | ref  | user_product_detail_index | user_product_detail_index | 161     | const,const |    2 | Using where; Using index |</span><br><span class="line">+<span class="comment">----+-------------+------------+------+---------------------------+---------------------------+---------+-------------+------+--------------------------+</span></span><br></pre></td></tr></table></figure><p>这次的查询中, 我们没有使用到范围查询, <code>key_len</code> 的值为 161. 为什么呢? </p><p>因为我们的查询条件 <code>WHERE user_id = 1 AND product_name = &#39;p1&#39;</code> 中, 仅仅使用到了联合索引中的前两个字段, 因此 keyLen(user_id) + keyLen(product_name) = 9 + 50 * 3 + 2 = 161</p><h3 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h3><p>EXplain 中的很多额外的信息会在 Extra 字段显示, 常见的有以下几种内容:</p><ul><li><p>Using filesort<br>当 Extra 中有 Using filesort 时, 表示 MySQL 需额外的排序操作, 不能通过索引顺序达到排序效果. 一般有 Using filesort, 都建议优化去掉, 因为这样的查询 CPU 资源消耗大.</p><p>  例如下面的例子:</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    mysql&gt; EXPLAIN SELECT * FROM order_info ORDER BY product_name;</span><br><span class="line">+<span class="comment">----+-------------+------------+-------+---------------+---------------------------+---------+------+------+-----------------------------+</span></span><br><span class="line">| id | select_type | table      | type  | possible_keys | key                       | key_len | ref  | rows | Extra                       |</span><br><span class="line">+<span class="comment">----+-------------+------------+-------+---------------+---------------------------+---------+------+------+-----------------------------+</span></span><br><span class="line">|  1 | SIMPLE      | order_info | index | NULL          | user_product_detail_index | 254     | NULL |    9 | Using index; Using filesort |</span><br><span class="line">+<span class="comment">----+-------------+------------+-------+---------------+---------------------------+---------+------+------+-----------------------------+</span></span><br></pre></td></tr></table></figure><p>  我们的索引是</p><blockquote><p>KEY <code>user_product_detail_index</code> (<code>user_id</code>, <code>product_name</code>, <code>productor</code>)</p></blockquote><p>  但是上面的查询中根据 <code>product_name</code> 来排序, 因此不能使用索引进行优化, 进而会产生 Using filesort.<br>如果我们将排序依据改为 <code>ORDER BY user_id, product_name</code>, 那么就不会出现 <code>Using filesort</code> 了. 例如:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM order_info ORDER BY user_id, product_name;</span><br><span class="line">+<span class="comment">----+-------------+------------+-------+---------------+---------------------------+---------+------+------+-------------+</span></span><br><span class="line">| id | select_type | table      | type  | possible_keys | key                       | key_len | ref  | rows | Extra       |</span><br><span class="line">+<span class="comment">----+-------------+------------+-------+---------------+---------------------------+---------+------+------+-------------+</span></span><br><span class="line">|  1 | SIMPLE      | order_info | index | NULL          | user_product_detail_index | 254     | NULL |    9 | Using index |</span><br><span class="line">+<span class="comment">----+-------------+------------+-------+---------------+---------------------------+---------+------+------+-------------+</span></span><br></pre></td></tr></table></figure></li><li><p>Using index<br>“覆盖索引扫描”, 表示查询在索引树中就可查找所需数据, 不用扫描表数据文件, 往往说明性能不错</p></li><li><p>Using temporary<br>查询有使用临时表, 一般出现于排序, 分组和多表 join 的情况, 查询效率不高, 建议优化.</p></li></ul><h1 id="Profiling"><a href="#Profiling" class="headerlink" title="Profiling"></a>Profiling</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>当我们要对某一条sql的性能进行分析时，可以使用它。</p><p>Profiling是从 mysql5.0.3版本以后才开放的。<br>启动profile之后，<strong>所有查询包括错误的语句</strong>都会记录在内。<br>关闭会话或者set profiling=0 就关闭了。（如果将profiling_history_size参数设置为0，同样具有关闭MySQL的profiling效果。）</p><p>此工具可用来查询SQL执行状态，System lock和Table lock 花多少时间等等，</p><p>对定位一条语句的<strong>I/O、CPU、IPC，Memory</strong>消耗 非常重要。(SQL 语句执行所消耗的最大两部分资源就是IO和CPU)</p><blockquote><p><em>在mysql5.7之后，profile信息将逐渐被废弃，mysql推荐使用performance schema</em></p></blockquote><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p><strong>简易流程大概如下：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> profiling=<span class="number">1</span>;  //打开分析，默认值为0（off），可以通过设置profiling为1或ON开启</span><br><span class="line"> </span><br><span class="line">run your sql1;</span><br><span class="line"> </span><br><span class="line">run your sql2;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">show</span> <span class="keyword">profiles</span>;//查看sql1, sql2的语句分析</span><br><span class="line"> </span><br><span class="line"><span class="keyword">show</span> profile <span class="keyword">for</span> <span class="keyword">query</span> <span class="number">1</span>;//查看sql1的具体分析</span><br><span class="line"> </span><br><span class="line"><span class="keyword">show</span> profile <span class="keyword">ALL</span> <span class="keyword">for</span> <span class="keyword">query</span> <span class="number">1</span>;//查看sql1相关的所有分析【主要看i/o与cpu,下边分析中有各项意义介绍】</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> profiling=<span class="number">0</span>;  //关闭分析</span><br></pre></td></tr></table></figure><p><strong>语法：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SHOW PROFILE [type [, type] ... ]</span><br><span class="line">   [FOR QUERY n]</span><br><span class="line">   [LIMIT row_count [OFFSET offset]]</span><br></pre></td></tr></table></figure><blockquote><p>type:</p><p>ALL | BLOCK IO | CONTEXT SWITCHES | CPU | IPC | MEMORY | PAGE FAULTS | SOURCE | SWAPS</p></blockquote><p><img src="/images/mysql_profiling_params.png" alt></p><p>SOURCE：显示和Source_function,Source_file,Source_line相关的开销信息</p><p><strong><em>注意：profiling被应用在每一个会话中，当前会话关闭后，profiling统计的信息将丢失。</em></strong></p><p><strong>实例：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like '%profil%';   ## 查看mysql profiling相关配置</span><br><span class="line">+<span class="comment">------------------------+-------+</span></span><br><span class="line">| Variable_name          | Value |</span><br><span class="line">+<span class="comment">------------------------+-------+</span></span><br><span class="line">| have_profiling         | YES   |</span><br><span class="line">| profiling              | OFF   | <span class="comment">## 是否开启</span></span><br><span class="line">| profiling_history_size | 15    | <span class="comment">## 记录历史条数</span></span><br><span class="line">+<span class="comment">------------------------+-------+</span></span><br><span class="line">3 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">set</span> profiling = <span class="keyword">ON</span>;  <span class="comment">## 开启分析</span></span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like '%profil%';</span><br><span class="line">+<span class="comment">------------------------+-------+</span></span><br><span class="line">| Variable_name          | Value |</span><br><span class="line">+<span class="comment">------------------------+-------+</span></span><br><span class="line">| have_profiling         | YES   |</span><br><span class="line">| profiling              | ON    |</span><br><span class="line">| profiling_history_size | 15    |</span><br><span class="line">+<span class="comment">------------------------+-------+</span></span><br><span class="line">3 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">show</span> <span class="keyword">tables</span>;                   </span><br><span class="line">+<span class="comment">-------------------------------------+</span></span><br><span class="line">| Tables_in_bigdata_new               |</span><br><span class="line">+<span class="comment">-------------------------------------+</span></span><br><span class="line">| TblDataShoppingRecord               |</span><br><span class="line">| TblDataViewRecord                   |</span><br><span class="line">| TblEmailNotifyRecord                |</span><br><span class="line">+<span class="comment">-------------------------------------+</span></span><br><span class="line">3 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">select</span> * <span class="keyword">from</span> TblDataShoppingRecord <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">id</span> <span class="keyword">desc</span> <span class="keyword">limit</span> <span class="number">1</span>\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">                id: 1263</span><br><span class="line">            status: off</span><br><span class="line">              name: mapdata_meta_27</span><br><span class="line">           creator: zhangsan</span><br><span class="line">        createTime: 2019-10-08 15:20:20</span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"><span class="keyword">ERROR</span>: </span><br><span class="line"><span class="keyword">No</span> <span class="keyword">query</span> specified</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">select</span> * <span class="keyword">from</span> TblDataShoppingRecord <span class="keyword">where</span> creator = <span class="string">'austin'</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">id</span> <span class="keyword">desc</span> <span class="keyword">limit</span> <span class="number">1</span>\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">                id: 1285</span><br><span class="line">            status: off</span><br><span class="line">              name: metadata_30</span><br><span class="line">           creator: austin</span><br><span class="line">        createTime: 2019-10-08 15:20:20</span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line"><span class="keyword">ERROR</span>: </span><br><span class="line"><span class="keyword">No</span> <span class="keyword">query</span> specified</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">show</span> <span class="keyword">profiles</span>;</span><br><span class="line">+<span class="comment">----------+------------+---------------------------------------------------------------------------------------------+</span></span><br><span class="line">| Query_ID | Duration   | Query                                                                                       |</span><br><span class="line">+<span class="comment">----------+------------+---------------------------------------------------------------------------------------------+</span></span><br><span class="line">|        1 | 0.00045400 | <span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'%profil%'</span>                                                              |</span><br><span class="line">|        <span class="number">2</span> | <span class="number">0.00086200</span> | <span class="keyword">show</span> <span class="keyword">tables</span>                                                                                 |</span><br><span class="line">|        <span class="number">3</span> | <span class="number">0.00034900</span> | <span class="keyword">select</span> * <span class="keyword">from</span> TblDataShoppingRecord <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">id</span> <span class="keyword">desc</span> <span class="keyword">limit</span> <span class="number">1</span>                                |</span><br><span class="line">|        <span class="number">4</span> | <span class="number">0.00040000</span> | <span class="keyword">select</span> * <span class="keyword">from</span> TblDataShoppingRecord <span class="keyword">where</span> creator = <span class="string">'austin'</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">id</span> <span class="keyword">desc</span> <span class="keyword">limit</span> <span class="number">1</span>       |</span><br><span class="line">+<span class="comment">----------+------------+---------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">show</span> profile <span class="keyword">for</span> <span class="keyword">query</span> <span class="number">4</span>;</span><br><span class="line">+<span class="comment">--------------------------------+----------+</span></span><br><span class="line">| Status                         | Duration |</span><br><span class="line">+<span class="comment">--------------------------------+----------+</span></span><br><span class="line">| starting                       | 0.000039 |</span><br><span class="line">| checking query <span class="keyword">cache</span> <span class="keyword">for</span> <span class="keyword">query</span> | <span class="number">0.000052</span> |</span><br><span class="line">| Opening <span class="keyword">tables</span>                 | <span class="number">0.000015</span> |</span><br><span class="line">| <span class="keyword">System</span> <span class="keyword">lock</span>                    | <span class="number">0.000005</span> |</span><br><span class="line">| <span class="keyword">Table</span> <span class="keyword">lock</span>                     | <span class="number">0.000037</span> |</span><br><span class="line">| init                           | <span class="number">0.000031</span> |</span><br><span class="line">| optimizing                     | <span class="number">0.000009</span> |</span><br><span class="line">| <span class="keyword">statistics</span>                     | <span class="number">0.000073</span> |</span><br><span class="line">| preparing                      | <span class="number">0.000016</span> |</span><br><span class="line">| executing                      | <span class="number">0.000005</span> |</span><br><span class="line">| Sorting <span class="keyword">result</span>                 | <span class="number">0.000006</span> |</span><br><span class="line">| Sending <span class="keyword">data</span>                   | <span class="number">0.000050</span> |</span><br><span class="line">| <span class="keyword">end</span>                            | <span class="number">0.000007</span> |</span><br><span class="line">| <span class="keyword">query</span> <span class="keyword">end</span>                      | <span class="number">0.000004</span> |</span><br><span class="line">| freeing items                  | <span class="number">0.000027</span> |</span><br><span class="line">| storing <span class="keyword">result</span> <span class="keyword">in</span> <span class="keyword">query</span> <span class="keyword">cache</span>  | <span class="number">0.000015</span> |</span><br><span class="line">| <span class="keyword">logging</span> slow <span class="keyword">query</span>             | <span class="number">0.000004</span> |</span><br><span class="line">| cleaning up                    | <span class="number">0.000005</span> |</span><br><span class="line">+<span class="comment">--------------------------------+----------+</span></span><br><span class="line"><span class="number">18</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">show</span> profile cpu <span class="keyword">for</span> <span class="keyword">query</span> <span class="number">4</span>;</span><br><span class="line">+<span class="comment">--------------------------------+----------+----------+------------+</span></span><br><span class="line">| Status                         | Duration | CPU_user | CPU_system |</span><br><span class="line">+<span class="comment">--------------------------------+----------+----------+------------+</span></span><br><span class="line">| starting                       | 0.000039 | 0.000000 |   0.000000 |</span><br><span class="line">| checking query <span class="keyword">cache</span> <span class="keyword">for</span> <span class="keyword">query</span> | <span class="number">0.000052</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |</span><br><span class="line">| Opening <span class="keyword">tables</span>                 | <span class="number">0.000015</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |</span><br><span class="line">| <span class="keyword">System</span> <span class="keyword">lock</span>                    | <span class="number">0.000005</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |</span><br><span class="line">| <span class="keyword">Table</span> <span class="keyword">lock</span>                     | <span class="number">0.000037</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |</span><br><span class="line">| init                           | <span class="number">0.000031</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |</span><br><span class="line">| optimizing                     | <span class="number">0.000009</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |</span><br><span class="line">| <span class="keyword">statistics</span>                     | <span class="number">0.000073</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |</span><br><span class="line">| preparing                      | <span class="number">0.000016</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |</span><br><span class="line">| executing                      | <span class="number">0.000005</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |</span><br><span class="line">| Sorting <span class="keyword">result</span>                 | <span class="number">0.000006</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |</span><br><span class="line">| Sending <span class="keyword">data</span>                   | <span class="number">0.000050</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |</span><br><span class="line">| <span class="keyword">end</span>                            | <span class="number">0.000007</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |</span><br><span class="line">| <span class="keyword">query</span> <span class="keyword">end</span>                      | <span class="number">0.000004</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |</span><br><span class="line">| freeing items                  | <span class="number">0.000027</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |</span><br><span class="line">| storing <span class="keyword">result</span> <span class="keyword">in</span> <span class="keyword">query</span> <span class="keyword">cache</span>  | <span class="number">0.000015</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |</span><br><span class="line">| <span class="keyword">logging</span> slow <span class="keyword">query</span>             | <span class="number">0.000004</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |</span><br><span class="line">| cleaning up                    | <span class="number">0.000005</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |</span><br><span class="line">+<span class="comment">--------------------------------+----------+----------+------------+</span></span><br><span class="line"><span class="number">18</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">show</span> profile <span class="keyword">BLOCK</span> IO, CPU, IPC, <span class="keyword">MEMORY</span>, <span class="keyword">SOURCE</span>, SWAPS  <span class="keyword">for</span> <span class="keyword">query</span> <span class="number">4</span>;   </span><br><span class="line">+<span class="comment">--------------------------------+----------+----------+------------+--------------+---------------+---------------+-------------------+-------+------------------+---------------+-------------+</span></span><br><span class="line">| Status                         | Duration | CPU_user | CPU_system | Block_ops_in | Block_ops_out | Messages_sent | Messages_received | Swaps | Source_function  | Source_file   | Source_line |</span><br><span class="line">+<span class="comment">--------------------------------+----------+----------+------------+--------------+---------------+---------------+-------------------+-------+------------------+---------------+-------------+</span></span><br><span class="line">| starting                       | 0.000039 | 0.000000 |   0.000000 |            0 |             0 |             0 |                 0 |     0 | NULL             | NULL          |        NULL |</span><br><span class="line">| checking query <span class="keyword">cache</span> <span class="keyword">for</span> <span class="keyword">query</span> | <span class="number">0.000052</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |            <span class="number">0</span> |             <span class="number">0</span> |             <span class="number">0</span> |                 <span class="number">0</span> |     <span class="number">0</span> | <span class="literal">unknown</span> <span class="keyword">function</span> | sql_cache.cc  |        <span class="number">1523</span> |</span><br><span class="line">| Opening <span class="keyword">tables</span>                 | <span class="number">0.000015</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |            <span class="number">0</span> |             <span class="number">0</span> |             <span class="number">0</span> |                 <span class="number">0</span> |     <span class="number">0</span> | <span class="literal">unknown</span> <span class="keyword">function</span> | sql_base.cc   |        <span class="number">4618</span> |</span><br><span class="line">| <span class="keyword">System</span> <span class="keyword">lock</span>                    | <span class="number">0.000005</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |            <span class="number">0</span> |             <span class="number">0</span> |             <span class="number">0</span> |                 <span class="number">0</span> |     <span class="number">0</span> | <span class="literal">unknown</span> <span class="keyword">function</span> | lock.cc       |         <span class="number">260</span> |</span><br><span class="line">| <span class="keyword">Table</span> <span class="keyword">lock</span>                     | <span class="number">0.000037</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |            <span class="number">0</span> |             <span class="number">0</span> |             <span class="number">0</span> |                 <span class="number">0</span> |     <span class="number">0</span> | <span class="literal">unknown</span> <span class="keyword">function</span> | lock.cc       |         <span class="number">271</span> |</span><br><span class="line">| init                           | <span class="number">0.000031</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |            <span class="number">0</span> |             <span class="number">0</span> |             <span class="number">0</span> |                 <span class="number">0</span> |     <span class="number">0</span> | <span class="literal">unknown</span> <span class="keyword">function</span> | sql_select.cc |        <span class="number">2528</span> |</span><br><span class="line">| optimizing                     | <span class="number">0.000009</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |            <span class="number">0</span> |             <span class="number">0</span> |             <span class="number">0</span> |                 <span class="number">0</span> |     <span class="number">0</span> | <span class="literal">unknown</span> <span class="keyword">function</span> | sql_select.cc |         <span class="number">833</span> |</span><br><span class="line">| <span class="keyword">statistics</span>                     | <span class="number">0.000073</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |            <span class="number">0</span> |             <span class="number">0</span> |             <span class="number">0</span> |                 <span class="number">0</span> |     <span class="number">0</span> | <span class="literal">unknown</span> <span class="keyword">function</span> | sql_select.cc |        <span class="number">1024</span> |</span><br><span class="line">| preparing                      | <span class="number">0.000016</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |            <span class="number">0</span> |             <span class="number">0</span> |             <span class="number">0</span> |                 <span class="number">0</span> |     <span class="number">0</span> | <span class="literal">unknown</span> <span class="keyword">function</span> | sql_select.cc |        <span class="number">1046</span> |</span><br><span class="line">| executing                      | <span class="number">0.000005</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |            <span class="number">0</span> |             <span class="number">0</span> |             <span class="number">0</span> |                 <span class="number">0</span> |     <span class="number">0</span> | <span class="literal">unknown</span> <span class="keyword">function</span> | sql_select.cc |        <span class="number">1780</span> |</span><br><span class="line">| Sorting <span class="keyword">result</span>                 | <span class="number">0.000006</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |            <span class="number">0</span> |             <span class="number">0</span> |             <span class="number">0</span> |                 <span class="number">0</span> |     <span class="number">0</span> | <span class="literal">unknown</span> <span class="keyword">function</span> | sql_select.cc |        <span class="number">2205</span> |</span><br><span class="line">| Sending <span class="keyword">data</span>                   | <span class="number">0.000050</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |            <span class="number">0</span> |             <span class="number">0</span> |             <span class="number">0</span> |                 <span class="number">0</span> |     <span class="number">0</span> | <span class="literal">unknown</span> <span class="keyword">function</span> | sql_select.cc |        <span class="number">2338</span> |</span><br><span class="line">| <span class="keyword">end</span>                            | <span class="number">0.000007</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |            <span class="number">0</span> |             <span class="number">0</span> |             <span class="number">0</span> |                 <span class="number">0</span> |     <span class="number">0</span> | <span class="literal">unknown</span> <span class="keyword">function</span> | sql_select.cc |        <span class="number">2574</span> |</span><br><span class="line">| <span class="keyword">query</span> <span class="keyword">end</span>                      | <span class="number">0.000004</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |            <span class="number">0</span> |             <span class="number">0</span> |             <span class="number">0</span> |                 <span class="number">0</span> |     <span class="number">0</span> | <span class="literal">unknown</span> <span class="keyword">function</span> | sql_parse.cc  |        <span class="number">5118</span> |</span><br><span class="line">| freeing items                  | <span class="number">0.000027</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |            <span class="number">0</span> |             <span class="number">0</span> |             <span class="number">0</span> |                 <span class="number">0</span> |     <span class="number">0</span> | <span class="literal">unknown</span> <span class="keyword">function</span> | sql_parse.cc  |        <span class="number">6142</span> |</span><br><span class="line">| storing <span class="keyword">result</span> <span class="keyword">in</span> <span class="keyword">query</span> <span class="keyword">cache</span>  | <span class="number">0.000015</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |            <span class="number">0</span> |             <span class="number">0</span> |             <span class="number">0</span> |                 <span class="number">0</span> |     <span class="number">0</span> | <span class="literal">unknown</span> <span class="keyword">function</span> | sql_cache.cc  |         <span class="number">985</span> |</span><br><span class="line">| <span class="keyword">logging</span> slow <span class="keyword">query</span>             | <span class="number">0.000004</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |            <span class="number">0</span> |             <span class="number">0</span> |             <span class="number">0</span> |                 <span class="number">0</span> |     <span class="number">0</span> | <span class="literal">unknown</span> <span class="keyword">function</span> | sql_parse.cc  |        <span class="number">1735</span> |</span><br><span class="line">| cleaning up                    | <span class="number">0.000005</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |            <span class="number">0</span> |             <span class="number">0</span> |             <span class="number">0</span> |                 <span class="number">0</span> |     <span class="number">0</span> | <span class="literal">unknown</span> <span class="keyword">function</span> | sql_parse.cc  |        <span class="number">1703</span> |</span><br><span class="line">+<span class="comment">--------------------------------+----------+----------+------------+--------------+---------------+---------------+-------------------+-------+------------------+---------------+-------------+</span></span><br><span class="line"><span class="number">18</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">set</span> profiling=<span class="number">0</span>;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like '%profil%';</span><br><span class="line">+<span class="comment">------------------------+-------+</span></span><br><span class="line">| Variable_name          | Value |</span><br><span class="line">+<span class="comment">------------------------+-------+</span></span><br><span class="line">| have_profiling         | YES   |</span><br><span class="line">| profiling              | OFF   |</span><br><span class="line">| profiling_history_size | 15    |</span><br><span class="line">+<span class="comment">------------------------+-------+</span></span><br><span class="line">3 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h2 id="结果参数说明"><a href="#结果参数说明" class="headerlink" title="结果参数说明"></a>结果参数说明</h2><p>其中标题含义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&quot;Status&quot;: &quot;query end&quot;,  状态</span><br><span class="line">&quot;Duration&quot;: &quot;1.751142&quot;, 持续时间</span><br><span class="line">&quot;CPU_user&quot;: &quot;0.008999&quot;, cpu用户</span><br><span class="line">&quot;CPU_system&quot;: &quot;0.003999&quot;, cpu系统</span><br><span class="line">&quot;Context_voluntary&quot;: &quot;98&quot;, 上下文主动切换</span><br><span class="line">&quot;Context_involuntary&quot;: &quot;0&quot;, 上下文被动切换</span><br><span class="line">&quot;Block_ops_in&quot;: &quot;8&quot;, 阻塞的输入操作</span><br><span class="line">&quot;Block_ops_out&quot;: &quot;32&quot;, 阻塞的输出操作</span><br><span class="line">&quot;Messages_sent&quot;: &quot;0&quot;, 消息发出</span><br><span class="line">&quot;Messages_received&quot;: &quot;0&quot;, 消息接受</span><br><span class="line">&quot;Page_faults_major&quot;: &quot;0&quot;, 主分页错误</span><br><span class="line">&quot;Page_faults_minor&quot;: &quot;0&quot;, 次分页错误</span><br><span class="line">&quot;Swaps&quot;: &quot;0&quot;, 交换次数</span><br><span class="line">&quot;Source_function&quot;: &quot;mysql_execute_command&quot;, 源功能</span><br><span class="line">&quot;Source_file&quot;: &quot;sql_parse.cc&quot;, 源文件</span><br><span class="line">&quot;Source_line&quot;: &quot;4465&quot; 源代码行</span><br></pre></td></tr></table></figure><p>不同阶段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">starting：开始</span><br><span class="line">checking permissions：检查权限</span><br><span class="line">Opening tables：打开表</span><br><span class="line">init ： 初始化</span><br><span class="line">System lock ：系统锁</span><br><span class="line">optimizing ： 优化</span><br><span class="line">statistics ： 统计</span><br><span class="line">preparing ：准备</span><br><span class="line">executing ：执行</span><br><span class="line">Sending data ：发送数据</span><br><span class="line">Sorting result ：排序</span><br><span class="line">end ：结束</span><br><span class="line">query end ：查询 结束</span><br><span class="line">closing tables ： 关闭表 ／去除TMP 表</span><br><span class="line">freeing items ： 释放物品</span><br><span class="line">cleaning up ：清理</span><br></pre></td></tr></table></figure><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>显示的记录数由变量“profiling_history_size”控制,默认15条，最大值为100，可以手动设置该参数值。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mysql&gt; set profiling_history_size = 30;  </span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like '%profil%';</span><br><span class="line">+<span class="comment">------------------------+-------+</span></span><br><span class="line">| Variable_name          | Value |</span><br><span class="line">+<span class="comment">------------------------+-------+</span></span><br><span class="line">| have_profiling         | YES   |</span><br><span class="line">| profiling              | OFF   |</span><br><span class="line">| profiling_history_size | 30    |</span><br><span class="line">+<span class="comment">------------------------+-------+</span></span><br><span class="line">3 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h1 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h1><p>[1] <a href="https://segmentfault.com/a/1190000008131735#articleHeader8" target="_blank" rel="noopener">MySQL 性能优化神器 Explain 使用分析</a><br>[2] <a href="https://blog.csdn.net/ty_hf/article/details/54895026" target="_blank" rel="noopener">Mysql分析-profile详解</a><br>[3] <a href="https://blog.csdn.net/Field_Yang/article/details/80629663" target="_blank" rel="noopener">MySQL性能分析工具profiling</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Explain&quot;&gt;&lt;a href=&quot;#Explain&quot; class=&quot;headerlink&quot; title=&quot;Explain&quot;&gt;&lt;/a&gt;Explain&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简
      
    
    </summary>
    
      <category term="Mysql" scheme="http://yoursite.com/categories/Mysql/"/>
    
      <category term="性能" scheme="http://yoursite.com/categories/Mysql/%E6%80%A7%E8%83%BD/"/>
    
    
      <category term="Mysql" scheme="http://yoursite.com/tags/Mysql/"/>
    
      <category term="工具" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Mysql索引底层原理</title>
    <link href="http://yoursite.com/2019/09/28/Mysql%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2019/09/28/Mysql索引底层原理/</id>
    <published>2019-09-28T07:32:15.000Z</published>
    <updated>2019-10-09T07:55:31.228Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常用引擎"><a href="#常用引擎" class="headerlink" title="常用引擎"></a>常用引擎</h2><h3 id="InnoDB（聚集索引）"><a href="#InnoDB（聚集索引）" class="headerlink" title="InnoDB（聚集索引）"></a>InnoDB（聚集索引）</h3><ul><li><p>InnoDB的存储文件有两个，后缀名分别是.frm 和.idb，其中.frm是表的定义文件，而.idb是索引和数据文件。</p></li><li><p>InnoDB 中存在表锁和行锁，不过行锁是在命中索引的情况下才会起作用。</p></li><li><p>InnoDB 支持事务，且支持四种隔离级别（读未提交、读已提交、可重复读、串行化），默认的为可重复读；而在 Oracle 数据库中，只支持串行化级别和读已提交这两种级别，其中默认的为读已提交级别。</p></li></ul><h3 id="MyISAM（非聚集索引）"><a href="#MyISAM（非聚集索引）" class="headerlink" title="MyISAM（非聚集索引）"></a>MyISAM（非聚集索引）</h3><ul><li><p>Myisam 的存储文件有三个，后缀名分别是.frm、.MYD、MYI，其中.frm是表的定义文件，.MYD是数据文件，.MYI是索引文件。</p></li><li><p>Myisam只支持表锁，且不支持事务。Myisam 由于有单独的索引文件，在读取数据方面的性能很高 。</p></li></ul><h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><p>可以用来优化查询的数据结构有哈希表，完全平衡二叉树，B树，B+树。我们使用最多的是B+树，InnoDB和Myisam都是用 <strong>B+Tree</strong> 来存储数据的。</p><p>数据结构可视化网站： </p><blockquote><p><a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html" target="_blank" rel="noopener">https://www.cs.usfca.edu/~galles/visualization/Algorithms.html</a></p></blockquote><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p><strong>为什么很少使用hash?</strong></p><ul><li><p>优点：直接计算下标，查询单一数据非常快。</p></li><li><p>缺点：如果是进行的范围查询的话，哈希索引就必须全表遍历，获得age数据，然后再依次进行比较，也就是相当于没有索引了。这样就不能优化查询效率了。</p></li></ul><h3 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h3><p><img src="/images/mysql_b_tree.jpg" alt></p><blockquote><p><strong>d</strong> 为大于1的一个正整数，称为B-Tree的度，表示节点的数据存储个数；</p><p><strong>h</strong> 为一个正整数，称为B-Tree的高度；</p><p>每个非叶子节点由n-1个key和n个指针组成，其中 d &lt;= n &lt;= 2d；</p><p>每个叶子节点最少包含一个key和两个指针，最多包含2d-1个key和2d个指针，叶节点的指针均为null；</p><p>所有叶节点具有相同的深度，等于树高h;</p><p>key和指针互相间隔，节点两端是指针;</p><p>一个节点中的key从左到右非递减排列;</p><p>所有节点组成树结构;</p><p>每个指针要么为null，要么指向另外一个节点;</p></blockquote><p>关于B-Tree有一系列有趣的性质，例如一个度为 d 的B-Tree，设其索引 N 个key，则其树高h的上限为 <strong>logd((N+1)/2)</strong> ，检索一个key，其查找节点个数的线性复杂度为 <strong>O(logdN)</strong> 。从这点可以看出，B-Tree是一个非常有效率的索引数据结构。</p><h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><p>B-Tree有许多变种，其中最常见的是B+Tree。</p><p><img src="/images/mysql_bplus_tree.jpg" alt></p><p>与B-Tree相比，B+Tree有以下不同点：</p><blockquote><ol><li><p>每个节点的指针上限为2d而不是2d+1;</p></li><li><p>非叶子节点不存储data，只存储key，可节省空间，增大 <strong>度</strong>;</p></li><li><p>叶子节点不存储指针;</p></li><li><p>带有顺序访问指针，提高了区间访问性能;</p></li></ol></blockquote><h3 id="局部性原理与磁盘预读"><a href="#局部性原理与磁盘预读" class="headerlink" title="局部性原理与磁盘预读"></a>局部性原理与磁盘预读</h3><p>由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分分之一，因此为了提高效率，要尽量减少磁盘I/O。</p><p>为了达到这个目的，磁盘往往<strong>不是严格按需读取，而是每次都会预读</strong>，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的局部性原理：</p><blockquote><p>当一个数据被用到时，其附近的数据也通常会马上被使用。程序运行期间所需要的数据通常比较集中。</p></blockquote><blockquote><p>由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，<strong>预读</strong>可以提高I/O效率。</p></blockquote><p>预读的长度<strong>一般为页（page）的整倍数</strong>。页是计算机<strong>管理存储器的最小逻辑块</strong>，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k），<strong>主存和磁盘以页为单位交换数据</strong>。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。</p><h3 id="mysql页文件配置"><a href="#mysql页文件配置" class="headerlink" title="mysql页文件配置"></a>mysql页文件配置</h3><h4 id="查看mysql页文件大小"><a href="#查看mysql页文件大小" class="headerlink" title="查看mysql页文件大小"></a>查看mysql页文件大小</h4><blockquote><p>SHOW GLOBAL STATUS like ‘Innodb_page_size’;</p></blockquote><h4 id="为什么Mysql页文件默认16kb就够了呢"><a href="#为什么Mysql页文件默认16kb就够了呢" class="headerlink" title="为什么Mysql页文件默认16kb就够了呢"></a>为什么Mysql页文件默认16kb就够了呢</h4><ul><li><p>假设我们一行数据大小为1K,那么一页就能存16条数据，也就是一个叶子节点能存16条数据;</p></li><li><p>再看非叶子节点，假设主键ID为bigint类型, 那么长度为8B，指针大小在Innodb源码中为6B，-共就是14B,那么一页里就可以存储16K/14=1170个(主键+指针)，那么：</p><ul><li>一颗高度 为2的B+树能存储的数据为: 1170 * 16 = 18720条</li><li>一 颗高度为3的B+树能存储的数据为: 1170 * 1170 * 16 = 21902400 (千万级条)。</li></ul></li></ul><p>所以在InnoDB中B+树高度一般为1-3层， 它就能满足千万级的数据存储。在查找数据时一次页的查找代表一次I/O, 所以通过主键索引查询通常只需要1-3次IO操作即可查找到数据。所以也就回答了我们的问题，1 页=16k这么设置是比较合适的，是适用大多数的企业的，当然这个值是可以修改的，所以也能根据业务的时间情况进行调整。</p><h3 id="B-Tree索引的性能分析"><a href="#B-Tree索引的性能分析" class="headerlink" title="B-/+Tree索引的性能分析"></a>B-/+Tree索引的性能分析</h3><p>一般以使用磁盘I/O次数评价索引结构的优劣。</p><p>先从B-Tree分析，根据B-Tree的定义，可知检索一次最多需要访问h个节点。数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。</p><p>为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：</p><blockquote><p>每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。</p><p>B-Tree中一次检索最多需要h-1次I/O（根节点常驻内存），渐进复杂度为O(h)=O(logdN)。一般实际应用中，度d是非常大的数字，通常超过100，因此h非常小（通常不超过3）。</p></blockquote><p>综上所述，用B-Tree作为索引结构效率是非常高的。B+Tree之所以更适合外存索引，原因和内节点度d有关。从上面分析可以看到，d越大索引的性能越好，而度的上限取决于节点内key和data的大小：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmax = floor(pagesize/(keysize+datasize+pointsize))</span><br></pre></td></tr></table></figure><p>floor表示向下取整。由于B+Tree内节点去掉了data域，因此可以拥有更大的度，拥有更好的性能。</p><h2 id="MySQL索引实现"><a href="#MySQL索引实现" class="headerlink" title="MySQL索引实现"></a>MySQL索引实现</h2><p>在MySQL中，索引属于存储引擎级别的概念，不同存储引擎对索引的实现方式是不同的。</p><h3 id="MyISAM索引实现"><a href="#MyISAM索引实现" class="headerlink" title="MyISAM索引实现"></a>MyISAM索引实现</h3><p><img src="/images/mysql_myisam_index.jpg" alt></p><ul><li><p>索引文件仅仅保存数据记录的地址，索引文件和数据文件是分离的；</p></li><li><p>主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复；</p></li><li><p>索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。</p></li></ul><h3 id="InnoDB索引实现"><a href="#InnoDB索引实现" class="headerlink" title="InnoDB索引实现"></a>InnoDB索引实现</h3><p>虽然InnoDB也使用B+Tree作为索引结构，但具体实现方式却与MyISAM截然不同。</p><p><img src="/images/mysql_innodb_index.jpg" alt></p><ul><li><p>数据文件本身就是索引文件，都存储在后缀为.idb的文件中；</p></li><li><p>叶节点data域保存了完整的数据记录, 而不是行地址；</p></li><li><p>因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求<strong>表必须有主键</strong>（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形；</p></li><li><p>聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：<strong>首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录</strong>；</p></li></ul><h3 id="InnodeDB主键选择与插入优化"><a href="#InnodeDB主键选择与插入优化" class="headerlink" title="InnodeDB主键选择与插入优化"></a>InnodeDB主键选择与插入优化</h3><p>基于以上特点就很容易理解为什么不建议使用过长的字段作为主键？而且推荐使用整形自增主键？</p><ul><li><p>所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大；</p></li><li><p>InnoDB数据文件本身是一颗B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择；</p></li></ul><h3 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h3><p>有如下数据表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> People (</span><br><span class="line">    last_name <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    first_name <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    dob <span class="built_in">date</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    gender enum(<span class="string">'m'</span>,<span class="string">'f'</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    <span class="keyword">key</span>(last_name,first_name,dob)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>这个建表语句在last_name、first_name、dob列上建立了一个联合索引，下图展示了该索引的存储结构。</p><p><img src="/images/mysql_union_indxe.jpg" alt></p><p>可以看到，联合索引中的索引项会先根据第一个索引列进行排序，第一个索引列相同的情况下，会再按照第二个索引列进行排序，依次类推。根据这种存储特点，B-Tree索引对如下类型的查找有效：</p><ul><li><p>全值匹配：查找条件和索引中的所有列相匹配</p></li><li><p>匹配最左前缀：查找条件只有索引中的第一列</p></li><li><p>匹配列前缀：只匹配某一列值的开头部分。这里并不一定只能匹配第一个索引列的前缀。例如在确定第一个索引列的值时，也可以在第二个索引列上匹配列前缀。在上面例子中，对于查找姓为Allen，名为J开头的人，也可以应用到索引。</p></li><li><p>匹配范围值，或者精确匹配某一列并范围匹配另外一列：例如查找姓在Allen和Barrymore之间的人，或者查找姓为Allen，名字在某一个范围内的人。</p></li><li><p>只访问索引的查询，即要查询的值在索引中都包含，只需要访问索引就行了，无需访问数据行。这种索引被称作<strong>覆盖索引</strong>。</p></li><li><p>对于上面列出的查询类型，索引除了可以用来查询外，还可以用来排序。</p></li></ul><p>下面是B-Tree索引的一些限制：</p><ul><li><p>如果不是从索引的最左列开始查找，则无法使用索引。例如直接查找名字为Bill的人，或查找某个生日的人都无法应用到上面的索引，因为都跳过了索引的第一个列。此外查找姓以某个字母结尾的人，也无法使用到上面的索引。</p></li><li><p>不能在中间跳过索引中的某个列，例如不能查找姓为Smith，生日为某个特定日期的类。这样的查询只能使用到索引的第一列。</p></li><li><p>如果查询中有某个列的范围查询，则该列右边的所有列都无法使用索引优化查找。例如有查询WHERE last_name=’Smith’ AND first_name LIKE ‘J%’ AND dob=’1976-12-23’，这个查询只能使用到索引的前两列，而不能使用整个索引。</p></li></ul><p>通过上面列出的这些条件，可见对于一个B-TREE联合索引，索引列的顺序非常重要。</p><blockquote><p> InnoDB中有一个功能叫“自适应哈希索引”，当InnoDB注意到某些索引值使用的非常频繁时，会在B-Tree索引之上再建立一层哈希索引，以加速查找效率。这是完全自动的内部行为，用户无法干预。</p></blockquote><h2 id="索引查询"><a href="#索引查询" class="headerlink" title="索引查询"></a>索引查询</h2><h3 id="多列索引"><a href="#多列索引" class="headerlink" title="多列索引"></a>多列索引</h3><p>当出现对多个索引列做相交(AND)操作的查询时，代表需要一个包含所有相关列的联合索引，而不是多个独立的单列索引。</p><p>在MySql官方提供的示例数据库sakila中，表film_actor在字段film_id和actor_id上各有一个单列索引，对于下面这条查询语句，这两个单列索引都不是很好的选择：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> film_id,actor_id <span class="keyword">FROM</span> film_actor <span class="keyword">WHERE</span> actor_id=<span class="number">1</span> <span class="keyword">OR</span> film_id=<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>在老的MySql版本中，这个查询会使用全表扫描。但在MySql5.0之后，查询能够同时使用这两个单列索引进行扫描，然后将结果合并，相当于转换成下面这条查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> film_id,actor_id <span class="keyword">FROM</span> film_actor <span class="keyword">WHERE</span> actor_id=<span class="number">1</span> </span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> film_id,actor_id <span class="keyword">FROM</span> film_actor <span class="keyword">WHERE</span> film_id=<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>在MySql5.7中，执行上面查询的执行计划如下图所示：</p><p><img src="/images/mysql_muti_cols_index.jpg" alt></p><p>从执行计划的type字段可以看到，MySql同时使用了两个索引，并将各自的查询结果合并。并且Extra字段描述了使用索引的详细信息。</p><p>虽然MySql在背后对查询进行了优化，使其可以同时利用两个单列索引。但是这需要耗费大量的CPU和内存资源，所以<strong>直接将查询改写成UNION的方式会更好</strong>。像这种两个列上都有索引的情况，用union代替or会得到更好的效果(注意要求两个列上都建有索引，如果没有索引，用union代替or反而会降低效率)。</p><p>如果在EXPLAIN中看到有索引合并，那就应该好好检查一下查询和表的结构，看看是不是已经是最优的。</p><h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p>如果一个索引包含所有需要查询的字段，就称之为“<strong>覆盖索引</strong>”。由于在索引的叶子节点中已经包含了要查询的全部数据，所以就可以从索引中直接获取查询结果，而没必要再回表查询。</p><p>索引一般远远小于数据行的大小，如果只需要访问索引，就会极大减少数据访问量。而且索引是按照顺序存储，所以在进行范围查询时会比随机从磁盘读取每一条数据的I/O要少的多。由此看出，覆盖索引能够极大的提高查询性能。</p><p>sakila数据库中包含了由store_id和film_id组成的一个联合索引，如下图所示：<br><img src="/images/mysql_union_index.jpg" alt></p><p>如果只查询store_id和film_id这两列，就可以使用这个索引做覆盖索引。</p><p><img src="/images/mysql_cover_index.jpg" alt></p><p>EXPLAIN的Extra列如果是Using index，则代表这个查询使用到了覆盖索引。注意type字段和是否为覆盖索引毫无关系。</p><h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><p>[1] <a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="noopener">MySQL索引背后的数据结构及算法原理</a></p><p>[2] <a href="https://segmentfault.com/a/1190000010991930#articleHeader3" target="_blank" rel="noopener">MySql索引</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;常用引擎&quot;&gt;&lt;a href=&quot;#常用引擎&quot; class=&quot;headerlink&quot; title=&quot;常用引擎&quot;&gt;&lt;/a&gt;常用引擎&lt;/h2&gt;&lt;h3 id=&quot;InnoDB（聚集索引）&quot;&gt;&lt;a href=&quot;#InnoDB（聚集索引）&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="Mysql" scheme="http://yoursite.com/categories/Mysql/"/>
    
      <category term="索引" scheme="http://yoursite.com/categories/Mysql/%E7%B4%A2%E5%BC%95/"/>
    
    
      <category term="Mysql" scheme="http://yoursite.com/tags/Mysql/"/>
    
      <category term="索引" scheme="http://yoursite.com/tags/%E7%B4%A2%E5%BC%95/"/>
    
      <category term="优化" scheme="http://yoursite.com/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Kafka快速入门</title>
    <link href="http://yoursite.com/2019/09/23/Kafka%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2019/09/23/Kafka快速入门/</id>
    <published>2019-09-23T11:46:50.000Z</published>
    <updated>2019-09-23T12:16:42.532Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Apache Kafka® 是 一个分布式流处理平台.<br>我们知道流处理平台有以下三种特性:</p><ol><li>可以让你发布和订阅流式的记录。这一方面与消息队列或者企业消息系统类似。</li><li>可以储存流式的记录，并且有较好的容错性。</li><li>可以在流式记录产生时就进行处理。</li></ol><p>Kafka适合什么样的场景?</p><p>它可以用于两大类别的应用:</p><ol><li>构造实时流数据管道，它可以在系统或应用之间可靠地获取数据。 (相当于message queue)</li><li>构建实时流式应用程序，对这些流数据进行转换或者影响。 (就是流处理，通过kafka stream topic和topic之间内部进行变化)</li></ol><p>首先是一些概念:</p><ul><li>Kafka作为一个集群，运行在一台或者多台服务器上.</li><li>Kafka 通过 topic 对存储的流数据进行分类。</li><li>每条记录中包含一个key，一个value和一个timestamp（时间戳）。</li></ul><h2 id="Topics和日志"><a href="#Topics和日志" class="headerlink" title="Topics和日志"></a>Topics和日志</h2><p>让我们首先深入了解下Kafka的核心概念:提供一串流式的记录— topic 。</p><p>Topic 就是数据主题，是数据记录发布的地方,可以用来区分业务系统。Kafka中的Topics总是多订阅者模式，一个topic可以拥有一个或者多个消费者来订阅它的数据。</p><p>对于每一个topic， Kafka集群都会维持一个分区日志，如下所示：</p><p><img src="/images/kafka_partition_log.jpg" alt></p><p>每个分区都是有序且顺序不可变的记录集，并且不断地追加到结构化的commit log文件。分区中的每一个记录都会分配一个id号来表示顺序，我们称之为offset，offset用来唯一的标识分区中每一条记录。</p><p><strong>Kafka 集群保留所有发布的记录—无论他们是否已被消费—并通过一个可配置的参数——保留期限来控制</strong>. 举个例子， 如果保留策略设置为2天，一条记录发布后两天内，可以随时被消费，两天过后这条记录会被抛弃并释放磁盘空间。<strong>Kafka的性能和数据大小无关，所以长时间存储数据没有什么问题</strong>.</p><p>日志中的 partition（分区）有以下几个用途。</p><ul><li>第一，当日志大小超过了单台服务器的限制，允许日志进行扩展。每个单独的分区都必须受限于主机的文件限制，不过一个主题可能有多个分区，因此可以处理无限量的数据。</li><li>第二，可以作为并行的单元集</li></ul><h2 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h2><p>日志的分区partition （分布）在Kafka集群的服务器上。每个服务器在处理数据和请求时，共享这些分区。每一个分区都会在已配置的服务器上进行备份，确保容错性.</p><p>每个分区都有一台 server 作为 “leader”，零台或者多台server作为 follwers 。leader server 处理一切对 partition （分区）的读写请求，而follwers只需被动的同步leader上的数据。当leader宕机了，followers 中的一台服务器会自动成为新的 leader。每台 server 都会成为某些分区的 leader 和某些分区的 follower，因此集群的负载是平衡的。</p><h2 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h2><p>如果所有的消费者实例在同一消费组中，消息记录会负载平衡到每一个消费者实例.</p><p>如果所有的消费者实例在不同的消费组中，每条消息记录会广播到所有的消费者进程.</p><p><img src="/images/kafka_consumer_group.jpg" alt></p><p>在Kafka中实现消费的方式是<strong>将日志中的分区划分到每一个消费者实例上</strong>，以便在任何时间，<strong>每个实例都是分区唯一的消费者</strong>。维护消费组中的消费关系由Kafka协议动态处理。如果新的实例加入组，他们将从组中其他成员处接管一些 partition 分区;如果一个实例消失，拥有的分区将被分发到剩余的实例。</p><p>Kafka 只保证分区内的记录是有序的，而不保证主题中不同分区的顺序。每个 partition 分区按照key值排序足以满足大多数应用程序的需求。但如果你需要总记录在所有记录的上面，可使用仅有一个分区的主题来实现，这意味着每个消费者组只有一个消费者进程。</p><p>Kafka的 topic 被分割成了一组完全有序的 partition，其中每一个 partition 在任意给定的时间内只能被每个订阅了这个 topic 的 consumer 组中的一个 consumer 消费。这意味着 partition 中 每一个 consumer 的位置仅仅是一个数字，即下一条要消费的消息的offset。这使得被消费的消息的状态信息相当少，每个 partition 只需要一个数字。这个状态信息还可以作为周期性的 checkpoint。这以非常低的代价实现了和消息确认机制等同的效果。</p><p>这种方式还有一个附加的好处。consumer 可以回退到之前的 offset 来再次消费之前的数据，这个操作违反了队列的基本原则，但事实证明对大多数 consumer 来说这是一个必不可少的特性。 例如，如果 consumer 的代码有 bug，并且在 bug 被发现前已经有一部分数据被消费了， 那么 consumer 可以在 bug 修复后通过回退到之前的 offset 来再次消费这些数据。</p><h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><p>Kafka 对消息的存储和缓存严重依赖于文件系统。现代操作系统提供了 read-ahead 和 write-behind 技术，read-ahead 是以大的 data block 为单位预先读取数据，而 write-behind 是将多个小型的逻辑写合并成一次大型的物理磁盘写入。关于该问题的进一步讨论可以参考 <a href="http://queue.acm.org/detail.cfm?id=1563874" target="_blank" rel="noopener">ACM Queue article</a>，他们发现实际上<a href="http://deliveryimages.acm.org/10.1145/1570000/1563874/jacobs3.jpg" target="_blank" rel="noopener">顺序磁盘访问在某些情况下比随机内存访问还要快</a>！</p><p>这里给出了一个非常简单的设计：相比于维护尽可能多的 in-memory cache，并且在空间不足的时候匆忙将数据 flush 到文件系统，我们把这个过程倒过来。所有数据一开始就被写入到文件系统的持久化日志中，而不用在 cache 空间不足的时候 flush 到磁盘。实际上，这表明数据被转移到了内核的 pagecache 中。 </p><p>使用文件系统和 pagecache 显得更有优势–我们可以通过自动访问所有空闲内存将可用缓存的容量至少翻倍，并且通过存储紧凑的字节结构而不是独立的对象，有望将缓存容量再翻一番。 这样使得32GB的机器缓存容量可以达到28-30GB,并且不会产生额外的 GC 负担。此外，即使服务重新启动，缓存依旧可用，而 in-process cache 则需要在内存中重建(重建一个10GB的缓存可能需要10分钟)，否则进程就要从 cold cache 的状态开始(这意味着进程最初的性能表现十分糟糕)。 这同时也极大的简化了代码，因为所有保持 cache 和文件系统之间一致性的逻辑现在都被放到了 OS 中，这样做比一次性的进程内缓存更准确、更高效。如果你的磁盘使用更倾向于顺序读取，那么 read-ahead 可以有效的使用每次从磁盘中读取到的有用数据预先填充 cache。</p><p><strong>持久化队列可以建立在简单的读取和向文件后追加两种操作之上</strong>，这和日志解决方案相同。这种架构的优点在于所有的操作复杂度都是O(1)，而且读操作不会阻塞写操作，读操作之间也不会互相影响。这有着明显的性能优势，在不产生任何性能损失的情况下能够访问几乎无限的硬盘空间，这意味着我们可以提供一些其它消息系统不常见的特性。例如：在 Kafka 中，我们可以让消息保留相对较长的一段时间(比如一周)，而不是试图在被消费后立即删除。正如我们后面将要提到的，这给消费者带来了很大的灵活性。</p><p><strong>优化</strong></p><ul><li><p>减少数据拷贝<br>使用 sendfile 方法，可以允许操作系统将数据从 pagecache 直接发送到网络，这样避免重新复制数据。所以这种优化方式，只需要最后一步的copy操作，将数据复制到 NIC 缓冲区。pagecache 和 sendfile 的组合使用意味着，在一个kafka集群中，大多数 consumer 消费时，您将看不到磁盘上的读取活动，因为数据将完全由缓存提供。</p></li><li><p>端到端批量压缩<br>Kafka 以高效的批处理格式支持一批消息可以压缩在一起发送到服务器。这批消息将以压缩格式写入，并且在日志中保持压缩，只会在 consumer 消费时解压缩。</p></li></ul><h2 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h2><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>生产者直接发送数据到主分区的服务器上，不需要经过任何中间路由。为了让生产者实现这个功能，所有的 kafka 服务器节点都能响应这样的元数据请求： 哪些服务器是活着的，主题的哪些分区是主分区，分配在哪个服务器上，这样生产者就能适当地直接发送它的请求到服务器上。</p><p><strong>客户端控制消息发送数据到哪个分区，这个可以实现随机的负载均衡方式, 或者使用一些特定语义的分区函数</strong>。 我们有提供特定分区的接口让用于根据指定的键值进行hash分区(当然也有选项可以重写分区函数)，例如，如果使用用户ID作为key，则用户相关的所有数据都会被分发到同一个分区上。</p><h3 id="异步发送"><a href="#异步发送" class="headerlink" title="异步发送"></a>异步发送</h3><p>批处理是提升性能的一个主要驱动，为了允许批量处理，kafka 生产者会尝试<strong>在内存中汇总数据，并用一次请求批次提交信息</strong>。 批处理，不仅仅可以配置指定的<strong>消息数量</strong>，也可以指定等待特定的<strong>延迟时间</strong>(如64k 或10ms)，这允许汇总更多的数据后再发送，在服务器端也会减少更多的IO操作。 该缓冲是可配置的，并给出了一个机制，通过权衡少量额外的延迟时间获取更好的吞吐量。</p><h2 id="消息交互语义"><a href="#消息交互语义" class="headerlink" title="消息交互语义"></a>消息交互语义</h2><p>Kafka可以提供的消息交付语义保证有多种：</p><ul><li><p>At most once——消息可能会丢失但绝不重传。</p></li><li><p>At least once——消息可以重传但绝不丢失。<br>在 0.11.0.0 之前的版本中, 如果 producer 没有收到表明消息已经被提交的响应, 那么 producer 除了将消息重传之外别无选择。 这里提供的是 at-least-once 的消息交付语义，因为如果最初的请求事实上执行成功了，那么重传过程中该消息就会被再次写入到 log 当中。</p></li><li><p>Exactly once——这正是人们想要的, 每一条消息只被传递一次.</p><p>从 0.11.0.0 版本开始，Kafka producer新增了幂等性的传递选项，该选项保证重传不会在 log 中产生重复条目。 为实现这个目的, broker 给每个 producer 都分配了一个 ID ，并且 producer 给每条被发送的消息分配了一个序列号来避免产生重复的消息。 同样也是从 0.11.0.0 版本开始, producer 新增了使用类似事务性的语义将消息发送到多个 topic partition 的功能： 也就是说，要么所有的消息都被成功的写入到了 log，要么一个都没写进去。这种语义的主要应用场景就是 Kafka topic 之间的 exactly-once 的数据传递。</p><p>并非所有使用场景都需要这么强的保证。对于延迟敏感的应用场景，我们允许生产者指定它需要的持久性级别。如果 producer 指定了它想要等待消息被提交，则可以使用10ms的量级。然而， producer 也可以指定它想要完全异步地执行发送，或者它只想等待直到 leader 节点拥有该消息（follower 节点有没有无所谓）。</p><p>现在让我们从 consumer 的视角来描述语义。 </p></li></ul><p>假设 consumer 要读取一些消息——它有几个处理消息和更新位置的选项。</p><ol><li><p>Consumer 可以先读取消息，然后将它的位置保存到 log 中，最后再对消息进行处理。在这种情况下，消费者进程可能会在保存其位置之后，带还没有保存消息处理的输出之前发生崩溃。而在这种情况下，即使在此位置之前的一些消息没有被处理，接管处理的进程将从保存的位置开始。在 consumer 发生故障的情况下，这对应于“at-most-once”的语义，可能会有消息得不到处理。</p></li><li><p>Consumer 可以先读取消息，然后处理消息，最后再保存它的位置。在这种情况下，消费者进程可能会在处理了消息之后，但还没有保存位置之前发生崩溃。而在这种情况下，当新的进程接管后，它最初收到的一部分消息都已经被处理过了。在 consumer 发生故障的情况下，这对应于“at-least-once”的语义。 在许多应用场景中，消息都设有一个主键，所以更新操作是幂等的（相同的消息接收两次时，第二次写入会覆盖掉第一次写入的记录）。</p></li></ol><h2 id="多副本"><a href="#多副本" class="headerlink" title="多副本"></a>多副本</h2><p>创建副本的单位是 topic 的 partition ，正常情况下， 每个分区都有一个 leader 和零或多个 followers 。 总的副本数是包含 leader 的总和。 所有的读写操作都由 leader 处理，一般 partition 的数量都比 broker 的数量多的多，各分区的 leader 均 匀的分布在brokers 中。所有的 followers 节点都同步 leader 节点的日志，日志中的消息和偏移量都和 leader 中的一致。（当然, 在任何给定时间, leader 节点的日志末尾时可能有几个消息尚未被备份完成）。</p><p>Followers 节点就像普通的 consumer 那样从 leader 节点那里拉取消息并保存在自己的日志文件中。Followers 节点可以从 leader 节点那里批量拉取消息日志到自己的日志文件中。</p><p>与大多数分布式系统一样，自动处理故障需要精确定义节点 “alive” 的概念。Kafka 判断节点是否存活有两种方式。</p><ol><li>节点必须可以维护和 ZooKeeper 的连接，Zookeeper 通过心跳机制检查每个节点的连接。</li><li>如果节点是个 follower ，它必须能及时的同步 leader 的写操作，并且延时不能太久。</li></ol><p>我们认为满足这两个条件的节点处于 “in sync” 状态，区别于 “alive” 和 “failed” 。 Leader会追踪所有 “in sync” 的节点。如果有节点挂掉了, 或是写超时, 或是心跳超时, leader 就会把它从同步副本列表中移除。 同步超时和写超时的时间由 replica.lag.time.max.ms 配置确定。</p><p>在所有时间里，Kafka 保证只要有至少一个同步中的节点存活，提交的消息就不会丢失。</p><p>Kafka分配Replica的算法如下：</p><ol><li>将所有Broker（假设共n个Broker）和待分配的Partition排序</li><li>将第i个Partition分配到第（i mod n）个Broker上</li><li>将第i个Partition的第j个Replica分配到第（(i + j) mod n）个Broker上</li></ol><h2 id="可用性和持久性保证"><a href="#可用性和持久性保证" class="headerlink" title="可用性和持久性保证"></a>可用性和持久性保证</h2><p>向 Kafka 写数据时，producers 设置 ack 是否提交完成， </p><ul><li>0：不等待broker返回确认消息,</li><li>1: leader保存成功返回或,</li><li>-1(all): 所有备份都保存成功返回.</li></ul><p>请注意. 设置 “ack = all” 并不能保证所有的副本都写入了消息。默认情况下，当 acks = all 时，只要 ISR 副本同步完成，就会返回消息已经写入。例如，一个 topic 仅仅设置了两个副本，那么只有一个 ISR 副本，那么当设置acks = all时返回写入成功时，剩下了的那个副本数据也可能数据没有写入。 尽管这确保了分区的最大可用性，但是对于偏好数据持久性而不是可用性的一些用户，可能不想用这种策略，因此，我们提供了两个topic 配置，可用于优先配置消息数据持久性：</p><ol><li><p>禁用 unclean leader 选举机制 - 如果所有的备份节点都挂了,分区数据就会不可用，直到最近的 leader 恢复正常。这种策略优先于数据丢失的风险， 参看上一节的 unclean leader 选举机制。</p></li><li><p>指定最小的 ISR 集合大小，只有当 ISR 的大小大于最小值，分区才能接受写入操作，以防止仅写入单个备份的消息丢失造成消息不可用的情况，这个设置只有在生产者使用 acks = all 的情况下才会生效，这至少保证消息被 ISR 副本写入。此设置是一致性和可用性 之间的折衷，对于设置更大的最小ISR大小保证了更好的一致性，因为它保证将消息被写入了更多的备份，减少了消息丢失的可能性。但是，这会降低可用性，因为如果 ISR 副本的数量低于最小阈值，那么分区将无法写入。</p></li></ol><h2 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h2><h3 id="ISR"><a href="#ISR" class="headerlink" title="ISR"></a>ISR</h3><p>Kafka 动态维护了一个同步状态的备份的集合 （a set of in-sync replicas）， 简称 ISR ，在这个集合中的节点都是和 leader 保持高度一致的，只有这个集合的成员才 有资格被选举为 leader，一条消息必须被这个集合 所有 节点读取并追加到日志中了，这条消息才能视为提交。这个 ISR 集合发生变化会在 ZooKeeper 持久化，正因为如此，这个集合中的任何一个节点都有资格被选为 leader 。因为 ISR 模型和 f+1 副本，一个 Kafka topic 冗余 f 个节点故障而不会丢失任何已经提交的消息。</p><p>Kafka 对于数据不会丢失的保证，是基于至少一个节点在保持同步状态，一旦分区上的所有备份节点都挂了，就无法保证了。但是，实际在运行的系统需要去考虑假设一旦所有的备份都挂了，怎么去保证数据不会丢失，这里有两种实现的方法</p><ol><li>等待一个 ISR 的副本重新恢复正常服务，并选择这个副本作为领 leader （它有极大可能拥有全部数据）。</li><li>选择第一个重新恢复正常服务的副本（不一定是 ISR 中的）作为leader。</li></ol><p>kafka 默认选择第二种策略，当所有的 ISR 副本都挂掉时，会选择一个可能不同步的备份作为 leader ，可以配置属性 unclean.leader.election.enable 禁用此策略，那么就会使用第 一种策略即停机时间优于不同步。</p><h3 id="如何选举Leader"><a href="#如何选举Leader" class="headerlink" title="如何选举Leader"></a>如何选举Leader</h3><p>　　最简单最直观的方案是，所有Follower都在Zookeeper上设置一个Watch，一旦Leader宕机，其对应的ephemeral znode会自动删除，此时所有Follower都尝试创建该节点，而创建成功者（Zookeeper保证只有一个能创建成功）即是新的Leader，其它Replica即为Follower。<br>　　但是该方法会有3个问题： 　　</p><ul><li><p>split-brain 这是由Zookeeper的特性引起的，虽然Zookeeper能保证所有Watch按顺序触发，但并不能保证同一时刻所有Replica“看”到的状态是一样的，这就可能造成不同Replica的响应不一致</p></li><li><p>herd effect 如果宕机的那个Broker上的Partition比较多，会造成多个Watch被触发，造成集群内大量的调整</p></li><li><p>Zookeeper负载过重 每个Replica都要为此在Zookeeper上注册一个Watch，当集群规模增加到几千个Partition时Zookeeper负载会过重。</p></li></ul><p>Kafka 0.8.* 的Leader Election方案解决了上述问题，它 <strong>在所有broker中选出一个controller</strong>，所有Partition的Leader选举都由controller决定。controller会将Leader的改变直接通过RPC的方式（比Zookeeper Queue的方式更高效）通知需为此作出响应的Broker。同时controller也负责增删Topic以及Replica的重新分配。如果 controller 节点挂了，其他 存活的 broker 都可能成为新的 controller 节点。</p><p>【更详细的分析可看】<a href="http://www.jasongj.com/2015/04/24/KafkaColumn2/" target="_blank" rel="noopener">Kafka设计解析（二）- Kafka High Availability （上）</a></p><h2 id="Custom-Rebalance"><a href="#Custom-Rebalance" class="headerlink" title="Custom Rebalance"></a>Custom Rebalance</h2><p>Consumer Rebalance 的算法如下：</p><ul><li>将目标 Topic 下的所有 Partirtion 排序，存于 PT</li><li>对某 Consumer Group 下所有 Consumer 排序，存于 CG，第 i 个 Consumer 记为 Ci</li><li>N=size(PT)/size(CG)，向上取整</li><li>解除 Ci 对原来分配的 Partition 的消费权（i 从 0 开始）</li><li>将第 i * N 到（i+1）* N−1 个 Partition 分配给 Ci</li></ul><p>根据 Kafka 社区 wiki，Kafka 作者正在考虑在还未发布的 0.9.x 版本中使用中心协调器 (Coordinator) 。大体思想是为所有 Consumer Group 的子集选举出一个 Broker 作为 Coordinator，由它 Watch Zookeeper，从而判断是否有 Partition 或者 Consumer 的增减，然后生成 Rebalance 命令，并检查是否这些 Rebalance 在所有相关的 Consumer 中被执行成功，如果不成功则重试，若成功则认为此次 Rebalance 成功（这个过程跟 Replication Controller 非常类似）:</p><h3 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h3><ul><li><p>1) Consumer 启动时，先向 Broker 列表中的任意一个 Broker 发送 ConsumerMetadataRequest，并通过 ConsumerMetadataResponse 获取它所在 Group 的 Coordinator 信息。</p></li><li><p>2）Consumer 连接到 Coordinator 并发送 HeartbeatRequest:</p><ul><li><p>如果返回的 HeartbeatResponse 没有任何错误码，Consumer 继续 fetch 数据。</p></li><li><p>若其中包含 IllegalGeneration 错误码，即说明 Coordinator 已经发起了 Rebalance 操作，此时 Consumer 停止 fetch 数据，commit offset，并发送 JoinGroupRequest 给它的 Coordinator，并在 JoinGroupResponse 中获得它应该拥有的所有 Partition 列表和它所属的 Group 的新的 Generation ID。此时 Rebalance 完成，Consumer 开始 fetch 数据。 </p></li></ul></li></ul><h3 id="故障检测机制"><a href="#故障检测机制" class="headerlink" title="故障检测机制"></a>故障检测机制</h3><p>Consumer 成功加入 Group 后，Consumer 和相应的 Coordinator 同时开始故障探测程序。</p><p>Consumer 向 Coordinator 发起周期性的 Heartbeat（HeartbeatRequest）并等待响应，该<br>周期为 session.timeout.ms/heartbeat.frequency。</p><ul><li><p>若 Consumer 在 session.timeout.ms 内未收到 HeartbeatResponse，或者发现相应的 Socket channel 断开，它即认为 Coordinator 已宕机并启动 Coordinator 探测程序。</p></li><li><p>若 Coordinator 在 session.timeout.ms 内没有收到一次 HeartbeatRequest，则它将该 Consumer 标记为宕机状态并为其所在 Group 触发一次 Rebalance 操作。</p></li></ul><p>Coordinator Failover 过程中，Consumer 可能会在新的 Coordinator 完成 Failover 过程之前或之后发现新的 Coordinator 并向其发送 HeatbeatRequest。</p><ul><li><p>对于后者，新的 Cooodinator 可能拒绝该请求，致使该 Consumer 重新探测 Coordinator 并发起新的连接请求。</p></li><li><p>如果该 Consumer 向新的 Coordinator 发送连接请求太晚，新的 Coordinator 可能已经在此之前将其标记为宕机状态而将之视为新加入的 Consumer 并触发一次 Rebalance 操作。 </p></li></ul><h3 id="Coordinator"><a href="#Coordinator" class="headerlink" title="Coordinator"></a>Coordinator</h3><p>1）稳定状态下，Coordinator 通过上述故障探测机制跟踪其所管理的每个 Group 下的每个 Consumer 的健康状态。</p><p>2）刚启动时或选举完成后，Coordinator 从 Zookeeper 读取它所管理的 Group 列表及这些 Group 的成员列表。如果没有获取到 Group 成员信息，它不会做任何事情直到某个 Group 中有成员注册进来。</p><p>3）在 Coordinator 完成加载其管理的 Group 列表及其相应的成员信息之前，它将为 HeartbeatRequest，OffsetCommitRequest 和 JoinGroupRequests 返回 CoordinatorStartupNotComplete 错误码。此时，Consumer 会重新发送请求。</p><p>4）Coordinator 会跟踪被其所管理的任何 Consumer Group 注册的 Topic 的 Partition 的变化，并为该变化触发 Rebalance 操作。创建新的 Topic 也可能触发 Rebalance，因为 Consumer 可以在 Topic 被创建之前就已经订阅它了。</p><p>Coordinator 发起 Rebalance 操作流程如下所示。</p><p><img src="/images/kafka_rebalance.jpg" alt></p><h2 id="Coordinator-Failover"><a href="#Coordinator-Failover" class="headerlink" title="Coordinator Failover"></a>Coordinator Failover</h2><p>如前文所述，Rebalance 操作需要经历如下几个阶段</p><p>1）Topic/Partition 的改变或者新 Consumer 的加入或者已有 Consumer 停止，触发 Coordinator 注册在 Zookeeper 上的 watch，Coordinator 收到通知准备发起 Rebalance 操作。</p><p>2）Coordinator 通过在 HeartbeatResponse 中返回 IllegalGeneration 错误码发起 Rebalance 操作。</p><p>3）Consumer 发送 JoinGroupRequest</p><p>4）Coordinator 在 Zookeeper 中增加 Group 的 Generation ID 并将新的 Partition 分配情况写入 Zookeeper</p><p>5）Coordinator 发送 JoinGroupResponse</p><p>【摘自】<a href="https://www.infoq.cn/article/kafka-analysis-part-4" target="_blank" rel="noopener">Kafka 设计解析（四）：Kafka Consumer 解析</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;Apache Kafka® 是 一个分布式流处理平台.&lt;br&gt;我们知道流处理平台有以下三种特性:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;可以让你发布和订
      
    
    </summary>
    
      <category term="中间件" scheme="http://yoursite.com/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
      <category term="Kafka" scheme="http://yoursite.com/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/Kafka/"/>
    
    
      <category term="kafka" scheme="http://yoursite.com/tags/kafka/"/>
    
      <category term="入门" scheme="http://yoursite.com/tags/%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>Mysql入门</title>
    <link href="http://yoursite.com/2019/09/22/Mysql%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2019/09/22/Mysql入门/</id>
    <published>2019-09-22T10:01:32.000Z</published>
    <updated>2019-11-22T11:36:54.350Z</updated>
    
    <content type="html"><![CDATA[<h2 id="重识Count"><a href="#重识Count" class="headerlink" title="重识Count()"></a>重识Count()</h2><h3 id="COUNT-列名-、COUNT-常量-和COUNT-之间区别"><a href="#COUNT-列名-、COUNT-常量-和COUNT-之间区别" class="headerlink" title="COUNT(列名)、COUNT(常量)和COUNT(*)之间区别"></a>COUNT(列名)、COUNT(常量)和COUNT(*)之间区别</h3><p>前面我们提到过 <code>COUNT(expr)</code> 用于做行数统计，统计的是expr不为NULL的行数，那么 <code>COUNT(列名)</code>、 <code>COUNT(常量)</code> 和 <code>COUNT(*)</code> 这三种语法中，expr分别是<code>列名</code>、 <code>常量</code> 和 <code>*</code>。</p><p>那么<code>列名</code>、 <code>常量</code> 和 <code>*</code> 这三个条件中，<code>常量</code> 是一个固定值，肯定不为NULL。<code>*</code> 可以理解为查询整行，所以肯定也不为NULL，那么就只有<code>列名</code>的查询结果有可能是NULL了。</p><p><strong>所以， COUNT(常量) 和 COUNT(*)表示的是直接查询符合条件的数据库表的行数。而COUNT(列名)表示的是查询符合条件的列的值不为NULL的行数。</strong></p><p>除了查询得到结果集有区别之外，<code>COUNT(*)</code>相比<code>COUNT(常量)</code> 和 <code>COUNT(列名)</code>来讲，<code>COUNT(*)</code>是SQL92定义的标准统计行数的语法，因为他是标准语法，所以MySQL数据库对他进行过很多优化。</p><h3 id="COUNT-的优化"><a href="#COUNT-的优化" class="headerlink" title="COUNT(*)的优化"></a>COUNT(*)的优化</h3><p>MyISAM和InnoDB有很多区别，其中有一个关键的区别和我们接下来要介绍的<code>COUNT(*)</code>有关，那就是:</p><ul><li>MyISAM不支持事务，MyISAM中的锁是表级锁；</li><li>而InnoDB支持事务，并且支持行级锁;</li></ul><p>因为MyISAM的锁是表级锁，同一张表上面的操作需要串行进行，所以，MyISAM做了一个简单的优化:</p><blockquote><p>它可以把表的总行数单独记录下来，如果从一张表中使用<code>COUNT(*)</code>进行查询的时候，可以直接返回这个记录下来的数值就可以了，当然，前提是不能有where条件。</p></blockquote><p>MyISAM之所以可以把表中的总行数记录下来供<code>COUNT(*)</code>查询使用，那是因为MyISAM数据库是表级锁，不会有并发的数据库行数修改，所以查询得到的行数是准确的。</p><p>但是，对于InnoDB来说，就不能做这种缓存操作了，因为InnoDB支持事务，其中大部分操作都是行级锁，所以可能表的行数可能会被并发修改，那么缓存记录下来的总行数就不准确了。</p><p>在InnoDB中，使用<code>COUNT(*)</code>查询行数的时候，不可避免的要进行扫表了，那么，就可以在扫表过程中下功夫来优化效率了。<br>从MySQL 8.0.13开始，针对InnoDB的 <code>SELECT COUNT(*) FROM tbl_name</code> 语句，确实在扫表的过程中做了一些优化。<strong>前提是查询语句中不包含WHERE或GROUP BY等条件。</strong></p><p><strong><code>COUNT(*)</code>的目的只是为了统计总行数，所以，他根本不关心自己查到的具体值，所以，他如果能够在扫表的过程中，选择一个成本较低的索引进行的话，那就可以大大节省时间。</strong></p><p>我们知道，InnoDB中索引分为<code>聚簇索引（主键索引）</code>和<code>非聚簇索引（非主键索引）</code>，聚簇索引的叶子节点中保存的是整行记录，而非聚簇索引的叶子节点中保存的是该行记录的主键的值。</p><blockquote><p>相比之下，非聚簇索引要比聚簇索引小很多，所以MySQL会优先选择最小的非聚簇索引来扫表。所以，当我们建表的时候，除了主键索引以外，创建一个非主键索引还是有必要的。</p></blockquote><p>至此，我们介绍完了MySQL数据库对于COUNT(*)的优化，这些优化的前提都是查询语句中不包含WHERE以及GROUP BY条件。</p><h3 id="COUNT-和COUNT-1"><a href="#COUNT-和COUNT-1" class="headerlink" title="COUNT(*)和COUNT(1)"></a>COUNT(*)和COUNT(1)</h3><p>看下MySQL官方文档是怎么说的：</p><blockquote><p>InnoDB handles SELECT COUNT(*) and SELECT COUNT(1) operations in the same way. There is no performance difference.</p></blockquote><p>画重点：<code>same way , no performance difference</code>。所以，<strong>对于COUNT(1)和COUNT(*)，MySQL的优化是完全一样的，根本不存在谁比谁快！</strong></p><p>建议使用COUNT(*)！因为这个是SQL92定义的标准统计行数的语法。</p><h3 id="COUNT-字段"><a href="#COUNT-字段" class="headerlink" title="COUNT(字段)"></a>COUNT(字段)</h3><p>最后，就是我们一直还没提到的COUNT(字段)，他的查询就比较简单粗暴了，就是进行全表扫描，然后判断指定字段的值是不是为NULL，不为NULL则累加。<br>相比<code>COUNT(*)</code>，<code>COUNT(字段)</code>多了一个步骤就是判断所查询的字段是否为NULL，所以他的性能要比COUNT(*)慢。</p><h2 id="事务及原理"><a href="#事务及原理" class="headerlink" title="事务及原理"></a>事务及原理</h2><p><a href="https://juejin.im/post/5d7dd7e7f265da03d60f2f56?utm_source=gold_browser_extension#heading-1" target="_blank" rel="noopener">Mysql事务及其原理</a></p><h3 id="事务的-ACID-属性"><a href="#事务的-ACID-属性" class="headerlink" title="事务的 ACID 属性"></a>事务的 ACID 属性</h3><ul><li><p><strong>原子性（Atomicity）</strong>：作为逻辑工作单元，一个事务里的所有操作的执行，要么全部成功，要么全部失败。</p></li><li><p><strong>一致性（Consistency）</strong>：数据库从一个一致性状态变换到另外一个一致性状态，数据库的完整性不会受到破坏。</p></li><li><p><strong>隔离性（Isolation）</strong>：通常来说，一个事务所做的修改在最终提交前，对其他事务是不可见的。为什么是通常来说，为了提高事务的并发引出不同的隔离级别，具体参考下一章节。</p></li><li><p><strong>持久性（Durability）</strong>：一旦事务提交，则其所做的修改就会永久保存到数据库中，即使系统故障，修改的数据也不会丢失。</p></li></ul><h3 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h3><p>为了尽可能的高并发，事务的隔离性被分为四个级别：读未提交、读已提交、可重复读和串行化。用户可以根据需要选择不同的级别。</p><ul><li><p><strong>未提交读（READ UNCOMMITTED）</strong>：一个事务还未提交，它的变更就能被别的事务看到。</p><p>  <strong>例</strong>：事务 A 可以读到事务 B 修改的但还未提交的数据，会导致脏读（可能事务 B 在提交后失败了，事务 A 读到的数据是脏的）。</p></li><li><p><strong>提交读（READ COMMITTED）</strong>：一个事务提交后，它的变更才能被其他事务看到。大多数据库系统的默认级别，但 Mysql 不是。</p><p>  <strong>例</strong>：事务 A 只能读到事务 B 修改并提交后的数据，会导致不可重复读（事务 A 中执行两次查询，一次在事务 B 提交过程中，一次在事务 B 提交之后，会导致两次读取的结果不一致）。</p></li><li><p><strong>可重复读（REPEATABLE READ）</strong>：未提交的事务的变更不能被其他事务看到，同时一次事务过程中多次读取同样记录的结果是一致的。</p><p>  <strong>例</strong>：事务 A 在执行过程中多次获取某范围内的记录，事务 B 提交后在此范围内插入或者删除 N条记录，事务 A 执行过程中多次范围读会存在不一致，即幻读（Mysql 的默认级别，InnoDB 通过 MVVC 解决了幻读的问题）。</p></li><li><p><strong>可串行化（SERIALIZABLE）</strong>：当两个事务间存在读写冲突时，数据库通过加锁强制事务串行执行，解决了前面所说的所有问题（脏读、不可重复读、幻读）。是最高隔离的隔离级别。</p></li></ul><p>用表格可以更清晰的描述四种隔离级别的定义和可能存在的问题：<br><img src="/images/mysql_isolate_level.jpg" alt></p><p>以上是对四种隔离级别的定义和初步认识，看<a href="https://juejin.im/post/5c9756296fb9a070ad504a05" target="_blank" rel="noopener">《十分钟搞懂MySQL四种事务隔离级别》</a>这篇文章可以彻底弄清楚他们之间的区别。</p><h2 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li><p><strong>分表 - 解决单表数据过大</strong><br>比如你单表都几千万数据了，你确定你能扛住么？绝对不行，<strong>单表数据量太大，会极大影响你的 sql 执行的性能</strong>，到了后面你的 sql 可能就跑的很慢了。一般来说，就以我的经验来看，单表到几百万的时候，性能就会相对差一些了，你就得分表了。</p><p>  分表就是把一个表的数据放到多个表中，然后查询的时候你就查一个表。比如按照用户 id 来分表，将一个用户的数据就放在一个表中。然后操作的时候你对一个用户就操作那个表就好了。这样可以控制每个表的数据量在可控的范围内，比如每个表就固定在 200 万以内。</p></li><li><p><strong>分库 - 解决单库并发压力太大</strong><br>一个库一般我们经验而言，最多支撑到并发 2000，一定要扩容了，而且一个健康的单库并发值你最好保持在每秒 1000 左右，不要太大。那么你可以<strong>将一个库的数据拆分到多个库中</strong>，访问的时候就访问一个库好了。</p><table><thead><tr><th></th><th>分库分表前</th><th>分库分表后</th></tr></thead><tbody><tr><td>并发支撑情况</td><td>MySQL 单机部署，扛不住高并发</td><td>MySQL从单机到多机，能承受的并发增加了多倍</td></tr><tr><td>磁盘使用情况</td><td>MySQL 单机磁盘容量几乎撑满</td><td>拆分为多个库，数据库服务器磁盘使用率大大降低</td></tr><tr><td>SQL 执行性能</td><td>单表数据量太大，SQL 越跑越慢</td><td>单表数据量减少，SQL 执行效率明显提升</td></tr></tbody></table></li></ul><h3 id="水平拆分"><a href="#水平拆分" class="headerlink" title="水平拆分"></a>水平拆分</h3><p>水平拆分的意思，就是把一个表的数据给弄到<strong>多个库的多个表里</strong>去，但是<strong>每个库的表结构都一样</strong>，只不过每个库表放的数据是不同的，<strong>所有库表的数据加起来就是全部数据</strong>。水平拆分的意义，就是<font color="red"><strong>将数据均匀放更多的库里，然后用多个库来扛更高的并发，还有就是用多个库的存储容量来进行扩容</strong></font>。</p><p><img src="/images/mysql_veri_split.jpg" alt></p><h3 id="垂直拆分"><a href="#垂直拆分" class="headerlink" title="垂直拆分"></a>垂直拆分</h3><p>垂直拆分的意思，就是<strong>把一个有很多字段的表给拆分成多个表，或者是多个库上去</strong>。<strong>每个库表的结构都不一样，每个库表都包含部分字段</strong>。一般来说，<strong>会将较少的访问频率很高的字段放到一个表里去，然后将较多的访问频率很低的字段放到另外一个表里去</strong>。因为数据库是有缓存的，你访问频率高的行字段越少，就可以在缓存里缓存更多的行，性能就越好。这个一般在表层面做的较多一些。<br>    <img src="/images/mysql_horize_split.jpg" alt></p><p>这个其实挺常见的，不一定我说，大家很多同学可能自己都做过，把一个大表拆开，订单表、订单支付表、订单商品表。</p><h3 id="拆表不拆库"><a href="#拆表不拆库" class="headerlink" title="拆表不拆库"></a>拆表不拆库</h3><p>还有<strong>表层面的拆分</strong>，就是分表，将一个表变成 N 个表，就是让每个表的数据量控制在一定范围内，保证 SQL 的性能。否则单表数据量越大，SQL 性能就越差。一般是 200 万行左右，不要太多，但是也得看具体你怎么操作，也可能是 500 万，或者是 100 万。你的SQL越复杂，就最好让单表行数越少。</p><p><strong>分库分表策略</strong></p><ul><li><p>垂直拆分，你可以在表层面来做，对一些字段特别多的表做一下拆分；</p></li><li><p>水平拆分，你可以说是并发承载不了，或者是数据量太大，容量承载不了，你给拆了，按什么字段来拆，你自己想好；</p></li><li><p>分表，你考虑一下，你如果哪怕是拆到每个库里去，并发和容量都 ok 了，但是每个库的表还是太大了，那么你就分表不分库，将这个表分开，保证每个表的数据量并不是很大。</p></li></ul><p>而且这儿还有两种<strong>分库分表的方式</strong>：</p><ul><li><p>按照 range 来分，就是每个库一段连续的数据，这个一般是按比如时间范围来的，但是这种一般较少用。</p><ul><li><p>优点： 扩容的时候很简单，因为你只要预备好，给每个月都准备一个库就可以了，到了一个新的月份的时候，自然而然，就会写新的库了</p></li><li><p>缺点：很容易产生热点问题，大量的流量都打在最新的数据上。实际生产用 range，要看场景；</p></li></ul></li><li><p>按照某个字段 hash 一下均匀分散，这个较为常用。</p><ul><li><p>优点：可以平均分配每个库的数据量和请求压力；</p></li><li><p>缺点：扩容起来比较麻烦，会有一个数据迁移的过程，之前的数据需要重新计算 hash 值重新分配到不同的库或表。</p></li></ul></li></ul><h2 id="分库分表中间件"><a href="#分库分表中间件" class="headerlink" title="分库分表中间件"></a>分库分表中间件</h2><p>比较常见的包括：</p><h3 id="Cobar"><a href="#Cobar" class="headerlink" title="Cobar"></a>Cobar</h3><p>阿里 b2b 团队开发和开源的，属于 proxy 层方案，就是介于应用服务器和数据库服务器之间。应用程序通过 JDBC 驱动访问 Cobar 集群，Cobar 根据 SQL 和分库规则对 SQL 做分解，然后分发到 MySQL 集群不同的数据库实例上执行。早些年还可以用，但是最近几年都没更新了，基本没啥人用，差不多算是被抛弃的状态吧。而且不支持读写分离、存储过程、跨库 join 和分页等操作。</p><h3 id="TDDL"><a href="#TDDL" class="headerlink" title="TDDL"></a>TDDL</h3><p>淘宝团队开发的，属于 client 层方案。支持基本的 crud 语法和读写分离，但不支持 join、多表查询等语法。目前使用的也不多，因为还依赖淘宝的 diamond 配置管理系统。</p><h3 id="Atlas"><a href="#Atlas" class="headerlink" title="Atlas"></a>Atlas</h3><p>360 开源的，属于 proxy 层方案，以前是有一些公司在用的，但是确实有一个很大的问题就是社区最新的维护都在 5 年前了。所以，现在用的公司基本也很少了。</p><h3 id="Sharding-jdbc"><a href="#Sharding-jdbc" class="headerlink" title="Sharding-jdbc"></a>Sharding-jdbc</h3><p>当当开源的，属于 client 层方案，目前已经更名为 ShardingSphere（后文所提到的 Sharding-jdbc，等同于 ShardingSphere）。确实之前用的还比较多一些，因为 SQL 语法支持也比较多，没有太多限制，而且截至 2019.4，已经推出到了 4.0.0-RC1 版本，支持分库分表、读写分离、分布式 id 生成、柔性事务（最大努力送达型事务、TCC 事务）。而且确实之前使用的公司会比较多一些（这个在官网有登记使用的公司，可以看到从 2017 年一直到现在，是有不少公司在用的），目前社区也还一直在开发和维护，还算是比较活跃，个人认为算是一个现在也可以选择的方案。</p><h3 id="Mycat"><a href="#Mycat" class="headerlink" title="Mycat"></a>Mycat</h3><p>基于 Cobar 改造的，属于 proxy 层方案，支持的功能非常完善，而且目前应该是非常火的而且不断流行的数据库中间件，社区很活跃，也有一些公司开始在用了。但是确实相比于 Sharding jdbc 来说，年轻一些，经历的锤炼少一些。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>综上，现在其实建议考量的，就是 <strong>Sharding-jdbc 和 Mycat</strong>，这两个都可以去考虑使用。</p><ul><li><p>Sharding-jdbc </p><ul><li><p>优点： 这种 <strong>client</strong> 层方案的优点在于不用部署，运维成本低，不需要代理层的二次转发请求，性能很高，建议中小型公司选用;</p></li><li><p>缺点： 如果遇到升级啥的需要各个系统都重新升级版本再发布，各个系统都需要耦合 Sharding-jdbc 的依赖；</p></li></ul></li><li><p>Mycat </p><ul><li><p>优点： 对于各个项目是透明的，如果遇到升级之类的都是自己中间件那里搞定就行；</p></li><li><p>优点： 这种 proxy 层方案的缺点在于需要部署，自己运维一套中间件，运维成本高，最好是专门弄个人来研究和维护 Mycat，然后大量项目直接透明使用即;</p></li></ul></li></ul><h2 id="Mysql主从复制"><a href="#Mysql主从复制" class="headerlink" title="Mysql主从复制"></a>Mysql主从复制</h2><h3 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h3><p>其实很简单，就是基于主从复制架构，简单来说，就搞一个主库，挂多个从库，然后我们就单单只是写主库，然后主库会自动把数据给同步到从库上去。</p><h3 id="主从复制原理"><a href="#主从复制原理" class="headerlink" title="主从复制原理"></a>主从复制原理</h3><p>主库将变更写入 binlog 日志，然后从库连接到主库之后，从库有一个 IO 线程，将主库的 binlog 日志拷贝到自己本地，写入一个 relay 中继日志中。接着从库中有一个 SQL 线程会从中继日志读取 binlog，然后执行 binlog 日志中的内容，也就是在自己本地再次执行一遍 SQL，这样就可以保证自己跟主库的数据是一样的。<br><img src="/images/mysql_master_slave_copy.jpg" alt></p><p>这里有一个非常重要的一点，就是<strong>从库同步主库数据的过程是串行化的</strong>，也就是说<strong>主库上并行的操作，在从库上会串行执行</strong>。所以这就是一个非常重要的点了，由于从库从主库拷贝日志以及串行执行 SQL 的特点，在高并发场景下，从库的数据一定会比主库慢一些，是有延时的。所以经常出现，刚写入主库的数据可能是读不到的，要过几十毫秒，甚至几百毫秒才能读取到。</p><p>而且这里还有另外一个问题，就是如果主库突然宕机，然后恰好数据还没同步到从库，那么有些数据可能在从库上是没有的，有些数据可能就丢失了。</p><p>所以 MySQL 实际上在这一块有两个机制，一个是<strong>半同步复制</strong>，用来解决主库数据丢失问题；一个是<strong>并行复制</strong>，用来解决主从同步延时问题。</p><ul><li><p><strong>半同步复制</strong><br>也叫 <strong>semi-sync</strong> 复制，指的就是主库写入 binlog 日志之后，<strong>强制立即</strong>将数据同步到从库，从库将日志写入自己本地的 relay log 之后，接着会返回一个 ack 给主库，主库接收到<strong>至少一个从库的 ack 之后</strong>才会认为写操作完成了；</p></li><li><p><strong>并行复制</strong><br>从库开启多个线程，<strong>并行读取 relay log 中不同库的日志，然后并行重放不同库的日志</strong>，这是<strong>库级别</strong>的并行。</p></li></ul><h3 id="主从同步延时问题"><a href="#主从同步延时问题" class="headerlink" title="主从同步延时问题"></a>主从同步延时问题</h3><p>一般来说，如果主从延迟较为严重，有以下解决方案：</p><ul><li><p><strong>分库，</strong>将一个主库拆分为多个主库，每个主库的写并发就减少了几倍，此时主从延迟可以忽略不计；</p></li><li><p>打开MySQL支持的<strong>并行复制</strong>，多个库并行复制。如果说某个库的写入并发就是特别高，单库写并发达到了 2000/s，并行复制还是没意义；</p></li><li><p>重写代码，写代码的同学，要慎重，插入数据时立马查询可能查不到;</p></li><li><p>如果确实是存在必须先插入，立马要求就查询到，然后立马就要反过来执行一些操作，对这个查询<strong>设置直连主库</strong>。不推荐这种方法，如果这么做，读写分离的意义就丧失了。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;重识Count&quot;&gt;&lt;a href=&quot;#重识Count&quot; class=&quot;headerlink&quot; title=&quot;重识Count()&quot;&gt;&lt;/a&gt;重识Count()&lt;/h2&gt;&lt;h3 id=&quot;COUNT-列名-、COUNT-常量-和COUNT-之间区别&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="Mysql" scheme="http://yoursite.com/categories/Mysql/"/>
    
      <category term="入门" scheme="http://yoursite.com/categories/Mysql/%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="基础" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="Mysql" scheme="http://yoursite.com/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>Redis入门教程</title>
    <link href="http://yoursite.com/2019/09/19/Redis%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/09/19/Redis入门教程/</id>
    <published>2019-09-19T11:22:30.000Z</published>
    <updated>2019-09-23T11:40:10.954Z</updated>
    
    <content type="html"><![CDATA[<h1 id="redis-的线程模型"><a href="#redis-的线程模型" class="headerlink" title="redis 的线程模型"></a>redis 的线程模型</h1><p>redis 内部使用文件事件处理器 <code>file event handler</code>，这个文件事件处理器是单线程的，所以 redis 才叫做单线程的模型。它采用 IO 多路复用机制同时监听多个 socket，将产生事件的 socket 压入内存队列中，事件分派器根据 socket 上的事件类型来选择对应的事件处理器进行处理。</p><p>文件事件处理器的结构包含 4 个部分：</p><ul><li>多个 socket</li><li>IO 多路复用程序</li><li>文件事件分派器</li><li>事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）</li></ul><p>多个 socket 可能会并发产生不同的操作，每个操作对应不同的文件事件，但是 IO 多路复用程序会监听多个 socket，会将产生事件的 socket 放入队列中排队，事件分派器每次从队列中取出一个 socket，根据 socket 的事件类型交给对应的事件处理器进行处理。</p><p>来看客户端与 redis 的一次通信过程：</p><p><img src="/images/redis_communication_process.jpg" alt></p><p>要明白，通信是通过 socket 来完成的，不懂的同学可以先去看一看 socket 网络编程。</p><p>首先，redis 服务端进程初始化的时候，会将 server socket 的 <code>AE_READABLE</code> 事件与连接应答处理器关联。</p><p>客户端 socket01 向 redis 进程的 server socket 请求建立连接，此时 server socket 会产生一个 <code>AE_READABLE</code> 事件，IO 多路复用程序监听到 server socket 产生的事件后，将该 socket 压入队列中。文件事件分派器从队列中获取 socket，交给<strong>连接应答处理器</strong>。连接应答处理器会创建一个能与客户端通信的 socket01，并将该 socket01 的 <code>AE_READABLE</code> 事件与命令请求处理器关联。</p><p>假设此时客户端发送了一个 <code>set key value</code> 请求，此时 redis 中的 socket01 会产生 <code>AE_READABLE</code> 事件，IO 多路复用程序将 socket01 压入队列，此时事件分派器从队列中获取到 socket01 产生的 <code>AE_READABLE</code> 事件，由于前面 socket01 的 <code>AE_READABLE</code> 事件已经与命令请求处理器关联，因此事件分派器将事件交给命令请求处理器来处理。命令请求处理器读取 socket01 的 <code>key value</code> 并在自己内存中完成 <code>key value</code> 的设置。操作完成后，它会将 socket01 的 <code>AE_WRITABLE</code> 事件与命令回复处理器关联。</p><p>如果此时客户端准备好接收返回结果了，那么 redis 中的 socket01 会产生一个 <code>AE_WRITABLE</code> 事件，同样压入队列中，事件分派器找到相关联的命令回复处理器，由命令回复处理器对 socket01 输入本次操作的一个结果，比如 <code>ok</code>，之后解除 socket01 的 <code>AE_WRITABLE</code> 事件与命令回复处理器的关联。</p><p>这样便完成了一次通信。关于 Redis 的一次通信过程，推荐读者阅读《<a href="https://github.com/doocs/technical-books#database" target="_blank" rel="noopener">Redis 设计与实现——黄健宏</a>》进行系统学习。</p><h1 id="redis单线程模型为什么快"><a href="#redis单线程模型为什么快" class="headerlink" title="redis单线程模型为什么快"></a>redis单线程模型为什么快</h1><blockquote><p>1、<strong>完全基于内存</strong>，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)；</p></blockquote><blockquote><p>2、<strong>数据结构简单，对数据操作也简单</strong>，Redis中的数据结构是专门进行设计的；</p></blockquote><blockquote><p>3、采用<strong>单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题</strong>，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；</p></blockquote><blockquote><p>4、<strong>使用多路I/O复用模型，非阻塞IO</strong>；</p></blockquote><blockquote><p>5、使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，<strong>Redis直接自己构建了VM 机制</strong>，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；</p></blockquote><blockquote><p>6、C 语言实现，一般来说，C 语言实现的程序“距离”操作系统更近，执行速度相对会更快。</p></blockquote><p>以上几点都比较好理解，下边我们针对多路 I/O 复用模型进行简单的探讨：</p><p><strong>（1）多路 I/O 复用模型</strong></p><p>多路I/O复用模型是利用 select、poll、epoll 可以同时监察多个流的 I/O 事件的能力，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有 I/O 事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流（epoll 是只轮询那些真正发出了事件的流），并且只依次顺序的处理就绪的流，这种做法就避免了大量的无用操作。</p><p><strong>这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。</strong>采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络 IO 的时间消耗），且 Redis 在内存中操作数据的速度非常快，也就是说内存内的操作不会成为影响Redis性能的瓶颈，主要由以上几点造就了 Redis 具有很高的吞吐量。</p><h1 id="redis持久化"><a href="#redis持久化" class="headerlink" title="redis持久化"></a>redis持久化</h1><h2 id="持久化的两种方式"><a href="#持久化的两种方式" class="headerlink" title="持久化的两种方式"></a>持久化的两种方式</h2><ul><li><strong>RDB</strong>：内存快照，全量；是对 redis 中的数据执行周期性的快照。</li><li><strong>AOF</strong>：对每条写入命令作为日志，以 append-only 的模式写入一个日志文件中，在 redis 重启的时候，可以通过回放 AOF 日志中的写入指令来重新构建整个数据集。类似于mysql的binlog, 存储紧张时会进行压缩，指令合并</li></ul><p>如果 redis 挂了，服务器上的内存和磁盘上的数据都丢了，可以从云服务上拷贝回来之前的数据，放到指定的目录中，然后重新启动 redis，redis 就会自动根据持久化数据文件中的数据，去恢复内存中的数据，继续对外提供服务。</p><p>如果同时使用 RDB 和 AOF 两种持久化机制，那么在 redis 重启的时候，会使用 AOF 来重新构建数据，<strong>因为 AOF 中的数据更加完整</strong>。</p><h2 id="RDB-优缺点"><a href="#RDB-优缺点" class="headerlink" title="RDB 优缺点"></a>RDB 优缺点</h2><p><strong>优点</strong></p><ul><li><p>RDB 会生成多个数据文件，每个数据文件都代表了某一个时刻中 redis 的数据，这种多个数据文件的方式，<strong>非常适合做冷备</strong>，可以将这种完整的数据文件发送到一些远程的安全存储上去，比如说 Amazon 的 S3 云服务上去，在国内可以是阿里云的 ODPS 分布式存储上，以预定好的备份策略来定期备份 redis 中的数据。</p></li><li><p>RDB 对 redis 对外提供的读写服务，影响非常小，<strong>可以让 redis 保持高性能</strong>，因为 redis 主进程只需要 fork 一个子进程，让子进程执行磁盘 IO 操作来进行 RDB 持久化即可。</p></li><li><p>相对于 AOF 持久化机制来说，<strong>直接基于 RDB 数据文件来重启和恢复 redis 进程，更加快速</strong>。</p></li></ul><p><strong>缺点</strong></p><ul><li><p>如果想要在 redis 故障时，尽可能少的丢失数据，那么 RDB 没有 AOF 好。一般来说，RDB 数据快照文件，都是每隔 5 分钟，或者更长时间生成一次，这个时候就得接受一旦 redis 进程宕机，那么会<strong>丢失最近 5 分钟的数据</strong>。</p></li><li><p>RDB 每次在 fork 子进程来执行 RDB 快照数据文件生成的时候，如果<strong>数据文件特别大，可能会导致对客户端提供的服务暂停数毫秒，或者甚至数秒</strong>。</p></li></ul><h2 id="AOF-优缺点"><a href="#AOF-优缺点" class="headerlink" title="AOF 优缺点"></a>AOF 优缺点</h2><p><strong>优点</strong></p><ul><li><p>AOF可以<strong>更好的保护数据不丢失</strong>，一般 AOF 会每隔 1 秒，通过一个后台线程执行一次<strong>fsync</strong>操作，最多丢失 1 秒钟的数据。</p></li><li><p>AOF日志文件<strong>以append-only 模式写入</strong>，所以没有任何磁盘寻址的开销，<strong>写入性能非常高</strong>，而且文件不容易破损，即使文件尾部破损，也很容易修复。</p></li><li><p>AOF日志文件即使过大的时候，出现后台重写操作，也不会影响客户端的读写。因为<strong>在 rewrite log 的时候，会对其中的指令进行压缩，创建出一份需要恢复数据的最小日志出来</strong>。在创建新日志文件的时候，老的日志文件还是照常写入。当新的 merge 后的日志文件 ready 的时候，再交换新老日志文件即可。</p></li><li><p>AOF日志文件的命令通过可读的方式进行记录，这个特性非常适合<strong>做灾难性的误删除的紧急恢复</strong>。比如某人不小心用 flushall 命令清空了所有数据，只要这个时候后台 rewrite 还没有发生，那么就可以立即拷贝 AOF 文件，将最后一条 flushall 命令给删了，然后再将该 AOF 文件放回去，就可以通过恢复机制，自动恢复所有数据。</p></li></ul><p><strong>缺点</strong></p><ul><li><p>对于同一份数据来说，AOF 日志文件通常比 RDB 数据快照文件更大。</p></li><li><p>AOF开启后，<strong>支持的写QPS会比RDB支持的写 QPS 低，</strong>因为 AOF 一般会配置成每秒 fsync 一次日志文件，当然，每秒一次 fsync，性能也还是很高的。（如果实时写入，那么 QPS 会大降，redis 性能会大大降低）</p></li><li><p>以前 AOF 发生过 bug，就是通过 AOF 记录的日志，进行数据恢复的时候，没有恢复一模一样的数据出来。所以说，类似 AOF 这种较为复杂的 <strong>基于命令日志 merge 回放</strong> 的方式，比基于 RDB 每次持久化一份完整的数据快照文件的方式，更加脆弱一些，容易有 bug。不过 AOF 就是为了避免 rewrite 过程导致的 bug，因此<strong>每次 rewrite 并不是基于旧的指令日志进行 merge 的，而是基于当时内存中的数据进行指令的重新构建</strong>，这样健壮性会好很多。</p></li></ul><h2 id="持久化方案"><a href="#持久化方案" class="headerlink" title="持久化方案"></a>持久化方案</h2><ul><li><p>不要仅仅使用 RDB，因为那样会导致你丢失很多数据；</p></li><li><p>也不要仅仅使用 AOF，因为那样有两个问题：第一，你通过 AOF 做冷备，没有 RDB 做冷备来的恢复速度更快；第二，RDB 每次简单粗暴生成数据快照，更加健壮，可以避免 AOF 这种复杂的备份和恢复机制的 bug；</p></li><li><p>redis支持 <strong>同时开启开启两种持久化方式</strong>，我们可以综合使用 AOF 和 RDB 两种持久化机制，<strong>用 AOF 来保证数据不丢失，作为数据恢复的第一选择; 用 RDB 来做不同程度的冷备，在 AOF 文件都丢失或损坏不可用的时候，还可以使用 RDB 来进行快速的数据恢复</strong>。 </p></li></ul><h1 id="redis高并发和高可用"><a href="#redis高并发和高可用" class="headerlink" title="redis高并发和高可用"></a>redis高并发和高可用</h1><p>redis 实现<strong>高并发</strong>主要依靠<strong>主从架构</strong>，一主多从，一般来说，很多项目其实就足够了，单主用来写入数据，单机几万 QPS，从用来查询数据，多个从实例可以提供每秒 10w 的 QPS。</p><p>如果想要在实现高并发的同时，<strong>容纳大量的数据</strong>，那么就需要 <strong>redis 集群</strong>，使用 redis 集群之后，可以提供每秒几十万的读写并发。</p><p>redis高可用，如果是做主从架构部署，那么加上哨兵就可以了，就可以实现，任何一个实例宕机，可以进行主备切换。</p><h2 id="redis主从架构"><a href="#redis主从架构" class="headerlink" title="redis主从架构"></a>redis主从架构</h2><p>单机的 redis，能够承载的 QPS 大概就在上万到几万不等。对于缓存来说，一般都是用来支撑读高并发的。因此架构做成主从(master-slave)架构，一主多从，主负责写，并且将数据复制到其它的 slave 节点，从节点负责读。所有的读请求全部走从节点。这样也可以很轻松实现水平扩容，支撑读高并发。</p><p><img src="/images/redis_master_slave_structure.jpg" alt></p><p>redis replication -&gt; 主从架构 -&gt; 读写分离 -&gt; 水平扩容支撑读高并发</p><h3 id="redis-replication-的核心机制"><a href="#redis-replication-的核心机制" class="headerlink" title="redis replication 的核心机制"></a>redis replication 的核心机制</h3><ul><li><p>redis 采用<strong>异步方式</strong>（master 每次接收到写命令之后，先在内部写入数据，然后异步发送给 slave node）复制数据到 slave 节点，不过 redis2.8 开始，slave node 会周期性地确认自己每次复制的数据量；</p></li><li><p>一个 master node 是可以配置多个 slave node 的；</p></li><li><p>slave node 也可以连接其他的 slave node；</p></li><li><p>slave node 做复制的时候，不会 block master node 的正常工作；</p></li><li><p>slave node 在做复制的时候，也不会 block 对自己的查询操作，它会用旧的数据集来提供服务；但是复制完成的时候，需要删除旧数据集，加载新数据集，这个时候就会暂停对外服务了；</p></li><li><p>slave node 主要用来进行横向扩容，做读写分离，扩容的 slave node 可以提高读的吞吐量。</p></li></ul><p>注意，如果采用了主从架构，那么建议<strong>必须开启 master node 的持久化</strong>，不建议用 slave node 作为 master node 的数据热备，因为那样的话，如果你关掉 master 的持久化，可能在 master 宕机重启的时候数据是空的，然后可能一经过复制， slave node 的数据也丢了。</p><p>另外，master 的各种备份方案，也需要做。万一本地的所有文件丢失了，从备份中挑选一份 rdb 去恢复 master，这样才能<strong>确保启动的时候，是有数据的</strong>，即使采用了后续讲解的高可用机制，slave node 可以自动接管 master node，但也可能 sentinel 还没检测到 master failure，master node 就自动重启了，还是可能导致上面所有的 slave node 数据被清空。</p><h3 id="redis-主从复制的核心原理"><a href="#redis-主从复制的核心原理" class="headerlink" title="redis 主从复制的核心原理"></a>redis 主从复制的核心原理</h3><p>当启动一个 slave node 的时候，它会发送一个 <strong>PSYNC</strong> 命令给 master node。</p><p>如果这是 slave node 初次连接到 master node，那么会触发一次 <strong>full resynchronization</strong> 全量复制：</p><ul><li>（1）master 会启动一个后台线程，开始生成一份 RDB 快照文件，同时还会将从客户端 client 新收到的所有写命令缓存在内存中；</li><li>（2）RDB 文件生成完毕后， master 会将这个 RDB 发送给 slave；</li><li>（3）slave 会先写入本地磁盘，然后再从本地磁盘加载到内存中；</li><li>（4）接着 master 会将内存中缓存的写命令发送到 slave，slave 也会同步这些数据。</li></ul><p>slave node 如果跟 master node 有网络故障，断开了连接，会自动重连，连接之后 master node 仅会复制给 slave 部分缺少的数据。</p><p><img src="/images/redis_m_2_s.jpg" alt></p><h3 id="主从复制的断点续传"><a href="#主从复制的断点续传" class="headerlink" title="主从复制的断点续传"></a>主从复制的断点续传</h3><p>从 redis2.8 开始，就支持<strong>主从复制的断点续传</strong>，如果主从复制过程中，网络连接断掉了，那么可以接着上次复制的地方，继续复制下去，而不是从头开始复制一份。</p><p>master node会 <strong>在内存中维护一个 backlog</strong>，master 和 slave 都会保存一个 replica offset 还有一个 master run id，offset 就是保存在 backlog 中的。如果 master 和 slave 网络连接断掉了，slave 会让 master 从上次 replica offset 开始继续复制，如果没有找到对应的 offset，那么就会执行一次 resynchronization。</p><blockquote><p>如果根据 host+ip 定位 master node，是不靠谱的，如果 master node 重启或者数据出现了变化，那么 slave node 应该根据不同的 run id 区分。</p></blockquote><h3 id="无磁盘化复制"><a href="#无磁盘化复制" class="headerlink" title="无磁盘化复制"></a>无磁盘化复制</h3><p>master 在内存中直接创建 RDB，然后发送给 slave，不会在自己本地落地磁盘了。只需要在配置文件中开启 repl-diskless-sync yes 即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">repl-diskless-sync yes</span><br><span class="line"></span><br><span class="line"># 等待 5s 后再开始复制，因为要等更多 slave 重新连接过来</span><br><span class="line">repl-diskless-sync-delay 5</span><br></pre></td></tr></table></figure><h3 id="复制的完整流程"><a href="#复制的完整流程" class="headerlink" title="复制的完整流程"></a>复制的完整流程</h3><p>slave node 启动时，会在自己本地保存 master node 的信息，包括 master node 的host和ip，但是复制流程没开始。</p><p>slave node 内部有个定时任务，每秒检查是否有新的 master node 要连接和复制，如果发现，就跟 master node 建立 socket 网络连接。然后 slave node 发送 ping 命令给 master node。如果 master 设置了 requirepass，那么 slave node 必须发送 masterauth 的口令过去进行认证。master node 第一次执行全量复制，将所有数据发给 slave node。而在后续，master node 持续将写命令，异步复制给 slave node。</p><p><img src="/images/redis_full_copy_process.jpg" alt></p><h4 id="全量复制"><a href="#全量复制" class="headerlink" title="全量复制"></a>全量复制</h4><ul><li><p>master 执行 bgsave ，在本地生成一份 rdb 快照文件。</p></li><li><p>master node 将 rdb 快照文件发送给 slave node，如果 rdb 复制时间超过 60秒（repl-timeout），那么 slave node 就会认为复制失败，可以适当调大这个参数(对于千兆网卡的机器，一般每秒传输 100MB，6G 文件，很可能超过 60s)</p></li><li><p>master node 在生成 rdb 时，会将所有新的写命令缓存在内存中，在 slave node 保存了 rdb 之后，再将新的写命令复制给 slave node。</p></li><li><p>如果在复制期间，内存缓冲区持续消耗超过 64MB，或者一次性超过 256MB，那么停止复制，复制失败。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client-output-buffer-limit slave 256MB 64MB 60</span><br></pre></td></tr></table></figure></li><li><p>slave node 接收到 rdb 之后，清空自己的旧数据，然后重新加载 rdb 到自己的内存中，同时基于旧的数据版本对外提供服务。</p></li><li><p>如果 slave node 开启了 AOF，那么会立即执行 <strong>BGREWRITEAOF</strong>，重写 AOF。 </p></li></ul><h4 id="增量复制"><a href="#增量复制" class="headerlink" title="增量复制"></a>增量复制</h4><ul><li><p>如果全量复制过程中，master-slave 网络连接断掉，那么 slave 重新连接 master 时，会触发增量复制。</p></li><li><p>master 直接从自己的 backlog 中获取部分丢失的数据，发送给 slave node，默认 backlog 就是 1MB。</p></li><li><p>master 就是根据 slave 发送的 psync 中的 offset 来从 backlog 中获取数据的。</p></li></ul><h4 id="heartbeat"><a href="#heartbeat" class="headerlink" title="heartbeat"></a>heartbeat</h4><p>主从节点互相都会发送 heartbeat 信息。</p><p>master 默认每隔 10秒 发送一次 heartbeat，slave node 每隔 1秒 发送一个 heartbeat。</p><h2 id="redis基于哨兵实现高可用"><a href="#redis基于哨兵实现高可用" class="headerlink" title="redis基于哨兵实现高可用"></a>redis基于哨兵实现高可用</h2><h3 id="哨兵的介绍"><a href="#哨兵的介绍" class="headerlink" title="哨兵的介绍"></a>哨兵的介绍</h3><p>sentinel，中文名是哨兵。哨兵是 redis 集群机构中非常重要的一个组件，主要有以下功能：</p><ul><li><p>集群监控：负责监控 redis master 和 slave 进程是否正常工作。</p></li><li><p>消息通知：如果某个 redis 实例有故障，那么哨兵负责发送消息作为报警通知给管理员。</p></li><li><p>故障转移：如果 master node 挂掉了，会自动转移到 slave node 上。</p></li><li><p>配置中心：如果故障转移发生了，通知 client 客户端新的 master 地址。</p></li></ul><p>哨兵用于实现 redis 集群的高可用，本身也是分布式的，作为一个哨兵集群去运行，互相协同工作。</p><ul><li><p>故障转移时，判断一个 master node 是否宕机了，需要大部分的哨兵都同意才行，涉及到了分布式选举的问题。</p></li><li><p>即使部分哨兵节点挂掉了，哨兵集群还是能正常工作的，因为如果一个作为高可用机制重要组成部分的故障转移系统本身是单点的，那就很很不合理了。</p></li></ul><h3 id="哨兵的核心知识"><a href="#哨兵的核心知识" class="headerlink" title="哨兵的核心知识"></a>哨兵的核心知识</h3><ul><li><p>哨兵至少需要 3 个实例，来保证自己的健壮性。</p></li><li><p>哨兵 + redis 主从的部署架构，是不保证数据零丢失的，只能保证 redis 集群的高可用性。</p></li><li><p>对于哨兵 + redis 主从这种复杂的部署架构，尽量在测试环境和生产环境，都进行充足的测试和演练。</p></li></ul><p>哨兵集群必须部署 2 个以上节点, 经典的 3 节点哨兵集群是这样的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">       +----+</span><br><span class="line">       | M1 |</span><br><span class="line">       | S1 |</span><br><span class="line">       +----+</span><br><span class="line">          |</span><br><span class="line">+----+    |    +----+</span><br><span class="line">| R2 |----+----| R3 |</span><br><span class="line">| S2 |         | S3 |</span><br><span class="line">+----+         +----+</span><br></pre></td></tr></table></figure><p>配置 quorum=2，如果 M1 所在机器宕机了，那么三个哨兵还剩下 2 个，S2 和 S3 可以一致认为 master 宕机了，然后选举出一个来执行故障转移，同时 3 个哨兵的 majority 是 2，所以还剩下的 2 个哨兵运行着，就可以允许执行故障转移.</p><h3 id="redis-哨兵主备切换的数据丢失问题"><a href="#redis-哨兵主备切换的数据丢失问题" class="headerlink" title="redis 哨兵主备切换的数据丢失问题"></a>redis 哨兵主备切换的数据丢失问题</h3><ul><li><p><strong>异步复制导致的数据丢失</strong><br>  因为 master -&gt; slave 的复制是异步的，所以可能有部分数据还没复制到 slave，master 就宕机了，此时这部分数据就丢失了。</p><p>  <img src="/images/redis_ms_switch_lost.jpg" alt></p></li></ul><ul><li><p><strong>脑裂导致的数据丢失</strong><br>脑裂，也就是说，某个 master 所在机器突然脱离了正常的网络，跟其他 slave 机器不能连接，但是实际上 master 还运行着。此时哨兵可能就会认为 master 宕机了，然后开启选举，将其他 slave 切换成了 master。这个时候，集群里就会有两个 master ，也就是所谓的<strong>脑裂</strong>。</p><p>  此时虽然某个 slave 被切换成了 master，但是可能 client 还没来得及切换到新的 master，还继续向旧 master 写数据。<strong>因此旧 master 再次恢复的时候，会被作为一个 slave 挂到新的 master 上去，自己的数据会清空，重新从新的 master 复制数据。</strong>而新的 master 并没有后来 client 写入的数据，因此，这部分数据也就丢失了。</p></li></ul><p><img src="/images/redis_brain_split.jpg" alt>    </p><h3 id="数据丢失问题的解决方案"><a href="#数据丢失问题的解决方案" class="headerlink" title="数据丢失问题的解决方案"></a>数据丢失问题的解决方案</h3><p>进行如下配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">min-slaves-to-write 1  ##  表示要求至少有1个slave</span><br><span class="line">min-slaves-max-lag 10  ##  表示数据复制和同步的延迟不能超过10秒</span><br></pre></td></tr></table></figure><ul><li><p><strong>减少异步复制数据的丢失</strong><br>有了 min-slaves-max-lag 这个配置，就可以确保说，一旦 <strong>slave 复制数据和 ack 延时太长</strong>，超过10s，就认为可能 master 宕机后损失的数据太多了，那么就拒绝写请求，这样可以把 master 宕机时由于部分数据未同步到 slave 导致的数据丢失降低的可控范围内。</p></li><li><p><strong>减少脑裂的数据丢失</strong><br>如果一个 master 出现了脑裂，跟其他 slave 丢了连接，那么上面两个配置可以确保说，如果不能继续给指定数量的 slave 发送数据，而且 slave 超过 10 秒没有给自己 ack 消息，那么就直接拒绝客户端的写请求。因此在脑裂场景下，最多就丢失 10 秒的数据。</p></li></ul><h3 id="sdown-和-odown-转换机制"><a href="#sdown-和-odown-转换机制" class="headerlink" title="sdown 和 odown 转换机制"></a>sdown 和 odown 转换机制</h3><ul><li><p>sdown 是主观宕机，就一个哨兵如果自己觉得一个 master 宕机了，那么就是主观宕机</p></li><li><p>odown 是客观宕机，如果 quorum 数量的哨兵都觉得一个 master 宕机了，那么就是客观宕机</p></li></ul><p>（1）sdown 达成的条件很简单，如果一个哨兵 ping 一个 master，超过了 is-master-down-after-milliseconds 指定的毫秒数之后，就主观认为 master 宕机了；</p><p>（2）如果一个哨兵在指定时间内，收到了 quorum 数量的其它哨兵也认为那个 master 是 sdown 的，那么就认为是 odown 了。</p><h3 id="哨兵集群的自动发现机制"><a href="#哨兵集群的自动发现机制" class="headerlink" title="哨兵集群的自动发现机制"></a>哨兵集群的自动发现机制</h3><ul><li><p>哨兵互相之间的发现，是通过 redis 的 pub/sub 系统实现的，每个哨兵都会往 <strong><code>__sentinel__:hello</code></strong> 这个 channel 里发送一个消息，这时候所有其他哨兵都可以消费到这个消息，并感知到其他的哨兵的存在。</p></li><li><p>每隔两秒钟，每个哨兵都会往自己监控的某个 master+slaves 对应的<strong><code>__sentinel__:hello</code></strong> channel 里发送一个消息，内容是自己的 host、ip 和 runid 还有对这个 master 的监控配置。</p></li><li><p>每个哨兵也会去监听自己监控的每个 master+slaves 对应的 <strong><code>__sentinel__:hello</code></strong> channel，然后去感知到同样在监听这个 master+slaves 的其他哨兵的存在。</p></li><li><p>每个哨兵还会跟其他哨兵交换对 master 的监控配置，互相进行监控配置的同步。</p></li></ul><h3 id="slave-配置的自动纠正"><a href="#slave-配置的自动纠正" class="headerlink" title="slave 配置的自动纠正"></a>slave 配置的自动纠正</h3><p>哨兵会负责自动纠正 slave 的一些配置，比如 slave 如果要成为潜在的 master 候选人，哨兵会确保 slave 复制现有 master 的数据；如果 slave 连接到了一个错误的 master 上，比如故障转移之后，那么哨兵会确保它们连接到正确的 master 上。</p><h3 id="slave-gt-master-选举算法"><a href="#slave-gt-master-选举算法" class="headerlink" title="slave-&gt;master 选举算法"></a>slave-&gt;master 选举算法</h3><p>如果一个 master 被认为 odown 了，而且 majority 数量的哨兵都允许主备切换，那么某个哨兵就会执行主备切换操作，此时首先要选举一个 slave 来，会考虑 slave 的一些信息：</p><ul><li>跟 master 断开连接的时长</li><li>slave 优先级</li><li>复制 offset</li><li>run id</li></ul><p>如果一个 slave 跟 master 断开连接的时间已经超过了 down-after-milliseconds 的 10 倍，外加 master 宕机的时长，那么 slave 就被认为不适合选举为 master。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(down-after-milliseconds * 10) + milliseconds_since_master_is_in_SDOWN_state</span><br></pre></td></tr></table></figure><p>接下来会对 slave 进行排序：</p><ul><li><p>按照 slave 优先级进行排序，slave priority 越低，优先级就越高。</p></li><li><p>如果 slave priority 相同，那么看 replica offset，哪个 slave 复制了越多的数据，offset 越靠后，优先级就越高。</p></li><li><p>如果上面两个条件都相同，那么选择一个 run id 比较小的那个 slave。</p></li></ul><h3 id="quorum-和-majority"><a href="#quorum-和-majority" class="headerlink" title="quorum 和 majority"></a>quorum 和 majority</h3><p>每次一个哨兵要做主备切换，首先需要 quorum 数量的哨兵认为 odown，然后选举出一个哨兵来做切换，这个哨兵还需要得到 majority 哨兵的授权，才能正式执行切换。</p><p>如果 quorum &lt; majority，比如 5 个哨兵，majority 就是 3，quorum 设置为 2，那么就 3 个哨兵授权就可以执行切换。</p><p>但是如果 quorum &gt;= majority，那么必须 quorum 数量的哨兵都授权，比如 5 个哨兵，quorum 是 5，那么必须 5 个哨兵都同意授权，才能执行切换。</p><h3 id="configuration-epoch"><a href="#configuration-epoch" class="headerlink" title="configuration epoch"></a>configuration epoch</h3><p>哨兵会对一套 redis master+slaves 进行监控，有相应的监控的配置。</p><p>执行切换的那个哨兵，会从要切换到的新 master（salve-&gt;master）那里得到一个 <strong>configuration epoch</strong>，这就是一个 version 号，每次切换的 version 号都必须是唯一的。</p><p>如果第一个选举出的哨兵切换失败了，那么其他哨兵，会等待 failover-timeout 时间，然后接替继续执行切换，此时会重新获取一个新的 configuration epoch，作为新的 version 号。</p><h3 id="configuration-传播"><a href="#configuration-传播" class="headerlink" title="configuration 传播"></a>configuration 传播</h3><p>哨兵完成切换之后，会在自己本地更新生成最新的 master 配置，然后同步给其他的哨兵，就是通过之前说的 pub/sub 消息机制。</p><p>这里之前的 version 号就很重要了，因为各种消息都是通过一个 channel 去发布和监听的，所以一个哨兵完成一次新的切换之后，新的 master 配置是跟着新的 version 号的。其他的哨兵都是<strong>根据版本号的大小来更新自己的 master 配置的</strong>。</p><h2 id="redis集群"><a href="#redis集群" class="headerlink" title="redis集群"></a>redis集群</h2><h3 id="集群介绍"><a href="#集群介绍" class="headerlink" title="集群介绍"></a>集群介绍</h3><p>Redis集群是一个提供在多个Redis节点间共享数据的程序集。主要是针对<strong>海量数据+高并发+高可用</strong>的场景。</p><p>Redis集群并不支持处理多个keys的命令, 因为这需要在不同的节点间移动数据, 从而达不到像Redis那样的性能, 在高负载的情况下可能会导致不可预料的错误.</p><p>Redis 集群通过分区来提供一定程度的可用性,在实际环境中当某个节点宕机或者不可达的情况下继续处理命令. Redis 集群的优势:</p><ul><li><p>自动将数据进行分片，每个 master 上放一部分数据</p></li><li><p>提供内置的高可用支持，部分 master 不可用时，还是可以继续工作的</p></li></ul><p>在 redis cluster 架构下，每个 redis 要放开两个端口号，比如一个是 6379，另外一个就是 加1w 的端口号，比如 16379。16379 端口号是用来进行节点间通信的，也就是 cluster bus 的东西，cluster bus 的通信，用来进行<strong>故障检测、配置更新、故障转移授权</strong>。</p><p>cluster bus 用了另外一种二进制的协议，gossip 协议，用于节点间进行高效的数据交换，占用更少的网络带宽和处理时间。</p><h3 id="节点间的内部通信机制"><a href="#节点间的内部通信机制" class="headerlink" title="节点间的内部通信机制"></a>节点间的内部通信机制</h3><h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><p>集群元数据的维护采用Gossip协议，所有节点都持有一份元数据，不同的节点如果出现了元数据的变更，就不断将元数据发送给其它的节点，让其它节点也进行元数据的变更。</p><ul><li><p>gossip好处在于，元数据的更新比较分散，不是集中在一个地方，更新请求会陆陆续续打到所有节点上去更新，降低了压力；</p></li><li><p>不好在于，元数据的更新有延时，可能导致集群中的一些操作会有一些滞后；</p><ul><li><p>10000端口：每个节点都有一个专门用于节点间通信的端口，就是自己提供服务的端口号+10000，比如 7001，那么用于节点间通信的就是 17001 端口。每个节点每隔一段时间都会往另外几个节点发送 ping 消息，同时其它几个节点接收到 ping 之后返回 pong。</p></li><li><p>交换的信息：信息包括故障信息，节点的增加和删除，hash slot 信息等等。</p></li></ul></li></ul><h4 id="gossip-协议"><a href="#gossip-协议" class="headerlink" title="gossip 协议"></a>gossip 协议</h4><p>gossip 协议包含多种消息，包含 ping,pong,meet,fail 等等。</p><ul><li>meet：某个节点发送 meet 给新加入的节点，让新节点加入集群中，然后新节点就会开始与其它节点进行通信。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-trib.rb add-node</span><br></pre></td></tr></table></figure></li></ul><p>其实内部就是发送了一个 gossip meet 消息给新加入的节点，通知那个节点去加入我们的集群。</p><ul><li><p>ping：每个节点都会频繁给其它节点发送 ping，其中包含自己的状态还有自己维护的集群元数据，互相通过 ping 交换元数据。</p></li><li><p>pong：返回 ping 和 meeet，包含自己的状态和其它信息，也用于信息广播和更新。</p></li><li><p>fail：某个节点判断另一个节点 fail 之后，就发送 fail 给其它节点，通知其它节点说，某个节点宕机了。</p></li></ul><h4 id="ping-消息深入"><a href="#ping-消息深入" class="headerlink" title="ping 消息深入"></a>ping 消息深入</h4><p>ping 时要携带一些元数据，如果很频繁，可能会加重网络负担。</p><p>每个节点<strong>每秒会执行 10 次 ping</strong>，每次会选择 5 个最久没有通信的其它节点。当然如果发现某个节点通信延时达到了 cluster_node_timeout / 2，那么立即发送 ping，避免数据交换延时过长，落后的时间太长了。比如说，两个节点之间都 10 分钟没有交换数据了，那么整个集群处于严重的元数据不一致的情况，就会有问题。所以 cluster_node_timeout 可以调节，如果调得比较大，那么会降低 ping 的频率。</p><p>每次 ping，<strong>会带上自己节点的信息，还有就是带上 1/10 其它节点的信息</strong>，发送出去，进行交换。至少包含 3 个其它节点的信息，最多包含 总节点数减 2 个其它节点的信息。</p><h3 id="Redis-集群的数据分片"><a href="#Redis-集群的数据分片" class="headerlink" title="Redis 集群的数据分片"></a>Redis 集群的数据分片</h3><p>Redis 集群引入了 哈希槽的概念.</p><p>Redis 集群有<strong>16384</strong>个哈希槽,每个key通过<strong>CRC16校验</strong>后对16384取模来决定放置哪个槽.集群的每个节点负责一部分hash槽,举个例子,比如当前集群有3个节点,那么:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">节点 A 包含 0 到 5500号哈希槽.</span><br><span class="line">节点 B 包含5501 到 11000 号哈希槽.</span><br><span class="line">节点 C 包含11001 到 16384号哈希槽.</span><br></pre></td></tr></table></figure><p>这种结构很容易添加或者删除节点. 比如如果我想新添加个节点D, 我需要从节点 A, B, C中得部分槽到D上. 如果我想移除节点A,需要将A中的槽移到B和C节点上,然后将没有任何槽的A节点从集群中移除即可. 由于从一个节点将哈希槽移动到另一个节点并不会停止服务,所以无论添加删除或者改变某个节点的哈希槽的数量都不会造成集群不可用的状态.</p><h3 id="redis-cluster-的高可用与主备切换原理"><a href="#redis-cluster-的高可用与主备切换原理" class="headerlink" title="redis cluster 的高可用与主备切换原理"></a>redis cluster 的高可用与主备切换原理</h3><p>redis cluster 的高可用的原理，几乎跟哨兵是类似的。</p><h4 id="判断节点宕机"><a href="#判断节点宕机" class="headerlink" title="判断节点宕机"></a>判断节点宕机</h4><p>如果一个节点认为另外一个节点宕机，那么就是 pfail，主观宕机。如果多个节点都认为另外一个节点宕机了，那么就是 fail，客观宕机，跟哨兵的原理几乎一样，sdown，odown。</p><p>在 cluster-node-timeout 内，某个节点一直没有返回 pong，那么就被认为 pfail。</p><p>如果一个节点认为某个节点 pfail 了，那么会在 gossip ping 消息中，ping 给其他节点，如果超过半数的节点都认为 pfail 了，那么就会变成 fail。</p><h4 id="从节点过滤"><a href="#从节点过滤" class="headerlink" title="从节点过滤"></a>从节点过滤</h4><p>对宕机的 master node，从其所有的 slave node 中，选择一个切换成 master node。</p><p>检查每个 slave node 与 master node 断开连接的时间，如果超过了 <code>cluster-node-timeout * cluster-slave-validity-factor</code>，那么就没有资格切换成 master。</p><h4 id="从节点选举"><a href="#从节点选举" class="headerlink" title="从节点选举"></a>从节点选举</h4><p>每个从节点，都根据自己对 master 复制数据的 offset，来设置一个选举时间，offset 越大（复制数据越多）的从节点，选举时间越靠前，优先进行选举。</p><p>所有的 master node 开始 slave 选举投票，给要进行选举的 slave 进行投票，如果大部分 master node（N/2 + 1）都投票给了某个从节点，那么选举通过，那个从节点可以切换成 master。</p><p>从节点执行主备切换，从节点切换为主节点。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;redis-的线程模型&quot;&gt;&lt;a href=&quot;#redis-的线程模型&quot; class=&quot;headerlink&quot; title=&quot;redis 的线程模型&quot;&gt;&lt;/a&gt;redis 的线程模型&lt;/h1&gt;&lt;p&gt;redis 内部使用文件事件处理器 &lt;code&gt;file event
      
    
    </summary>
    
      <category term="中间件" scheme="http://yoursite.com/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
      <category term="Redis" scheme="http://yoursite.com/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="入门" scheme="http://yoursite.com/tags/%E5%85%A5%E9%97%A8/"/>
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>常用消息队列简介</title>
    <link href="http://yoursite.com/2019/09/05/%E5%B8%B8%E7%94%A8%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%AE%80%E4%BB%8B/"/>
    <id>http://yoursite.com/2019/09/05/常用消息队列简介/</id>
    <published>2019-09-05T12:30:48.000Z</published>
    <updated>2019-10-09T08:17:04.075Z</updated>
    
    <content type="html"><![CDATA[<h2 id="消息队列常见场景"><a href="#消息队列常见场景" class="headerlink" title="消息队列常见场景"></a>消息队列常见场景</h2><p>消息队列常见的使用场景比较核心的有 4 个：解耦、异步、削峰、分布式事务。</p><h3 id="解耦"><a href="#解耦" class="headerlink" title="解耦"></a>解耦</h3><p><img src="/images/mq_application.jpg" alt></p><p>通过一个 MQ，Pub/Sub 发布订阅消息这么一个模型，A 系统就跟其它系统彻底解耦了。</p><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p>看一个场景，A 系统接收一个请求，需要在自己本地写库，还需要在 BCD 三个系统写库，自己本地写库要 3ms，BCD 三个系统分别写库要 300ms、450ms、200ms。最终请求总延时是 3 + 300 + 450 + 200 = 953ms，接近 1s，用户感觉搞个什么东西，慢死了慢死了。用户通过浏览器发起请求，等待个 1s，这几乎是不可接受的。<br>使用 MQ，那么 A 系统连续发送 3 条消息到 MQ 队列中，假如耗时 5ms，A 系统从接受一个请求到返回响应给用户，总时长是 3 + 5 = 8ms，对于用户而言，其实感觉上就是点个按钮，8ms 以后就直接返回了。</p><p><img src="/images/mq_async_application.jpg" alt></p><h3 id="削峰"><a href="#削峰" class="headerlink" title="削峰"></a>削峰</h3><p>每天 0:00 到 12:00，A 系统风平浪静，每秒并发请求数量就 50 个。结果每次一到 12:00 ~ 13:00 ，每秒并发请求数量突然会暴增到 5k+ 条。但是系统是直接基于 MySQL 的，大量的请求涌入 MySQL，每秒钟对 MySQL 执行约 5k 条 SQL。一般的 MySQL，扛到每秒 2k 个请求就差不多了，如果每秒请求到 5k 的话，可能就直接把 MySQL 给打死了，导致系统崩溃，用户也就没法再使用系统了。<br>但是高峰期一过，到了下午的时候，就成了低峰期，可能也就 1w 的用户同时在网站上操作，每秒中的请求数量可能也就 50 个请求，对整个系统几乎没有任何的压力。<br>使用 MQ，每秒 5k 个请求写入 MQ，A 系统每秒钟最多处理 2k 个请求，因为 MySQL 每秒钟最多处理 2k 个。A 系统从 MQ 中慢慢拉取请求，每秒钟就拉取 2k 个请求，不要超过自己每秒能处理的最大请求数量就 ok，这样下来，哪怕是高峰期的时候，A 系统也绝对不会挂掉。而 MQ 每秒钟 5k 个请求进来，就 2k 个请求出去，结果就导致在中午高峰期（1 个小时），可能有几十万甚至几百万的请求积压在 MQ 中。这个短暂的高峰期积压是 ok 的，因为高峰期过了之后，每秒钟就 50 个请求进 MQ，但是 A 系统依然会按照每秒 2k 个请求的速度在处理。所以说，只要高峰期一过，A 系统就会快速将积压的消息给解决掉。</p><p><img src="/images/mq_xuefeng.jpg" alt></p><h3 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h3><p><img src="/images/mq_distributed_transaction.jpg" alt></p><p>发送消息开启确认发布机制，MQ收到后会返回回执，超时未收到回执，发送方可重新发送；<br>消费者开启手动ack模式，控制消息的重发、清楚、丢弃，保证数据可靠处理。</p><h2 id="队列高可用"><a href="#队列高可用" class="headerlink" title="队列高可用"></a>队列高可用</h2><p><a href="https://blog.csdn.net/lyhkmm/article/details/78775369" target="_blank" rel="noopener">RabbitMq入门以及使用教程</a> </p><p><a href="https://learnku.com/articles/27446" target="_blank" rel="noopener">RabbitMQ 的应用场景以及基本原理介绍</a></p><h3 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h3><p>两种集群模式</p><h4 id="普通模式"><a href="#普通模式" class="headerlink" title="普通模式"></a>普通模式</h4><p>默认的集群模式。</p><p> <img src="/images/rabbit_mq_cluster.jpg" alt></p><ul><li><p>场景1、客户端直接连接队列所在节点<br>如果有一个消息生产者或者消息消费者通过amqp-client的客户端连接至节点1进行消息的发布或者订阅，那么此时的集群中的消息收发只与节点1相关，这个没有任何问题；</p></li><li><p>场景2、客户端连接的是非队列数据所在节点<br>如果消息生产者所连接的是节点2或者节点3，此时队列1的完整数据不在该两个节点上，那么在发送消息过程中这两个节点主要起了一个路由转发作用，根据这两个节点上的元数据（也就是上文提到的：指向queue的owner node的指针）转发至节点1上，最终发送的消息还是会存储至节点1的队列1上。<br>同样，如果消息消费者所连接的节点2或者节点3，那这两个节点也会作为路由节点起到转发作用，将会从节点1的队列1中拉取消息进行消费。</p></li></ul><p>特点：</p><ul><li><ol><li>非高可用</li></ol></li><li><ol start="2"><li>主要是提高吞吐量的</li></ol></li></ul><h4 id="镜像模式"><a href="#镜像模式" class="headerlink" title="镜像模式"></a>镜像模式</h4><p>把需要的队列做成镜像队列，存在于多个节点，属于RabbitMQ的HA方案<br>跟普通集群模式不一样的是，在镜像集群模式下，你创建的 queue，无论元数据还是 queue 里的消息都会存在于多个实例上，就是说，每个 RabbitMQ 节点都有这个 queue 的一个完整镜像，包含 queue 的全部数据的意思。然后每次你写消息到 queue 的时候，都会自动把消息同步到多个实例的 queue 上。</p><p><img src="/images/rabbitmq_image_cluster.jpg" alt></p><p>这样的话，好处在于，你任何一个机器宕机了，没事儿，其它机器（节点）还包含了这个 queue 的完整数据，别的 consumer 都可以到其它节点上去消费数据。坏处在于，第一，这个性能开销也太大了吧，消息需要同步到所有机器上，导致网络带宽压力和消耗很重！第二，这么玩儿，不是分布式的，就没有扩展性可言了，如果某个 queue 负载很重，你加机器，新增的机器也包含了这个 queue 的所有数据，并没有办法线性扩展你的 queue。</p><h4 id="高可用分布式集群"><a href="#高可用分布式集群" class="headerlink" title="高可用分布式集群"></a>高可用分布式集群</h4><p><img src="/images/rabbit_ha_cluster.jpg" alt></p><p>基于镜像模式，对于消息的生产和消费者可以通过HAProxy的软负载将请求分发至RabbitMQ集群中的Node1～Node7节点，其中Node8～Node10的三个节点作为磁盘节点保存集群元数据和配置信息。</p><h2 id="消息不丢失"><a href="#消息不丢失" class="headerlink" title="消息不丢失"></a>消息不丢失</h2><h3 id="RabbitMQ-1"><a href="#RabbitMQ-1" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h3><p><img src="/images/rabbitmq_ms_not_missing.jpg" alt></p><h3 id="Kafaka"><a href="#Kafaka" class="headerlink" title="Kafaka"></a>Kafaka</h3><ul><li><p>消费者:<br>关闭自动提交 offset，在处理完之后自己手动提交offset；</p></li><li><p>kafka:设置如下 4 个参数：</p><ul><li><p>给 topic 设置 replication.factor 参数：这个值必须大于 1，要求每个 partition 必须有至少 2 个副本。</p></li><li><p>在 Kafka 服务端设置 min.insync.replicas 参数：这个值必须大于 1，这个是要求一个 leader 至少感知到有至少一个 follower 还跟自己保持联系，没掉队，这样才能确保 leader 挂了还有一个 follower 吧。</p></li><li><p>在 producer 端设置 acks=all：这个是要求每条数据，必须是写入所有 replica 之后，才能认为是写成功了。</p></li><li><p>在 producer 端设置 retries=MAX（很大很大很大的一个值，无限次重试的意思）：这个是要求一旦写入失败，就无限重试，卡在这里了。</p></li></ul></li><li><p>生产者:<br>如果按照上述的思路设置了 acks=all，一定不会丢，要求是，你的 leader 接收到消息，所有的 follower 都同步到了消息之后，才认为本次写成功了。如果没满足这个条件，生产者会自动不断的重试，重试无限次。</p></li></ul><h2 id="消息顺序性"><a href="#消息顺序性" class="headerlink" title="消息顺序性"></a>消息顺序性</h2><h3 id="场景描述"><a href="#场景描述" class="headerlink" title="场景描述"></a>场景描述</h3><p>举个例子，数据从一个 mysql 库原封不动地同步到另一个 mysql 库里面去（mysql -&gt; mysql）。常见的一点在于说比如大数据 team，就需要同步一个 mysql 库过来，对公司的业务系统的数据做各种复杂的操作。</p><p>你在 mysql 里增删改一条数据，对应出来了增删改 3 条 <code>binlog</code> 日志，接着这三条 <code>binlog</code> 发送到 MQ 里面，再消费出来依次执行，起码得保证人家是按照顺序来的吧？不然本来是：增加、修改、删除；你楞是换了顺序给执行成删除、修改、增加，不全错了么。</p><p>本来这个数据同步过来，应该最后这个数据被删除了；结果你搞错了这个顺序，最后这个数据保留下来了，数据同步就出错了。</p><p>先看看顺序会错乱的俩场景：</p><ul><li><strong>RabbitMQ</strong>：一个 queue，多个 consumer。比如，生产者向 RabbitMQ 里发送了三条数据，顺序依次是 data1/data2/data3，压入的是 RabbitMQ 的一个内存队列。有三个消费者分别从 MQ 中消费这三条数据中的一条，结果消费者2先执行完操作，把 data2 存入数据库，然后是 data1/data3。这不明显乱了。</li></ul><p><img src="/images/rabbit_mq_sequence_error.jpg" alt></p><ul><li><strong>Kafka</strong>：比如说我们建了一个 topic，有三个 partition。生产者在写的时候，其实可以指定一个 key，比如说我们指定了某个订单 id 作为 key，那么这个订单相关的数据，一定会被分发到同一个 partition 中去，而且这个 partition 中的数据一定是有顺序的。<br>消费者从 partition 中取出来数据的时候，也一定是有顺序的。到这里，顺序还是 ok 的，没有错乱。接着，我们在消费者里可能会搞<strong>多个线程来并发处理消息</strong>。因为如果消费者是单线程消费处理，而处理比较耗时的话，比如处理一条消息耗时几十 ms，那么 1 秒钟只能处理几十条消息，这吞吐量太低了。而多个线程并发跑的话，顺序可能就乱掉了。</li></ul><p><img src="/images/kafka_squence_error.jpg" alt></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="RabbitMQ-2"><a href="#RabbitMQ-2" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h4><p>拆分多个 queue，每个 queue 一个 consumer，就是多一些 queue 而已，确实是麻烦点；或者就一个 queue 但是对应一个 consumer，然后这个 consumer 内部用内存队列做排队，然后分发给底层不同的 worker 来处理。</p><p><img src="/images/rabbit_mq_sq_resover.jpg" alt></p><h4 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h4><ul><li>一个 topic，一个 partition，一个 consumer，内部单线程消费，单线程吞吐量太低，一般不会用这个。</li><li>写 N 个内存 queue，具有相同 key 的数据都到同一个内存 queue；然后对于 N 个线程，每个线程分别消费一个内存 queue 即可，这样就能保证顺序性。</li></ul><p><img src="/images/kafka_sq_resover.jpg" alt></p><h2 id="常见消息队列对比"><a href="#常见消息队列对比" class="headerlink" title="常见消息队列对比"></a>常见消息队列对比</h2><table><thead><tr><th>特性</th><th>ActiveMQ</th><th>RabbitMQ</th><th>RocketMQ</th><th>Kafka</th></tr></thead><tbody><tr><td>单机吞吐量</td><td>万级，比 RocketMQ、Kafka 低一个数量级</td><td>同 ActiveMQ</td><td>10 万级，支撑高吞吐</td><td>10 万级，高吞吐，一般配合大数据类的系统来进行实时数据计算、日志采集等场景</td></tr><tr><td>topic 数量对吞吐量的影响</td><td></td><td></td><td>topic 可以达到几百/几千的级别，吞吐量会有较小幅度的下降，这是 RocketMQ 的一大优势，在同等机器下，可以支撑大量的 topic</td><td>topic 从几十到几百个时候，吞吐量会大幅度下降，在同等机器下，Kafka 尽量保证 topic 数量不要过多，如果要支撑大规模的 topic，需要增加更多的机器资源</td></tr><tr><td>时效性</td><td>ms 级</td><td>微秒级，这是 RabbitMQ 的一大特点，延迟最低</td><td>ms 级</td><td>延迟在 ms 级以内</td></tr><tr><td>可用性</td><td>高，基于主从架构实现高可用</td><td>同 ActiveMQ</td><td>非常高，分布式架构</td><td>非常高，分布式，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用</td></tr><tr><td>消息可靠性</td><td>有较低的概率丢失数据</td><td>基本不丢</td><td>经过参数优化配置，可以做到 0 丢失</td><td>同 RocketMQ</td></tr><tr><td>功能支持</td><td>MQ 领域的功能极其完备</td><td>基于 erlang 开发，并发能力很强，性能极好，延时很低</td><td>MQ 功能较为完善，还是分布式的，扩展性好</td><td>功能较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及日志采集被大规模使用</td></tr></tbody></table><p>综上，各种对比之后，有如下建议：</p><ul><li><p>一般的业务系统要引入 MQ，最早大家都用 ActiveMQ，但是现在确实大家用的不多了，没经过大规模吞吐量场景的验证，社区也不是很活跃，不推荐用这个了；</p></li><li><p>后来大家开始用 RabbitMQ，但是确实 erlang 语言阻止了大量的 Java 工程师去深入研究和掌控它，对公司而言，几乎处于不可控的状态，但是确实人家是开源的，比较稳定的支持，活跃度也高；</p></li><li><p>现在确实越来越多的公司会去用 RocketMQ，确实很不错，毕竟是阿里出品，但社区可能有突然黄掉的风险（目前 RocketMQ 已捐给 <a href="https://github.com/apache/rocketmq" target="_blank" rel="noopener">Apache</a>，但 GitHub 上的活跃度其实不算高）对自己公司技术实力有绝对自信的，推荐用 RocketMQ，否则回去老老实实用 RabbitMQ 吧，人家有活跃的开源社区，绝对不会黄。</p></li><li><p>所以<strong>中小型公司</strong>，技术实力较为一般，技术挑战不是特别高，用 RabbitMQ 是不错的选择；<strong>大型公司</strong>，基础架构研发实力较强，用 RocketMQ 是很好的选择。</p></li><li><p>如果是<strong>大数据领域</strong>的实时计算、日志采集等场景，用 Kafka 是业内标准的，绝对没问题，社区活跃度很高，绝对不会黄，何况几乎是全世界这个领域的事实性规范。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;消息队列常见场景&quot;&gt;&lt;a href=&quot;#消息队列常见场景&quot; class=&quot;headerlink&quot; title=&quot;消息队列常见场景&quot;&gt;&lt;/a&gt;消息队列常见场景&lt;/h2&gt;&lt;p&gt;消息队列常见的使用场景比较核心的有 4 个：解耦、异步、削峰、分布式事务。&lt;/p&gt;
&lt;h3 
      
    
    </summary>
    
      <category term="中间件" scheme="http://yoursite.com/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
      <category term="消息队列" scheme="http://yoursite.com/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
      <category term="入门" scheme="http://yoursite.com/tags/%E5%85%A5%E9%97%A8/"/>
    
      <category term="消息队列" scheme="http://yoursite.com/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot集成Mybatis</title>
    <link href="http://yoursite.com/2019/08/29/Spring-Boot%E9%9B%86%E6%88%90Mybatis/"/>
    <id>http://yoursite.com/2019/08/29/Spring-Boot集成Mybatis/</id>
    <published>2019-08-29T12:53:01.000Z</published>
    <updated>2019-09-23T12:07:39.443Z</updated>
    
    <content type="html"><![CDATA[<p>SpringBoot 整合 Mybatis 有两种常用的方式，一种就是我们常见的 xml 的方式 ，还有一种是全注解的方式。我觉得这两者没有谁比谁好，在 SQL 语句不太长的情况下，我觉得全注解的方式一定是比较清晰简洁的。但是，复杂的 SQL 确实不太适合和代码写在一起。</p><p>下面记录一下配置过程：</p><h2 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h2><p>创建一个spring boot的maven工程, pom核心内容如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mysql.version</span>&gt;</span>5.1.46<span class="tag">&lt;/<span class="name">mysql.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mybatis.version</span>&gt;</span>1.3.5<span class="tag">&lt;/<span class="name">mybatis.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--msyql核心驱动--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mysql.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--这个是官方的mybatis依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mybatis.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.generator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-generator-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">id</span>&gt;</span>mybatis-generator<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">phase</span>&gt;</span>deploy<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>generate<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- Mybatis-Generator 工具配置文件的位置 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configurationFile</span>&gt;</span>src/main/resources/mybatis-generator/generatorConfig.xml<span class="tag">&lt;/<span class="name">configurationFile</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">verbose</span>&gt;</span>true<span class="tag">&lt;/<span class="name">verbose</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">overwrite</span>&gt;</span>true<span class="tag">&lt;/<span class="name">overwrite</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 这个是自动生成mapper等的依赖，必须得加--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.generator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-generator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mybatis.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--这个是自动生成mapper等的依赖，必须得加--&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--https://mvnrepository.com/artifact/org.mybatis.generator/mybatis-generator-core--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.generator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-generator-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mybatis.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mysql.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>application.properties</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">## mapper xml 文件地址</span><br><span class="line">mybatis.mapper-locations=classpath*:mapper/*Mapper.xml</span><br><span class="line"></span><br><span class="line">#数据库设置</span><br><span class="line">spring.datasource.type=com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">##数据库url</span><br><span class="line">spring.datasource.url=jdbc:mysql://127.0.0.1:3306/test?characterEncoding=utf8&amp;useSSL=false</span><br><span class="line">##数据库用户名</span><br><span class="line">spring.datasource.username=xxxx</span><br><span class="line">##数据库密码</span><br><span class="line">spring.datasource.password=xxxx</span><br><span class="line">##数据库驱动</span><br><span class="line">spring.datasource.driver-class-name=com.mysql.jdbc.Driver</span><br><span class="line"></span><br><span class="line"># Mybatis Generator configuration</span><br><span class="line"># dao类和实体类的位置</span><br><span class="line">mybatis.project =src/main/java</span><br><span class="line"># mapper文件的位置</span><br><span class="line">mybatis.resources=src/main/resources</span><br></pre></td></tr></table></figure><h2 id="自动生成xml方式"><a href="#自动生成xml方式" class="headerlink" title="自动生成xml方式"></a>自动生成xml方式</h2><h3 id="generatorConfig配置"><a href="#generatorConfig配置" class="headerlink" title="generatorConfig配置"></a>generatorConfig配置</h3><p>在src/main/resource下创建mybatis-generator文件夹，在文件夹下创建generatorConfig.xml文件，制定generator生成规则：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE generatorConfiguration</span></span><br><span class="line"><span class="meta">        PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN"</span></span><br><span class="line"><span class="meta">        "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置生成器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">generatorConfiguration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--执行generator插件生成文件的命令： call mvn mybatis-generator:generate -e --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 引入配置文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">"application.properties"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--classPathEntry:数据库的JDBC驱动,换成你自己的驱动位置 可选 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;classPathEntry location="~/Downloads/mysql-connector-java-5.1.24-bin.jar"/&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 一个数据库一个context --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--defaultModelType="flat" 大数据字段，不分表 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context</span> <span class="attr">id</span>=<span class="string">"MysqlTables"</span> <span class="attr">targetRuntime</span>=<span class="string">"MyBatis3Simple"</span> <span class="attr">defaultModelType</span>=<span class="string">"flat"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 自动识别数据库关键字，默认false，如果设置为true，根据SqlReservedWords中定义的关键字列表；</span></span><br><span class="line"><span class="comment">        一般保留默认值，遇到数据库关键字（Java关键字），使用columnOverride覆盖 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"autoDelimitKeywords"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 生成的Java文件的编码 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"javaFileEncoding"</span> <span class="attr">value</span>=<span class="string">"utf-8"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- beginningDelimiter和endingDelimiter：指明数据库的用于标记数据库对象名的符号，比如ORACLE就是双引号，MYSQL默认是`反引号； --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"beginningDelimiter"</span> <span class="attr">value</span>=<span class="string">"`"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"endingDelimiter"</span> <span class="attr">value</span>=<span class="string">"`"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 格式化java代码 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"javaFormatter"</span> <span class="attr">value</span>=<span class="string">"org.mybatis.generator.api.dom.DefaultJavaFormatter"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 格式化XML代码 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"xmlFormatter"</span> <span class="attr">value</span>=<span class="string">"org.mybatis.generator.api.dom.DefaultXmlFormatter"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">type</span>=<span class="string">"org.mybatis.generator.plugins.SerializablePlugin"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">type</span>=<span class="string">"org.mybatis.generator.plugins.ToStringPlugin"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 为了防止生成的代码中有很多注释，比较难看，加入下面的配置控制 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">commentGenerator</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suppressAllComments"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span><span class="comment">&lt;!-- 是否取消注释 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suppressDate"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span> <span class="comment">&lt;!-- 是否生成注释带时间戳--&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">commentGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- jdbc连接 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdbcConnection</span> <span class="attr">driverClass</span>=<span class="string">"$&#123;spring.datasource.driver-class-name&#125;"</span> <span class="attr">connectionURL</span>=<span class="string">"$&#123;spring.datasource.url&#125;"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">userId</span>=<span class="string">"$&#123;spring.datasource.username&#125;"</span> <span class="attr">password</span>=<span class="string">"$&#123;spring.datasource.password&#125;"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 类型转换 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaTypeResolver</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 是否使用bigDecimal， false可自动转化以下类型（Long, Integer, Short, etc.） --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"forceBigDecimals"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaTypeResolver</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 生成实体类地址 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaModelGenerator</span> <span class="attr">targetPackage</span>=<span class="string">"com.austin.entity"</span> <span class="attr">targetProject</span>=<span class="string">"$&#123;mybatis.project&#125;"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 是否允许子包，即targetPackage.schemaName.tableName --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"enableSubPackages"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 是否对model添加 构造函数 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"constructorBased"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 是否对类CHAR类型的列的数据进行trim操作 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"trimStrings"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 建立的Model对象是否 不可改变  即生成的Model对象不会有 setter方法，只有构造方法 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"immutable"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaModelGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 生成maperxml文件, targetPackage表示xml文件存放地址 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sqlMapGenerator</span> <span class="attr">targetPackage</span>=<span class="string">"mapper"</span> <span class="attr">targetProject</span>=<span class="string">"$&#123;mybatis.resources&#125;"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"enableSubPackages"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">sqlMapGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 生成mapxml对应client，也就是接口dao --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaClientGenerator</span> <span class="attr">targetPackage</span>=<span class="string">"com.austin.dao"</span> <span class="attr">targetProject</span>=<span class="string">"$&#123;mybatis.project&#125;"</span> <span class="attr">type</span>=<span class="string">"XMLMAPPER"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"enableSubPackages"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaClientGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--table可以有多个,每个数据库中的表都可以写一个table，</span></span><br><span class="line"><span class="comment">        tableName表示要匹配的数据库表名,也可以在tableName属性中通过使用%通配符来匹配所有数据库表,只有匹配的表才会自动生成文件</span></span><br><span class="line"><span class="comment">        domainObjectName是生成的实体类名称,可以不写，默认会用表名的驼峰格式</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">"tbl_user"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">domainObjectName</span>=<span class="string">"UserInfo"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">enableCountByExample</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">enableUpdateByExample</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">enableDeleteByExample</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">enableSelectByExample</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">selectByExampleQueryId</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"useActualColumnNames"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 数据库表主键 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">generatedKey</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">sqlStatement</span>=<span class="string">"Mysql"</span> <span class="attr">identity</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">"tbl_role"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">domainObjectName</span>=<span class="string">"RoleInfo"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">enableCountByExample</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">enableUpdateByExample</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">enableDeleteByExample</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">enableSelectByExample</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">selectByExampleQueryId</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"useActualColumnNames"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 数据库表主键 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">generatedKey</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">sqlStatement</span>=<span class="string">"Mysql"</span> <span class="attr">identity</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">generatorConfiguration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中，如果在pom中配置了红框中所示的依赖，则不需要额外指定classPathEntry路径。<br><img src="/images/mybatis_pom_config.png" alt></p><h3 id="工程结构"><a href="#工程结构" class="headerlink" title="工程结构"></a>工程结构</h3><p><img src="/images/mybatis_structure.jpg" alt></p><h3 id="执行生成"><a href="#执行生成" class="headerlink" title="执行生成"></a>执行生成</h3><p>执行可以采用两种方式</p><h4 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h4><p>pom文件所在路径执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn mybatis-generator:generate</span><br></pre></td></tr></table></figure><h4 id="IDE"><a href="#IDE" class="headerlink" title="IDE"></a>IDE</h4><p><img src="/images/mybatis_generate.jpg" alt></p><h3 id="生成结果"><a href="#生成结果" class="headerlink" title="生成结果"></a>生成结果</h3><p><img src="/images/mybatis_generate_res.jpg" alt></p><h2 id="注解方式"><a href="#注解方式" class="headerlink" title="注解方式"></a>注解方式</h2><p>全注解的方式，这种方式和后面提到的xml的方式的区别仅仅在于 一个将 sql 语句写在 java 代码中，一个写在 xml 配置文件中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StudentMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Insert</span>(<span class="string">"insert into tbl_student(name, class_name, age) values (#&#123;name&#125;, #&#123;className&#125;, #&#123;age&#125;)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(@Param(<span class="string">"name"</span>)</span> String name, @<span class="title">Param</span><span class="params">(<span class="string">"className"</span>)</span> String className, @<span class="title">Param</span><span class="params">(<span class="string">"age"</span>)</span> <span class="keyword">int</span> age)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select</span>(<span class="string">"select * from tbl_student"</span>)</span><br><span class="line">    <span class="function">List&lt;Student&gt; <span class="title">findAllStudent</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><p>（1）mapper文件无法注入<br>出错原因： 启动类上需要通过@MapperScan指定mpper文件路径。</p><h2 id="代码路径"><a href="#代码路径" class="headerlink" title="代码路径"></a>代码路径</h2><p><a href="https://github.com/austin-brant/mybatis-spring-boot-demo" target="_blank" rel="noopener">https://github.com/austin-brant/mybatis-spring-boot-demo</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;SpringBoot 整合 Mybatis 有两种常用的方式，一种就是我们常见的 xml 的方式 ，还有一种是全注解的方式。我觉得这两者没有谁比谁好，在 SQL 语句不太长的情况下，我觉得全注解的方式一定是比较清晰简洁的。但是，复杂的 SQL 确实不太适合和代码写在一起。&lt;
      
    
    </summary>
    
      <category term="数据库中间件" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
      <category term="Mybatis" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E9%97%B4%E4%BB%B6/Mybatis/"/>
    
    
      <category term="Springboot" scheme="http://yoursite.com/tags/Springboot/"/>
    
      <category term="Mybatis" scheme="http://yoursite.com/tags/Mybatis/"/>
    
  </entry>
  
  <entry>
    <title>[多线程]Volatile和Synchronization详解</title>
    <link href="http://yoursite.com/2019/08/14/%E5%A4%9A%E7%BA%BF%E7%A8%8B-Volatile%E5%92%8CSynchronization%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/08/14/多线程-Volatile和Synchronization详解/</id>
    <published>2019-08-14T04:55:13.000Z</published>
    <updated>2019-08-14T12:58:37.958Z</updated>
    
    <content type="html"><![CDATA[<p>在多线程并发编程中synchronized和volatile都扮演着重要的角色，volatile是轻量级的synchronized，它在多处理器开发中保证了共享变量的“可见性”。如果volatile变量修饰符使用恰当的话，它比synchronized的使用和执行成本更低，因为它不会引起线程上下文的切换和调度。本文将深入分析volatile和synchronize的原理，通过深入分析帮助我们正确地使用volatile和synchronize关键字。首先先了解下并发编程的三大概念。</p><h1 id="并发编程的三大概念"><a href="#并发编程的三大概念" class="headerlink" title="并发编程的三大概念"></a>并发编程的三大概念</h1><h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><blockquote><p>可见性的意思是当一个线程修改一个共享变量时，另外一个线程能立马读到这个修改的值。</p></blockquote><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><blockquote><p>原子（atomic）本意是“不能被进一步分割的最小粒子”，而原子操作（atomic operation）意为“不可被中断的一个或一系列操作”。即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</p></blockquote><p>在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。但在多处理器上实现原子操作就变得有点复杂。</p><p>比如 a=0；（a非long和double类型） 这个操作是不可分割的，那么我们说这个操作时原子操作。再比如：a++； 这个操作实际是a = a + 1；是可分割的，所以他不是一个原子操作。非原子操作都会存在线程安全问题，需要我们使用同步技术（sychronized）来让它变成一个原子操作。一个操作是原子操作，那么我们称它具有原子性。java的concurrent包下提供了一些原子类，我们可以通过阅读API来了解这些原子类的用法。比如：AtomicInteger、AtomicLong、AtomicReference等。</p><h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><blockquote><p>有序性就是程序执行的顺序按照代码的先后顺序执行。</p></blockquote><p>什么是指令重排序，一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。</p><p>指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性。也就是说，要想并发程序正确地执行，必须要保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能会导致程序运行不正确。</p><p>在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。在Java里面，可以通过volatile关键字来保证一定的“有序性”。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。</p><p>另外，Java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 happens-before 原则。如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。</p><h1 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h1><p><img src="/images/java_memory_structure.png" alt="java内存模型"></p><p>Java内存模型规定了所有的变量都存储在<strong>主内存</strong>中。<font color="#dd0000">为了提高处理速度，<strong>处理器不直接和主内存进行通信</strong>，而是先将系统内存的数据读到内部缓存（L1，L2或其他，俗称工作内存），线程对变量的所有操作（读取，赋值）都必须在工作内存中进行</font>，但操作完不知道何时会写到内存。</p><p>不同线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。</p><h1 id="Volatile的定义与实现原理"><a href="#Volatile的定义与实现原理" class="headerlink" title="Volatile的定义与实现原理"></a>Volatile的定义与实现原理</h1><p>Java语言规范第3版中对volatile的定义如下：Java编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致地更新，线程应该确保通过 <strong>排他锁</strong> 单独获得这个变量。Java语言提供了volatile，在某些情况下比锁要更加方便。如果一个字段被声明成volatile，Java线程内存模型确保所有线程看到这个变量的值是一致的。</p><p>让我们在X86处理器下通过工具获取JIT编译器生成的汇编指令来查看对volatile进行写操作时，CPU会做什么事情。</p><p>Java代码如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">instance = <span class="keyword">new</span> Singleton();     <span class="comment">// instance是volatile变量</span></span><br></pre></td></tr></table></figure><p>转变成汇编代码，如下。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x01a3de1d: movb $0×0,0×1104800(%esi);0x01a3de24: lock addl $0×0,(%esp);</span><br></pre></td></tr></table></figure><p>有volatile变量修饰的共享变量进行写操作的时候会多出第二行汇编代码，通过查IA-32架构软件开发者手册可知，Lock前缀的指令在多核处理器下会引发了两件事情:</p><blockquote><font color="#dd0000"> 1）将当前处理器缓存行的数据写回到系统内存。<p> 2）这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效。<br></p></font><p></p></blockquote><p>如果对声明了volatile的变量进行写操作，<strong>JVM就会向处理器发送一条Lock前缀的指令</strong>，将这个变量所在缓存行的数据写回到系统内存。但是，就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题。所以，在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议，每个处理器通过 <strong>嗅探在总线上传播的数据</strong> 来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会 <strong>重新从系统内存中把数据读到处理器缓存里</strong> 。</p><p>具体讲解volatile的两条实现原则。</p><ul><li><p>1）<strong>Lock前缀指令会引起处理器缓存回写到内存</strong></p><p>  Lock前缀指令导致在执行指令期间，声言处理器的LOCK#信号。在多处理器环境中，LOCK#信号确保在声言该信号期间，处理器可以独占任何共享内存。但是，在新的处理器里，LOCK＃信号一般不锁总线，而是锁缓存，毕竟锁总线开销的比较大，它会锁定这块内存区域的缓存并回写到内存，并使用缓存一致性机制来确保修改的原子性，此操作被称为 <strong>“缓存锁定”</strong> ，<strong>缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据</strong>。</p></li><li><p>2）<strong>一个处理器的缓存回写到内存会导致其他处理器的缓存无效</strong> </p><p>  IA-32处理器和Intel 64处理器使用 <strong>MESI（修改、独占、共享、无效）控制协议</strong> 去维护内部缓存和其他处理器缓存的一致性。在多核处理器系统中进行操作的时候，IA-32和Intel 64处理器能 <strong>嗅探其他处理器访问系统内存和它们的内部缓存</strong>。 <strong>处理器使用嗅探技术保证它的内部缓存、系统内存和其他处理器的缓存的数据在总线上保持一致</strong>。 例如，在Pentium和P6 family处理器中，如果通过嗅探一个处理器来检测其他处理器打算写内存地址，<strong>而这个地址当前处于共享状态，那么正在嗅探的处理器将使它自己的缓存行无效，在下次访问相同内存地址时，强制执行缓存行填充。</strong></p></li></ul><h1 id="Synchronized的实现"><a href="#Synchronized的实现" class="headerlink" title="Synchronized的实现"></a>Synchronized的实现</h1><p>在多线程并发编程中synchronized一直是元老级角色，很多人都会称呼它为重量级锁。但是，随着Java SE 1.6对synchronized进行了各种优化之后，有些情况下它就并不那么重了。下面详细介绍Java SE 1.6中为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁，以及锁的存储结构和升级过程。</p><p>先来看下利用synchronized实现同步的基础：Java中的每一个对象都可以作为锁。具体表现为以下3种形式。</p><ul><li><p><strong>对于普通同步方法，锁是当前实例对象。</strong></p></li><li><p><strong>对于静态同步方法，锁是当前类的Class对象。</strong></p></li><li><p><strong>对于同步方法块，锁是Synchonized括号里配置的对象。</strong></p></li></ul><p>当一个线程试图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁。</p><p>从JVM规范中可以看到Synchonized在JVM里的实现原理，JVM基于进入和退出Monitor对象来实现方法同步和代码块同步，但两者的实现细节不一样。代码块同步是使用 <strong>monitorenter</strong> 和<strong>monitorexit</strong> 指令实现的，而方法同步是使用另外一种方式实现的，细节在JVM规范里并没有详细说明。但是，方法的同步同样可以使用这两个指令来实现。</p><p><font color="#dd0000">monitorenter指令是在编译后插入到同步代码块的开始位置，而monitorexit是插入到方法结束处和异常处，JVM要保证每个monitorenter必须有对应的monitorexit与之配对</font>。任何对象都有一个monitor与之关联，当且一个monitor被持有后，它将处于锁定状态。线程执行到monitorenter指令时，将会尝试获取对象所对应的monitor的所有权，即尝试获得对象的锁。</p><h2 id="Java对象头"><a href="#Java对象头" class="headerlink" title="Java对象头"></a>Java对象头</h2><p>synchronized用的锁是存在Java对象头里的。如果对象是数组类型，则虚拟机用3个字宽（Word）存储对象头，如果对象是非数组类型，则用2字宽存储对象头。在32位虚拟机中，1字宽等于4字节，即32bit。</p><p>Java对象头里的Mark Word里默认存储对象的HashCode、分代年龄和锁标记位。32位JVM的Mark Word的默认存储结构如下表所示：</p><p><img src="/images/object_header1.png" alt></p><p>在运行期间，Mark Word里存储的数据会随着锁标志位的变化而变化。Mark Word可能变化为存储以下4种数据，如下表：</p><p><img src="/images/object_header2.png" alt></p><p>在64位虚拟机下，Mark Word是64bit大小的，其存储结构如下表所示：</p><p><img src="/images/object_header3.png" alt></p><h2 id="锁的升级"><a href="#锁的升级" class="headerlink" title="锁的升级"></a>锁的升级</h2><p>Java SE 1.6为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”，在Java SE 1.6中，锁一共有4种状态，级别从低到高依次是：<font color="#dd0000"><strong>无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态</strong></font>，这几个状态会随着竞争情况逐渐升级。<strong>锁可以升级但不能降级</strong>，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率，下文会详细分析。</p><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>HotSpot的作者经过研究发现，大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，<strong>以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁</strong>。 如果测试成功，表示线程已经获得了锁。如果测试失败，则需要再测试一下Mark Word中偏向锁的标识是否设置成1（表示当前是偏向锁）：如果没有设置，则使用CAS竞争锁；如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。</p><p><strong>(1) 偏向锁的撤销</strong></p><p>偏向锁使用了一种 <u><strong>等到竞争出现才释放锁</strong></u> 的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。</p><p>偏向锁的撤销，需要等待全局安全点（在这个时间点上没有正在执行的字节码）。</p><ul><li><p>它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着;</p></li><li><p>如果线程不处于活动状态，则将对象头设置成无锁状态；</p></li><li><p>如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。</p></li></ul><p>下图中的线程1演示了偏向锁初始化的流程，线程2演示了偏向锁撤销的流程。</p><p><img src="/images/partiality_lock.jpg" alt></p><p><strong>(2) 关闭偏向锁</strong></p><p>偏向锁在Java 6和Java 7里是默认启用的，但是它在应用程序启动几秒钟之后才激活，如有必要可以使用JVM参数来关闭延迟：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:BiasedLockingStartupDelay=0</span><br></pre></td></tr></table></figure><p>如果你确定应用程序里所有的锁通常情况下处于竞争状态，可以通过JVM参数关闭偏向锁：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:-UseBiasedLocking=false</span><br></pre></td></tr></table></figure><p>那么程序默认会进入轻量级锁状态。 </p><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p><strong>（1）轻量级锁加锁</strong></p><p>线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并 <font color="#dd0000"><strong>将对象头中的Mark Word复制到锁记录中</strong></font>，官方称 <strong>为Displaced Mark Word</strong> 。然后线程尝试 <font color="#dd0000"><strong>使用CAS将对象头中的Mark Word替换为指向锁记录的指针</strong></font>。 如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。</p><p><strong>（2）轻量级锁解锁</strong></p><p>轻量级解锁时，会 <font color="#dd0000"><strong>使用原子的CAS操作将Displaced Mark Word替换回到对象头</strong></font>，如果成功，则表示没有竞争发生。<strong>如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁</strong>。下图是两个线程同时争夺锁，导致锁膨胀的流程图。</p><p><img src="/images/lock_upgrade.jpg" alt></p><p>因为自旋会消耗CPU，<strong>为了避免无用的自旋（比如获得锁的线程被阻塞住了），一旦锁升级成重量级锁，就不会再恢复到轻量级锁状态</strong>。当锁处于这个状态下，其他线程试图获取锁时，都会被阻塞住，当持有锁的线程释放锁之后会唤醒这些线程，被唤醒的线程就会进行新一轮的夺锁之争。</p><h3 id="锁的对比"><a href="#锁的对比" class="headerlink" title="锁的对比"></a>锁的对比</h3><table><thead><tr><th>锁</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>无锁</td><td>高性能</td><td></td><td>基本上无并发，不存在线程竞争</td></tr><tr><td>偏向锁</td><td>加锁解锁不需要额外消耗，和执行非同步方法相比仅存在纳秒级差距</td><td>若线程间存在锁竞争，会带来额外的锁撤销消耗</td><td>只有一个线程访问的同步块场景</td></tr><tr><td>轻量级锁</td><td>竞争的线程一直自旋不会阻塞，提高了程序响应速度</td><td>未得到锁的线程自旋消耗CPU</td><td>追求响应时间，同步块执行速度非常快</td></tr><tr><td>重量级锁</td><td>线程竞争不使用自旋，不消耗CPU</td><td>线程竞争会直接阻塞，进入内核态，响应时间慢</td><td>追求吞吐量，同步块执行时间较长</td></tr></tbody></table><h1 id="Volatile-vs-Synchronize"><a href="#Volatile-vs-Synchronize" class="headerlink" title="Volatile vs Synchronize"></a>Volatile vs Synchronize</h1><ol><li><p>volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的;</p></li><li><p>volatile仅能实现变量的修改可见性，并不能保证原子性；synchronized则可以保证变量的修改可见性和原子性;</p></li><li><p>volatile不会造成线程的阻塞; synchronized可能会造成线程的阻塞。</p></li><li><p>volatile标记的变量不会被编译器优化(禁止指令重排)；synchronized标记的变量可以被编译器优化</p></li><li><p>volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。</p></li></ol><blockquote><p>本文主要摘抄于 《Java并发编程的艺术》（第二章） 只作为个人读书记录。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在多线程并发编程中synchronized和volatile都扮演着重要的角色，volatile是轻量级的synchronized，它在多处理器开发中保证了共享变量的“可见性”。如果volatile变量修饰符使用恰当的话，它比synchronized的使用和执行成本更低，因
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
      <category term="多线程" scheme="http://yoursite.com/categories/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="Synchronization" scheme="http://yoursite.com/tags/Synchronization/"/>
    
      <category term="Volatile" scheme="http://yoursite.com/tags/Volatile/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal源码解析</title>
    <link href="http://yoursite.com/2019/08/13/ThreadLocal%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2019/08/13/ThreadLocal源码解析/</id>
    <published>2019-08-13T13:53:11.000Z</published>
    <updated>2019-08-13T14:08:30.053Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ThreadLocal的作用"><a href="#ThreadLocal的作用" class="headerlink" title="ThreadLocal的作用"></a>ThreadLocal的作用</h2><p>ThreadLocal的作用是提供线程内的局部变量，说白了，就是在各线程内部创建一个变量的副本，相比于使用各种锁机制访问变量，ThreadLocal的思想就是用空间换时间，使各线程都能访问属于自己这一份的变量副本，变量值不互相干扰，减少同一个线程内的多个函数或者组件之间一些公共变量传递的复杂度。</p><p><strong>ThreadLocal特性及使用场景</strong></p><ul><li>1、方便同一个线程使用某一对象，避免不必要的参数传递；</li><li>2、线程间数据隔离（每个线程在自己线程里使用自己的局部变量，各线程间的ThreadLocal对象互不影响）；</li><li>3、获取数据库连接、Session、关联ID（比如日志的uniqueID，方便串起多个日志）；</li></ul><p><strong>ThreadLocal应注意</strong></p><ul><li>1、ThreadLocal并未解决多线程访问共享对象的问题；</li><li>2、ThreadLocal并不是每个线程拷贝一个对象，而是直接new（新建）一个；</li><li>3、如果ThreadLocal.set()的对象是多线程共享的，那么还是涉及并发问题。</li></ul><h2 id="图解TreadLocal"><a href="#图解TreadLocal" class="headerlink" title="图解TreadLocal"></a>图解TreadLocal</h2><p><img src="/images/thread_local.jpg" alt></p><p>每个线程可能有多个ThreadLocal，同一线程的各个ThreadLocal存放于同一个ThreadLocalMap中。</p><p>图解ThreadLocal(JDK8).vsdx原图下载地址：<a href="https://github.com/zxiaofan/JDK-Study/tree/master/src/java1/lang/threadLocal" target="_blank" rel="noopener">https://github.com/zxiaofan/JDK-Study/tree/master/src/java1/lang/threadLocal</a></p><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><h3 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">        Object value;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * ThreadLocalMap的key是ThreadLocal</span></span><br><span class="line"><span class="comment">        * value是Object（即我们所谓的“线程本地数据”）</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">            <span class="keyword">super</span>(k);</span><br><span class="line">            value = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始容量，2的幂等次方</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实际保存数据的数组，超过threshold会2倍扩容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Entry[] table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实际存储的entry数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 下次扩容的阈值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> threshold;  <span class="comment">// Default to 0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Set the resize threshold to maintain at worst a 2/3 load factor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setThreshold</span><span class="params">(<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        threshold = len * <span class="number">2</span> / <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 往后移动一位</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((i + <span class="number">1</span> &lt; len) ? i + <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 往前移动一位</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">prevIndex</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((i - <span class="number">1</span> &gt;= <span class="number">0</span>) ? i - <span class="number">1</span> : len - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Construct a new map initially containing (firstKey, firstValue).</span></span><br><span class="line"><span class="comment">     * ThreadLocalMaps懒汉模式, 等第一个entry被放入时才初始化.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">        table = <span class="keyword">new</span> Entry[INITIAL_CAPACITY];</span><br><span class="line">        <span class="keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">        table[i] = <span class="keyword">new</span> Entry(firstKey, firstValue);</span><br><span class="line">        size = <span class="number">1</span>;</span><br><span class="line">        setThreshold(INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将父线程的ThreadLocalMaps内容复制过来</span></span><br><span class="line"><span class="comment">     * Called only by createInheritedMap.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ThreadLocalMap</span><span class="params">(ThreadLocalMap parentMap)</span> </span>&#123;</span><br><span class="line">        Entry[] parentTable = parentMap.table;</span><br><span class="line">        <span class="keyword">int</span> len = parentTable.length;</span><br><span class="line">        setThreshold(len);</span><br><span class="line">        table = <span class="keyword">new</span> Entry[len];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">            Entry e = parentTable[j];</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                ThreadLocal&lt;Object&gt; key = (ThreadLocal&lt;Object&gt;) e.get();</span><br><span class="line">                <span class="keyword">if</span> (key != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    Object value = key.childValue(e.value);</span><br><span class="line">                    Entry c = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">                    <span class="keyword">int</span> h = key.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">while</span> (table[h] != <span class="keyword">null</span>)</span><br><span class="line">                        h = nextIndex(h, len);</span><br><span class="line">                    table[h] = c;</span><br><span class="line">                    size++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ThreadLocalMap是定制的hashMap，仅用于维护当前线程的本地变量值。仅ThreadLocal类对其有操作权限，是Thread的私有属性。为避免占用空间较大或生命周期较长的数据常驻于内存引发一系列问题，hash table的key是弱引用WeakReferences。当空间不足时，会清理未被引用的entry。<strong>这时Entry里的key为null了，那么直到线程结束前，Entry中的value都是无法回收的，这里可能产生内存泄露</strong>。</p><h3 id="SuppliedThreadLocal"><a href="#SuppliedThreadLocal" class="headerlink" title="SuppliedThreadLocal"></a>SuppliedThreadLocal</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SuppliedThreadLocal</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Supplier&lt;? extends T&gt; supplier;</span><br><span class="line"></span><br><span class="line">        SuppliedThreadLocal(Supplier&lt;? extends T&gt; supplier) &#123;</span><br><span class="line">            <span class="keyword">this</span>.supplier = Objects.requireNonNull(supplier);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> supplier.get();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SuppliedThreadLocal是JDK8新增的内部类，只是扩展了ThreadLocal的初始化值的方法而已，允许使用JDK8新增的Lambda表达式赋值。需要注意的是，函数式接口Supplier不允许为null。</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * ThreadLocal初始化时会调用nextHashCode()方法初始化</span></span><br><span class="line"><span class="comment">   * threadLocalHashCode，且threadLocalHashCode初始化后不可变。</span></span><br><span class="line"><span class="comment">   * threadLocalHashCode可用来标记不同的ThreadLocal实例。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threadLocalHashCode = nextHashCode();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger nextHashCode =</span><br><span class="line">        <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_INCREMENT = <span class="number">0x61c88647</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextHashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * JDK8新增，支持Lambda表达式，和ThreadLocal重写的initialValue()效果一样。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; <span class="function">ThreadLocal&lt;S&gt; <span class="title">withInitial</span><span class="params">(Supplier&lt;? extends S&gt; supplier)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SuppliedThreadLocal&lt;&gt;(supplier);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadLocal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ThreadLocal类变量有3个，其中2个是静态变量（包括一个常量），实际作为作为ThreadLocal实例的变量只有threadLocalHashCode这1个，而且已经初始化就不可变了。</p><p>其中withInitial()方法使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">jdk8Test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Supplier&lt;String&gt; supplier =<span class="keyword">new</span> Supplier&lt;String&gt;()&#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">           <span class="keyword">return</span><span class="string">"supplier_new"</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;;</span><br><span class="line">   </span><br><span class="line">    threadLocal= ThreadLocal.withInitial(supplier);</span><br><span class="line">    System.out.println(threadLocal.get()); <span class="comment">// supplier_new</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Lambda表达式</span></span><br><span class="line">    threadLocal= ThreadLocal.withInitial(()-&gt;<span class="string">"sup_new_2"</span>);</span><br><span class="line">    System.out.println(threadLocal.get()); <span class="comment">// sup_new_2</span></span><br><span class="line">    </span><br><span class="line">    ThreadLocal&lt;DateFormat&gt; localDate = ThreadLocal.withInitial(()-&gt;<span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>));</span><br><span class="line">    System.out.println(localDate.get().format(<span class="keyword">new</span> Date())); <span class="comment">// 2017-01-22</span></span><br><span class="line">    </span><br><span class="line">    ThreadLocal&lt;String&gt; local =<span class="keyword">new</span> ThreadLocal&lt;&gt;().withInitial(supplier);</span><br><span class="line">    System.out.println(local.get()); <span class="comment">// supplier_new</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接看代码，可以分析主要有以下几步：</p><ul><li><ol><li>获取当前的Thread对象，通过getMap获取Thread内的ThreadLocalMap</li></ol></li><li><ol start="2"><li>如果map已经存在，以当前的ThreadLocal为键，获取Entry对象，并从从Entry中取出值</li></ol></li><li><ol start="3"><li>否则，调用setInitialValue进行初始化。</li></ol></li></ul><h4 id="getMap"><a href="#getMap" class="headerlink" title="getMap"></a>getMap</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getMap很简单，就是返回线程中ThreadLocalMap，跳到Thread源码里看，ThreadLocalMap是这么定义的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p>所以ThreadLocalMap还是定义在ThreadLocal里面的，我们前面已经说过ThreadLocalMap中的Entry定义，下面为了先介绍ThreadLocalMap的定义我们把setInitialValue放在前面说。</p><h4 id="setInitialValue"><a href="#setInitialValue" class="headerlink" title="setInitialValue"></a>setInitialValue</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    T value = initialValue();</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>setInititialValue在Map不存在的时候调用。</p><ol><li><p>首先是调用initialValue生成一个初始的value值，深入initialValue函数，我们可知它就是返回一个null，<strong>如果创建ThreadLocal时调用withInitial() 方法指定了初始方法，则返回自定义值</strong>；</p></li><li><p>还是在get()一下Map，如果map存在，则直接map.set(), 这个函数会放在后文说；</p></li></ol><ol><li>如果map不存在，则会调用createMap()创建ThreadLocalMap。</li></ol><h4 id="createMap"><a href="#createMap" class="headerlink" title="createMap"></a>createMap</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比较简单，就是调用了ThreadLocalMap内部类的构造函数而已。</p><h4 id="map-getEntry"><a href="#map-getEntry" class="headerlink" title="map.getEntry"></a>map.getEntry</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">    Entry e = table[i];</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>首先是计算索引位置i，通过计算key的hash%(table.length-1)得出；</li><li>根据获取Entry，如果Entry存在且Entry的key恰巧等于ThreadLocal，那么直接返回Entry对象；</li><li>否则，也就是在此位置上找不到对应的Entry，那么就调用getEntryAfterMiss。</li></ol><h4 id="getEntryAfterMiss"><a href="#getEntryAfterMiss" class="headerlink" title="getEntryAfterMiss"></a>getEntryAfterMiss</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntryAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key, <span class="keyword">int</span> i, Entry e)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == key)</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>)</span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            i = nextIndex(i, len);</span><br><span class="line">        e = tab[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法我们还得结合上一步看，上一步是因为不满足</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e != null &amp;&amp; e.get() == key</span><br></pre></td></tr></table></figure><p>才沦落到调用getEntryAfterMiss的，所以:</p><ul><li><p>首先e如果为null的话，证明不存在value, 那么getEntryAfterMiss还是直接返回null的</p></li><li><p>如果是不满足e.get() == key，那么进入while循环，这里是不断循环，如果e一直不为空，那么就调用nextIndex，不断递增i，在此过程中一直会做两个判断：</p><ul><li><p>如果 k == key, 那么代表找到了这个所需要的Entry，直接返回；</p></li><li><p>如果 k == null，那么证明这个Entry中key已经为null, 那么这个Entry就是一个过期对象，这里调用expungeStaleEntry清理该Entry。这里解答了前面留下的一个坑，即ThreadLocal Ref销毁时，ThreadLocal实例由于只有Entry中的一条弱引用指着，那么就会被GC掉，Entry的key没了，value可能会内存泄露的，<strong>其实在每一个get，set操作时都会不断清理掉这种key为null的Entry的</strong>。</p></li></ul></li></ul><p><strong>为什么循环查找？</strong></p><blockquote><p>这里你可以直接跳到下面的set方法，主要是因为<strong>处理哈希冲突</strong>的方法，我们都知道HashMap采用拉链法处理哈希冲突，即在一个位置已经有元素了，就采用链表把冲突的元素链接在该元素后面，而ThreadLocal采用的是开放地址法，即有冲突后，把要插入的元素放在要插入的位置后面为null的地方</p><p>具体关于这两种方法的区别可以参考：<a href="https://link.juejin.im/?target=http%3A%2F%2Fblog.csdn.net%2Fxtzmm1215%2Farticle%2Fdetails%2F47177701" target="_blank" rel="noopener">解决哈希（HASH）冲突的主要方法</a>。</p><p>所以上面的循环就是因为我们在第一次计算出来的i位置不一定存在key与我们想查找的key恰好相等的Entry，所以只能不断在后面循环，来查找是不是被插到后面了，直到找到为null的元素，因为若是插入也是到null为止的。</p></blockquote><h4 id="expungeStaleEntry"><a href="#expungeStaleEntry" class="headerlink" title="expungeStaleEntry"></a>expungeStaleEntry</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">expungeStaleEntry</span><span class="params">(<span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// （1）删掉staleSlot位置value值</span></span><br><span class="line">    tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// （2）Rehash until we encounter null</span></span><br><span class="line">    Entry e;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = nextIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">         i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            e.value = <span class="keyword">null</span>;</span><br><span class="line">            tab[i] = <span class="keyword">null</span>;</span><br><span class="line">            size--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 删除元素后，需要重新移动存活的元素，因为查找时遇到null会终止</span></span><br><span class="line">            <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (h != i) &#123;</span><br><span class="line">                tab[i] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (tab[h] != <span class="keyword">null</span>)</span><br><span class="line">                    h = nextIndex(h, len);</span><br><span class="line">                tab[h] = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看上面这段代码主要有两部分：</p><ul><li><p>(1) 这段主要是将i位置上的Entry的value设为null，Entry的引用也设为null，那么系统GC的时候自然会清理掉这块内存；</p></li><li><p>(2) 这段就是扫描位置staleSlot之后，null之前的Entry数组，清除每一个key为null的Entry，同时若是key不为空，做rehash，调整其位置。</p></li></ul><p><strong>为什么要做rehash呢？</strong></p><blockquote><p>因为我们在清理的过程中会把某个值设为null，那么这个值后面的区域如果之前是连着前面的，那么下次循环查找时，就会只查到null为止。</p></blockquote><p>举个例子就是：</p><p>…, &lt;key1(hash1), value1&gt;, &lt;key2(hash1), value2&gt;,…</p><p>即key1和key2的hash值相同, 此时，若插入</p><p>&lt;key3(hash2), value3&gt;</p><p>其hash计算的目标位置被 </p><p>&lt;key2(hash1), value2&gt;</p><p>占了，于是往后寻找可用位置，hash表可能变为：</p><p>…, &lt;key1(hash1), value1&gt;, &lt;key2(hash1), value2&gt;, &lt;key3(hash2), value3&gt;, …</p><p>此时，若 </p><p>&lt;key2(hash1), value2&gt;</p><p>被清理，显然 </p><p>&lt;key3(hash2), value3&gt;<br>应该往前移(即通过rehash调整位置)，否则若以key3查找hash表，将会找不到key3。</p><h3 id="set方法"><a href="#set方法" class="headerlink" title="set方法"></a>set方法</h3><p>我们在get方法的循环查找那里也大概描述了set方法的思想，即开放地址法,下面看具体代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先也是获取当前线程，根据线程获取到ThreadLocalMap，若是有ThreadLocalMap，则调用 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.set(ThreadLocal&lt;?&gt; key, Object value)</span><br></pre></td></tr></table></figure><p>若是没有则调用createMap创建。</p><h4 id="map-set"><a href="#map-set" class="headerlink" title="map.set"></a>map.set</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">         e != <span class="keyword">null</span>;</span><br><span class="line">         e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">    <span class="keyword">int</span> sz = ++size;</span><br><span class="line">    <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">        rehash();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看上面这段代码：</p><ol><li><p>首先还是根据key计算出位置i，然后查找i位置上的Entry，</p></li><li><p>若是Entry已经存在并且key等于传入的key，那么这时候直接给这个Entry赋新的value值。</p></li><li><p>若是Entry (e != null) 存在，但是key为null，则调用replaceStaleEntry来更换这个key为空的Entry</p></li><li><p>不断循环检测，直到遇到为null的地方，这时候要是还没在循环过程中return，那么就在这个null的位置新建一个Entry，并且插入，同时size增加1。</p></li><li><p>最后调用cleanSomeSlots，这个函数就不细说了，你只要知道内部还是调用了上面提到的expungeStaleEntry函数清理key为null的Entry就行了，最后返回是否清理了Entry，接下来再判断 sz&gt;thresgold ,这里就是判断是否达到了rehash的条件，达到的话就会调用rehash函数。</p></li></ol><p>上面这段代码有两个函数还需要分析下，首先是:</p><h4 id="replaceStaleEntry"><a href="#replaceStaleEntry" class="headerlink" title="replaceStaleEntry"></a>replaceStaleEntry</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">replaceStaleEntry</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    Entry e;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向前找到key为null的位置</span></span><br><span class="line">    <span class="keyword">int</span> slotToExpunge = staleSlot;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = prevIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">         i = prevIndex(i, len))</span><br><span class="line">        <span class="keyword">if</span> (e.get() == <span class="keyword">null</span>)</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// staleSlot节点key为空，属于应该清理节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nextIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">         i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;  <span class="comment">// 更新value值</span></span><br><span class="line"></span><br><span class="line">            tab[i] = tab[staleSlot]; <span class="comment">// i指向key为空节点</span></span><br><span class="line">            tab[staleSlot] = e;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//  staleSlot前面全不为空，i节点指向最新key为null位置</span></span><br><span class="line">            <span class="keyword">if</span> (slotToExpunge == staleSlot)</span><br><span class="line">                slotToExpunge = i;</span><br><span class="line">            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新key为空节点位置</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span> &amp;&amp; slotToExpunge == staleSlot)</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If key not found, put new entry in stale slot</span></span><br><span class="line">    tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If there are any other stale entries in run, expunge them</span></span><br><span class="line">    <span class="keyword">if</span> (slotToExpunge != staleSlot)</span><br><span class="line">        cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先我们回想上一步是因为这个位置的Entry的key为null才调用replaceStaleEntry。</p><ol><li><p>第1个for循环：我们向前找到key为null的位置，记录为slotToExpunge,这里是为了后面的清理过程，可以不关注了；</p></li><li><p>第2个for循环：我们从staleSlot起到下一个null为止，若是找到key和传入key相等的Entry，就给这个Entry赋新的value值，并且把它和staleSlot位置的Entry交换，然后调用CleanSomeSlots清理key为null的Entry。</p></li><li><p>若是一直没有key和传入key相等的Entry，那么就在staleSlot处新建一个Entry。函数最后再清理一遍空key的Entry。</p></li></ol><p>说完replaceStaleEntry，还有个重要的函数是rehash以及rehash的条件：</p><blockquote><p>首先是sz &gt; threshold时调用rehash</p></blockquote><h4 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 清理全部空节点</span></span><br><span class="line">    expungeStaleEntries();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use lower threshold for doubling to avoid hysteresis</span></span><br><span class="line">    <span class="keyword">if</span> (size &gt;= threshold - threshold / <span class="number">4</span>)</span><br><span class="line">        resize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>清理完空key的Entry后，如果size大于3/4的threshold，则调用resize函数：</p><h4 id="resize"><a href="#resize" class="headerlink" title="resize"></a>resize</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entry[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldLen = oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> newLen = oldLen * <span class="number">2</span>;</span><br><span class="line">    Entry[] newTab = <span class="keyword">new</span> Entry[newLen];</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldLen; ++j) &#123;</span><br><span class="line">        Entry e = oldTab[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">                e.value = <span class="keyword">null</span>; <span class="comment">// Help the GC 下次gc会被回收</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (newLen - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">while</span> (newTab[h] != <span class="keyword">null</span>)</span><br><span class="line">                    h = nextIndex(h, newLen);</span><br><span class="line">                newTab[h] = e;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setThreshold(newLen);</span><br><span class="line">    size = count;</span><br><span class="line">    table = newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由源码我们可知每次扩容大小扩展为原来的2倍，然后再一个for循环里，清除空key的Entry，同时重新计算key不为空的Entry的hash值，把它们放到正确的位置上，再更新ThreadLocalMap的所有属性。</p><h3 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h3><p>最后一个需要探究的就是remove函数，它用于在map中移除一个不用的Entry。也是先计算出hash值，若是第一次没有命中，就循环直到null，在此过程中也会调用expungeStaleEntry清除空key节点。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">         e != <span class="keyword">null</span>;</span><br><span class="line">         e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">         <span class="keyword">if</span> (e.get() == key) &#123;</span><br><span class="line">            e.clear();</span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用ThreadLocal的最佳实践"><a href="#使用ThreadLocal的最佳实践" class="headerlink" title="使用ThreadLocal的最佳实践"></a>使用ThreadLocal的最佳实践</h2><p>我们发现无论是set,get还是remove方法，过程中key为null的Entry都会被擦除，那么Entry内的value也就没有强引用链，GC时就会被回收。那么怎么会存在内存泄露呢？但是以上的思路是假设你调用get或者set方法了，很多时候我们都没有调用过，所以最佳实践就是:</p><ol><li>使用者需要手动调用remove函数，删除不再使用的ThreadLocal.</li><li>尽量将ThreadLocal设置成private static的，这样ThreadLocal会尽量和线程本身一起消亡。</li></ol><h2 id="问题与思考"><a href="#问题与思考" class="headerlink" title="问题与思考"></a>问题与思考</h2><p>（1）如果有多个ThreadLocal都对同一个线程ThreadLocalMap写数据时，可能存在hash位置冲突，导致set()和get()效率显著下降；</p><p>（2）ThreadLocal不能读取父线程的ThradLocalMap内容，需要使用InheritableThreadLocal；</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ThreadLocal的作用&quot;&gt;&lt;a href=&quot;#ThreadLocal的作用&quot; class=&quot;headerlink&quot; title=&quot;ThreadLocal的作用&quot;&gt;&lt;/a&gt;ThreadLocal的作用&lt;/h2&gt;&lt;p&gt;ThreadLocal的作用是提供线程内的局
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
      <category term="多线程" scheme="http://yoursite.com/categories/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="ThreadLocal" scheme="http://yoursite.com/tags/ThreadLocal/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法-入门</title>
    <link href="http://yoursite.com/2019/08/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2019/08/12/数据结构与算法-入门/</id>
    <published>2019-08-12T13:14:02.000Z</published>
    <updated>2019-08-12T13:15:22.522Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组，将元素存储到内存的连续位置中，是最基本的数据结构。在任何和编程相关的面试中，都会被问到和数组相关的问题，可以说是非常热门的考题之一。比如：将数组反转、对数组进行排序、搜索数组中的元素等。</p><p>数组数据结构的主要优点是如果知道索引就可以通过 O(l) 进行快速搜索，但是在数组中添加和删除元素的速度会很慢，因为数组一旦被创建，就无法更改其大小。如果需要创建更长或更短的数组，得先创建一个新数组，再把原数组中的所有元素复制到新创建的数组中。</p><p>解决数组相关问题的关键是要熟悉数组的数据结构和基本的构造，如循环、递归等等；下面给出了 10 道热门面试题帮助大家掌握知识并进行练习。</p><h3 id="1-给定一个-1-100-的整数数组，请找到其中缺少的数字。"><a href="#1-给定一个-1-100-的整数数组，请找到其中缺少的数字。" class="headerlink" title="1. 给定一个 1-100 的整数数组，请找到其中缺少的数字。"></a>1. 给定一个 1-100 的整数数组，请找到其中缺少的数字。</h3><p>解决方法与代码：<a href="https://javarevisited.blogspot.com/2014/11/how-to-find-missing-number-on-integer-array-java.html" target="_blank" rel="noopener">https://javarevisited.blogspot.com/2014/11/how-to-find-missing-number-on-integer-array-java.html</a></p><p>两种思路：<br>（1）如果只缺少一个数字，n*(n+1)/2 - sum 就是缺失的数字；<br>（2）缺失多个数字或是某些数字重复出现，则只能遍历一遍，记录哪些数字出现过，可用List或BitSet来记录。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给定一个 1-n 的整数数组，请找到其中缺少的数字</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> austin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2019/7/30 14:31</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FindMissingNumber</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 支持多个重复或是缺失多个情况</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr   数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> count n</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printMissingNumber</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> missingCount = count - arr.length;</span><br><span class="line">        BitSet bitSet = <span class="keyword">new</span> BitSet(count);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">            bitSet.set(i - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> lastIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; missingCount; i++) &#123;</span><br><span class="line">            lastIndex = bitSet.nextClearBit(lastIndex);</span><br><span class="line">            System.out.println(++lastIndex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 只支持缺失1个情况</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printSingleMissingNumber</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> exceptedSum = count * (count + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(exceptedSum - sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 缺失一个数字</span></span><br><span class="line">        printMissingNumber(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>&#125;, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 缺失3个数字</span></span><br><span class="line">        printMissingNumber(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">8</span>&#125;, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 缺失一个数字</span></span><br><span class="line">        printSingleMissingNumber(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>&#125;, <span class="number">6</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-在给定的成对整数数组中，请找出所有总和等于给定数字的组合。"><a href="#2-在给定的成对整数数组中，请找出所有总和等于给定数字的组合。" class="headerlink" title="2. 在给定的成对整数数组中，请找出所有总和等于给定数字的组合。"></a>2. 在给定的成对整数数组中，请找出所有总和等于给定数字的组合。</h3><p>解决方法与代码：<a href="http://javarevisited.blogspot.com/2014/08/how-to-find-all-pairs-in-array-of-integers-whose-sum-equal-given-number-java.html" target="_blank" rel="noopener">http://javarevisited.blogspot.com/2014/08/how-to-find-all-pairs-in-array-of-integers-whose-sum-equal-given-number-java.html</a></p><p>三种思路：<br>（1）两层循环，时间复杂度O(n^2);<br>（2）存储到HashTable里，在HashTable里找（sum - arr[i]）值， 时间复杂度： O(n), 空间复杂度： O(n);<br>（3）先排序O(nlogn), 然后首尾想加，往中间靠；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在给定的成对整数数组中，请找出所有总和等于给定数字的组合</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> austin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2019/7/30 15:35</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComposeSum</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 可输出全部组合</span></span><br><span class="line"><span class="comment">     * 两层循环</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printPairs</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> first = array[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; array.length; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> second = array[j];</span><br><span class="line">                <span class="keyword">if</span> ((first + second) == sum) &#123;</span><br><span class="line">                    System.out.printf(<span class="string">"(%d, %d) %n"</span>, first, second);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * map方式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printPairsUsingSet</span><span class="params">(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (numbers.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Set set = <span class="keyword">new</span> HashSet(numbers.length);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> value : numbers) &#123;</span><br><span class="line">            <span class="keyword">int</span> target = n - value; <span class="comment">// if target number is not in set then add</span></span><br><span class="line">            <span class="keyword">if</span> (!set.contains(target)) &#123;</span><br><span class="line">                set.add(value);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.printf(<span class="string">"(%d, %d) %n"</span>, value, target);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 先排序 O(n log(n))</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printPairsUsingTwoPointers</span><span class="params">(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (numbers.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(numbers);</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = numbers.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = numbers[left] + numbers[right];</span><br><span class="line">            <span class="keyword">if</span> (sum == k) &#123;</span><br><span class="line">                System.out.printf(<span class="string">"(%d, %d) %n"</span>, numbers[left], numbers[right]);</span><br><span class="line">                left = left + <span class="number">1</span>;</span><br><span class="line">                right = right - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; k) &#123;</span><br><span class="line">                left = left + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; k) &#123;</span><br><span class="line">                right = right - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        printPairs(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123; <span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, -<span class="number">2</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;, <span class="number">12</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        printPairsUsingSet(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123; <span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, -<span class="number">2</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;, <span class="number">12</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        printPairsUsingTwoPointers(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123; <span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, -<span class="number">2</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;, <span class="number">12</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-数组中重复的数据"><a href="#3-数组中重复的数据" class="headerlink" title="3. 数组中重复的数据"></a>3. 数组中重复的数据</h3><p>给定一个整数数组 a，其中1 ≤ a[i] ≤ n （n为数组长度）, 其中有些元素出现两次而其他元素出现一次。</p><p>找到所有出现两次的元素。</p><p>你可以不用到任何额外空间并在O(n)时间复杂度内解决这个问题吗？</p><p>示例：</p><p>输入:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[4,3,2,7,8,2,3,1]</span><br></pre></td></tr></table></figure><p>输出:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[2,3]</span><br></pre></td></tr></table></figure><p>解题思路：<br>这个题目开头暗示了n的范围，所以可以加以利用，将元素转换成数组的索引并对应的将该处的元素乘以-1； 若数组索引对应元素的位置本身就是负数，则表示已经对应过一次；在结果列表里增加该索引的正数就行；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; dupliacates = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                i = -i;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(nums[i-<span class="number">1</span>] &lt; <span class="number">0</span>)&#123;  <span class="comment">// 已经重复过</span></span><br><span class="line">                dupliacates.add(i);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[i-<span class="number">1</span>] = -<span class="number">1</span> * nums[i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dupliacates;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-快速排序"><a href="#4-快速排序" class="headerlink" title="4. 快速排序"></a>4. 快速排序</h3><p>快排采用的是分治的思想。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 快速排序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> austin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2019/7/30 20:05</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == nums || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        quickSort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 选取中位数</span></span><br><span class="line">        <span class="keyword">int</span> pivot = nums[low + (high - low) / <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> left = low;</span><br><span class="line">        <span class="keyword">int</span> right = high;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">while</span> (nums[left] &lt; pivot) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (nums[right] &gt; pivot) &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (left &lt;= right) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = nums[left];</span><br><span class="line">                nums[left] = nums[right];</span><br><span class="line">                nums[right] = temp;</span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (low &lt; right) &#123;</span><br><span class="line">            quickSort(nums, low, right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (high &gt; left) &#123;</span><br><span class="line">            quickSort(nums, left, high);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] unsorted = &#123;<span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">"Unsorted array :"</span> + Arrays.toString(unsorted));</span><br><span class="line">        sort(unsorted);</span><br><span class="line">        System.out.println(<span class="string">"Sorted array :"</span> + Arrays.toString(unsorted));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>链表是另一种常见的数据结构，和数组相似，链表也是线性的数据结构并且以线性方式存储元素。而与数组不同的是，链表不是将元素存储在连续的位置中，而是可以存储在任意位置，彼此之间通过节点相互连接。</p><p>链表也可以说就是一个节点列表，每个节点中包含存储的值和下一个节点的地址。也正是因为这种结构，在链表里添加和删除元素很容易，你只需要更改链接而不用创建新的数组。但是搜索会很困难，并且在单链表中找到一个元素就需要 O（n）个时间。</p><p>链表有多种形式，如：单链表，允许你在一个方向上进行遍历；双链表，可以在两个方向上进行遍历；循环链表，最后节点的指针指向第一个节点从而形成一个环形的链；因为链表是一种递归数据结构，所以在解决链表问题时，熟练掌握递归算法就显得更加重要了。</p><h3 id="1-判断单链表是否存在环及求环入口点"><a href="#1-判断单链表是否存在环及求环入口点" class="headerlink" title="1. 判断单链表是否存在环及求环入口点"></a>1. 判断单链表是否存在环及求环入口点</h3><ul><li><ol><li>先判断是否有环<br>设置两个指针(fast, slow)，初始值都指向头，slow每次前进一步，fast每次前进二步，如果链表存在环，则fast必定先进入环，而slow后进入环，两个指针必定相遇。(当然，fast先行头到尾部为NULL，则为无环链表)</li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode quick = head;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">null</span> != quick)&#123;</span><br><span class="line">            <span class="keyword">if</span>(quick.next != <span class="keyword">null</span> &amp;&amp; <span class="keyword">null</span> != quick.next.next)&#123;</span><br><span class="line">                quick = quick.next.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="keyword">if</span>(slow == quick)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此问题可扩展至：</p><blockquote><p>求循环链表任一节点“对面的”（最远端）的节点</p></blockquote><p>算法同上，当quick到达起始节点或起始节点next时，slow指示的就是最远端的节点。</p><ul><li><ol start="2"><li>经过第1步确认存在环后，寻找环入口点：</li></ol></li></ul><p>算法描述：</p><p>当quick若与slow相遇时，slow肯定没有走遍历完链表，而quick已经在环内循环了n圈(1&lt;=n)。<br>假设slow走了s步，则fast走了2s步（fast步数还等于s 加上在环上多转的n圈），设环长为r，则：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2s = s + nr</span><br><span class="line">s = nr</span><br></pre></td></tr></table></figure><p>设整个链表长L，入口环与相遇点距离为x，起点到环入口点的距离为a。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a + x = s = nr</span><br><span class="line"></span><br><span class="line">a + x = (n–1)r + r = (n-1)r + L - a</span><br><span class="line"></span><br><span class="line">a = (n-1)r + (L – a – x)</span><br></pre></td></tr></table></figure><p><strong>(L – a – x)</strong> 为相遇点到环入口点的距离，由此可知，<strong>从链表头到环入口点等于(n-1)循环内环+相遇点到环入口点</strong></p><p>于是我们从<strong>链表头、与相遇点分别设一个指针，每次各走一步，两个指针必定相遇，且相遇第一点为环入口点</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode quick = head.next.next;</span><br><span class="line">        <span class="comment">// 一定有环， 寻找相遇点</span></span><br><span class="line">        <span class="keyword">while</span>(slow != quick)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            quick = quick.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// quick指针重新指向head节点</span></span><br><span class="line">        quick = head;</span><br><span class="line">        <span class="keyword">while</span>(slow != quick)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            quick = quick.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此问题可扩展至：</p><blockquote><p>判断两个单链表是否相交，如果相交，给出相交的第一个点（两个链表都不存在环）。</p></blockquote><p>根据问题描述，两个单链表自相交点起，将合并为一个单链表，这是理解算法的关键。</p><p>算法描述：</p><blockquote><p>将其中一个链表首尾相连，检测另外一个链表是否存在环，如果存在，则两个链表相交，而检测出来的依赖环入口即为相交的第一个点。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> == headA || <span class="keyword">null</span> == headB)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 先将一个链表构成环</span></span><br><span class="line">        ListNode tail = headA;</span><br><span class="line">        <span class="keyword">while</span>(tail.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            tail = tail.next;</span><br><span class="line">        &#125;</span><br><span class="line">        tail.next = headA;</span><br><span class="line">        </span><br><span class="line">        ListNode slow = headB;</span><br><span class="line">        ListNode quick = headB;</span><br><span class="line">        <span class="keyword">while</span>(quick != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">null</span> != quick.next &amp;&amp; <span class="keyword">null</span> != quick.next.next)&#123;</span><br><span class="line">                quick = quick.next.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                tail.next = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="keyword">if</span>(slow == quick)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 能够执行到此处一定是有环</span></span><br><span class="line">        quick = headB;</span><br><span class="line">        <span class="keyword">while</span>(slow != quick)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            quick = quick.next;</span><br><span class="line">        &#125;</span><br><span class="line">        tail.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-单链表相交"><a href="#2-单链表相交" class="headerlink" title="2. 单链表相交"></a>2. 单链表相交</h3><p>找到两个单链表相交的起始节点。</p><p>注意：<br>如果两个链表没有交点，返回 null.<br>在返回结果后，两个链表仍须保持原有的结构。<br>可假定整个链表结构中没有循环。<br>程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。</p><p>解题思路：<strong>双指针法</strong></p><ol><li>创建两个指针 pA 和 pB，分别初始化为链表 A 和 B 的头结点。然后让它们向后逐结点遍历。</li><li>当 pA 到达链表的尾部时，将它重定位到链表 B 的头结点 (你没看错，就是链表 B); 类似的，当 pB 到达链表的尾部时，将它重定位到链表 A 的头结点。</li><li>若在某一时刻 pA 和 pB 相遇，则 pA/pB 为相交结点。</li></ol><p>想弄清楚为什么这样可行, 可以考虑以下两个链表: A={1,3,5,7,9,11} 和 B={2,4,9,11}，相交于结点 9。<br>由于 B.length (=4) &lt; A.length (=6)，pB 比 pA 少经过 2 个结点，会先到达尾部。将 pB 重定向到 A 的头结点，pA 重定向到 B 的头结点后，pB 要比 pA 多走 2 个结点。因此，它们会同时到达交点。<br>如果两个链表存在相交，它们末尾的结点必然相同。因此当 pA/pB 到达链表结尾时，记录下链表 A/B 对应的元素。若最后元素不相同，则两个链表不相交。</p><p>复杂度分析</p><blockquote><p>时间复杂度 : O(m+n)O(m+n)。<br>空间复杂度 : O(1)O(1)。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(headA == <span class="keyword">null</span> || headB == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ListNode pA = headA, pB = headB;</span><br><span class="line">        <span class="comment">// 在这里第一轮体现在pA和pB第一次到达尾部会移向另一链表的表头,         </span></span><br><span class="line">        <span class="comment">// 而第二轮体现在如果pA或pB相交就返回交点, 不相交最后就是null==null</span></span><br><span class="line">        <span class="keyword">while</span>(pA != pB)&#123;</span><br><span class="line">            pA = pA == <span class="keyword">null</span> ? headB : pA.next;</span><br><span class="line">            pB = pB == <span class="keyword">null</span> ? headA : pB.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-反转单链表"><a href="#3-反转单链表" class="headerlink" title="3. 反转单链表"></a>3. 反转单链表</h3><p>两种思路：<br>（1）迭代<br>假设存在链表 <code>1 → 2 → 3 → Ø</code>，我们想要把它改成 <code>Ø ← 1 ← 2 ← 3</code>。</p><p>在遍历列表时，将当前节点的 next 指针改为指向前一个元素。由于节点没有引用其上一个节点，因此必须事先存储其前一个元素。在更改引用之前，还需要另一个指针来存储下一个节点。不要忘记在最后返回新的头引用！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode prev = <span class="keyword">null</span>;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        ListNode next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            next = cur.next;</span><br><span class="line">            cur.next = prev;</span><br><span class="line">            prev = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度分析</p><p>时间复杂度：O(n)，假设 n 是列表的长度，时间复杂度是 O(n)。<br>空间复杂度：O(1)。</p><p>（2）递归<br>核心思想：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head.next.next = head</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode p = reverseList(head.next);</span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度分析</p><p>时间复杂度：O(n)，假设 n 是列表的长度，那么时间复杂度为 O(n)。<br>空间复杂度：O(n)，由于使用递归，将会使用隐式栈空间。递归深度可能会达到 n 层。</p><h3 id="4-删除链表的倒数第N个节点"><a href="#4-删除链表的倒数第N个节点" class="headerlink" title="4. 删除链表的倒数第N个节点"></a>4. 删除链表的倒数第N个节点</h3><p>双指针法：<br>第一个指针从列表的开头向前移动 n+1n+1 步，而第二个指针将从列表的开头出发。现在，这两个指针被 n 个结点分开。我们通过同时移动两个指针向前来保持这个恒定的间隔，直到第一个指针到达最后一个结点。此时第二个指针将指向从最后一个结点数起的第 n 个结点。我们重新链接第二个指针所引用的结点的 next 指针指向该结点的下下个结点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123; </span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>); <span class="comment">// 哑指针，防止极端情况</span></span><br><span class="line">        dummy.next = head;</span><br><span class="line">        ListNode first = dummy;</span><br><span class="line">        ListNode second = dummy;</span><br><span class="line">        <span class="comment">// Advances first pointer so that the gap between first and second is n nodes apart</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            first = first.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Move first to the end, maintaining the gap</span></span><br><span class="line">        <span class="keyword">while</span> (first != <span class="keyword">null</span>) &#123;</span><br><span class="line">            first = first.next;</span><br><span class="line">            second = second.next;</span><br><span class="line">        &#125;</span><br><span class="line">        second.next = second.next.next;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>二叉树是一种非常重要的数据结构，很多其它数据结构都是基于二叉树的基础演变而来的。</p><p>对于二叉树，有深度遍历和广度遍历，深度遍历有前序、中序以及后序三种遍历方法，广度遍历即我们平常所说的层次遍历。</p><p>因为树的定义本身就是递归定义，因此采用递归的方法去实现树的三种遍历不仅容易理解而且代码很简洁，而对于广度遍历来说，需要其他数据结构的支撑，比如堆了。所以，对于一段代码来说，可读性有时候要比代码本身的效率要重要的多。</p><h3 id="1-二叉树深度遍历"><a href="#1-二叉树深度遍历" class="headerlink" title="1. 二叉树深度遍历"></a>1. 二叉树深度遍历</h3><ul><li>递归方式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 前序遍历</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrderTraverse1</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">System.out.print(root.val+<span class="string">"  "</span>);</span><br><span class="line">preOrderTraverse1(root.left);</span><br><span class="line">preOrderTraverse1(root.right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 中序遍历</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrderTraverse1</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">inOrderTraverse1(root.left);</span><br><span class="line">System.out.print(root.val+<span class="string">"  "</span>);</span><br><span class="line">inOrderTraverse1(root.right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 后序遍历</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrderTraverse1</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">postOrderTraverse1(root.left);</span><br><span class="line">postOrderTraverse1(root.right);</span><br><span class="line">System.out.print(root.val+<span class="string">"  "</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>非递归方式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 前序遍历</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrderTraverse</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    TreeNode cur = root;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(cur.val);</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur = stack.pop();</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 中序遍历</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">midOrderTraverse</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    TreeNode cur = root;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur = stack.pop();</span><br><span class="line">            System.out.println(cur.val);</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 后序遍历</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrderTraverse</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    TreeNode cur = root;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur = stack.pop();</span><br><span class="line">            System.out.println(cur.val);</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-二叉树层遍历"><a href="#2-二叉树层遍历" class="headerlink" title="2. 二叉树层遍历"></a>2. 二叉树层遍历</h3><p>层次遍历的代码比较简单，只需要一个队列即可，先在队列中加入根结点。之后对于任意一个结点来说，在其出队列的时候，访问之。同时如果左孩子和右孩子有不为空的，入队列。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">levelTraverse</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.offer(root);</span><br><span class="line">    TreeNode cur;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">        cur = queue.poll();</span><br><span class="line">        System.out.print(cur.val);</span><br><span class="line">        <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">            queue.offer(cur.left);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            queue.offer(cur.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;数组&quot;&gt;&lt;a href=&quot;#数组&quot; class=&quot;headerlink&quot; title=&quot;数组&quot;&gt;&lt;/a&gt;数组&lt;/h2&gt;&lt;p&gt;数组，将元素存储到内存的连续位置中，是最基本的数据结构。在任何和编程相关的面试中，都会被问到和数组相关的问题，可以说是非常热门的考题之一。比
      
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>虚拟机性能监控与故障处理工具</title>
    <link href="http://yoursite.com/2019/08/12/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7/"/>
    <id>http://yoursite.com/2019/08/12/虚拟机性能监控与故障处理工具/</id>
    <published>2019-08-12T13:10:43.000Z</published>
    <updated>2019-10-09T06:49:28.236Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本文参考的是周志明的 《深入理解Java虚拟机》 第四章 ，为了整理思路，简单记录一下，方便后期查阅。</p><p>JDK本身提供了很多方便的JVM性能调优监控工具，除了集成式的VisualVM和jConsole外，还有jps、jstack、jmap、jhat、jstat、hprof等小巧的工具，本文希望能起抛砖引玉之用，让大家能开始对JVM性能调优的常用工具有所了解。</p><h2 id="JDK的命令行工具"><a href="#JDK的命令行工具" class="headerlink" title="JDK的命令行工具"></a>JDK的命令行工具</h2><table><thead><tr><th>命令名称</th><th>全称</th><th>用途</th></tr></thead><tbody><tr><td><strong>jstat</strong></td><td>JVM Statistics Monitoring Tool</td><td>用于收集Hotspot虚拟机各方面的运行数据</td></tr><tr><td><strong>jps</strong></td><td>JVM Process Status Tool</td><td>显示指定系统内所有的HotSpot虚拟机进程</td></tr><tr><td><strong>jinfo</strong></td><td>Configuration Info for Java</td><td>显示虚拟机配置信息</td></tr><tr><td><strong>jmap</strong></td><td>JVM Memory Map</td><td>生成虚拟机的内存转储快照，生成heapdump文件</td></tr><tr><td><strong>jhat</strong></td><td>JVM Heap Dump Browser</td><td>用于分析heapdump文件，它会建立一个HTTP/HTML服务器，让用户在浏览器上查看分析结果</td></tr><tr><td><strong>jstack</strong></td><td>JVM Stack Trace</td><td>显示虚拟机的线程快照</td></tr></tbody></table><p>详情参考： <a href="https://www.ymq.io/2017/08/01/jvm-4/" target="_blank" rel="noopener">https://www.ymq.io/2017/08/01/jvm-4/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;本文参考的是周志明的 《深入理解Java虚拟机》 第四章 ，为了整理思路，简单记录一下，方便后期查阅。&lt;/p&gt;
&lt;p&gt;JDK本身提供了很多方
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
      <category term="JVM" scheme="http://yoursite.com/categories/Java/JVM/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="工具" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="Jvm" scheme="http://yoursite.com/tags/Jvm/"/>
    
  </entry>
  
</feed>
