<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Austin Brant</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-12-20T12:39:22.126Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Austin Brant</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>分布式ID生成器</title>
    <link href="http://yoursite.com/2019/12/20/%E5%88%86%E5%B8%83%E5%BC%8FID%E7%94%9F%E6%88%90%E5%99%A8/"/>
    <id>http://yoursite.com/2019/12/20/分布式ID生成器/</id>
    <published>2019-12-20T12:31:12.000Z</published>
    <updated>2019-12-20T12:39:22.126Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本要求"><a href="#基本要求" class="headerlink" title="基本要求"></a>基本要求</h2><ul><li>全局唯一  </li><li>趋势递增  </li><li>效率高（生成、使用、索引）</li><li>控制并发</li></ul><h2 id="常用策略"><a href="#常用策略" class="headerlink" title="常用策略"></a>常用策略</h2><p><img src="/images/distribute_uuid.jpg" alt></p><p><img src="/images/distribute_mysql_autoincrement.jpg" alt></p><p><img src="/images/distribute_mysql_ad.jpg" alt></p><p><img src="/images/distribute_snowflower.jpg" alt></p><p><img src="/images/distribute_snow_ad.jpg" alt></p><p><img src="/images/distribute_id_redis.jpg" alt></p><p><img src="/images/distribute_redis_advantage.jpg" alt></p><p><img src="/images/distribute_id_pk.jpg" alt></p><p><img src="/images/distribute_id_topk.jpg" alt></p><h2 id="Twitter雪花算法SnowFlake"><a href="#Twitter雪花算法SnowFlake" class="headerlink" title="Twitter雪花算法SnowFlake"></a>Twitter雪花算法SnowFlake</h2><p><img src="/images/distribute_snow_flower.jpg" alt></p><ul><li><p>1) 1位，不用。二进制中最高位为1的都是负数，但是我们生成的id一般都使用整数，所以这个最高位固定是0</p></li><li><p>2) 41位，用来记录时间戳（毫秒）。</p></li><li><p>3) 41位可以表示2^41−1个数字，如果只用来表示正整数（计算机中正数包含0），可以表示的数值范围是：0 至 2^41−1，减1是因为可表示的数值范围是从0开始算的，而不是1。<br>也就是说41位可以表示2^41−1个毫秒的值，转化成单位年则是(2^41−1)/(1000∗60∗60∗24∗365)=69年</p></li><li><p>4) 10位，用来记录工作机器id。<br>可以部署在2^10=1024个节点，包括5位datacenterId和5位workerId</p></li><li><p>5) 5位（bit）可以表示的最大正整数是2^5−1=31，即可以用0、1、2、3、….31这32个数字，来表示不同的datecenterId或workerId</p></li><li><p>6) 12位，序列号，用来记录同毫秒内产生的不同id。<br>12位（bit）可以表示的最大正整数是2^12−1=4095，即可以用0、1、2、3、….4094这4095个数字，来表示同一机器同一时间截（毫秒)内产生的4095个ID序号<br>由于在Java中64bit的整数是long类型，所以在Java中SnowFlake算法生成的id就是long来存储的。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基本要求&quot;&gt;&lt;a href=&quot;#基本要求&quot; class=&quot;headerlink&quot; title=&quot;基本要求&quot;&gt;&lt;/a&gt;基本要求&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;全局唯一  &lt;/li&gt;
&lt;li&gt;趋势递增  &lt;/li&gt;
&lt;li&gt;效率高（生成、使用、索引）&lt;/li&gt;
&lt;li&gt;控
      
    
    </summary>
    
      <category term="分布式" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="分布式" scheme="http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Springboot集成mybatis自定义插件开发</title>
    <link href="http://yoursite.com/2019/12/20/Springboot%E9%9B%86%E6%88%90mybatis%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    <id>http://yoursite.com/2019/12/20/Springboot集成mybatis自定义插件开发/</id>
    <published>2019-12-20T12:14:43.000Z</published>
    <updated>2019-12-20T12:18:12.339Z</updated>
    
    <content type="html"><![CDATA[<h2 id="mybatis架构"><a href="#mybatis架构" class="headerlink" title="mybatis架构"></a>mybatis架构</h2><p><img src="/images/mybatis_structure.png" alt="Pasted Graphi"></p><h2 id="mybatis工作原理"><a href="#mybatis工作原理" class="headerlink" title="mybatis工作原理"></a>mybatis工作原理</h2><p><img src="/images/mybatis_process.jpg" alt="-w777"></p><p>执行流程：</p><ol><li>读取核心配置文件并返回InputStream流对象。 </li><li>根据InputStream流对象解析出Configuration对象，然后创建SqlSessionFactory工厂对象 </li><li>根据一系列属性从SqlSessionFactory工厂中创建SqlSession </li><li>从SqlSession中调用Executor执行数据库操作&amp;&amp;生成具体SQL指令 </li><li>对执行结果进行二次封装 </li><li>提交与事务</li></ol><h2 id="mybatis插件简介"><a href="#mybatis插件简介" class="headerlink" title="mybatis插件简介"></a>mybatis插件简介</h2><p>mybatis插件就是在执行数据库操作的时候，对于特定方法进行拦截增强，做一些额外的处理的一种方式。<br>myabtis的插件的增强原理是利用动态代理实现的，可以对数据库操作的执行类做拦截，mybatis主要操作流程如下：</p><p><img src="/images/mybatis_process.jpg" alt></p><p>mybatis中的几个操作数据库的执行类是：Executor、StatementHandler、ParameterHandler、ResultSetHandler，其中：</p><ul><li><p>Executor 是总的执行者，他就像一个大总管，用于协调管理其他执行者。</p></li><li><p>StatementHandler 拦截Sql语法构建的处理, 是用于生成Statement或者PreparedStatement的执行者，同时他会调用ParameterHandler进行对sql语句中的参数设值，设置完了之后会通过StatementHandler 去调用sql在数据库中执行，最后返回一个结果集，通过ResultSetHandler将结果集和对应的实体进行映射填充数据，之后会把结果实体返回给StatementHandler。</p></li><li><p>ParameterHandler ：拦截参数的处理 </p></li><li><p>ResultSetHandler ：拦截结果集的处理 </p></li></ul><p>所以，我们对这几个执行者进行拦截，比如对于StatementHandler 拦截，即是对于sql操作进行拦截，Mybatis自定义插件必须实现Interceptor接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">    <span class="function">Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line">    <span class="function">Object <span class="title">plugin</span><span class="params">(Object target)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>intercept方法：拦截器具体处理逻辑方法 </li><li>plugin方法：根据签名signatureMap生成动态代理对象 </li><li>setProperties方法：设置Properties属性</li></ul><p>下面就对于这个StatementHandler 进行拦截做一个分页实例。</p><h2 id="分页插件"><a href="#分页插件" class="headerlink" title="分页插件"></a>分页插件</h2><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>拦截数据sql,实现分页功能</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Austin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2019/9/1 11:37   Sun</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Intercepts</span>(<span class="meta">@Signature</span>(</span><br><span class="line">        type = StatementHandler.class,</span><br><span class="line">        method = <span class="string">"prepare"</span>,</span><br><span class="line">        args = &#123;Connection.class, Integer.class&#125;</span><br><span class="line">))</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PagePlugin</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;mybatis.page.plugin.dialect&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String dialect;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;mybatis.page.plugin.pageSqlId&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String pageSqlId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插件需要做的事情</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// 确定哪些方法需要做分页</span></span><br><span class="line">        StatementHandler statementHandler = (StatementHandler) invocation.getTarget();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取原始sql</span></span><br><span class="line">        BoundSql boundSql = statementHandler.getBoundSql();</span><br><span class="line">        String sql = boundSql.getSql();</span><br><span class="line">        System.out.println(<span class="string">"原始sql: "</span> + sql);</span><br><span class="line"></span><br><span class="line">        MetaObject metaObject = MetaObject.forObject(statementHandler,</span><br><span class="line">                SystemMetaObject.DEFAULT_OBJECT_FACTORY,</span><br><span class="line">                SystemMetaObject.DEFAULT_OBJECT_WRAPPER_FACTORY,</span><br><span class="line">                <span class="keyword">new</span> DefaultReflectorFactory());</span><br><span class="line"></span><br><span class="line">        MappedStatement mappedStatement = (MappedStatement) metaObject.getValue(<span class="string">"delegate.mappedStatement"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//        //sql语句类型 select、delete、insert、update</span></span><br><span class="line">        <span class="comment">//        String sqlCommandType = mappedStatement.getSqlCommandType().toString();</span></span><br><span class="line">        <span class="comment">// 获取mapper接口中的方法名</span></span><br><span class="line">        String mapperMethodName = mappedStatement.getId();</span><br><span class="line"></span><br><span class="line">        Object paramObj = boundSql.getParameterObject();</span><br><span class="line">        <span class="keyword">if</span> (mapperMethodName.matches(<span class="string">".*ByPage$"</span>)) &#123;</span><br><span class="line">            Map&lt;String, Object&gt; params = (Map&lt;String, Object&gt;) paramObj;</span><br><span class="line">            PageInfo pageInfo = (PageInfo) params.get(<span class="string">"page"</span>);   <span class="comment">// map.put("page", pageInfo)</span></span><br><span class="line"></span><br><span class="line">            String countSql = <span class="string">"select count(1) from ("</span> + sql + <span class="string">") temp "</span>;</span><br><span class="line">            System.out.println(<span class="string">"查询总数sql: "</span> + countSql);</span><br><span class="line"></span><br><span class="line">            Connection connection = (Connection) invocation.getArgs()[<span class="number">0</span>];</span><br><span class="line">            PreparedStatement countStatement = connection.prepareStatement(countSql);</span><br><span class="line">            ParameterHandler parameterHandler = (ParameterHandler) metaObject.getValue(<span class="string">"delegate.parameterHandler"</span>);</span><br><span class="line">            parameterHandler.setParameters(countStatement);</span><br><span class="line">            ResultSet rs = countStatement.executeQuery();</span><br><span class="line">            <span class="keyword">if</span> (rs.next()) &#123;</span><br><span class="line">                pageInfo.setTotalNumber(rs.getInt(<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            rs.close();</span><br><span class="line">            countStatement.close();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 改造sql limit count</span></span><br><span class="line">            String pageSql = <span class="keyword">this</span>.generatePageSql(sql, pageInfo);</span><br><span class="line">            System.out.println(<span class="string">"分页sql: "</span> + pageSql);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 改造后的sql放回</span></span><br><span class="line">            metaObject.setValue(<span class="string">"delegate.boundSql.sql"</span>, pageSql);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行流程提交mybatis</span></span><br><span class="line">        <span class="keyword">return</span> invocation.proceed();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">generatePageSql</span><span class="params">(String sql, PageInfo pageInfo)</span> </span>&#123;</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">if</span> (dialect.equals(<span class="string">"mysql"</span>)) &#123;</span><br><span class="line">            sb.append(sql);</span><br><span class="line">            sb.append(<span class="string">" limit "</span> + pageInfo.getStartIndex() + <span class="string">" ,"</span> + pageInfo.getTotalSelect());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">plugin</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Plugin.wrap(target, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>myabtis自定义插件只需要实现Interceptor接口即可，并且注解@Intercepts以及@Signature配置需要拦截的对象，其中</p><ul><li>type是需要拦截的对象Class，</li><li>method是对象里面的方法，</li><li>args是方法参数类型。</li></ul><h2 id="注入插件到拦截链"><a href="#注入插件到拦截链" class="headerlink" title="注入插件到拦截链"></a>注入插件到拦截链</h2><p>这里有两种方式注入</p><ul><li><p>方式一：直接注入</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Spring boot项目中只需要在拦截器类上加 @Component 注解即可。</span><br></pre></td></tr></table></figure></li><li><p>方式二：通过myabtis配置加入到拦截链中(多个拦截器时，这种方式可以控制拦截顺序）</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@MapperScan</span>(&#123;<span class="string">"com.springboot.demo.mapper"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperConfig</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//将插件加入到mybatis插件拦截链中</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ConfigurationCustomizer <span class="title">configurationCustomizer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConfigurationCustomizer() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(Configuration configuration)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//插件拦截链采用了责任链模式，执行顺序和加入连接链的顺序有关</span></span><br><span class="line">                MyPlugin myPlugin = <span class="keyword">new</span> MyPlugin();</span><br><span class="line">                <span class="comment">//设置参数，比如阈值等，可以在配置文件中配置，这里直接写死便于测试</span></span><br><span class="line">                Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">                <span class="comment">//这里设置慢查询阈值为1毫秒，便于测试</span></span><br><span class="line">                properties.setProperty(<span class="string">"time"</span>, <span class="string">"1"</span>);</span><br><span class="line">                myPlugin.setProperties(properties);</span><br><span class="line">                </span><br><span class="line">                configuration.addInterceptor(myPlugin);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;mybatis架构&quot;&gt;&lt;a href=&quot;#mybatis架构&quot; class=&quot;headerlink&quot; title=&quot;mybatis架构&quot;&gt;&lt;/a&gt;mybatis架构&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/images/mybatis_structure.png&quot; a
      
    
    </summary>
    
      <category term="数据库中间件" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
      <category term="Mybatis" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E9%97%B4%E4%BB%B6/Mybatis/"/>
    
    
      <category term="Springboot" scheme="http://yoursite.com/tags/Springboot/"/>
    
      <category term="Mybatis" scheme="http://yoursite.com/tags/Mybatis/"/>
    
  </entry>
  
  <entry>
    <title>java编译执行有第三方依赖的类</title>
    <link href="http://yoursite.com/2019/12/20/java%E7%BC%96%E8%AF%91%E6%89%A7%E8%A1%8C%E6%9C%89%E7%AC%AC%E4%B8%89%E6%96%B9%E4%BE%9D%E8%B5%96%E7%9A%84%E7%B1%BB/"/>
    <id>http://yoursite.com/2019/12/20/java编译执行有第三方依赖的类/</id>
    <published>2019-12-20T11:53:51.000Z</published>
    <updated>2019-12-20T11:54:48.749Z</updated>
    
    <content type="html"><![CDATA[<p>有时候在进行开发的过程中，需要自己写个测试类来进行某个局部功能的测试，在测试的过程中，需要引入第三方jar包或者公司其他成员的帮助类，比如说：我需要测试一个<br>net.sf.json.JSONObject解析数据的时候中文乱码问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> net.sf.json.JSONException;</span><br><span class="line"><span class="keyword">import</span> net.sf.json.JSONObject;</span><br><span class="line"><span class="keyword">import</span> net.sf.json.JsonConfig;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.URLEncoder;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by 神器 on 2017/3/29.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZyhqErrorMsgDemo</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        InputStream inputStream = <span class="keyword">null</span>;</span><br><span class="line">        InputStreamReader inputStreamReader = <span class="keyword">null</span>;</span><br><span class="line">        BufferedReader in = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            String filePath = <span class="string">"/home/1.txt"</span>;</span><br><span class="line">            File file = <span class="keyword">new</span> File(filePath);</span><br><span class="line">            String code = codeString(filePath);</span><br><span class="line">            System.out.println(<span class="string">"文件类型:"</span> + code);</span><br><span class="line">            inputStream = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">            inputStreamReader = <span class="keyword">new</span> InputStreamReader(inputStream, <span class="string">"UTF-8"</span>);</span><br><span class="line">            in = <span class="keyword">new</span> BufferedReader(inputStreamReader);</span><br><span class="line">            String firstLine = in.readLine();<span class="comment">//过滤掉首行，以便循环体从第二行（申赎明细处理结果）</span></span><br><span class="line">            String line = <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">while</span> ((line = in.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"line:=====&gt;"</span>+ line);</span><br><span class="line">                System.out.println();</span><br><span class="line">                System.out.println();</span><br><span class="line">                JSONObject jsonObject = JSONObject.fromObject(line);</span><br><span class="line">                String status = jsonObject.getString(<span class="string">"status"</span>);</span><br><span class="line">                String objectStr = jsonObject.getString(<span class="string">"content"</span>);</span><br><span class="line">                String errorMessage = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    errorMessage = jsonObject.get(<span class="string">"errorMessage"</span>).toString();</span><br><span class="line">                &#125;<span class="keyword">catch</span> (JSONException ex) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"there is no errorMessage from Zyhq holding respon file"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"errorMessage:------&gt;"</span> + errorMessage);</span><br><span class="line">            &#125;</span><br><span class="line">            in.close();</span><br><span class="line">            inputStreamReader.close();</span><br><span class="line">            inputStream.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception ex)&#123;</span><br><span class="line">            System.out.println(<span class="string">"下载文件并解析文件内容时出错"</span>+ex.getStackTrace());</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (in != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    in.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"> </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (inputStreamReader != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    inputStreamReader.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"> </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (inputStream != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    inputStream.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"> </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断文件的编码格式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fileName :file</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 文件编码格式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">codeString</span><span class="params">(String fileName)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        BufferedInputStream bin = <span class="keyword">new</span> BufferedInputStream(</span><br><span class="line">                <span class="keyword">new</span> FileInputStream(fileName));</span><br><span class="line">        <span class="keyword">int</span> p = (bin.read() &lt;&lt; <span class="number">8</span>) + bin.read();</span><br><span class="line">        String code = <span class="keyword">null</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">switch</span> (p) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xefbb</span>:</span><br><span class="line">                code = <span class="string">"UTF-8"</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xfffe</span>:</span><br><span class="line">                code = <span class="string">"Unicode"</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xfeff</span>:</span><br><span class="line">                code = <span class="string">"UTF-16BE"</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                code = <span class="string">"GBK"</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写好之后上传到服务器上，需要自己在java文件目录上传好依赖的第三方jar包，然后编译：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac -cp commons-beanutils-1.8.3.jar:commons-collections-3.2.1.jar:commons-lang-2.6.jar:commons-logging-1.2.jar:json-lib-2.4-jdk15.jar: ZyhqErrorMsgDemo.java</span><br></pre></td></tr></table></figure><p><font color="red"><strong>切记：最后一个jar包后的：后面要加上一个空格再引入自己的Java文件</strong></font></p><p>执行的命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac -cp commons-beanutils-1.8.3.jar:commons-collections-3.2.1.jar:commons-lang-2.6.jar:commons-logging-1.2.jar:json-lib-2.4-jdk15.jar: ZyhqErrorMsgDemo</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有时候在进行开发的过程中，需要自己写个测试类来进行某个局部功能的测试，在测试的过程中，需要引入第三方jar包或者公司其他成员的帮助类，比如说：我需要测试一个&lt;br&gt;net.sf.json.JSONObject解析数据的时候中文乱码问题&lt;/p&gt;
&lt;figure class=&quot;
      
    
    </summary>
    
      <category term="教程" scheme="http://yoursite.com/categories/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Java" scheme="http://yoursite.com/categories/%E6%95%99%E7%A8%8B/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="基础" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Guice使用入门</title>
    <link href="http://yoursite.com/2019/12/20/Guice%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2019/12/20/Guice使用入门/</id>
    <published>2019-12-20T11:49:15.000Z</published>
    <updated>2019-12-20T11:51:13.622Z</updated>
    
    <content type="html"><![CDATA[<p>Guice是谷歌推出的一个轻量级依赖注入框架，帮助我们解决Java项目中的依赖注入问题。如果使用过Spring的话，会了解到依赖注入是个非常方便的功能。不过假如只想在项目中使用依赖注入，那么引入Spring未免大材小用了。这时候我们可以考虑使用Guice。本文参考了Guice官方文档，详细信息可以直接查看Guice文档。</p><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>如果使用Maven的话，添加下面的依赖项。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.google.inject&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;guice&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;4.2.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><p>Guice的注入非常方便，不需要配置文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 被依赖的dao</span></span><br><span class="line"><span class="meta">@Singleton</span> <span class="comment">// 打上了这个标记说明是单例的，否则Guice每次回返回一个新的对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDao</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"dao is saying"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// service，依赖 UserDao</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">private</span> UserDao mUserDao;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mUserDao.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Start</span>  </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//这步就是我们问Guice去要对象</span></span><br><span class="line">        <span class="keyword">final</span> Injector injector = Guice.createInjector();</span><br><span class="line">        <span class="keyword">final</span> UserService userService = injector.getInstance(UserService.class);</span><br><span class="line">        userService.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果输出：</p><pre><code>dao is saying</code></pre><p>复制代码可以看到没有任何的xml配置，唯一需要做的，就是在需要注入的属性上打上<code>@inject</code>。<br>使用 <code>Guice.createInjector()</code> 启动。通常需要尽早在程序中创建注入器。这样 Guice 能够帮助您创建大部分对象.</p><p><strong>该demo中，并没有用到Module，也成功运行了，是因为之前没有涉及到接口，当只是依赖<font color="red"> 确切的实现类 </font> 的时候，Guice会自动的找到需要注入的实现类</strong></p><h2 id="依赖绑定"><a href="#依赖绑定" class="headerlink" title="依赖绑定"></a>依赖绑定</h2><h3 id="链式绑定"><a href="#链式绑定" class="headerlink" title="链式绑定"></a>链式绑定</h3><p>我们在绑定依赖的时候不仅可以将父类和子类绑定，还可以将子类和更具体的子类绑定。下面的例子中，当我们需要<code>TransactionLog</code>的时候，<code>Guice</code>最后会为我们注入<code>MySqlDatabaseTransactionLog</code>对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BillingModule</span> <span class="keyword">extends</span> <span class="title">AbstractModule</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        bind(TransactionLog.class).to(DatabaseTransactionLog.class);</span><br><span class="line">        bind(DatabaseTransactionLog.class).to(MySqlDatabaseTransactionLog.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注解绑定"><a href="#注解绑定" class="headerlink" title="注解绑定"></a>注解绑定</h3><p>当我们需要将多个同一类型的对象注入不同对象的时候，就需要使用注解区分这些依赖了。最简单的办法就是使用@Named注解进行区分。</p><p>首先需要在要注入的地方添加@Named注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealBillingService</span> <span class="keyword">implements</span> <span class="title">BillingService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Inject</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">RealBillingService</span><span class="params">(@Named(<span class="string">"Checkout"</span>)</span> CreditCardProcessor processor,</span></span><br><span class="line"><span class="function">      TransactionLog transactionLog) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>然后在绑定中添加<code>annotatedWith</code>方法指定<code>@Named中</code>指定的名称。由于编译器无法检查字符串，所以Guice官方建议我们保守地使用这种方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bind(CreditCardProcessor.class)</span><br><span class="line">    .annotatedWith(Names.named(<span class="string">"Checkout"</span>))</span><br><span class="line">    .to(CheckoutCreditCardProcessor.class);</span><br></pre></td></tr></table></figure><p>如果希望使用<strong>类型安全</strong>的方式，可以自定义注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BindingAnnotation</span> </span><br><span class="line"><span class="meta">@Target</span>(&#123; FIELD, PARAMETER, METHOD &#125;) </span><br><span class="line"><span class="meta">@Retention</span>(RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> PayPal &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在需要注入的类上应用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealBillingService</span> <span class="keyword">implements</span> <span class="title">BillingService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Inject</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">RealBillingService</span><span class="params">(@PayPal CreditCardProcessor processor,</span></span></span><br><span class="line"><span class="function"><span class="params">      TransactionLog transactionLog)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>在配置类中，使用方法也和@Named类似。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bind(CreditCardProcessor.class)</span><br><span class="line">    .annotatedWith(PayPal.class)</span><br><span class="line">    .to(PayPalCreditCardProcessor.class);</span><br></pre></td></tr></table></figure><h3 id="实例绑定"><a href="#实例绑定" class="headerlink" title="实例绑定"></a>实例绑定</h3><p>有时候需要直接注入一个对象的实例，而不是从依赖关系中解析。如果我们要注入基本类型的话只能这么做。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">bind(String.class)</span><br><span class="line">    .annotatedWith(Names.named(<span class="string">"JDBC URL"</span>))</span><br><span class="line">    .toInstance(<span class="string">"jdbc:mysql://localhost/pizza"</span>);</span><br><span class="line">    </span><br><span class="line">bind(Integer.class)</span><br><span class="line">    .annotatedWith(Names.named(<span class="string">"login timeout seconds"</span>))</span><br><span class="line">    .toInstance(<span class="number">10</span>);</span><br><span class="line">```    </span><br><span class="line">    </span><br><span class="line">如果使用`toInstance()`方法注入的实例比较复杂的话，可能会影响程序启动。这时候可以使用`<span class="meta">@Provides</span>`方法代替。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### @Provides方法</span><br><span class="line">当一个对象很复杂，无法使用简单的构造器来生成的时候，我们可以使用`<span class="meta">@Provides</span>`方法，也就是在配置类中生成一个注解了`<span class="meta">@Provides</span>`的方法。在该方法中我们可以编写任意代码来构造对象。</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BillingModule</span> <span class="keyword">extends</span> <span class="title">AbstractModule</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Provides</span></span><br><span class="line">  <span class="function">TransactionLog <span class="title">provideTransactionLog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DatabaseTransactionLog transactionLog = <span class="keyword">new</span> DatabaseTransactionLog();</span><br><span class="line">    transactionLog.setJdbcUrl(<span class="string">"jdbc:mysql://localhost/pizza"</span>);</span><br><span class="line">    transactionLog.setThreadPoolSize(<span class="number">30</span>);</span><br><span class="line">    <span class="keyword">return</span> transactionLog;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@Provides</code>方法也可以应用<code>@Named</code>和自定义注解，还可以注入其他依赖，Guice会在调用方法之前注入需要的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Provides</span> <span class="meta">@PayPal</span></span><br><span class="line"><span class="function">CreditCardProcessor <span class="title">providePayPalCreditCardProcessor</span><span class="params">(@Named(<span class="string">"PayPal API key"</span>)</span> String apiKey) </span>&#123;</span><br><span class="line">  PayPalCreditCardProcessor processor = <span class="keyword">new</span> PayPalCreditCardProcessor();</span><br><span class="line">  processor.setApiKey(apiKey);</span><br><span class="line">  <span class="keyword">return</span> processor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Provider绑定"><a href="#Provider绑定" class="headerlink" title="Provider绑定"></a>Provider绑定</h3><p>如果项目中存在多个比较复杂的对象需要构建，使用<code>@Provides</code>方法会让配置类变得比较乱。我们可以使用Guice提供的<code>Provider</code>接口将复杂的代码放到单独的类中。办法很简单，实现<code>Provider&lt;T&gt;</code>接口的<code>get</code>方法即可。在<code>Provider</code>类中，我们可以使用<code>@Inject</code>任意注入对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DatabaseTransactionLogProvider</span> <span class="keyword">implements</span> <span class="title">Provider</span>&lt;<span class="title">TransactionLog</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Connection connection;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Inject</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DatabaseTransactionLogProvider</span><span class="params">(Connection connection)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.connection = connection;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> TransactionLog <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DatabaseTransactionLog transactionLog = <span class="keyword">new</span> DatabaseTransactionLog();</span><br><span class="line">    transactionLog.setConnection(connection);</span><br><span class="line">    <span class="keyword">return</span> transactionLog;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在配置类中使用<code>toProvider</code>方法绑定到<code>Provider</code>上即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BillingModule</span> <span class="keyword">extends</span> <span class="title">AbstractModule</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    bind(TransactionLog.class)</span><br><span class="line">        .toProvider(DatabaseTransactionLogProvider.class);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>默认情况下Guice会在每次注入的时候创建一个新对象。如果希望创建一个单例依赖的话，可以在实现类上应用<code>@Singleton</code>注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Singleton</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InMemoryTransactionLog</span> <span class="keyword">implements</span> <span class="title">TransactionLog</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* everything here should be threadsafe! */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者也可以在配置类中指定。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bind(TransactionLog.class)</span><br><span class="line">    .to(InMemoryTransactionLog.class)</span><br><span class="line">    .in(Singleton.class);</span><br></pre></td></tr></table></figure><p>在<code>@Provides</code>方法中也可以指定单例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Provides</span> </span><br><span class="line"><span class="meta">@Singleton</span></span><br><span class="line"><span class="function">TransactionLog <span class="title">provideTransactionLog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果一个类型上存在多个冲突的作用域，<code>Guice</code>会使用<code>bind()</code>方法中指定的作用域。如果不想使用注解的作用域，可以在<code>bind()</code>方法中将对象绑定为<code>Scopes.NO_SCOPE</code>。</p><p>Guice和它的扩展提供了很多作用域，有单例<code>Singleton</code>，Session作用域<code>SessionScoped</code>，Request请求作用域<code>RequestScoped</code>等等。我们可以根据需要选择合适的作用域。</p><p>参考：<br><a href="https://juejin.im/post/5a375e156fb9a0452a3c6b96" target="_blank" rel="noopener">Google-Guice入门教程</a></p><p><a href="https://www.jianshu.com/p/a648322dc680" target="_blank" rel="noopener">Guice 快速入门</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Guice是谷歌推出的一个轻量级依赖注入框架，帮助我们解决Java项目中的依赖注入问题。如果使用过Spring的话，会了解到依赖注入是个非常方便的功能。不过假如只想在项目中使用依赖注入，那么引入Spring未免大材小用了。这时候我们可以考虑使用Guice。本文参考了Guic
      
    
    </summary>
    
      <category term="教程" scheme="http://yoursite.com/categories/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Guice" scheme="http://yoursite.com/categories/%E6%95%99%E7%A8%8B/Guice/"/>
    
    
      <category term="Guice" scheme="http://yoursite.com/tags/Guice/"/>
    
      <category term="教程" scheme="http://yoursite.com/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Kafka进阶-基本原理</title>
    <link href="http://yoursite.com/2019/12/20/Kafka%E8%BF%9B%E9%98%B6-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2019/12/20/Kafka进阶-基本原理/</id>
    <published>2019-12-20T11:34:19.000Z</published>
    <updated>2019-12-20T11:45:27.290Z</updated>
    
    <content type="html"><![CDATA[<h2 id="集群架构图"><a href="#集群架构图" class="headerlink" title="集群架构图"></a>集群架构图</h2><p><img src="/images/kafka_cluster_architecture.png" alt="kafka_cluster_architecture"></p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul><li><p>日志收集：一个公司可以用Kafka可以收集各种服务的log，通过kafka以统一接口服务的方式开放给各种consumer，例如hadoop、Hbase、Solr等。</p></li><li><p>消息系统：解耦和生产者和消费者、缓存消息等。</p></li><li><p>用户活动跟踪：Kafka经常被用来记录web用户或者app用户的各种活动，如浏览网页、搜索、点击等活动，这些活动信息被各个服务器发布到kafka的topic中，然后订阅者通过订阅这些topic来做实时的监控分析，或者装载到hadoop、数据仓库中做离线分析和挖掘。</p></li><li><p>运营指标：Kafka也经常用来记录运营监控数据。包括收集各种分布式应用的数据，生产各种操作的集中反馈，比如报警和报告。</p></li><li><p>流式处理：比如spark streaming和storm</p></li><li><p>事件源</p></li></ul><h2 id="如何做到高吞吐、低延迟"><a href="#如何做到高吞吐、低延迟" class="headerlink" title="如何做到高吞吐、低延迟"></a>如何做到高吞吐、低延迟</h2><p>Kafka写数据的大致方式：<strong>先写操作系统的页缓存（Page Cache）,然后由操作系统自行决定何时刷到磁盘</strong>。</p><p>因此 Kafka 达到高吞吐、低延迟的原因主要有以下4点：</p><ul><li><p><strong>页缓存是在内存中分配的</strong>，所以消息写入的速度很快。</p></li><li><p>Kafka不必和底层的文件系统进行交互，所有<strong>繁琐的I/O操作都由操作系统来处理</strong>。</p></li><li><p>Kafka采用<strong>追加写的方式，避免了磁盘随机写操作</strong>。</p></li><li><p><strong>使用以Sendfile为代表的零拷贝技术</strong>提高了读取数据的效率。</p></li></ul><blockquote><p>PS: 使用页缓存而非堆内存还有一个好处，就是当Kafka broker的进程崩溃时，堆内存的数据会丢失，但是<strong>页缓存的数据依然存在</strong>，重启Kafka broker后可以继续提供服务。</p></blockquote><h2 id="Producer工作流程"><a href="#Producer工作流程" class="headerlink" title="Producer工作流程"></a>Producer工作流程</h2><p><img src="/images/kafka_producer_process.jpg" alt></p><h3 id="序列化消息-amp-amp-计算partition"><a href="#序列化消息-amp-amp-计算partition" class="headerlink" title="序列化消息 &amp;&amp; 计算partition"></a>序列化消息 &amp;&amp; 计算partition</h3><p>根据key和value的配置对消息进行序列化,然后计算partition：  </p><ul><li><p>ProducerRecord对象中如果指定了partition，就使用这个partition;</p></li><li><p>否则根据key和topic的partition数目取余;</p></li><li><p>如果key也没有的话就随机生成一个counter，使用这个counter来和partition数目取余。这个counter每次使用的时候递增。</p></li></ul><h3 id="发送到batch-amp-amp-唤醒Sender线程"><a href="#发送到batch-amp-amp-唤醒Sender线程" class="headerlink" title="发送到batch &amp;&amp; 唤醒Sender线程"></a>发送到batch &amp;&amp; 唤醒Sender线程</h3><p>根据topic-partition获取对应的<code>batchs（Dueue&lt;ProducerBatch&gt;）</code>，然后将消息append到batch中. 如果有batch满了则唤醒Sender线程。队列的操作是加锁执行，所以batch内消息是有序的，后续的Sender操作为异步操作。  </p><h3 id="Sender把消息有序发到broker（tp-replia-leader）"><a href="#Sender把消息有序发到broker（tp-replia-leader）" class="headerlink" title="Sender把消息有序发到broker（tp replia leader）"></a>Sender把消息有序发到broker（tp replia leader）</h3><p><strong>确定tp relica leader 所在的broker</strong></p><ul><li><p>Kafka中每台broker都保存了kafka集群的<code>metadata</code>信息，metadata信息里包括了每个topic的所有partition的信息: <code>leader</code>, <code>leader_epoch</code>, <code>controller_epoch</code>, <code>isr</code>, <code>replicas</code>等; Kafka客户端从任一broker都可以获取到需要的metadata信息; sender线程通过metadata信息可以知道tp leader的brokerId</p></li><li><p>producer也保存了metada信息，同时根据metadata更新策略（定期更新<code>metadata.max.age.ms</code>、失效检测，强制更新)：检查到metadata失效以后，调用<code>metadata.requestUpdate()</code>强制更新</p></li></ul><p><strong>幂等性发送</strong><br>为实现Producer的幂等性，Kafka引入了<code>Producer ID</code>（即PID）和<code>Sequence Number</code>。<strong>对于每个PID，该Producer发送消息的每个&lt;Topic, Partition&gt;都对应一个单调递增的Sequence Number</strong>。同样，Broker端也会为每个&lt;PID, Topic, Partition&gt;维护一个序号，并且每Commit一条消息时将其对应序号递增。对于接收的每条消息，如果其序号比Broker维护的序号）大一，则Broker会接受它，否则将其丢弃：  </p><ul><li><p>如果消息序号比Broker维护的序号差值比一大，说明中间有数据尚未写入，即乱序，此时Broker拒绝该消息，Producer抛出<code>InvalidSequenceNumber</code></p></li><li><p>如果消息序号小于等于Broker维护的序号，说明该消息已被保存，即为重复消息，Broker直接丢弃该消息，Producer抛出<code>DuplicateSequenceNumber</code></p></li></ul><h3 id="Sender处理broker发来的produce-response"><a href="#Sender处理broker发来的produce-response" class="headerlink" title="Sender处理broker发来的produce response"></a>Sender处理broker发来的produce response</h3><p>一旦broker处理完Sender的produce请求，就会发送produce response给Sender，此时producer将执行我们为send()设置的回调函数。至此producer的send执行完毕。   </p><h2 id="Consumer工作流程"><a href="#Consumer工作流程" class="headerlink" title="Consumer工作流程"></a>Consumer工作流程</h2><h3 id="Poll消息"><a href="#Poll消息" class="headerlink" title="Poll消息"></a>Poll消息</h3><p><img src="/images/kafka_consumer_poll.jpg" alt></p><ul><li><p>消费者通过fetch线程拉消息（单线程）</p></li><li><p>消费者通过心跳线程来与broker发送心跳。超时会认为挂掉</p></li><li><p>每个<code>consumer group</code>在<code>broker</code>上都有一个<code>coordnator</code>来管理，消费者加入和退出，以及消费消息的位移都由<code>coordnator</code>处理。</p></li></ul><h3 id="位移管理"><a href="#位移管理" class="headerlink" title="位移管理"></a>位移管理</h3><p>consumer的消息位移代表了当前group对topic-partition的消费进度，consumer宕机重启后可以继续从该offset开始消费。</p><p>在kafka0.8之前，位移信息存放在zookeeper上，由于zookeeper不适合高并发的读写，新版本Kafka把位移信息当成消息，发往 <strong><em>__consumers_offsets</em></strong> 这个 topic 所在的 broker，<strong><em>__consumers_offsets</em></strong> 默认有50个分区。<br>消息的key 是 <code>groupId+topic_partition</code>, value 是<code>offset</code>.<br><img src="/images/kafka_weiyi_manage.jpg" alt="-w887"></p><h3 id="Kafka-Group状态"><a href="#Kafka-Group状态" class="headerlink" title="Kafka Group状态"></a>Kafka Group状态</h3><p><img src="/images/kafka_group_status.jpg" alt></p><ul><li><p><strong>Empty</strong>：初始状态，Group 没有任何成员，如果所有的 offsets 都过期的话就会变成 Dead</p></li><li><p><strong>PreparingRebalance</strong>：Group 正在准备进行 Rebalance</p></li><li><p><strong>AwaitingSync</strong>：Group 正在等待 group leader 的分配方案</p></li><li><p><strong>Stable</strong>：稳定的状态（Group is stable）；</p></li><li><p><strong>Dead</strong>： Group 内已经没有成员，并且它的 Metadata 已经被移除</p></li></ul><h3 id="重平衡Reblance"><a href="#重平衡Reblance" class="headerlink" title="重平衡Reblance"></a>重平衡Reblance</h3><p>当一些原因导致consumer对partition消费不再均匀时，kafka 会自动执行rebalance，使得consumer对partition的消费再次平衡。</p><p>什么时候发生rebalance？：</p><ul><li><p>组订阅topic数变更</p></li><li><p>topic partition数变更</p></li><li><p>consumer成员变更</p></li></ul><h4 id="Reblance过程"><a href="#Reblance过程" class="headerlink" title="Reblance过程"></a>Reblance过程</h4><ul><li><p><strong>举例1 consumer被检测为崩溃引起的rebalance</strong><br>比如心跳线程在 <code>timeout</code> 时间内没和 <code>broker</code> 发送心跳，此时 <code>coordinator</code> 认为该group应该进行rebalance。接下来其他consumer发来fetch请求后，coordinator将回复他们进行rebalance通知。当consumer成员收到请求后，只有leader会根据分配策略进行分配，然后把各自的分配结果返回给coordinator。 这个时候只有consumer leader返回的是实质数据，其他返回的都为空。收到分配方法后，coordinator将会把分配策略同步给各consumer.</p></li><li><p><strong>举例2 consumer加入引起的rebalance</strong></p><ul><li><p>使用 <strong>join</strong> 协议，表示有consumer 要加入到group中<br><img src="/images/kafka_rebalance_join.jpg" alt></p></li><li><p>使用 <strong>sync</strong> 协议，根据分配规则进行分配<br><img src="/images/kafka_rebalance_sync.jpg" alt></p></li></ul></li></ul><h3 id="Rebalance机制存在的问题"><a href="#Rebalance机制存在的问题" class="headerlink" title="Rebalance机制存在的问题"></a>Rebalance机制存在的问题</h3><p>在大型系统中，一个topic可能对应数百个consumer实例。 </p><ul><li><p>这些consumer陆续加入到一个空消费组将导致多次的rebalance； </p></li><li><p>此外consumer 实例启动的时间不可控，很有可能超出coordinator确定的rebalance timeout(即max.poll.interval.ms)，将会再次触发rebalance，而每次rebalance的代价又相当地大，因为很多状态都需要在rebalance前被持久化，而在rebalance后被重新初始化</p><h3 id="新版本改进"><a href="#新版本改进" class="headerlink" title="新版本改进"></a>新版本改进</h3><p>通过延迟进入 <code>PreparingRebalance</code> 状态减少 rebalance 次数<br><img src="/images/kafka_preparing_rebalance.jpg" alt></p><p>  新版本新增了 <code>group.initial.rebalance.delay.ms</code> 参数。<strong>空消费组接受到成员加入请求时，不立即转化到 <code>PreparingRebalance</code> 状态来开启rebalance。当时间超过<code>group.initial.rebalance.delay.ms</code>后，再把group状态改为PreparingRebalance（开启rebalance）</strong>。</p><p>  <strong>实现机制是在coordinator底层新增一个group状态：<code>InitialRebalance</code></strong>。假设此时有多个consumer陆续启动，那么group状态先转化为 <code>InitialRebalance</code>，待<code>group.initial.rebalance.delay.ms</code> 时间后，再转换为<code>PreparingRebalance</code>（开启rebalance）.</p></li></ul><h3 id="消息传输一致"><a href="#消息传输一致" class="headerlink" title="消息传输一致"></a>消息传输一致</h3><p>Kafka提供3种消息传输一致性语义：最多1次，最少1次，恰好1次。</p><ul><li><p><strong>at most once</strong>: 消费者fetch消息, 然后保存offset,然后处理消息; 当client保存offset之后,但是在消息处理过程中consumer进程失效(crash), 导致部分消息未能继续处理.那么此后可能其他consumer会接管,但是因为offset已经提前保存,那么新的consumer将不能fetch到offset之前的消息(尽管它们尚没有被处理), 这就是”at most once”.** 可能会出现数据丢失情况;**</p></li><li><p><strong>at least once</strong>: 消费者fetch消息, 然后处理消息, 然后保存offset. 如果消息处理成功之后, 但是在保存offset阶段zookeeper异常或者consumer失效,导致保存offset操作未能执行成功, 这就导致接下来再次fetch时可能获得上次已经处理过的消息,这就是”at least once”.<strong>可能会重传数据，有可能出现数据被重复处理的情况;</strong></p></li><li><p><strong>exactly once</strong>：并不是指真正只传输1次，只不过有一个机制。确保不会出现“数据被重复处理”和“数据丢失”的情况。消费者的场景中可以采取以下方案来得到“恰好1次”的一致性语义：</p><blockquote><p> 最少1次 ＋ 消费者的输出中额外增加已处理消息最大编号：由于已处理消息最大编号的存在，不会出现重复处理消息的情况</p></blockquote></li></ul><h2 id="Broker设计原理"><a href="#Broker设计原理" class="headerlink" title="Broker设计原理"></a>Broker设计原理</h2><p>Broker 是Kafka 集群中的节点。负责处理生产者发送过来的消息，消费者消费的请求。以及集群节点的管理等。</p><h3 id="broker消息存储"><a href="#broker消息存储" class="headerlink" title="broker消息存储"></a>broker消息存储</h3><ul><li><p>Kafka的消息<strong>以二进制的方式紧凑地存储</strong>，节省了很大空间</p></li><li><p>此外<strong>消息存在 ByteBuffer 而不是堆</strong>，这样broker进程挂掉时，数据不会丢失，同时避免了gc问题</p></li><li><p>通过<strong>零拷贝和顺序寻址</strong>，让消息存储和读取速度都非常快</p></li><li><p>处理fetch请求的时候<strong>通过 zero-copy 加快速度</strong></p></li></ul><h3 id="broker状态数据"><a href="#broker状态数据" class="headerlink" title="broker状态数据"></a>broker状态数据</h3><p>broker设计中，每台机器都保存了相同的状态数据。主要包括以下：</p><ul><li><p>Controller所在的broker ID，即保存了当前集群中controller是哪台broker;</p></li><li><p>集群中所有broker的信息：比如每台broker的ID、机架信息以及配置的若干组连接信息</p></li><li><p>集群中所有节点的信息：严格来说，它和上一个有些重复，不过此项是按照<strong>broker ID</strong>和<strong>监听器类型</strong>进行分组的。 对于超大集群来说，使用这一项缓存可以快速地定位和查找给定节点信息，而无需遍历上一项中的内容，算是一个优化吧</p></li><li><p>集群中所有分区的信息：所谓分区信息指的是<strong>分区的leader、ISR和AR信息以及当前处于offline状态的副本集合</strong>。 这部分数据按照 topic-partitionID 进行分组，可以快速地查找到每个分区的当前状态。（注：AR表示assigned replicas，即创建topic时为该分区分配的副本集合）</p></li></ul><h3 id="broker负载均衡"><a href="#broker负载均衡" class="headerlink" title="broker负载均衡"></a>broker负载均衡</h3><ul><li><p><strong>分区数量负载</strong>：各台broker的partition数量应该均匀<br>partition Replica分配算法如下：</p><ul><li><p>将所有Broker（假设共n个Broker）和待分配的Partition排序;</p></li><li><p>将第i个Partition分配到第（i mod n）个Broker上</p></li><li><p>将第i个Partition的第j个Replica分配到第（(i + j) mod n）个Broker上</p></li></ul></li></ul><ul><li><strong>容量大小负载</strong>：每台broker的硬盘占用大小应该均匀<br>在kafka1.1之前，Kafka能够保证各台broker上partition数量均匀，但由于每个partition内的消息数不同，可能存在不同硬盘之间内存占用差异大的情况。在Kafka1.1中增加了<strong>副本跨路径迁移功能</strong> <code>kafka-reassign-partitions.sh</code>，我们可以结合它和监控系统，实现自动化的负载均衡</li></ul><h2 id="Kafaka重要参数"><a href="#Kafaka重要参数" class="headerlink" title="Kafaka重要参数"></a>Kafaka重要参数</h2><ul><li><p>acks  </p><blockquote><p>producer收到多少broker的答复才算真的发送成功<br>acks = 0 : 不接收发送结果<br>acks = all 或者 -1: 表示发送消息时，不仅要写入本地日志，还要等待所有副本写入成功。<br>acks = 1: 写入本地日志即可，是上述二者的折衷方案，也是默认值。</p></blockquote></li><li><p>retries  </p><blockquote><p>默认为 0，即不重试，立即失败。<br>一个大于 0 的值，表示重试次数。</p></blockquote></li><li><p>buffer.memory</p><blockquote><p>指定 producer 端用于缓存消息的缓冲区的大小，默认 32M；<br>适当提升该参数值，可以增加一定的吞吐量, 但是batch太大会增大延迟，可搭配linger_ms参数使用</p></blockquote></li><li><p>linger_ms</p><blockquote><p>如果batch太大，或者producer qps不高，batch添加的会很慢，我们可以强制在linger_ms时间后发送batch数据</p></blockquote></li><li><p>batch.size</p><blockquote><p>producer 会将发送分区的多条数据封装在一个 batch 中进行发送，这里的参数指的就是 batch 的大小。<br>该参数值过小的话，会降低吞吐量，过大的话，会带来较大的内存压力。<br>默认为 16K，建议合理增加该值。</p></blockquote></li></ul><h2 id="丢失数据的场景及解决方案"><a href="#丢失数据的场景及解决方案" class="headerlink" title="丢失数据的场景及解决方案"></a>丢失数据的场景及解决方案</h2><h3 id="consumer端"><a href="#consumer端" class="headerlink" title="consumer端"></a>consumer端</h3><p>不是严格意义的丢失，其实只是漏消费了。<br>设置了 <code>auto.commit.enable=true</code> ，当 consumer fetch 了一些数据但还没有完全处理掉的时候，刚好到 commit interval 触发了提交 offset 操作，接着 consumer 挂掉。这时已经fetch的数据还没有处理完成但已经被commit掉，因此没有机会再次被处理，数据丢失。</p><p><strong>解决方案：</strong><br><code>enable.auto.commit=false</code> 关闭自动提交位移，在消息被完整处理之后再手动提交位移</p><h3 id="producer端"><a href="#producer端" class="headerlink" title="producer端"></a>producer端</h3><p>I/O 线程发送消息之前，producer 崩溃， 则 producer 的内存缓冲区的数据将丢失</p><p><strong>解决方案：</strong></p><ul><li><p>同步发送，性能差，不推荐。</p></li><li><p>仍然异步发送，通过“无消息丢失配置”（来自胡夕的《Apache Kafka 实战》）极大降低丢失的可能性：</p><ul><li><p><code>block.on.buffer.full = true</code> 尽管该参数在0.9.0.0已经被标记为“deprecated”，但鉴于它的含义非常直观，所以这里还是显式设置它为true，<strong>使得producer将一直等待缓冲区直至其变为可用。否则如果producer生产速度过快耗尽了缓冲区，producer将抛出异常</strong></p></li><li><p><code>acks=all</code> 很好理解，所有follower都响应了才认为消息提交成功，即”committed”</p></li><li><p><code>retries = MAX</code> 无限重试，直到你意识到出现了问题:)</p></li><li><p><code>max.in.flight.requests.per.connection = 1</code> 限制客户端在单个连接上能够发送的未响应请求的个数。设置此值是1表示kafka broker在响应请求之前client不能再向同一个broker发送请求。注意：<strong>设置此参数是为了避免消息乱序</strong></p></li><li><p>使用<code>KafkaProducer.send(record, callback)</code>而不是<code>send(record)</code>方法 自定义回调逻辑处理消息发送失败</p></li><li><p>callback逻辑中最好显式关闭<code>producer：close(0)</code> 注意：设置此参数是为了避免消息乱序</p></li><li><p><code>unclean.leader.election.enable=false</code> 关闭unclean leader选举，即<strong>不允许非ISR中的副本被选举为leader，以避免数据丢失</strong></p></li><li><p><code>replication.factor &gt;= 3</code> 这个完全是个人建议了，参考了Hadoop及业界通用的三备份原则</p></li><li><p><code>min.insync.replicas &gt; 1</code> 消息至少要被写入到这么多副本才算成功，也是提升数据持久性的一个参数。与acks配合使用</p></li><li><p>保证<code>replication.factor &gt; min.insync.replicas</code> 如果两者相等，当一个副本挂掉了分区也就没法正常工作了。通常设置<code>replication.factor = min.insync.replicas + 1</code> 即可</p></li></ul></li></ul><h2 id="如何选择Partiton的数量"><a href="#如何选择Partiton的数量" class="headerlink" title="如何选择Partiton的数量"></a>如何选择Partiton的数量</h2><ul><li><p>在创建 Topic 的时候可以指定 Partiton 数量，也可以在创建完后手动修改。但 <strong>Partiton 数量只能增加不能减少</strong>。中途增加 Partiton，<strong>partition里面的message不会重新进行分配，原来的partition里面的message数据不会变</strong>，新加的这个partition刚开始是空的，随后进入这个topic的message就会重新参与所有partition的load balance。</p></li><li><p>Partition 的数量直接决定了该 Topic 的并发处理能力。但也并不是越多越好。<strong>Partition 的数量对消息延迟性会产生影响</strong>。</p></li><li><p>一般建议选择 <strong>Broker Num * Consumer Num</strong>，这样<strong>平均每个 Consumer 会同时读取 Broker 数目个 Partition</strong> ， 这些 Partition 压力可以平摊到每台 Broker 上</p></li></ul><h2 id="controller的职责"><a href="#controller的职责" class="headerlink" title="controller的职责"></a>controller的职责</h2><p>在 kafka 集群中，某个 broker 会被选举承担特殊的角色，即<strong>控制器（controller)</strong>，用于<strong>管理和协调 kafka 集群</strong>，具体职责如下：</p><ul><li><p>管理副本和分区的状态</p></li><li><p>更新集群元数据信息</p></li><li><p>创建、删除 topic</p></li><li><p>分区重分配</p></li><li><p>leader 副本选举</p></li><li><p>topic 分区扩展</p></li><li><p>broker 加入、退出集群</p></li><li><p>受控关闭</p></li><li><p>controller leader选举</p></li></ul><h2 id="节点异常情形"><a href="#节点异常情形" class="headerlink" title="节点异常情形"></a>节点异常情形</h2><h3 id="leader挂了（leader-failover）"><a href="#leader挂了（leader-failover）" class="headerlink" title="leader挂了（leader failover）"></a>leader挂了（leader failover）</h3><p>当 leader 挂了之后，controller 默认会从 <strong><em>ISR</em></strong> 中选择一个 replica 作为 leader 继续工作，条件是<strong>新 leader 必须有挂掉 leader 的所有数据</strong>。</p><p>如果为了系统的可用性，而容忍降低数据的一致性的话，可以将 <code>unclean.leader.election.enable = true</code>，开启 kafka 的<strong>“脏 leader 选举”</strong>。当 ISR 中没有 replica，则选一个幸存的replica作为leader 继续响应请求，如此操作提高了 Kafka 的分区容忍度，但是数据一致性降低了。</p><h3 id="broker挂了（broker-failover）"><a href="#broker挂了（broker-failover）" class="headerlink" title="broker挂了（broker failover）"></a>broker挂了（broker failover）</h3><p>broker上面有很多 partition 和多个 leader 。因此至少需要处理如下内容：</p><ul><li><p>更新该 broker 上所有 follower 的状态</p></li><li><p>重新给 leader 在该 broker 上的 partition 选举 leader</p></li><li><p>选举完成后，要更新 partition 的状态，比如谁是 leader 等</p></li></ul><p>kafka 集群启动后，所有的 broker 都会被 controller 监控，一旦有 broker 宕机，<strong>ZK 的监听机制会通知到 controller</strong>， controller 拿到挂掉 broker 中所有的 partition，以及它上面的存在的 leader，然后从 partition的 <strong><em>ISR</em></strong> 中选择一个 follower 作为 leader，更改 partition 的 follower 和 leader 状态。</p><h3 id="controller挂了（controller-failover）"><a href="#controller挂了（controller-failover）" class="headerlink" title="controller挂了（controller failover）"></a>controller挂了（controller failover）</h3><ul><li><p>由于每个 broker 都会在 zookeeper 的 “/controller” 节点注册 watcher，当 controller 宕机时 zookeeper 中的临时节点消失，所有存活的 broker 收到 fire 的通知</p></li><li><p>存活的 broker 收到 fire 的通知后，每个 broker 都尝试创建新的 controller path，只有一个竞选成功并当选为 controller。</p></li></ul><h2 id="Zookeeper在Kafka中作用"><a href="#Zookeeper在Kafka中作用" class="headerlink" title="Zookeeper在Kafka中作用"></a>Zookeeper在Kafka中作用</h2><ul><li><p>管理 broker 与 consumer 的动态加入与离开。（Producer 不需要管理，随便一台计算机都可以作为Producer 向 Kakfa Broker 发消息）</p></li><li><p>触发负载均衡，当 broker 或 consumer 加入或离开时会触发负载均衡算法，使得一个 consumer group 内的多个 consumer 的消费负载平衡。（因为一个 comsumer 消费一个或多个partition，一个 partition 只能被一个 consumer 消费）</p></li><li><p>维护消费关系及每个 partition 的消费信息</p></li></ul><h2 id="Page-Cache带来的好处"><a href="#Page-Cache带来的好处" class="headerlink" title="Page Cache带来的好处"></a>Page Cache带来的好处</h2><p>Linux 总会把系统中还没被应用使用的内存挪来给 Page Cache，在命令行输入<code>free</code>，或者 <code>cat /proc/meminfo</code> ，“Cached”的部分就是 Page Cache。</p><p>Page Cache 中每个文件是一棵 <strong>Radix 树</strong>（又称 PAT 位树, 一种多叉搜索树），节点由 <strong><em>4k</em></strong> 大小的 Page 组成，可以通过文件的偏移量（如 0x1110001）快速定位到某个Page。</p><p>当写操作发生时，它只是将数据写入 Page Cache 中，并将该页置上 dirty 标志。</p><p>当读操作发生时，它会<strong>首先在 Page Cache 中查找，如果有就直接返回，没有的话就会从磁盘读取文件写入 Page Cache 再读取</strong>。</p><p>可见，<strong>只要生产者与消费者的速度相差不大，消费者会直接读取之前生产者写入Page Cache的数据，大家在内存里完成接力，根本没有磁盘访问</strong>。</p><p>而比起在内存中维护一份消息数据的传统做法，这<strong>既不会重复浪费一倍的内存，Page Cache 又不需要 GC</strong> （可以放心使用60G内存了），而且<strong>即使 Kafka 重启了，Page Cache 还依然在</strong>。</p><p>参考：<br>[1] <a href="https://zhuanlan.zhihu.com/p/65512721" target="_blank" rel="noopener">Kafka常见问题 [知乎]</a><br>[2] <a href="https://mp.weixin.qq.com/s/zxPz_aFEMrshApZQ727h4g" target="_blank" rel="noopener">Kafka系统设计开篇</a><br>[3] <a href="https://blog.csdn.net/u013573133/article/details/48142677" target="_blank" rel="noopener">Kafka史上最详细原理总结</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;集群架构图&quot;&gt;&lt;a href=&quot;#集群架构图&quot; class=&quot;headerlink&quot; title=&quot;集群架构图&quot;&gt;&lt;/a&gt;集群架构图&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/images/kafka_cluster_architecture.png&quot; alt=&quot;kaf
      
    
    </summary>
    
      <category term="中间件" scheme="http://yoursite.com/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
      <category term="Kafka" scheme="http://yoursite.com/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/Kafka/"/>
    
    
      <category term="kafka" scheme="http://yoursite.com/tags/kafka/"/>
    
      <category term="基本原理" scheme="http://yoursite.com/tags/%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Mysql锁机制</title>
    <link href="http://yoursite.com/2019/12/20/Mysql%E9%94%81%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2019/12/20/Mysql锁机制/</id>
    <published>2019-12-20T11:23:50.000Z</published>
    <updated>2019-12-20T12:03:52.269Z</updated>
    
    <content type="html"><![CDATA[<h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><p>MySQL/InnoDB的加锁，一直是一个常见的话题。例如，数据库如果有高并发请求，如何保证数据完整性？产生死锁问题如何排查并解决？下面是不同锁等级的区别</p><ul><li><p><strong>表级锁</strong><br>开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高 ，并发度最低。</p></li><li><p><strong>页面锁</strong><br>开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</p></li><li><p><strong>行级锁</strong><br>开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</p></li></ul><p>查看数据库支持的存储引擎：</p><blockquote><p>SHOW ENGINES</p></blockquote><p><img src="/images/msyql_lock_transaction.jpg" alt></p><h2 id="InnoDB存储引擎"><a href="#InnoDB存储引擎" class="headerlink" title="InnoDB存储引擎"></a>InnoDB存储引擎</h2><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>用数据版本（Version）记录机制实现，这是乐观锁最常用的一种实现方式。</p><p>何谓数据版本？</p><p>即为数据增加一个版本标识，一般是通过为数据库表增加一个数字类型的 “version” 字段来实现。</p><ul><li><p>当读取数据时，将version字段的值一同读出，数据每更新一次，对此version值加1。</p></li><li><p>当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的version值进行比对，如果数据库表当前版本号与第一次取出来的version值相等，则予以更新，否则认为是过期数据。</p></li></ul><p>举例：<br>1、数据库表三个字段，分别是id、value、version</p><blockquote><p>select id,value,version from TABLE where id = #{id}</p></blockquote><p>2、每次更新表中的value字段时，为了防止发生冲突，需要这样操作</p><blockquote><p>update TABLE<br>set value=2,version=version+1<br>where id=#{id} and version=#{version}</p></blockquote><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>悲观锁就是在操作数据时，认为此操作会出现数据冲突，所以<strong>在进行每次操作时都要通过获取锁才能进行对相同数据的操作</strong>，这点跟java中的synchronized很相似，所以悲观锁需要耗费较多的时间。</p><p>另外与乐观锁相对应的，<strong>悲观锁是由数据库自己实现</strong>了的，要用的时候，我们直接调用数据库的相关语句就可以了。</p><p>说到这里，由悲观锁涉及到的另外两个锁概念就出来了，它们就是共享锁与排它锁。共享锁和排它锁是悲观锁的不同的实现，它俩都属于悲观锁的范畴。</p><h4 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h4><p>共享锁又称读锁 (read lock)，是读操作创建的锁。其他用户可以并发读取数据，但任何事务都不能对数据进行修改（获取数据上的排他锁），直到已释放所有共享锁。当如果事务对读锁进行修改操作，很可能会造成死锁。如下图所示。<br><img src="/images/mysql_share_lock.jpg" alt></p><p><strong>如果事务T对数据A加上共享锁后，则其他事务只能对A再加共享锁，不能加排他锁</strong>。获得共享锁的事务只能读数据，不能修改数据。</p><p>在查询语句后面增加 <code>LOCK IN SHARE MODE</code>，Mysql会<strong>对查询结果中的每行都加共享锁</strong>，当没有其他线程对查询结果集中的任何一行使用排他锁时，可以成功申请共享锁，否则会被阻塞。 其他线程也可以读取使用了共享锁的表，而且这些线程读取的是同一个版本的数据。</p><p>加上共享锁后，对于<code>update</code>，<code>insert</code>，<code>delete</code>语句会自动加排它锁。</p><h4 id="排它锁"><a href="#排它锁" class="headerlink" title="排它锁"></a>排它锁</h4><p>排他锁<code>Exclusive Lock</code>（也叫writer lock）又称写锁。</p><p>名词解释：若某个事物对某一行加上了排他锁，<strong>只能这个事务对其进行读写，在此事务结束之前，其他事务不能对其进行加任何锁</strong>，其他进程可以读取, 不能进行写操作，需等待其释放。</p><p>若事务 1 对数据对象A加上X锁，事务 1 可以读A也可以修改A，其他事务不能再对A加任何锁，直到事物 1 释放A上的锁。这保证了其他事务在事物 1 释放A上的锁之前不能再读取和修改A。<strong>排它锁会阻塞所有的排它锁和共享锁.</strong></p><p>读取为什么要加读锁呢？</p><blockquote><p>防止数据在被读取的时候被别的线程加上写锁。</p></blockquote><p>排他锁使用方式：在需要执行的语句后面加上<code>for update</code>就可以了</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">status</span> <span class="keyword">from</span> <span class="keyword">TABLE</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure><p>排他锁，也称写锁，独占锁，当前写操作没有完成前，它会阻断其他写锁和读锁。<br><img src="/images/mysql_exclusive_lock.jpg" alt></p><p>排他锁之所以能阻止<code>update</code>,<code>delete</code>等操作是因为<code>update</code>，<code>delete</code>操作会自动加排他锁，<br>也就是说<strong>即使加了排他锁也无法阻止<code>select</code>操作</strong>。而<code>select XXX for update</code> 语法可以对<code>select</code>操作加上排他锁。 所以为了防止更新丢失可以在<code>select</code>时加上<code>for update</code>加锁, 这样就可以阻止其余事务的<code>select for update</code> <strong>(但注意无法阻止select)</strong>.</p><p>要使用排他锁，我们必须关闭mysql数据库的自动提交属性，因为MySQL默认使用autocommit模式，也就是说，当你执行一个更新操作后，MySQL会立刻将结果进行提交。</p><h3 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h3><p>多个事务操作同一行数据时，后来的事务处于阻塞等待状态。这样可以避免了脏读等数据一致性的问题。后来的事务可以操作其他行数据，解决了表锁高并发性能低的问题。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Transaction-A</span></span><br><span class="line">mysql&gt; set autocommit = 0;</span><br><span class="line">mysql&gt; update innodb_lock set v='1001' where id=1;</span><br><span class="line">mysql&gt; commit;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Transaction-B</span></span><br><span class="line">mysql&gt; update innodb_lock set v='2001' where id=2;</span><br><span class="line">Query OK, 1 row affected (0.37 sec)</span><br><span class="line">mysql&gt; update innodb_lock set v='1002' where id=1;  ## 被事务A阻塞</span><br><span class="line">Query OK, 1 row affected (37.51 sec)</span><br></pre></td></tr></table></figure><p>现实：<strong>当执行批量修改数据脚本的时候，行锁升级为表锁</strong>。其他对订单的操作都处于等待中，，，</p><p>原因：<strong>InnoDB只有在通过索引条件检索数据时使用行级锁，否则使用表锁</strong>！ 而模拟操作正是通过id去作为检索条件，而id又是MySQL自动创建的唯一索引，所以才忽略了行锁变表锁的情况</p><p><strong>总结</strong>：<font color="red"><strong>InnoDB的行锁是针对索引加的锁，不是针对记录加的锁。并且该索引不能失效，否则都会从行锁升级为表锁。</strong></font></p><ul><li><p>行锁的劣势<br>开销大；加锁慢；会出现死锁</p></li><li><p>行锁的优势<br>锁的粒度小，发生锁冲突的概率低；处理并发的能力强</p></li><li><p>加锁的方式<br>自动加锁。对于<code>UPDATE</code>、<code>DELETE</code>和<code>INSERT</code>语句，InnoDB会自动给涉及数据集加排他锁；对于普通SELECT语句，InnoDB不会加任何锁；当然我们也可以显示的加锁：</p></li></ul><p>从上面的案例看出，行锁变表锁似乎是一个坑，可MySQL没有这么无聊给你挖坑。这是因为MySQL有自己的执行计划。</p><p>当你需要更新一张较大表的大部分甚至全表的数据时。而你又傻乎乎地用索引作为检索条件。一不小心开启了行锁(没毛病啊！保证数据的一致性！)。可MySQL却认为大量对一张表使用行锁，会导致事务执行效率低，从而可能造成其他事务长时间锁等待和更多的锁冲突问题，性能严重下降。所以MySQL会将行锁升级为表锁，即实际上并没有使用索引。</p><p>我们仔细想想也能理解，既然整张表的大部分数据都要更新数据，在一行一行地加锁效率则更低。其实我们可以通过<code>explain</code>命令查看MySQL的执行计划，你会发现key为null。表明MySQL实际上并没有使用索引，行锁升级为表锁也和上面的结论一致。</p><p>注意：<strong>行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁</strong>。</p><p>行锁根据锁定范围又分为间隙锁、临键锁和记录锁。<br><img src="/images/mysql_lock_partition.jpg" alt></p><h4 id="临健锁"><a href="#临健锁" class="headerlink" title="临健锁"></a>临健锁</h4><p>当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的临键锁（Next-Key锁）。<br><img src="/images/mysql_next_key_lock.jpg" alt></p><p>危害(坑)：若执行的条件是范围过大，则InnoDB会将整个范围内所有的索引键值全部锁定，很容易对性能造成影响。</p><h4 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h4><p><img src="/images/mysql_gap_lock.jpg" alt></p><h4 id="记录锁"><a href="#记录锁" class="headerlink" title="记录锁"></a>记录锁</h4><p><img src="/images/mysql_record_lock.jpg" alt><br>记录锁在锁定非主键索引时，也会一并锁定主键；</p><h3 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h3><p>Innodb 的行锁是在有索引的情况下，没有索引的表是锁定全表的。</p><p>在Innodb引擎中既支持行锁也支持表锁，那么什么时候会锁住整张表，什么时候只锁住一行呢？</p><blockquote><p>只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！</p></blockquote><p>在实际应用中，要特别注意InnoDB行锁的这一特性，不然的话，可能导致大量的锁冲突，从而影响并发性能。</p><p>行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁。</p><p>行级锁的缺点是：<strong>由于需要请求大量的锁资源，所以速度慢，内存消耗大。</strong></p><h3 id="死锁（Deadlock）"><a href="#死锁（Deadlock）" class="headerlink" title="死锁（Deadlock）"></a>死锁（Deadlock）</h3><p>所谓死锁：是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。由于资源占用是互斥的，当某个进程提出申请资源后，使得有关进程在无外力协助下，永远分配不到必需的资源而无法继续运行，这就产生了一种特殊现象死锁。</p><p>解除正在死锁的状态有两种方法：<br><strong>第一种：</strong></p><ul><li><p>1、查询是否锁表  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">OPEN</span> <span class="keyword">TABLES</span> <span class="keyword">where</span> In_use &gt; <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li><li><p>2、查询进程（如果您有SUPER权限，您可以看到所有线程。否则，您只能看到您自己的线程）  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">processlist</span></span><br></pre></td></tr></table></figure></li><li><p>3、杀死进程id（就是上面命令的id列）   </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">kill</span> <span class="keyword">id</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>第二种：</strong></p><ul><li>1、查看当前的事务  </li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> INFORMATION_SCHEMA.INNODB_TRX;</span><br></pre></td></tr></table></figure><ul><li><p>2、查看当前锁定的事务  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> INFORMATION_SCHEMA.INNODB_LOCKS;</span><br></pre></td></tr></table></figure></li><li><p>3、查看当前等锁的事务  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> INFORMATION_SCHEMA.INNODB_LOCK_WAITS;</span><br></pre></td></tr></table></figure></li><li><p>4、杀死进程  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">kill</span> 进程<span class="keyword">ID</span></span><br></pre></td></tr></table></figure></li></ul><p>产生死锁的四个必要条件：</p><ul><li>互斥条件：一个资源每次只能被一个进程使用。</li><li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li><li>不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。</li><li>循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</li></ul><p>如果系统资源充足，进程的资源请求都能够得到满足，死锁出现的可能性就很低，否则就会因争夺有限的资源而陷入死锁。其次，进程运行推进顺序与速度不同，也可能产生死锁。虽然不能完全避免死锁，但可以使死锁的数量减至最少。将死锁减至最少可以增加事务的吞吐量并减少系统开销，因为只有很少的事务回滚，而回滚会取消事务执行的所有工作。由于死锁时回滚的操作由应用程序重新提交。</p><p>下列方法有助于最大限度地降低死锁：</p><ul><li>按同一顺序访问对象。</li><li>避免事务中的用户交互。</li><li>保持事务简短并在一个批处理中。</li><li>使用低隔离级别。</li><li>使用绑定连接。</li></ul><h2 id="MyISAM存储引擎"><a href="#MyISAM存储引擎" class="headerlink" title="MyISAM存储引擎"></a>MyISAM存储引擎</h2><p>InnoDB和MyISAM的最大不同点有两个：</p><ul><li>InnoDB支持事务(transaction)；MyISAM不支持事务</li><li>Innodb默认采用行锁， MyISAM是默认采用表锁。</li></ul><p><strong>MyISAM不适合高并发</strong></p><h3 id="共享读锁"><a href="#共享读锁" class="headerlink" title="共享读锁"></a>共享读锁</h3><p>对MyISAM表的读操作（加读锁），不会阻塞其他进程对同一表的读操作，但会阻塞对同一表的写操作。只有当读锁释放后，才能执行其他进程的写操作。在锁释放前不能读其他表。<br><img src="/images/mysql_myisam_share_lock.jpg" alt></p><h3 id="独占写锁"><a href="#独占写锁" class="headerlink" title="独占写锁"></a>独占写锁</h3><p>对MyISAM表的写操作（加写锁）<strong>，会阻塞其他进程对同一表的读和写操作，只有当写锁释放后，才会执行其他进程的读写操作。</strong>在锁释放前不能写其他表。<br><img src="/images/mysql_myisam_exclusive_lock.jpg" alt></p><p><strong>总结：</strong></p><ul><li><p>表锁，读锁会阻塞写，不会阻塞读。而写锁则会把读写都阻塞。</p></li><li><p>表锁的加锁/解锁方式：MyISAM在执行查询语句(SELECT)前,会<strong>自动给涉及的所有表加读锁</strong>,在执行更新操作 (<code>UPDATE</code>、<code>DELETE</code>、<code>INSERT</code>等)前，会自动给涉及的表加写锁，这个过程并不需要用户干预，因此，用户一般不需要直接用LOCK TABLE命令给MyISAM表显式加锁。</p></li></ul><p>如果用户想要显示的加锁可以使用以下命令：<br><strong>锁定表</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LOCK</span> <span class="keyword">TABLES</span> tbl_name &#123;<span class="keyword">READ</span> | WRITE&#125;,[ tbl_name &#123;<span class="keyword">READ</span> | WRITE&#125;,…]</span><br></pre></td></tr></table></figure><p><strong>解锁表</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UNLOCK</span> <span class="keyword">TABLES</span></span><br></pre></td></tr></table></figure><p>在用 <code>LOCK TABLES</code> 给表显式加表锁时, 必须同时取得所有涉及到表的锁。</p><p>在执行 <code>LOCK TABLES</code> 后，只能访问显式加锁的这些表，不能访问未加锁的表;</p><p><strong>如果加的是读锁，那么只能执行查询操作，而不能执行更新操作。</strong></p><p>在自动加锁的情况下也基本如此，MyISAM 总是一次获得 SQL 语句所需要的全部锁。这也正是 MyISAM 表不会出现死锁(Deadlock Free)的原因。</p><p>对表test_table增加读锁：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LOCK</span> <span class="keyword">TABLES</span> test_table <span class="keyword">READ</span> </span><br><span class="line"><span class="keyword">UNLOCK</span> test_table</span><br></pre></td></tr></table></figure><p>对表test_table增加写锁</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LOCK</span> <span class="keyword">TABLES</span> test_table WRITE</span><br><span class="line"><span class="keyword">UNLOCK</span> test_table</span><br></pre></td></tr></table></figure><p>当使用 <code>LOCK TABLES</code> 时，不仅需要一次锁定用到的所有表,而且,同一个表在 SQL 语句中出现多少次，就要通过与 SQL 语句中相同的别名锁定多少次，否则也会出错！<br>比如如下SQL语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> a.first_name,b.first_name, <span class="keyword">from</span> actor a,actor b <span class="keyword">where</span> a.first_name = b.first_name;</span><br></pre></td></tr></table></figure><p>该Sql语句中，<code>actor</code>表以别名的方式出现了两次，分别是<code>a</code>,<code>b</code>，这时如果要在该Sql执行之前加锁就要使用以下Sql:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lock</span> <span class="keyword">table</span> actor <span class="keyword">as</span> a <span class="keyword">read</span>, actor <span class="keyword">as</span> b <span class="keyword">read</span>;</span><br></pre></td></tr></table></figure><h3 id="并发插入"><a href="#并发插入" class="headerlink" title="并发插入"></a>并发插入</h3><p>上文说到过 MyISAM 表的读和写是串行的, 但这是就总体而言的。在一定条件下,MyISAM表也支持查询和插入操作的并发进行。 MyISAM存储引擎有一个系统变量<code>concurrent_insert</code>,专门用以控制其并发插入的行为,其值分别可以为0、1或2。</p><blockquote><p>0: 不允许并发插入;<br>1: 如果MyISAM表中没有空洞(即表的中间没有被删除的行), MyISAM允许在一个进程读表的同时,另一个进程从表尾插入记录。这也是MySQL 的默认设置;<br>2: 无论MyISAM表中有没有空洞, 都允许在表尾并发插入记录;</p></blockquote><p>可以利用MyISAM存储引擎的并发插入特性,来解决应用中对同一表查询和插入的锁争用。</p><h3 id="MyISAM的锁调度"><a href="#MyISAM的锁调度" class="headerlink" title="MyISAM的锁调度"></a>MyISAM的锁调度</h3><p>MyISAM 存储引擎的读锁和写锁是互斥的，读写操作是串行的。那么，一个进程请求某个 MyISAM 表的读锁，同时另一个进程也请求同一表的写锁，MySQL 如何处理呢?</p><p><strong>答案是<font color="red">写进程</font>先获得锁。</strong></p><p>不仅如此，即使读请求先到锁等待队列，写请求后到，写锁也会插到读锁请求之前！这是因为 MySQL 认为写请求一般比读请求要重要。这也正是 MyISAM 表不太适合于有大量更新操作和查询操作应用的原因，因为大量的更新操作会造成查询操作很难获得读锁，从而可能永远阻塞。这种情况有时可能会变得非常糟糕！</p><p>幸好我们可以通过一些设置来调节 MyISAM 的调度行为。</p><p>通过指定启动参数<code>low-priority-updates</code>，使MyISAM引擎默认给予读请求以优先的权利。</p><ul><li><p>通过执行命令<code>SET LOWPRIORITYUPDATES=1</code>, 使该连接发出的更新请求优先级降低。</p></li><li><p>通过指定<code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>语句的<code>LOW_PRIORITY</code>属性, 降低该语句的优先级。</p></li><li><p>另外, MySQL也供了一种折衷的办法来调节读写冲突, 即给系统参数<code>max_write_lock_count</code> 设置一个合适的值, 当一个表的读锁达到这个值后, MySQL就暂时将写请求的优先级降低, 给读进程一定获得锁的机会。</p></li></ul><p><strong>总结</strong></p><ul><li><p>MySQL的MyISAM引擎支持表级锁。</p></li><li><p>表级锁分为两种：共享读锁、互斥写锁。这两种锁都是阻塞锁。</p></li><li><p>可以在读锁上增加读锁，不能在读锁上增加写锁。在写锁上不能增加写锁。</p></li><li><p>默认情况下，MySql在执行查询语句之前会加读锁，在执行更新语句之前会执行写锁。</p></li><li><p>如果想要显示的加锁/解锁的花可以使用LOCK TABLES和UNLOCK来进行。</p></li><li><p>在使用LOCK TABLES之后，在解锁之前，不能操作未加锁的表。</p></li><li><p>在加锁时，如果显示的指明是要增加读锁，那么在解锁之前，只能进行读操作，不能执行写操作。</p></li><li><p>如果一次Sql语句要操作的表以别名的方式多次出现，那么就要在加锁时都指明要加锁的表的别名。</p></li><li><p>MyISAM存储引擎有一个系统变量<code>concurrent_insert</code>, 专门用以控制其并发插入的行为,其值分别可以为0、1或2。</p></li><li><p>由于读锁和写锁互斥，那么在调度过程中，默认情况下，MySql会本着写锁优先的原则。可以通过<code>low-priority-updates</code>来设置。</p></li></ul><h2 id="利用锁实现事务"><a href="#利用锁实现事务" class="headerlink" title="利用锁实现事务"></a>利用锁实现事务</h2><h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h3><p>修改加上排他锁，那么其他事务就无法读取到正在修改的数据行；<br><img src="/images/mysql_tx_read.png" alt></p><h3 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h3><p>查询加上读锁，则其他事务就无法修改；<br><img src="/images/mysql_tx_repeated_read.jpg" alt></p><h3 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h3><p>范围查询会通过间隙锁使其他事务无法插入范围数据，这不会出现幻读；<br><img src="/images/mysql_tx_huandu.jpg" alt></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.im/post/5b82e0196fb9a019f47d1823#heading-10" target="_blank" rel="noopener">全面了解mysql锁机制（InnoDB）与问题排查</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;总览&quot;&gt;&lt;a href=&quot;#总览&quot; class=&quot;headerlink&quot; title=&quot;总览&quot;&gt;&lt;/a&gt;总览&lt;/h2&gt;&lt;p&gt;MySQL/InnoDB的加锁，一直是一个常见的话题。例如，数据库如果有高并发请求，如何保证数据完整性？产生死锁问题如何排查并解决？下面是不
      
    
    </summary>
    
      <category term="Mysql" scheme="http://yoursite.com/categories/Mysql/"/>
    
      <category term="锁机制" scheme="http://yoursite.com/categories/Mysql/%E9%94%81%E6%9C%BA%E5%88%B6/"/>
    
    
      <category term="Mysql" scheme="http://yoursite.com/tags/Mysql/"/>
    
      <category term="锁" scheme="http://yoursite.com/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>JVM基础 - 入门篇</title>
    <link href="http://yoursite.com/2019/12/13/JVM%E5%9F%BA%E7%A1%80-%E5%85%A5%E9%97%A8%E7%AF%87/"/>
    <id>http://yoursite.com/2019/12/13/JVM基础-入门篇/</id>
    <published>2019-12-13T08:15:47.000Z</published>
    <updated>2019-12-20T11:07:55.179Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JDK体系结构"><a href="#JDK体系结构" class="headerlink" title="JDK体系结构"></a>JDK体系结构</h1><p><img src="/images/jdk_structure.jpg" alt></p><h1 id="JVM内存模型"><a href="#JVM内存模型" class="headerlink" title="JVM内存模型"></a>JVM内存模型</h1><p>一张图描述JVM内存模型<br><img src="/images/jvm_structure.png" alt></p><p>JVM包括两个子系统和两个组件：</p><h2 id="两个子系统"><a href="#两个子系统" class="headerlink" title="两个子系统"></a>两个子系统</h2><ul><li><p><strong>ClassLoader（类装载）</strong><br>根据给定的全限定名类名(如：java.lang.Object)来装载 class文件 到 <strong>运行时数据区</strong> 中的 <strong>方法区</strong>。程序中可以继承 <code>java.lang.ClassLoader</code> 类来实现自己的ClassLoader。</p></li><li><p><strong>ExecutionEngine（执行引擎）</strong><br>执行classes中的指令。任何JVM <code>specification</code>实现(JDK)的核心都是Execution engine，不同的JDK例如Sun的JDK和IBM的JDK好坏主要就取决于他们各自实现的Execution engine的好坏。</p></li></ul><h2 id="两个组件"><a href="#两个组件" class="headerlink" title="两个组件"></a>两个组件</h2><ul><li><p><strong>Native Interface(本地接口)</strong><br>与native libraries交互，是其它编程语言交互的接口。当调用native方法的时候，就进入了一个全新的并且不再受虚拟机限制的世界，所以也很容易出现JVM无法控制的native heap OutOfMemory。</p></li><li><p><strong>Runtime Data Area（运行时数据区）</strong><br>这就是我们常说的JVM的内存。主要分为五个部分：</p><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>有时候也成为<strong>永久代</strong>，该区域是被<strong>线程共享</strong>的。</p></li><li><p>作用<br>方法区主要用来存储已被虚拟机加载的<strong>类的信息</strong>、<strong>常量</strong>、<strong>静态变量</strong> 和 <strong>即时编译器(JIT)编译后的代码</strong> 等数据.</p></li><li><p>GC<br>在该区内很少发生垃圾回收，但是并不代表不发生GC，在这里进行的GC主要是 <strong>对方法区里的常量池和对类型的卸载</strong>，但<strong>回收效率很低</strong>，当方法区无法满足内存需求时，会报 <strong>OOM</strong> 异常；</p></li></ul><p>方法区里有一个<strong>运行时常量池</strong>，用于存放<strong>静态编译产生的字面量和符号引用</strong>。该常量池具有动态性，也就是说常量并不一定是编译时确定，<strong>运行时生成的常量也会存在这个常量池</strong>中。</p><blockquote><p><strong>方法区和元数据区是不同jdk版本对JVM协议的不同实现；</strong></p></blockquote><h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><p>虚拟机栈也就是我们平常所称的栈内存, 它为java方法服务，每个方法在执行的时候都会创建一个栈帧，用于存储<strong>局部变量表</strong>、<strong>操作数栈</strong>、<strong>动态链接</strong> 和 <strong>方法出口</strong>等信息。<br><img src="/images/jvm_thread_stack.png" alt="-w728"></p><ul><li><p><strong>虚拟机栈</strong><br>是线程私有的，它的<strong>生命周期与线程相同</strong>。每个方法从调用到执行过程，就对应着栈桢在虚拟机栈中从入栈到出栈的过程。</p></li><li><p><strong>栈桢</strong><br>虚拟机栈由多个栈桢（Stack Frame）组成。一个线程会执行一个或多个方法，一个方法对应一个栈桢。</p></li><li><p><strong>局部变量表</strong><br>局部变量表里存储的是<strong>基本数据类型</strong>、<strong>returnAddress类型</strong>（指向一条字节码指令的地址）和<strong>对象引用</strong>，这个对象引用有可能是指向对象起始地址的一个指针，也有可能是代表对象的句柄或者与对象相关联的位置。<strong>局部变量所需的内存空间在编译器间确定</strong>。</p></li><li><p><strong>操作数栈</strong><br>操作数栈的作用主要用来<strong>存储运算结果以及运算的操作数</strong>，它不同于局部变量表通过索引来访问，而是<strong>压栈和出栈的方式</strong></p></li></ul><p>每个栈帧都包含一个指向运行时常量池中<strong>该栈帧所属方法的引用</strong>，持有这个引用是为了<strong>支持方法调用过程中的动态连接</strong>. 动态链接就是<strong>将常量池中的符号引用在运行期转化为直接引用</strong>。</p><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>本地方法栈和虚拟机栈类似，虚拟机栈是为虚拟机执行Java方法而准备的，而本地方法栈为虚拟机执行Native本地方法而准备的。</p><h3 id="堆（Heap）"><a href="#堆（Heap）" class="headerlink" title="堆（Heap）"></a>堆（Heap）</h3><p>Java堆是所有线程所共享的一块内存。</p><p>在虚拟机启动时创建，几乎所有的对象实例、数组都在这里存放，对于大多数应用来说，堆是JVM管理的内存中最大的一块区域，也是最容易发生OOM的区域，因此该区域经常发生垃圾回收操作。</p><p>大多数JVM都会将堆实现为大小可扩展的，通过-Xmx、-Xms等参数控制。</p><p><img src="/images/eden_survior.jpg" alt></p><p>新生的对象默认放在Eden区, Eden区满了会触发minor GC/yong GC;</p><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>占用内存空间小，字节码解释器工作时通过改变这个计数值可以<strong>选取下一条需要执行的字节码指令</strong>，<strong>分支、循环、跳转、异常处理和线程恢复</strong>等功能都需要依赖这个计数器完成。该内存区域是唯一一个java虚拟机规范没有规定任何OOM情况的区域。</p><h1 id="JVM内存快照示例"><a href="#JVM内存快照示例" class="headerlink" title="JVM内存快照示例"></a>JVM内存快照示例</h1><p>基于上述原理，现在写一个简单的代码来举例描述下具体各个区域是怎么分配的。</p><blockquote><p>Math.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Math</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> initData = <span class="number">666</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> c = (a + b) * <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Math math = <span class="keyword">new</span> Math();</span><br><span class="line">        <span class="keyword">int</span> result = math.compute();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>javap是jdk自带的一个工具在jdk安装目录的/bin下面可以找到，可以对代码反编译，也可以查看java编译器生成的字节码，对代码的执行过程进行分析，了解jvm内部的工作。</p></blockquote><p>通过以下指令可以得到Java字节码指令：</p><blockquote><p>javac Math.java<br>javap -c Math.class &gt; Math.txt</p></blockquote><p>Math.txt(为了便于编译，Math.txt中去掉了User相关内容)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">Compiled from <span class="string">"Math.java"</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Math</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> initData;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> User user  = <span class="keyword">new</span> User();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Math</span><span class="params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       1: invokespecial #1     // Method java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compute</span><span class="params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: iconst_1</span><br><span class="line">       <span class="number">1</span>: istore_1</span><br><span class="line">       <span class="number">2</span>: iconst_2</span><br><span class="line">       <span class="number">3</span>: istore_2</span><br><span class="line">       <span class="number">4</span>: iload_1</span><br><span class="line">       <span class="number">5</span>: iload_2</span><br><span class="line">       <span class="number">6</span>: iadd</span><br><span class="line">       <span class="number">7</span>: bipush        <span class="number">10</span>  </span><br><span class="line">       <span class="number">9</span>: imul</span><br><span class="line">      <span class="number">10</span>: istore_3</span><br><span class="line">      <span class="number">11</span>: iload_3</span><br><span class="line">      <span class="number">12</span>: ireturn</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       0: new           #2      // class Math</span><br><span class="line">       <span class="number">3</span>: dup </span><br><span class="line">       4: invokespecial #3      // Method "&lt;init&gt;":()V</span><br><span class="line">       <span class="number">7</span>: astore_1</span><br><span class="line">       <span class="number">8</span>: aload_1</span><br><span class="line">       9: invokevirtual #4      // Method compute:()I</span><br><span class="line">      <span class="number">12</span>: istore_2</span><br><span class="line">      13: getstatic     #5      // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">      <span class="number">16</span>: iload_2</span><br><span class="line">      17: invokevirtual #6      // Method java/io/PrintStream.println:(I)V</span><br><span class="line">      <span class="number">20</span>: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过查询<a href="https://gist.github.com/pwxcoo/d8b321c24ccf031c3ee94ff36bc857d4" target="_blank" rel="noopener">javap 字节码指令集</a>，可以看到每一步操作:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">栈和局部变量操作 </span><br><span class="line">将常量压入栈的指令 </span><br><span class="line">aconst_null 将<span class="keyword">null</span>对象引用压入栈 </span><br><span class="line">iconst_m1 将<span class="keyword">int</span>类型常量-<span class="number">1</span>压入栈 </span><br><span class="line">iconst_0 将<span class="keyword">int</span>类型常量<span class="number">0</span>压入栈 </span><br><span class="line">iconst_1 将<span class="keyword">int</span>类型常量<span class="number">1</span>压入栈 </span><br><span class="line">iconst_2 将<span class="keyword">int</span>类型常量<span class="number">2</span>压入栈 </span><br><span class="line">iconst_3 将<span class="keyword">int</span>类型常量<span class="number">3</span>压入栈 </span><br><span class="line">iconst_4 将<span class="keyword">int</span>类型常量<span class="number">4</span>压入栈 </span><br><span class="line">iconst_5 将<span class="keyword">int</span>类型常量<span class="number">5</span>压入栈 </span><br><span class="line">lconst_0 将<span class="keyword">long</span>类型常量<span class="number">0</span>压入栈 </span><br><span class="line">lconst_1 将<span class="keyword">long</span>类型常量<span class="number">1</span>压入栈 </span><br><span class="line">fconst_0 将<span class="keyword">float</span>类型常量<span class="number">0</span>压入栈 </span><br><span class="line">fconst_1 将<span class="keyword">float</span>类型常量<span class="number">1</span>压入栈 </span><br><span class="line">dconst_0 将<span class="keyword">double</span>类型常量<span class="number">0</span>压入栈 </span><br><span class="line">dconst_1 将<span class="keyword">double</span>类型常量<span class="number">1</span>压入栈 </span><br><span class="line">bipush 将一个<span class="number">8</span>位带符号整数压入栈 </span><br><span class="line">sipush 将<span class="number">16</span>位带符号整数压入栈 </span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>此时内存区域如下图所示：</p><p><img src="/images/jvm_math_snapshot.png" alt></p><h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><p><strong>Minor GC和Full GC区别</strong></p><ul><li>Minor GC/Young GC: 指新生代发生的垃圾收集动作，Minor GC非常频繁，回收速度一般比较快；</li><li>Major GC/Full GC: 一般会回收老年代，年轻代，方法区（永久区）的垃圾，Major GC的速度一般会比Minor GC慢10倍以上。</li></ul><h2 id="什么时候回收"><a href="#什么时候回收" class="headerlink" title="什么时候回收"></a>什么时候回收</h2><ul><li><p>Minor GC触发条件<br>当Eden区满时，触发Minor GC。</p></li><li><p>Full GC触发条件</p><ul><li><p>（1）调用System.gc时，系统建议执行Full GC，但是不必然执行</p></li><li><p>（2）老年代空间不足</p></li><li><p>（3）方法区空间不足</p></li><li><p>（4）通过Minor GC后进入老年代的平均大小大于老年代的可用内存</p></li><li><p>（5）由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小、</p><h2 id="怎么回收"><a href="#怎么回收" class="headerlink" title="怎么回收"></a>怎么回收</h2><p>从GC的底层机制可以看出，对于可以搜索到的对象进行复制操作，对于搜索不到的对象，<strong>调用finalize()方法进行释放</strong>。</p></li></ul></li></ul><p>具体过程：当GC线程启动时，会通过可达性分析法把Eden区和From Space区的存活对象复制到To Space区，然后把Eden Space和From Space区的对象释放掉。当GC轮训扫描To Space区一定次数后，把依然存活的对象复制到老年代，然后释放To Space区的对象。</p><p>对于用可达性分析法搜索不到的对象，GC并不一定会回收该对象。要完全回收一个对象，至少需要经过<strong>两次标记的过程</strong>。</p><ul><li><p>第一次标记<br>对于一个没有其他引用的对象，筛选该对象是否有必要执行finalize()方法，如果没有执行必要，则意味可直接回收。（筛选依据：是否复写或执行过finalize()方法；因为finalize方法只能被执行一次）。</p></li><li><p>第二次标记<br>如果被筛选判定位有必要执行，则会放入FQueue队列，并自动创建一个低优先级的finalize线程来执行释放操作。如果在一个对象释放前被其他对象引用，则该对象会被移除FQueue队列。</p></li></ul><h2 id="JVM内存分配与回收策略"><a href="#JVM内存分配与回收策略" class="headerlink" title="JVM内存分配与回收策略"></a>JVM内存分配与回收策略</h2><h3 id="对象优先在Eden区分配"><a href="#对象优先在Eden区分配" class="headerlink" title="对象优先在Eden区分配"></a>对象优先在Eden区分配</h3><p>大多数情况下，对象在新生代中Eden区分配，当Eden区没有足够空间时，虚拟机将发起一次Minor GC.</p><h3 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h3><ul><li><p>既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须识别哪些对象应该放在新生代，哪些需要放在老年代。为了做到这一点，虚拟机给每个对象一个对象年龄（Age）计数器。</p></li><li><p>如果对象在Eden区出生并经过一次minor gc后仍然存活，并且大小能被Survivor容纳的话，将会移动到另一个Survivor区，并将对象年龄设为1。对象在Survivor中每熬过一次minor gc，年龄就增1岁，当增加到一定大小（默认为15岁），就会晋升到老年代。对象晋升到老年代的年龄阈值可以通过<code>-XX:MaxTenuringThreshold</code>来设置。</p></li></ul><h3 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h3><ul><li><p>大对象就是需要大量连续内存空间的对象，比如：长字符串、数组</p></li><li><p>JVM参数<code>-神器:PretenureSizeThreshold</code>可以设置大对象的大小，如果对象超过了设置大小，在创建时就会直接进入老年代，不会进入年轻代，这个参数只在<strong>Serial</strong>和<strong>ParNew</strong>两个收集器下有效</p></li><li><p>例如 <code>-神器:PretenureSizeThreshold=1000000 -XX:+UseSerialGC</code></p></li><li><p>这么做的目的：<strong>避免为大对象分配内存时的复制操作而降低效率</strong>；</p></li></ul><h3 id="对象动态年龄判断"><a href="#对象动态年龄判断" class="headerlink" title="对象动态年龄判断"></a>对象动态年龄判断</h3><ul><li><p>当前放置对象的Survivor区域里（另一块Survivor为空），一批对象的总大小大于这块Survivor区域内存大小的50%，那么此时大于这批对象年龄最大值的对象，就可以直接提前进入老年代了；</p></li><li><p>例如Survivor区域里现有一批对象：<code>年龄为1对象 + 年龄为2对象 + ... +  年龄为n对象</code> 所占空间总和超过了Survivor区总大小的50%，此时就会把年龄大于n的对象提前放入老年代；</p></li></ul><h3 id="老年代空间分配担保机制"><a href="#老年代空间分配担保机制" class="headerlink" title="老年代空间分配担保机制"></a>老年代空间分配担保机制</h3><p>年轻代每次Minor gc之前，JVM都会计算下老年代剩余可用空间：</p><ul><li><p>如果老年代剩余可用空间小于年轻代里现有的所有对象的大小之和（包括垃圾对象），就会看一个 <code>-神器:-HandlePromotionFailure</code> （JDK1.8默认就设置了）的参数是否配置了，如果有这个参数，就会看看老年代的可用内存大小，是否大于之前每次minor gc后进入老年代的对象平均大小；</p></li><li><p>如果上一步结果是小于或者没有设置该参数，JVM就会发起一次Full GC，对老年代和年轻代一起进行垃圾回收；</p></li><li><p>如果上一步结果是大于该参数，正常进行Minor GC;当然如果Minor GC后，剩余存活对象里需要移动到老年代的总大小超过了老年代可用空间，还是会触发Full GC;</p></li><li><p>如果回收完还是没有足够空间存放新建的对象，就会发生 <strong>OOM</strong>；</p></li></ul><p><img src="/images/jvm_fenpei_danbao.jpg" alt></p><h2 id="垃圾对象判断"><a href="#垃圾对象判断" class="headerlink" title="垃圾对象判断"></a>垃圾对象判断</h2><p>如何判断一个对象是否可以被回收，常见的做法有两种：</p><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>给对象头中添加一个引用计数器，每当有一个地方引用它，就给它的计数器+1；当引用失效，计数器就-1；只要计数器为0，就表示当前对象没有被使用，可以被回收。</p><ul><li><p><strong>优点</strong><br>引用计数收集器可以很快的执行，交织在程序运行中。对程序需要不被长时间打断的实时环境比较有利。</p></li><li><p><strong>缺点</strong><br>无法检测出循环引用。如父对象有一个对子对象的引用，子对象反过来引用父对象。这样，他们的引用计数永远不可能为0.</p></li></ul><p>Java的引用类型一般分为四种：</p><ul><li><p><strong>强引用</strong><br>普通的变量引用；</p></li><li><p><strong>软引用</strong><br>将对象用SoftReference软引用类型的对象包裹，正常情况下不会被回收，但是GC做完之后发现释放不出空间存放新对象，就会把这些软引用的对象回收掉。软引用可用来实现对内存敏感度不高的高速缓存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> SoftReference&lt;User&gt;  user = <span class="keyword">new</span> SoftReference&lt;User&gt;(<span class="keyword">new</span> User());</span><br></pre></td></tr></table></figure></li><li><p><strong>弱引用</strong><br>将对象用WeakReference弱引用类型的对象包裹，弱引用跟没引用差不多，GC会直接回收掉，很少用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> WeakReference&lt;User&gt; user = <span class="keyword">new</span> WeakReference&lt;User&gt;(<span class="keyword">new</span> User());</span><br></pre></td></tr></table></figure></li><li><p><strong>虚引用</strong><br>也成为幽灵引用或者幻影引用，它是最弱的一种引用关系，几乎不用。</p></li></ul><h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>这个算法的基本思想是通过一系列被称为”GC Roots”的对象作为起始点，从这些节点向下搜索，找到的对象都标记为非垃圾对象，剩余的都为垃圾对象；</p><p><strong>GC Roots:</strong> <font color="red">线程栈的本地变量、静态属性、常量、本地方法栈的变量等</font>；</p><p><strong>finalize()方法最终判定对象是否存活</strong><br>即使在可达性分析算法中不可达的对象，也并非是 『<strong>非死不可</strong>』，标记完之后只是暂时处于 『<strong>缓刑</strong>』 阶段，要真正宣告一个对象死亡，至少要经历再次标记过程。</p><p>标记的前提是：<strong>对象在进行可达性分析之后发现没有与任何GC Roots相连的引用链</strong>。</p><ul><li><p>第一次标记并进行一次筛选<br>对象如果没有覆盖<code>finalize()</code>方法，将会直接被回收；</p></li><li><p>第二次标记<br>如果这个对象覆盖了<code>finalize()</code>方法，只要在该方法中重新与引用链上的任何一个对象建立了关联，就可以拯救自己，不会被回收。</p></li></ul><p><strong>如何判断一个类是无用类：</strong><br>类需要同时满足下面3个条件才能算是 <strong>无用类</strong>：</p><ul><li><p>该类所有的实例都已经被回收，也就是堆中不存在该类的任何实例；</p></li><li><p>加载该类的ClassLoader已经被回收；</p></li><li><p>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法；</p></li></ul><h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><p>常用的垃圾回收算法有：标记-清除算法、复制算法、标记-整理算法、分代收集算法。目前主流的JVM（HotSpot）采用的是分代收集算法。</p><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>标记-清除算法采用从根集合进行扫描，对存活的对象对象标记，标记完毕后，再扫描整个空间中未被标记的对象，进行回收。标记-清除算法不需要进行对象的移动，并且仅对不存活的对象进行处理，在<strong>存活对象比较多的情况下极为高效</strong>，但由于标记-清除算法直接回收不存活的对象，因此会<strong>造成内存碎片</strong>。<br><img src="/images/jvm_mark_swep.jpg" alt></p><h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p><img src="/images/jvm_copy.jpg" alt></p><h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><p><img src="/images/jvm_mark_zhengli.jpg" alt></p><h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p><img src="/images/jvm_fendai_collection.jpg" alt></p><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p><img src="/images/java_gc_collectors.png" alt></p><h3 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h3><p><img src="/images/java_gc_serial.jpg" alt></p><h3 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h3><p><img src="/images/java_gc_parnew.jpg" alt></p><h3 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h3><p><img src="/images/java_gc_scavenge.jpg" alt></p><h3 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h3><p><img src="/images/java_gc_cms-collec.jpg" alt></p><p><img src="/images/java_cms_advantage.jpg" alt></p><p><img src="/images/java_cms_parameter.jpg" alt></p><h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h3><p><img src="/images/java_gc_g1.jpg" alt></p><p><img src="/images/java_gc_g1_process.jpg" alt></p><p><img src="/images/java_gc_g1_class.jpg" alt></p><h1 id="JVM优化"><a href="#JVM优化" class="headerlink" title="JVM优化"></a>JVM优化</h1><h2 id="能否对JVM调优，让其几乎不发生Full-GC"><a href="#能否对JVM调优，让其几乎不发生Full-GC" class="headerlink" title="能否对JVM调优，让其几乎不发生Full GC?"></a>能否对JVM调优，让其几乎不发生Full GC?</h2><p>评估对象大小和生命周期，调整年轻代大小和Eden/Survivor区比例，保证minor gc就能够回收基本所有对象，避免对象因为过大或年龄太大进入老年代。<br><img src="/images/jvm_full_gc_optimize.jpg" alt></p><p>需要放入survivor区的对象大于survivor区大小的50%时，会触发担保机制，直接放入老年代；</p><h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><p><a href="https://juejin.im/post/5df5c76ee51d45581634f256?utm_source=gold_browser_extension" target="_blank" rel="noopener">【搞定Jvm面试】Java 内存区域揭秘附常见面试题解析</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JDK体系结构&quot;&gt;&lt;a href=&quot;#JDK体系结构&quot; class=&quot;headerlink&quot; title=&quot;JDK体系结构&quot;&gt;&lt;/a&gt;JDK体系结构&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/images/jdk_structure.jpg&quot; alt&gt;&lt;/p&gt;
&lt;h1 
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
      <category term="JVM" scheme="http://yoursite.com/categories/Java/JVM/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Jvm" scheme="http://yoursite.com/tags/Jvm/"/>
    
  </entry>
  
  <entry>
    <title>Redis数据结构及常见使用场景</title>
    <link href="http://yoursite.com/2019/12/06/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%B8%B8%E8%A7%81%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <id>http://yoursite.com/2019/12/06/Redis数据结构及常见使用场景/</id>
    <published>2019-12-06T12:25:19.000Z</published>
    <updated>2019-12-06T12:50:53.518Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis基础数据类型及使用场景"><a href="#Redis基础数据类型及使用场景" class="headerlink" title="Redis基础数据类型及使用场景"></a>Redis基础数据类型及使用场景</h2><p><img src="/images/redis_basitc_data_structure.jpg" alt></p><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p><img src="/images/redis_string_basic_op.jpg" alt></p><p><img src="/images/redis_string_basic_caculate.jpg" alt></p><ul><li><p>缓存功能：String字符串是最常用的数据类型，不仅仅是Redis，各个语言都是最基本类型，因此，利用Redis作为缓存，配合其它数据库作为存储层，利用Redis支持高并发的特点，可以大大加快系统的读写速度、以及降低后端数据库的压力。</p></li><li><p>计数器：许多系统都会使用Redis作为系统的实时计数器，可以快速实现计数和查询的功能。而且最终的数据结果可以按照特定的时间落地到数据库或者其它存储介质当中进行永久保存。</p></li><li><p>共享用户Session：用户重新刷新一次界面，可能需要访问一下数据进行重新登录，或者访问页面缓存Cookie，但是可以利用Redis将用户的Session集中管理，在这种模式只需要保证Redis的高可用，每次用户Session的更新和获取都可以快速完成。大大提高效率。</p></li></ul><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p><img src="/images/redis_hash_basic_op.jpg" alt></p><p><img src="/images/redis_hash_basic_cache.jpg" alt></p><p><img src="/images/redis_hash_elec_strore.jpg" alt></p><p>这个是类似 Map 的一种结构，这个一般就是可以将结构化的数据，比如一个对象（前提是这个对象没嵌套其他的对象）给缓存在 Redis 里，然后每次读写缓存的时候，可以就操作 Hash 里的某个字段。<br>但是这个的场景其实还是多少单一了一些，因为现在很多对象都是比较复杂的，比如你的商品对象可能里面就包含了很多属性，其中也有对象。我自己使用的场景用得不是那么多。</p><p><img src="/images/redis_hash_advantage.jpg" alt></p><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>List 是有序列表，这个还是可以玩儿出很多花样的。</p><p><img src="/images/redis_list_basic_op.jpg" alt></p><p><img src="/images/redis_list_stack.jpg" alt></p><ul><li>比如可以通过 List 存储一些<strong>列表型的数据结构</strong>，类似粉丝列表、文章的评论列表之类的东西。<br>比如可以通过 <code>lrange</code> 命令，读取某个闭区间内的元素，可以基于 List 实现<code>分页查询</code>，这个是很棒的一个功能，基于 Redis 实现简单的高性能分页，可以做类似微博那种下拉不断分页的东西，性能高，就一页一页走。</li></ul><p>比如可以搞个简单的消息队列，从 List 头怼进去，从 List 屁股那里弄出来。List本身就是我们在开发过程中比较常用的数据结构了，热点数据更不用说了。</p><ul><li><p>消息队列：Redis的链表结构，可以轻松实现阻塞队列，可以使用<strong>左进右出的命令</strong>组成来完成队列的设计。比如：数据的生产者可以通过<code>Lpush</code>命令从左边插入数据，多个数据消费者，可以使用<code>BRpop</code>命令阻塞的“抢”列表尾部的数据。</p></li><li><p>文章列表或者数据分页展示的应用。<br>比如，我们常用的博客网站的文章列表，当用户量越来越多时，而且每一个用户都有自己的文章列表，而且当文章多时，都需要分页展示，这时可以考虑使用Redis的列表，列表不但有序同时还支持按照范围内获取元素，可以完美解决分页查询功能。大大提高查询效率。</p></li></ul><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>Set 是无序集合，会自动去重的那种。</p><p><img src="/images/redis_set_basic_op.jpg" alt></p><p><img src="/images/redis_set_basic_weixin.jpg" alt></p><p><img src="/images/redis_set_basic_weibo.jpg" alt></p><p><img src="/images/redis_set_basic_weibo_guanzhu.jpg" alt></p><ul><li><p><strong>去重：</strong> 直接基于 Set 将系统里需要去重的数据扔进去，自动就给去重了，如果你需要对一些数据进行快速的全局去重，你当然也可以基于 JVM 内存里的 HashSet 进行去重，但是如果你的某个系统部署在多台机器上呢？得基于Redis进行全局的 Set 去重。</p></li><li><p>可以基于 Set 玩 <strong>交集、并集、差集</strong> 的操作。比如交集吧，我们可以把两个人的好友列表整一个交集，看看俩人的共同好友是谁？对吧。反正这些场景比较多，因为对比很快，操作也简单，两个查询一个Set搞定。</p></li></ul><h3 id="Sorted-Set"><a href="#Sorted-Set" class="headerlink" title="Sorted Set"></a>Sorted Set</h3><p>Sorted set 是排序的 Set，<strong>去重并可以排序</strong>，写进去的时候给一个分数，自动根据分数排序。</p><p>有序集合的使用场景与集合类似，但是set集合不是自动有序的，而<strong>Sorted set可以利用分数进行成员间的排序，而且是插入时就排序好</strong>。所以当你需要一个有序且不重复的集合列表时，就可以选择Sorted set数据结构作为选择方案。</p><p><img src="/images/redis_sorted_weibo.jpg" alt></p><ul><li><p>排行榜：有序集合经典使用场景。例如视频网站需要对用户上传的视频做排行榜，榜单维护可能是多方面：按照时间、按照播放量、按照获得的赞数等。</p></li><li><p>用<code>Sorted Sets</code>来做带权重的队列，比如普通消息的score为1，重要消息的score为2，然后工作线程可以选择按score的倒序来获取工作任务。让重要的任务优先执行。</p></li></ul><h3 id="Redis更多应用场景"><a href="#Redis更多应用场景" class="headerlink" title="Redis更多应用场景"></a>Redis更多应用场景</h3><p><img src="/images/redis_more_yingyong.jpg" alt></p><p><img src="/images/redis_collect_elec.jpg" alt></p><h2 id="Redis-和-Memcached-区别"><a href="#Redis-和-Memcached-区别" class="headerlink" title="Redis 和 Memcached 区别"></a>Redis 和 Memcached 区别</h2><h3 id="Memcache"><a href="#Memcache" class="headerlink" title="Memcache"></a>Memcache</h3><p>先来看看 MC 的特点：</p><ul><li><p>MC 处理请求时使用<code>多线程异步IO</code> 的方式，可以合理利用 CPU 多核的优势，性能非常优秀；</p></li><li><p>MC 功能简单，使用内存存储数据；</p></li><li><p>MC 的内存结构以及钙化问题；</p></li><li><p>MC 对缓存的数据可以设置失效期，过期后的数据会被清除；</p></li><li><p>失效的策略采用延迟失效，就是当再次使用数据时检查是否失效；</p></li><li><p>当容量存满时，会对缓存中的数据进行剔除，剔除时除了会对过期 key 进行清理，还会按 LRU 策略对数据进行剔除。</p></li></ul><p>另外，使用 MC 有一些限制，这些限制在现在的互联网场景下很致命，成为大家选择Redis、MongoDB的重要原因：</p><ul><li><p>key 不能超过 250 个字节；</p></li><li><p>value 不能超过 1M 字节；</p></li><li><p>key 的最大失效时间是 30 天；</p></li><li><p>只支持 K-V 结构，不提供持久化和主从同步功能。</p></li></ul><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><p>简单说一下 Redis 的特点，方便和 Memcache 比较。</p><ul><li><p>与 MC 不同的是，Redis 采用单线程模式处理请求。这样做的原因有 2 个：</p><ul><li><p>一个是因为采用了非阻塞的异步事件处理机制；</p></li><li><p>另一个是缓存数据都是内存操作 IO 时间不会太长，单线程可以避免线程上下文切换产生的代价。</p></li></ul></li><li><p>Redis 支持持久化，所以 Redis 不仅仅可以用作缓存，也可以用作 NoSQL 数据库。</p></li><li><p>相比 MC，Redis 还有一个非常大的优势，就是除了 K-V 之外，还支持复杂的数据结构，例如 list、set、sorted set、hash 等。</p></li><li><p>Redis 提供主从同步机制，以及原生支持集群模式，能够提供高可用服务, 在 redis3.x 版本中，便能支持 Cluster 模式; 而 Memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据。</p></li></ul><h3 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h3><p>由于 Redis 只使用单核，而 Memcached 可以使用多核，所以<strong>平均每一个核上 Redis 在存储小数据时比 Memcached 性能更高。而在 100k 以上的数据中，Memcached 性能要高于 Redi</strong>s，虽然 Redis 最近也在存储大数据的性能上进行优化，但是比起 Remcached，还是稍有逊色。</p><h2 id="Redis-线程模型"><a href="#Redis-线程模型" class="headerlink" title="Redis 线程模型"></a>Redis 线程模型</h2><p>Redis 内部使用 <strong>文件事件处理器</strong> <code>file event handler</code>，这个文件事件处理器是单线程的，所以 Redis 才叫做单线程的模型。它<strong>采用 IO 多路复用机制同时监听多个 Socket</strong>，根据 Socket 上的事件来选择对应的事件处理器进行处理。</p><p>文件事件处理器的结构包含 4 个部分：</p><ul><li>多个 Socket</li><li>IO 多路复用程序</li><li>文件事件分派器</li><li>事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）</li></ul><p>多个 Socket 可能会并发产生不同的操作，每个操作对应不同的文件事件，但是 IO 多路复用程序会监听多个 Socket，会将 Socket 产生的事件放入队列中排队，事件分派器每次从队列中取出一个事件，把该事件交给对应的事件处理器进行处理。</p><h2 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h2><h3 id="Bitmap"><a href="#Bitmap" class="headerlink" title="Bitmap"></a>Bitmap</h3><p>位图是支持按 bit 位来存储信息，可以用来实现 <code>布隆过滤器（BloomFilter）</code>；</p><h3 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h3><p>供不精确的去重计数功能，比较适合用来做大规模数据的去重统计，例如统计 UV；</p><h3 id="Geospatial"><a href="#Geospatial" class="headerlink" title="Geospatial"></a>Geospatial</h3><p>可以用来保存地理位置，并作<code>位置距离计算</code>或者<code>根据半径计算位置</code>等。有没有想过用Redis来实现附近的人？或者计算最优地图路径？</p><h3 id="pub-sub"><a href="#pub-sub" class="headerlink" title="pub/sub"></a>pub/sub</h3><p>功能是订阅发布功能，可以用作简单的消息队列。 </p><h3 id="Pipeline"><a href="#Pipeline" class="headerlink" title="Pipeline"></a>Pipeline</h3><p>可以批量执行一组指令，一次性返回全部结果，可以减少频繁的请求应答。</p><h3 id="Lua"><a href="#Lua" class="headerlink" title="Lua"></a>Lua</h3><p>Redis 支持提交 Lua 脚本来执行一系列的功能, 利用他的原子性。</p><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>最后一个功能是事务，但 Redis 提供的不是严格的事务，Redis 只保证串行执行命令，并且能保证全部执行，但是执行命令失败时并不会回滚，而是会继续执行下去。</p><h2 id="Redis集群"><a href="#Redis集群" class="headerlink" title="Redis集群"></a>Redis集群</h2><p><img src="/images/redis_cluster_crc_ms.jpg" alt></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1]<a href="https://juejin.im/post/5db66ed9e51d452a2f15d833" target="_blank" rel="noopener">《吊打面试官》系列-Redis基础</a><br>[2]<a href="https://juejin.im/post/5dbef8306fb9a0203f6fa3e2" target="_blank" rel="noopener">《吊打面试官》系列-缓存雪崩、击穿、穿透</a><br>[3]<a href="https://juejin.im/post/5dc3a9fbf265da4d3c072eab" target="_blank" rel="noopener">《吊打面试官》系列-Redis哨兵、持久化、主从、手撕LRU</a><br>[4]<a href="https://juejin.im/post/5dc850b4e51d452c2308ee27" target="_blank" rel="noopener">《吊打面试官》系列-Redis终章凛冬将至、FPX新王登基</a><br>[5]<a href="https://juejin.im/post/5dd09f5af265da0be72aacbd" target="_blank" rel="noopener">《吊打面试官》系列-秒杀系统设计</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Redis基础数据类型及使用场景&quot;&gt;&lt;a href=&quot;#Redis基础数据类型及使用场景&quot; class=&quot;headerlink&quot; title=&quot;Redis基础数据类型及使用场景&quot;&gt;&lt;/a&gt;Redis基础数据类型及使用场景&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/ima
      
    
    </summary>
    
      <category term="中间件" scheme="http://yoursite.com/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
      <category term="Redis" scheme="http://yoursite.com/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="入门" scheme="http://yoursite.com/tags/%E5%85%A5%E9%97%A8/"/>
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Tomcat系统架构[转载]</title>
    <link href="http://yoursite.com/2019/12/06/Tomcat%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84-%E8%BD%AC%E8%BD%BD/"/>
    <id>http://yoursite.com/2019/12/06/Tomcat系统架构-转载/</id>
    <published>2019-12-06T12:09:24.000Z</published>
    <updated>2019-12-09T12:07:22.663Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Tomcat顶层架构"><a href="#Tomcat顶层架构" class="headerlink" title="Tomcat顶层架构"></a>Tomcat顶层架构</h2><p>先上一张Tomcat的顶层结构图，如下<br><img src="/images/tomcat_structure.jpg" alt></p><p>简化清晰版<br><img src="/images/tomcat_stucture2.jpg" alt></p><ul><li><p>Tomcat中最顶层的容器是Server，代表着整个服务器，从上图中可以看出，一个Server可以包含至少一个Service，用于具体提供服务。</p></li><li><p>Service主要包含两个部分：<strong>Connector</strong>和<strong>Container</strong>。从上图中可以看出 Tomcat 的心脏就是这两个组件，他们的作用如下：</p><ul><li><p>Connector用于<strong>处理连接相关的事情，并提供Socket与Request和Response相关的转化</strong>; </p></li><li><p>Container用于<strong>封装和管理Servlet，以及具体处理Request请求</strong>；</p></li></ul></li></ul><p><font color="red"><strong>一个Tomcat中只有一个Server，一个Server可以包含多个Service，一个Service只有一个Container，但是可以有多个Connectors，这是因为一个服务可以有多个连接，如同时提供Http和Https链接，也可以提供向相同协议不同端口的连接</strong></font></p><p>示意图如下（Engine、Host、Context下边会说到）：<br><img src="/images/engine_host_context.jpg" alt></p><p>多个 Connector 和一个 Container 就形成了一个 Service，有了 Service 就可以对外提供服务了，但是 Service 还要一个生存的环境，必须要有人能够给它生命、掌握其生死大权，那就非 Server 莫属了！所以<strong>整个 Tomcat 的生命周期由 Server 控制</strong>。</p><p>另外，上述的包含关系或者说是父子关系，都可以在tomcat的conf目录下的<code>server.xml</code>配置文件中看出，如下是删除了注释内容之后的一个完整的<code>server.xml</code>配置文件（Tomcat版本为8.0）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version='1.0' encoding='utf-8'?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Server</span> <span class="attr">port</span>=<span class="string">"8005"</span> <span class="attr">shutdown</span>=<span class="string">"SHUTDOWN"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.startup.VersionLoggerListener"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.core.AprLifecycleListener"</span> <span class="attr">SSLEngine</span>=<span class="string">"on"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.core.JreMemoryLeakPreventionListener"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.mbeans.GlobalResourcesLifecycleListener"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.core.ThreadLocalLeakPreventionListener"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">GlobalNamingResources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Resource</span> <span class="attr">name</span>=<span class="string">"UserDatabase"</span> <span class="attr">auth</span>=<span class="string">"Container"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">type</span>=<span class="string">"org.apache.catalina.UserDatabase"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">description</span>=<span class="string">"User database that can be updated and saved"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">factory</span>=<span class="string">"org.apache.catalina.users.MemoryUserDatabaseFactory"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">pathname</span>=<span class="string">"conf/tomcat-users.xml"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">GlobalNamingResources</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">Service</span> <span class="attr">name</span>=<span class="string">"Catalina"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8060"</span> <span class="attr">protocol</span>=<span class="string">"HTTP/1.1"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">connectionTimeout</span>=<span class="string">"20000"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">redirectPort</span>=<span class="string">"8443"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8009"</span> <span class="attr">protocol</span>=<span class="string">"AJP/1.3"</span> <span class="attr">redirectPort</span>=<span class="string">"8443"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Engine</span> <span class="attr">name</span>=<span class="string">"Catalina"</span> <span class="attr">defaultHost</span>=<span class="string">"localhost"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Realm</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.realm.LockOutRealm"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Realm</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.realm.UserDatabaseRealm"</span> <span class="attr">resourceName</span>=<span class="string">"UserDatabase"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">Realm</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">Host</span> <span class="attr">name</span>=<span class="string">"localhost"</span>  <span class="attr">appBase</span>=<span class="string">"webapps"</span> <span class="attr">unpackWARs</span>=<span class="string">"true"</span> <span class="attr">autoDeploy</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Context</span> <span class="attr">path</span>=<span class="string">""</span> <span class="attr">docBase</span>=<span class="string">"/xxx/target/bigdata-web"</span> </span></span><br><span class="line"><span class="tag">                    <span class="attr">debug</span>=<span class="string">"0"</span> <span class="attr">reloadable</span>=<span class="string">"true"</span> <span class="attr">crossContext</span>=<span class="string">"true"</span> <span class="attr">allowLinking</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">Valve</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.valves.AccessLogValve"</span> <span class="attr">directory</span>=<span class="string">"logs"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">prefix</span>=<span class="string">"localhost_access_log"</span> <span class="attr">suffix</span>=<span class="string">".txt"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">pattern</span>=<span class="string">"%h %l %u %t &amp;quot;%r&amp;quot; %s %b"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">Host</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Engine</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">Service</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Server</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上边的配置文件，还可以通过下边的一张结构图更清楚的理解：</p><p><img src="/images/web_xml.jpg" alt></p><p>Server标签设置的端口号为8005，shutdown=”SHUTDOWN” ，表示在8005端口监听“SHUTDOWN”命令，如果接收到了就会关闭Tomcat。一个Server有一个Service，当然还可以进行配置。Service左边的内容都属于Container的，Service下边是多个Connector。</p><h2 id="Tomcat顶层架构小结"><a href="#Tomcat顶层架构小结" class="headerlink" title="Tomcat顶层架构小结"></a>Tomcat顶层架构小结</h2><ul><li><p>（1）Tomcat中只有一个Server，一个Server可以有多个Service，一个Service可以有多个Connector和一个Container；</p></li><li><p>（2） Server掌管着整个Tomcat的生死大权；</p></li><li><p>（4）Service 是对外提供服务的；</p></li><li><p>（5）Connector用于接受请求并将请求封装成Request和Response来具体处理；</p></li><li><p>（6）Container用于封装和管理Servlet，以及具体处理request请求；</p></li></ul><p>以上是整个Tomcat顶层的分层架构和各个组件之间的关系以及作用，但对于绝大多数的开发人员来说Server和Service对我们来说确实很远，而我们开发中绝大部分进行配置的内容是属于Connector和Container的，所以接下来介绍一下<strong>Connector</strong>和<strong>Container</strong>。</p><h2 id="Connector和Container的微妙关系"><a href="#Connector和Container的微妙关系" class="headerlink" title="Connector和Container的微妙关系"></a>Connector和Container的微妙关系</h2><p><img src="/images/connector_container.jpg" alt="-w578"></p><p>由上述内容我们大致可以知道一个请求发送到Tomcat之后，首先经过<strong>Service</strong>然后会交给我们的<strong>Connector</strong>，<strong>Connector</strong>用于接收请求并将接收的请求封装为Request和Response来具体处理，Request和Response封装完之后再交由Container进行处理，Container处理完请求之后再返回给Connector，最后在由Connector通过Socket将处理的结果返回给客户端，这样整个请求的就处理完了！</p><p>Connector最底层使用的是Socket来进行连接的，Request和Response是按照HTTP协议来封装的，所以Connector同时需要实现TCP/IP协议和HTTP协议！</p><p>Tomcat既然处理请求，那么肯定需要先接收到这个请求，接收请求这个东西我们首先就需要看一下Connector！</p><h2 id="Connector架构分析"><a href="#Connector架构分析" class="headerlink" title="Connector架构分析"></a>Connector架构分析</h2><p>Connector用于接受请求并将请求封装成Request和Response，然后交给Container进行处理，Container处理完之后在交给Connector返回给客户端。</p><p>因此，我们可以把Connector分为四个方面进行理解：</p><blockquote><p>（1）Connector如何接受请求的？<br>（2）如何将请求封装成Request和Response的？<br>（3）封装完之后的Request和Response如何交给Container进行处理的？<br>（4）Container处理完之后如何交给Connector并返回给客户端的？</p></blockquote><p>首先看一下Connector的结构图，如下所示：</p><p> <img src="/images/connector_structure.jpg" alt></p><p><strong>Connector</strong>就是使用<strong>ProtocolHandler</strong>来处理请求的，不同的<strong>ProtocolHandler</strong>代表不同的连接类型，比如：<strong>Http11Protocol</strong>使用的是普通Socket来连接的，<strong>Http11NioProtocol</strong>使用的是NioSocket来连接的。</p><p>其中ProtocolHandler由包含了三个部件：<strong>Endpoint</strong>、<strong>Processor</strong>、<strong>Adapter</strong>。</p><ul><li><p><strong>Endpoint</strong> 用来处理底层Socket的网络连接</p><ul><li><p>Endpoint由于是处理底层的Socket网络连接，因此Endpoint是用来实现<strong>TCP/IP</strong>协议的</p></li><li><p>Endpoint 的抽象实现<code>AbstractEndpoint</code>里面定义的 <code>Acceptor</code> 和 <code>AsyncTimeout</code> 两个内部类和一个 <code>Handler</code> 接口。</p><blockquote><p><code>Acceptor</code>用于监听请求<br><code>AsyncTimeout</code>用于检查异步Request的超时<br><code>Handler</code> 用于处理接收到的Socket，在内部调用Processor进行处理</p></blockquote></li></ul></li><li><p><strong>Processor</strong> 用于将Endpoint接收到的Socket封装成Request</p><ul><li>Processor用来实现<strong>HTTP</strong>协议的</li></ul></li><li><p><strong>Adapter</strong> 用于将Request交给Container进行具体的处理</p><ul><li>Adapter将请求适配到Servlet容器进行具体的处理</li></ul></li></ul><p>至此，我们应该很轻松的回答（1）（2）（3）的问题了，但是（4）还是不知道，那么我们就来看一下Container是如何进行处理的以及处理完之后是如何将处理完的结果返回给Connector的？</p><h2 id="Container架构分析"><a href="#Container架构分析" class="headerlink" title="Container架构分析"></a>Container架构分析</h2><p>Container用于封装和管理Servlet，以及具体处理Request请求，在Connector内部包含了4个子容器，结构图如下：</p><p><img src="/images/container_structure.jpg" alt></p><p>4个子容器的作用分别是：</p><ul><li><p><strong>Engine</strong>：引擎，用来管理多个站点，一个Service最多只能有一个Engine；</p></li><li><p><strong>Host</strong>：代表一个站点，也可以叫虚拟主机，通过配置Host就可以添加站点；</p></li><li><p><strong>Context</strong>：代表一个应用程序，对应着平时开发的一套程序，或者一个 <code>WEB-INF</code> 目录以及下面的 <code>web.xml</code> 文件；</p></li><li><p><strong>Wrapper</strong>：每一Wrapper封装着一个Servlet；</p></li></ul><p>下面找一个Tomcat的文件目录对照一下，如下图所示：<br><img src="/images/tomcat_deploy_folder.jpg" alt></p><p><strong>Context和Host的区别</strong></p><p><strong>Context</strong>表示一个应用，<strong>Tomcat中默认的配置下 webapps 下的每一个文件夹目录都是一个<code>Context</code></strong>，其中ROOT目录中存放着主应用，其他目录存放着子应用，而<strong>整个 webapps 就是一个Host站点</strong>。</p><p>我们访问应用Context的时候，如果是<code>ROOT</code>下的则直接使用域名就可以访问，例如：<a href="http://www.ledouit.com" target="_blank" rel="noopener">www.ledouit.com</a>.</p><p>如果是Host（webapps）下的其他应用，则可以使用 <a href="http://www.ledouit.com/docs" target="_blank" rel="noopener">www.ledouit.com/docs</a> 进行访问，当然默认指定的根应用（ROOT）是可以进行设定的，只不过Host站点下默认的主应用是ROOT目录下的。</p><p>看到这里我们知道Container是什么，但是还是不知道Container是如何进行处理的以及处理完之后是如何将处理完的结果返回给Connector的？别急！下边就开始探讨一下Container是如何进行处理的！</p><h2 id="Container如何处理请求的"><a href="#Container如何处理请求的" class="headerlink" title="Container如何处理请求的"></a>Container如何处理请求的</h2><p>Container处理请求是使用 <strong>Pipeline-Valve</strong> 管道来处理的！（Valve是阀门之意）</p><p><strong>Pipeline-Valve</strong> 是<strong>责任链模式</strong>，责任链模式是指在一个请求处理的过程中有很多处理者依次对请求进行处理，每个处理者负责做自己相应的处理，处理完之后将处理后的请求返回，再让下一个处理着继续处理。但是！Pipeline-Valve使用的责任链模式和普通的责任链模式有些不同！区别主要有以下两点：</p><ul><li><p>每个Pipeline都有特定的Valve，而且是在管道的最后一个执行，这个Valve叫做 <strong>BaseValve</strong>，<strong>BaseValve是不可删除的</strong>；</p></li><li><p>在上层容器的管道的BaseValve中会调用下层容器的管道。</p></li></ul><p>我们知道 Container 包含四个子容器，而这四个子容器对应的 BaseValve 分别是：</p><blockquote><p><strong>StandardEngineValve</strong>、<strong>StandardHostValve</strong>、<strong>StandardContextValve</strong>、<strong>StandardWrapperValve</strong></p></blockquote><p>Pipeline的处理流程图如下（图D）：<br><img src="/images/tomcat_pipeline_valve.jpg" alt></p><p>（1）Connector在接收到请求后会首先调用最顶层容器的Pipeline来处理，这里的最顶层容器的Pipeline就是<strong>EnginePipeline</strong>（Engine的管道）；</p><p>（2）在Engine的管道中依次会执行EngineValve1、EngineValve2等等，最后会执行StandardEngineValve，在StandardEngineValve中会调用Host管道，然后再依次执行Host的HostValve1、HostValve2等，最后在执行StandardHostValve，然后再依次调用Context的管道和Wrapper的管道，最后执行到StandardWrapperValve。</p><p>（3）当执行到StandardWrapperValve的时候，会在 <strong>StandardWrapperValve中创建FilterChain</strong>，并调用其doFilter方法来处理请求，这个FilterChain包含着我们配置的与请求相匹配的Filter和Servlet，其<strong>doFilter方法会依次调用所有的Filter的doFilter方法和Servlet的service方法</strong>，这样请求就得到了处理！</p><p>（4）当所有的Pipeline-Valve都执行完之后，并且处理完了具体的请求，这个时候就可以将返回的结果交给Connector了，Connector在通过Socket的方式将结果返回给客户端。</p><h2 id="Servlet生命周期"><a href="#Servlet生命周期" class="headerlink" title="Servlet生命周期"></a>Servlet生命周期</h2><p><img src="/images/servlet_lifecycle.png" alt></p><h2 id="Tomcat优化"><a href="#Tomcat优化" class="headerlink" title="Tomcat优化"></a>Tomcat优化</h2><h3 id="硬件优化"><a href="#硬件优化" class="headerlink" title="硬件优化"></a>硬件优化</h3><p>单个服务器所能提供CPU、内存、硬盘的性能对处理能力有决定性影响，所以说服务器性能好，Tomcat也不会太差</p><h3 id="Tomcat本身优化"><a href="#Tomcat本身优化" class="headerlink" title="Tomcat本身优化"></a>Tomcat本身优化</h3><p>Tomcat 的自身参数的优化，这块很像 ApacheHttp Server。修改一下 xml 配置文件中的参数，调整最大连接数，超时等.</p><h4 id="Connector-连接器的配置"><a href="#Connector-连接器的配置" class="headerlink" title="Connector 连接器的配置"></a>Connector 连接器的配置</h4><p>Tomcat连接器的三种方式： <code>bio</code>、<code>nio</code> 和 <code>apr</code>，三种方式性能差别很大，<code>apr</code>的性能最优， <code>bio</code> 的性能最差。而 Tomcat 7 使用的 Connector  默认就启用的 Apr 协议，但需要系统安装 Apr 库，否则就会使用 bio 方式。</p><h4 id="配置文件优化"><a href="#配置文件优化" class="headerlink" title="配置文件优化"></a>配置文件优化</h4><p>配置文件优化其实就是对 <code>server.xml</code> 优化，可以提大大提高 Tomcat 的处理请求的能力，下面我们来看 Tomcat 容器内的优化。</p><p>默认配置下，Tomcat 会为每个连接器创建一个绑定的线程池（最大线程数 200），服务启动时，默认创建了 5 个空闲线程随时等待用户请求。</p><p>首先，打开 ${TOMCAT_HOME}/conf/server.xml，搜索【&lt;Executor name=”tomcatThreadPool”】，开启并调整为:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Executor</span> <span class="attr">name</span>=<span class="string">"tomcatThreadPool"</span> <span class="attr">namePrefix</span>=<span class="string">"catalina-exec-"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">maxThreads</span>=<span class="string">"500"</span> <span class="attr">minSpareThreads</span>=<span class="string">"20"</span> <span class="attr">maxSpareThreads</span>=<span class="string">"50"</span> <span class="attr">maxIdleTime</span>=<span class="string">"60000"</span>/&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>注意， Tomcat 7 在开启线程池前，一定要安装好 Apr 库，并可以启用，否则会有错误报出，shutdown.sh 脚本无法关闭进程。</p></blockquote><p>然后，修改&lt;Connector …&gt;节点，增加 executor 属性，搜索【port=”8080”】，调整为:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">executor</span>=<span class="string">"tomcatThreadPool"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">port</span>=<span class="string">"8080"</span> <span class="attr">protocol</span>=<span class="string">"HTTP/1.1"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">URIEncoding</span>=<span class="string">"UTF-8"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">connectionTimeout</span>=<span class="string">"30000"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">enableLookups</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">disableUploadTimeout</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">connectionUploadTimeout</span>=<span class="string">"150000"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">acceptCount</span>=<span class="string">"300"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">keepAliveTimeout</span>=<span class="string">"120000"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">maxKeepAliveRequests</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">compression</span>=<span class="string">"on"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">compressionMinSize</span>=<span class="string">"2048"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">compressableMimeType</span>=<span class="string">"text/html,text/xml,text/javascript,text/css,text/plain,image/gif,image/jpg,image/png"</span> </span></span><br><span class="line"><span class="tag">           <span class="attr">redirectPort</span>=<span class="string">"8443"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><p><strong>maxThreads</strong> : Tomcat使用线程来处理接收的每个请求，这个值表示 Tomcat 可创建的最大的线程数，默认值是 200</p></li><li><p><strong>minSpareThreads</strong>：最小空闲线程数，Tomcat 启动时的初始化的线程数，表示即使没有人使用也开这么多空线程等待，默认值是 10。</p></li><li><p><strong>maxSpareThreads</strong>：最大备用线程数，一旦创建的线程超过这个值，Tomcat 就会关闭不再需要的 socket 线程。</p></li></ul><p>上边配置的参数，最大线程 500（一般服务器足以），要根据自己的实际情况合理设置，设置越大会耗费内存和 CPU，因为 CPU 疲于线程上下文切换，没有精力提供请求服务了，最小空闲线程数 20，线程最大空闲时间 60 秒，当然允许的最大线程连接数还受制于操作系统的内核参数设置，设置多大要根据自己的需求与环境。当然<strong>线程可以配置在“tomcatThreadPool”中，也可以直接配置在“Connector”中，但不可以重复配置</strong>。</p><ul><li><p><strong>URIEncoding</strong>：指定 Tomcat 容器的 URL 编码格式，语言编码格式这块倒不如其它 WEB 服务器软件配置方便，需要分别指定。</p></li><li><p><strong>connnectionTimeout</strong>： 网络连接超时，单位：毫秒，设置为 0 表示永不超时，这样设置有隐患的。通常可设置为 30000 毫秒，可根据检测实际情况，适当修改。</p></li><li><p><strong>enableLookups</strong>： 是否反查域名，以返回远程主机的主机名，取值为：true 或 false，如果设置为false，则直接返回IP地址，为了提高处理能力，应设置为 false。</p></li><li><p><strong>disableUploadTimeout</strong>：上传时是否使用超时机制。</p></li><li><p><strong>connectionUploadTimeout</strong>：上传超时时间，毕竟文件上传可能需要消耗更多的时间，这个根据你自己的业务需要自己调，以使Servlet有较长的时间来完成它的执行，需要与上一个参数一起配合使用才会生效。</p></li><li><p><strong>acceptCount</strong>：指定当所有可以使用的处理请求的线程数都被使用时，可传入连接请求的最大队列长度，超过这个数的请求将不予处理，默认为100个。</p></li><li><p><strong>keepAliveTimeout</strong>：长连接最大保持时间（毫秒），表示在下次请求过来之前，Tomcat保持该连接多久，默认是使用 connectionTimeout 时间，-1 为不限制超时。</p></li><li><p><strong>maxKeepAliveRequests</strong>：表示在服务器关闭之前，该连接最大支持的请求数。超过该请求数的连接也将被关闭，1表示禁用，-1表示不限制个数，默认100个，一般设置在100~200之间。</p></li><li><p><strong>compression</strong>：是否对响应的数据进行 GZIP 压缩，off：表示禁止压缩；on：表示允许压缩（文本将被压缩）、force：表示所有情况下都进行压缩，默认值为off，压缩数据后可以有效的减少页面的大小，一般可以减小1/3左右，节省带宽。</p></li><li><p><strong>compressionMinSize</strong>：表示压缩响应的最小值，只有当响应报文大小大于这个值的时候才会对报文进行压缩，如果开启了压缩功能，默认值就是2048。</p></li><li><p><strong>compressableMimeType</strong>：压缩类型，指定对哪些类型的文件进行数据压缩。</p></li><li><p><strong>noCompressionUserAgents</strong>=”gozilla, traviata”： 对于以下的浏览器，不启用压缩。</p></li></ul><p><strong>如果已经对代码进行了动静分离，静态页面和图片等数据就不需要Tomcat处理了，那么也就不需要配置在 Tomcat 中配置压缩了。</strong></p><p>以上是一些常用的配置参数属性，当然还有好多其它的参数设置，还可以继续深入的优化，HTTP Connector 与 AJP Connector 的参数属性值，可以参考官方文档的详细说明：<br><a href="https://tomcat.apache.org/tomcat-7.0-doc/config/http.html" target="_blank" rel="noopener">https://tomcat.apache.org/tomcat-7.0-doc/config/http.html</a></p><h4 id="禁用AJP连接器"><a href="#禁用AJP连接器" class="headerlink" title="禁用AJP连接器"></a>禁用AJP连接器</h4><p>AJP（Apache JServer Protocol）AJPv13协议是面向包的。WEB服务器和Servlet容器通过TCP连接来交互；为了节省SOCKET创建的昂贵代价，WEB服务器会尝试维护一个永久TCP连接到servlet容器，并且在多个请求和响应周期过程会重用连接。如图:<br><img src="/images/tomcat_aij.png" alt><br>在Nginx+tomcat的架构中，禁用AJP连接器：<br><img src="/images/forbidden_aij.png" alt></p><h3 id="JVM优化"><a href="#JVM优化" class="headerlink" title="JVM优化"></a>JVM优化</h3><p>根据服务器物理内容情况配置相关参数优化tomcat性能。</p><p>当应用程序需要的内存超出堆的最大值时虚拟机就会提示内存溢出，并且导致应用服务崩溃。因此一般建议堆的最大值设置为可用内存的最大值的80%。 Tomcat默认可以使用的内存为128MB，在较大型的应用项目中，这点内存是不够的，需要调大.</p><p>Unix下，在文件/bin/catalina.sh的前面，增加如下设置： </p><blockquote><p>JAVA_OPTS=’-Xms【初始化内存大小】 -Xmx【可以使用的最大内存】 -XX:PermSize=64M -XX:MaxPermSize=128m’</p></blockquote><p>需要把几个参数值调大。例如： <code>JAVA_OPTS=’-Xms256m -Xmx512m’</code> 表示初始化内存为256MB，可以使用的最大内存为512MB。</p><p>参数详解:   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-server  启用jdk 的 server 版；</span><br><span class="line">-Xms    java虚拟机初始化时的最小内存；</span><br><span class="line">-Xmx    java虚拟机可使用的最大内存；</span><br><span class="line">-XX:PermSize    内存永久代保留区域</span><br><span class="line">-XX:MaxPermSize   内存最大永久代保留区域 </span><br><span class="line">-Xmn    jvm最小内存</span><br></pre></td></tr></table></figure><p>原文链接： <a href="https://blog.csdn.net/xlgen157387/article/details/79006434" target="_blank" rel="noopener">四张图带你了解Tomcat系统架构–让面试官颤抖的Tomcat回答系列</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Tomcat顶层架构&quot;&gt;&lt;a href=&quot;#Tomcat顶层架构&quot; class=&quot;headerlink&quot; title=&quot;Tomcat顶层架构&quot;&gt;&lt;/a&gt;Tomcat顶层架构&lt;/h2&gt;&lt;p&gt;先上一张Tomcat的顶层结构图，如下&lt;br&gt;&lt;img src=&quot;/imag
      
    
    </summary>
    
      <category term="Web" scheme="http://yoursite.com/categories/Web/"/>
    
      <category term="Tomcat" scheme="http://yoursite.com/categories/Web/Tomcat/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Web" scheme="http://yoursite.com/tags/Web/"/>
    
      <category term="Tomcat" scheme="http://yoursite.com/tags/Tomcat/"/>
    
  </entry>
  
  <entry>
    <title>Java动态代理</title>
    <link href="http://yoursite.com/2019/11/29/Java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    <id>http://yoursite.com/2019/11/29/Java动态代理/</id>
    <published>2019-11-29T09:04:34.000Z</published>
    <updated>2019-11-29T09:13:55.882Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是代理"><a href="#什么是代理" class="headerlink" title="什么是代理"></a>什么是代理</h2><p>我们大家都知道微商代理，简单地说就是代替厂家卖商品，厂家“委托”代理为其销售商品。关于微商代理，首先我们从他们那里买东西时通常不知道背后的厂家究竟是谁，也就是说，“委托者”对我们来说是不可见的;其次，微商代理主要以朋友圈的人为目标客户，这就相当于为厂家做了一次对客户群体的“过滤”。我们把微商代理和厂家进一步抽象，前者可抽象为代理类，后者可抽象为委托类(被代理类)。通过使用代理，通常有两个优点，并且能够分别与我们提到的微商代理的两个特点对应起来：</p><ul><li><p>优点一：可以隐藏委托类的实现;</p></li><li><p>优点二：可以实现客户与委托类间的解耦，在不修改委托类代码的情况下能够做一些额外的处理。</p></li></ul><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>代理模式：给某一个对象提供一个代理，并由代理对象来控制对真实对象的访问。代理模式是一种结构型设计模式。</p><p>代理模式角色分为 3 种：</p><ul><li><p>Subject（抽象主题角色）：定义代理类和真实主题的公共对外方法，也是代理类代理真实主题的方法；</p></li><li><p>RealSubject（真实主题角色）：真正实现业务逻辑的类；</p></li><li><p>Proxy（代理主题角色）：用来代理和封装真实主题；</p></li></ul><p>代理模式的结构比较简单，其核心是代理类，为了让客户端能够一致性地对待真实对象和代理对象，在代理模式中引入了抽象层</p><p><img src="/images/proxy_model_dynamic.png" alt></p><p>如果根据字节码的创建时机来分类，可以分为静态代理和动态代理：</p><ul><li><p>静态代理<br>就是在程序运行前就已经存在代理类的字节码文件，代理类和真实主题角色的关系在运行前就确定了。</p></li><li><p>动态代理<br>源码是在程序运行期间由JVM根据反射等机制动态的生成，所以在运行前并不存在代理类的字节码文件。</p></li></ul><h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><p>我们先通过实例来学习静态代理，然后理解静态代理的缺点，再来学习本文的主角：动态代理</p><p>编写一个接口 UserService ，以及该接口的一个实现类 UserServiceImpl：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">()</span></span>;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"查询 selectById"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"更新 update"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将通过静态代理对 UserServiceImpl 进行功能增强，在调用 select 和 update 之前记录一些日志。写一个代理类 UserServiceProxy，代理类需要实现 UserService</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceProxy</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> UserService target; <span class="comment">// 被代理的对象</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserServiceProxy</span><span class="params">(UserService target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        before();</span><br><span class="line">        target.select();    <span class="comment">// 这里才实际调用真实主题角色的方法</span></span><br><span class="line">        after();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        before();</span><br><span class="line">        target.update();    <span class="comment">// 这里才实际调用真实主题角色的方法</span></span><br><span class="line">        after();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;     <span class="comment">// 在执行方法之前执行</span></span><br><span class="line">        System.out.printf(<span class="string">"log start time [%s] \n"</span>, <span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;      <span class="comment">// 在执行方法之后执行</span></span><br><span class="line">        System.out.printf(<span class="string">"log end time [%s] \n"</span>, <span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        UserService userServiceImpl = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line">        UserService proxy = <span class="keyword">new</span> UserServiceProxy(userServiceImpl);</span><br><span class="line"></span><br><span class="line">        proxy.select();</span><br><span class="line">        proxy.update();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">log start time [Thu Dec 20 14:13:25 CST 2018] </span><br><span class="line">查询 selectById</span><br><span class="line">log end time [Thu Dec 20 14:13:25 CST 2018] </span><br><span class="line">log start time [Thu Dec 20 14:13:25 CST 2018] </span><br><span class="line">更新 update</span><br><span class="line">log end time [Thu Dec 20 14:13:25 CST 2018]</span><br></pre></td></tr></table></figure><p>通过静态代理，我们达到了功能增强的目的，而且没有侵入原代码，这是静态代理的一个优点。</p><h3 id="静态代理缺点"><a href="#静态代理缺点" class="headerlink" title="静态代理缺点"></a>静态代理缺点</h3><p>虽然静态代理实现简单，且不侵入原代码，但是，当场景稍微复杂一些的时候，静态代理的缺点也会暴露出来。</p><ul><li><p>1、 当需要代理多个类的时候，由于代理对象要实现与目标对象一致的接口，有两种方式：</p><ul><li><p>只维护一个代理类，由这个代理类实现多个接口，但是这样就导致<strong>代理类过于庞大</strong>;</p></li><li><p>新建多个代理类，每个目标对象对应一个代理类，但是这样会<strong>产生过多的代理类</strong>;</p></li></ul></li><li><p>2、 当接口需要增加、删除、修改方法的时候，目标对象与代理类都要同时修改，<strong>不易维护</strong>。</p></li></ul><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><h3 id="生成原理"><a href="#生成原理" class="headerlink" title="生成原理"></a>生成原理</h3><p>Java虚拟机类加载过程主要分为五个阶段：<code>加载</code>、<code>验证</code>、<code>准备</code>、<code>解析</code>、`初始化。其中加载阶段需要完成以下3件事情：</p><ul><li><p>通过一个类的全限定名来获取定义此类的二进制字节流</p></li><li><p>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</p></li><li><p>在内存中生成一个代表这个类的 <code>java.lang.Class</code> 对象，作为方法区这个类的各种数据访问入口</p></li></ul><p>由于虚拟机规范对这3点要求并不具体，所以实际的实现是非常灵活的，关于第1点，获取类的二进制字节流（class字节码）就有很多途径：</p><ul><li><p>从ZIP包获取，这是JAR、EAR、WAR等格式的基础</p></li><li><p>从网络中获取，典型的应用是 Applet</p></li><li><p>运行时计算生成，这种场景使用最多的是<strong>动态代理技术</strong>，在 <code>java.lang.reflect.Proxy</code> 类中，就是用了 <code>ProxyGenerator.generateProxyClass</code>来为特定接口生成形式为 <code>*$Proxy</code> 的代理类的二进制字节流</p></li><li><p>由其它文件生成，典型应用是JSP，即由JSP文件生成对应的Class类</p></li><li><p>从数据库中获取等等</p></li></ul><p>所以，动态代理就是想办法，根据接口或目标对象，计算出代理类的字节码，然后再加载到JVM中使用。但是如何计算？如何生成？情况也许比想象的复杂得多，我们需要借助现有的方案。</p><h3 id="常见的字节码操作类库"><a href="#常见的字节码操作类库" class="headerlink" title="常见的字节码操作类库"></a>常见的字节码操作类库</h3><blockquote><p>这里有一些介绍：java-source.net/open-source…</p></blockquote><ul><li><p>Apache BCEL (Byte Code Engineering Library)：是Java classworking广泛使用的一种框架，它可以深入到JVM汇编语言进行类操作的细节。</p></li><li><p>ObjectWeb ASM：是一个Java字节码操作框架。它可以用于直接以二进制形式动态生成stub根类或其他代理类，或者在加载时动态修改类。</p></li><li><p>CGLIB(Code Generation Library)：是一个功能强大，高性能和高质量的代码生成库，用于扩展JAVA类并在运行时实现接口。</p></li><li><p>Javassist：是Java的加载时反射系统，它是一个用于在Java中编辑字节码的类库; 它使Java程序能够在运行时定义新类，并在JVM加载之前修改类文件。 </p></li></ul><p>为了让生成的代理类与目标对象（真实主题角色）保持一致性，从现在开始将介绍以下两种最常见的方式：</p><blockquote><p>通过实现接口的方式 -&gt; JDK动态代理<br>通过继承类的方式 -&gt; CGLIB动态代理</p></blockquote><p>注：使用ASM对使用者要求比较高，使用Javassist会比较麻烦</p><h3 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h3><p>JDK动态代理主要涉及两个类：<code>java.lang.reflect.Proxy</code> 和<code>java.lang.reflect.InvocationHandler</code>，我们仍然通过案例来学习.</p><p>编写一个调用逻辑处理器 LogHandler 类，提供日志增强功能，并实现 InvocationHandler 接口；在 LogHandler 中维护一个目标对象，这个对象是被代理的对象（真实主题角色）；在 invoke 方法中编写方法调用的逻辑处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    Object target;  <span class="comment">// 被代理的对象，实际的方法执行者</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LogHandler</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        before();</span><br><span class="line">        <span class="comment">// 调用 target 的 method 方法</span></span><br><span class="line">        Object result = method.invoke(target, args);  </span><br><span class="line">        after();</span><br><span class="line">        <span class="keyword">return</span> result;  <span class="comment">// 返回方法的执行结果</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用invoke方法之前执行</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">"log start time [%s] \n"</span>, <span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用invoke方法之后执行</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">"log end time [%s] \n"</span>, <span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写客户端，获取动态生成的代理类的对象须借助 Proxy 类的 newProxyInstance 方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> proxy.UserService;</span><br><span class="line"><span class="keyword">import</span> proxy.UserServiceImpl;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserClientJdkDynamic</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IllegalAccessException, InstantiationException </span>&#123;</span><br><span class="line">        <span class="comment">// 设置变量可以保存动态代理类，默认名称以 $Proxy0 格式命名</span></span><br><span class="line">        <span class="comment">// System.getProperties().setProperty("sun.misc.ProxyGenerator.saveGeneratedFiles", "true");</span></span><br><span class="line">        <span class="comment">// 1. 创建被代理的对象，UserService接口的实现类</span></span><br><span class="line">        UserServiceImpl userServiceImpl = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 获取对应的 ClassLoader</span></span><br><span class="line">        ClassLoader classLoader = userServiceImpl.getClass().getClassLoader();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 获取所有接口的Class，这里的UserServiceImpl只实现了一个接口UserService，</span></span><br><span class="line">        Class[] interfaces = userServiceImpl.getClass().getInterfaces();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 4. 创建一个将传给代理类的调用请求处理器，处理所有的代理对象上的方法调用</span></span><br><span class="line">        <span class="comment">//     这里创建的是一个自定义的日志处理器，须传入实际的执行对象 userServiceImpl</span></span><br><span class="line">        InvocationHandler logHandler = <span class="keyword">new</span> LogHandler(userServiceImpl);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">   5.根据上面提供的信息，创建代理对象 在这个过程中，</span></span><br><span class="line"><span class="comment">               a.JDK会通过根据传入的参数信息动态地在内存中创建和.class 文件等同的字节码</span></span><br><span class="line"><span class="comment">               b.然后根据相应的字节码转换成对应的class，</span></span><br><span class="line"><span class="comment">               c.然后调用newInstance()创建代理实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">        UserService proxy = (UserService) Proxy.newProxyInstance(classLoader, interfaces, logHandler);</span><br><span class="line">        <span class="comment">// 调用代理的方法</span></span><br><span class="line">        proxy.select();</span><br><span class="line">        proxy.update();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 6. 保存JDK动态代理生成的代理类，类名保存为 UserServiceProxy</span></span><br><span class="line">        ProxyUtils.generateClassFile(userServiceImpl.getClass(), <span class="string">"UserServiceProxy2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">log start time [Thu Dec 20 16:55:19 CST 2018] </span><br><span class="line">查询 selectById</span><br><span class="line">log end time [Thu Dec 20 16:55:19 CST 2018] </span><br><span class="line">log start time [Thu Dec 20 16:55:19 CST 2018] </span><br><span class="line">更新 update</span><br><span class="line">log end time [Thu Dec 20 16:55:19 CST 2018]</span><br></pre></td></tr></table></figure><h4 id="InvocationHandler和Proxy核心方法介绍"><a href="#InvocationHandler和Proxy核心方法介绍" class="headerlink" title="InvocationHandler和Proxy核心方法介绍"></a>InvocationHandler和Proxy核心方法介绍</h4><h5 id="java-lang-reflect-InvocationHandler"><a href="#java-lang-reflect-InvocationHandler" class="headerlink" title="java.lang.reflect.InvocationHandler"></a>java.lang.reflect.InvocationHandler</h5><p><code>Object invoke(Object proxy, Method method, Object[] args)</code>  定义了代理对象调用方法时希望执行的动作，用于集中处理在动态代理类对象上的方法调用</p><h5 id="java-lang-reflect-Proxy"><a href="#java-lang-reflect-Proxy" class="headerlink" title="java.lang.reflect.Proxy"></a>java.lang.reflect.Proxy</h5><p><code>static InvocationHandler getInvocationHandler(Object proxy)</code>  用于获取指定代理对象所关联的调用处理器</p><p><code>static Class&lt;?&gt; getProxyClass(ClassLoader loader, Class&lt;?&gt;... interfaces)</code> 返回指定接口的代理类</p><p><code>static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</code>   构造实现指定接口的代理类的一个新实例，所有方法会调用给定处理器对象的 invoke 方法</p><p><code>static boolean isProxyClass(Class&lt;?&gt; cl)</code>  返回 cl 是否为一个代理类</p><h4 id="代理类"><a href="#代理类" class="headerlink" title="代理类"></a>代理类</h4><p>JDK自动生成的代理类到底长什么样子呢？借助上面第6步操作，可以把代理类保存下来一探究竟， target 的类路径下找到 UserServiceProxy2.class，双击后IDEA的反编译插件会将该二进制class文件转变成java文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line"><span class="keyword">import</span> proxy.UserService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceProxy2</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m4;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserServiceProxy2</span><span class="params">(InvocationHandler var1)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object var1)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="comment">// 省略...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="comment">// 省略...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m4, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="comment">// 省略...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m3, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            m1 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"equals"</span>, Class.forName(<span class="string">"java.lang.Object"</span>));</span><br><span class="line">            m2 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"toString"</span>);</span><br><span class="line">            m4 = Class.forName(<span class="string">"proxy.UserService"</span>).getMethod(<span class="string">"select"</span>);</span><br><span class="line">            m0 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"hashCode"</span>);</span><br><span class="line">            m3 = Class.forName(<span class="string">"proxy.UserService"</span>).getMethod(<span class="string">"update"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError(var2.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoClassDefFoundError(var3.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 UserServiceProxy 的代码中我们可以发现：</p><ul><li><p><code>UserServiceProxy2</code> 继承了 <code>Proxy</code> 类，并且实现了被代理的所有接口，以及equals、hashCode、toString等方法</p></li><li><p>由于<code>UserServiceProxy2</code>继承了 <code>Proxy</code> 类，所以每个代理类都会关联一个 <code>InvocationHandler</code> 方法调用处理器</p></li><li><p>类和所有方法都被 <code>public final</code> 修饰，所以代理类只可被使用，不可以再被继承</p></li><li><p>每个方法都有一个 <code>Method</code> 对象来描述，<code>Method</code> 对象在<code>static</code>静态代码块中创建，以 <code>m+</code> 数字 的格式命名</p></li><li><p>调用方法的时候通过 <code>super.h.invoke(this, m1, (Object[])null)</code> 调用，其中的 <code>super.h.invoke</code> 实际上是在创建代理的时候传递给 <code>Proxy.newProxyInstance</code> 的 <code>LogHandler</code> 对象，它继承 <code>InvocationHandler</code> 类，负责实际的调用处理逻辑</p></li></ul><p>而 LogHandler 的 invoke 方法接收到 method、args 等参数后，进行一些处理，然后通过反射让被代理的对象 target 执行方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    before();</span><br><span class="line">    <span class="comment">// 调用 target 的 method 方法</span></span><br><span class="line">    Object result = method.invoke(target, args);            </span><br><span class="line">    after();</span><br><span class="line">    <span class="keyword">return</span> result;  <span class="comment">// 返回方法的执行结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JDK动态代理执行方法调用的过程简图如下：</p><p><img src="/images/dynamic_process.png" alt></p><h3 id="CGLIB动态代理"><a href="#CGLIB动态代理" class="headerlink" title="CGLIB动态代理"></a>CGLIB动态代理</h3><p>maven引入CGLIB包，然后编写一个UserDao类，它没有接口，只有两个方法，select() 和 update()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"UserDao 查询 selectById"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"UserDao 更新 update"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写一个 LogInterceptor ，继承了 MethodInterceptor，用于方法的拦截回调</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object target;  <span class="comment">//目标类</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LogInterceptor</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回代理对象</span></span><br><span class="line"><span class="comment">     * 具体实现，暂时先不追究。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">createProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);  <span class="comment">// 回调函数  拦截器</span></span><br><span class="line">        <span class="comment">// 设置代理对象的父类,可以看到代理对象是目标对象的子类。所以这个接口类就可以省略了</span></span><br><span class="line">        enhancer.setSuperclass(<span class="keyword">this</span>.target.getClass());</span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> object      表示要进行增强的对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method      表示拦截的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> objects     数组表示参数列表，基本数据类型需要传入其包装类型，如int--&gt;Integer、long-Long、double--&gt;Double</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> methodProxy 表示对方法的代理，invokeSuper方法表示对被代理对象方法的调用</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 执行结果</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object object, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        before();</span><br><span class="line">        <span class="comment">// 注意这里是调用 invokeSuper 而不是 invoke，否则死循环，</span></span><br><span class="line">        <span class="comment">// methodProxy.invokesuper执行的是原始类的方法，method.invoke执行的是子类的方法</span></span><br><span class="line">        Object result = methodProxy.invokeSuper(object, objects);</span><br><span class="line">        after();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(String.format(<span class="string">"log start time [%s] "</span>, <span class="keyword">new</span> Date()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(String.format(<span class="string">"log end time [%s] "</span>, <span class="keyword">new</span> Date()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//目标对象</span></span><br><span class="line">        UserDao userDao = <span class="keyword">new</span> UserDao();</span><br><span class="line">        LogInterceptor interceptor = <span class="keyword">new</span> LogInterceptor(userDao);</span><br><span class="line">        <span class="comment">// 代理对象，调用cglib系统方法自动生成</span></span><br><span class="line">        <span class="comment">// 注意：代理类是目标类的子类。</span></span><br><span class="line">        UserDao proxy = (UserDao) interceptor.createProxy();</span><br><span class="line">        proxy.select();</span><br><span class="line">        proxy.update();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">log start time [Fri Nov 29 10:51:17 CST 2019] </span><br><span class="line">UserDao 查询 selectById</span><br><span class="line">log end time [Fri Nov 29 10:51:17 CST 2019] </span><br><span class="line">log start time [Fri Nov 29 10:51:17 CST 2019] </span><br><span class="line">UserDao 更新 update</span><br><span class="line">log end time [Fri Nov 29 10:51:17 CST 2019]</span><br></pre></td></tr></table></figure><p><strong>CGLIB 创建动态代理类的模式是：</strong></p><ul><li><p>查找目标类上的所有非final 的public类型的方法定义；</p></li><li><p>将这些方法的定义转换成字节码；</p></li><li><p>将组成的字节码转换成相应的代理的class对象；</p></li><li><p>实现 <code>MethodInterceptor</code> 接口，用来处理对代理类上所有方法的请求</p></li></ul><h3 id="JDK与CGLIB动态代理对比"><a href="#JDK与CGLIB动态代理对比" class="headerlink" title="JDK与CGLIB动态代理对比"></a>JDK与CGLIB动态代理对比</h3><ul><li><p>JDK动态代理：基于<font color="red">Java反射机制</font>实现，必须要<font color="red">实现了接口</font>的业务类才能用这种办法生成代理对象。</p></li><li><p>Cglib动态代理：基于<font color="red">ASM机制</font>实现，通过<font color="red">生成业务类的子类</font>作为代理类。</p></li></ul><p><strong>JDK动态代理优势</strong></p><ul><li><p>最小化依赖关系，减少依赖意味着简化开发和维护，JDK 本身的支持，可能比 cglib 更加可靠。</p></li><li><p>平滑进行 JDK 版本升级，而字节码类库通常需要进行更新以保证在新版 Java 上能够使用。</p></li><li><p>代码实现简单。</p></li></ul><p><strong>基于类似 cglib 框架的优势</strong></p><ul><li>无需实现接口，达到代理类无侵入</li><li>只操作我们关心的类，而不必为其他相关类增加工作量。</li><li>高性能</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://juejin.im/post/5c1ca8df6fb9a049b347f55c" target="_blank" rel="noopener">Java 动态代理详解</a></p><p>[2] <a href="https://juejin.im/post/5ad3e6b36fb9a028ba1fee6a" target="_blank" rel="noopener">Java动态代理</a></p><p>[3] <a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&mid=2247483785&idx=1&sn=f696c8c49cb7ecce9818247683482a1c&chksm=e9c2ed84deb564925172b2dd78d307d4dc345fa313d3e44f01e84fa22ac5561b37aec5cbd5b4&scene=0#rd" target="_blank" rel="noopener">Java反射机制详解</a></p><p>[4] <a href="https://blog.csdn.net/lovejj1994/article/details/78080124" target="_blank" rel="noopener">从代理模式再出发！Proxy.newProxyInstance的秘密</a></p><p>[5] <a href="https://blog.csdn.net/yhl_jxy/article/details/80586785" target="_blank" rel="noopener">JDK动态代理实现原理(jdk8)</a></p><h2 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h2><p>文中代码： <a href="https://github.com/austin-brant/dynamic-proxy-demo" target="_blank" rel="noopener">https://github.com/austin-brant/dynamic-proxy-demo</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是代理&quot;&gt;&lt;a href=&quot;#什么是代理&quot; class=&quot;headerlink&quot; title=&quot;什么是代理&quot;&gt;&lt;/a&gt;什么是代理&lt;/h2&gt;&lt;p&gt;我们大家都知道微商代理，简单地说就是代替厂家卖商品，厂家“委托”代理为其销售商品。关于微商代理，首先我们从他们那里买
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
      <category term="基础" scheme="http://yoursite.com/categories/Java/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="基础" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>布隆过滤器(Bloom Filter)</title>
    <link href="http://yoursite.com/2019/11/27/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8-Bloom-Filter/"/>
    <id>http://yoursite.com/2019/11/27/布隆过滤器-Bloom-Filter/</id>
    <published>2019-11-27T02:35:39.000Z</published>
    <updated>2019-11-29T09:27:20.987Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>布隆过滤器（英语：Bloom Filter）是1970年由一个叫布隆的小伙子提出的。它实际上是一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。</p><ul><li>优点： 空间效率和查询时间都远远超过一般的算法</li><li>缺点： 有一定的误识别率和删除困难。</li></ul><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>布隆过滤器的原理是，当一个元素被加入集合时，通过 <code>K</code> 个散列函数将这个元素映射成一个位数组中的 <code>K</code> 个点，把它们置为1。检索时，我们只要看看这些点是不是都是1就（大约）知道集合中有没有它了：</p><ul><li>如果这些点有任何一个0，则被检元素一定不在；</li><li>如果都是1，则被检元素很可能在</li></ul><p>这就是布隆过滤器的基本思想。</p><p>Bloom Filter跟单哈希函数Bit-Map不同之处在于：<strong>Bloom Filter使用了k个哈希函数，每个字符串跟k个bit对应</strong>。从而降低了冲突的概率。<br><img src="/images/bloom_theory.jpg" alt></p><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p><img src="/images/cache_strike.jpg" alt></p><blockquote><p>每次查询都会直接打到DB</p></blockquote><p>简而言之，言而简之就是我们先把我们数据库的数据都加载到我们的过滤器中，比如数据库的id现在有：1、2、3</p><p>那就用id：1 为例子, 他在上图中经过三次hash之后，把三次原本值0的地方改为1<br>下次数据进来查询的时候如果id的值是1，那么我就把1拿去三次hash 发现三次hash的值，跟上面的三个位置完全一样，那就能证明过滤器中有1的, 反之如果不一样就说明不存在了</p><p>那应用的场景在哪里呢？一般我们都会用来<strong>防止缓存击穿</strong></p><p>简单来说就是你数据库的id都是1开始然后自增的，那我知道你接口是通过id查询的，我就拿负数去查询，这个时候，会发现缓存里面没这个数据，我又去数据库查也没有，一个请求这样，100个，1000个，10000个呢？你的DB基本上就扛不住了，如果在缓存里面加上这个，是不是就不存在了，你判断没这个数据就不去查了，直接return一个数据为空不就好了嘛。</p><h2 id="Bloom-Filter缺点"><a href="#Bloom-Filter缺点" class="headerlink" title="Bloom Filter缺点"></a>Bloom Filter缺点</h2><p>bloom filter之所以能做到在时间和空间上的效率比较高，是因为<strong>牺牲了判断的准确率、删除的便利性</strong></p><ul><li><p>存在误判，可能要查到的元素并没有在容器中，但是hash之后得到的k个位置上值都是1。如果bloom filter中存储的是黑名单，那么可以通过建立一个白名单来存储可能会误判的元素。</p></li><li><p>删除困难。一个放入容器的元素映射到bit数组的k个位置上是1，删除的时候不能简单的直接置为0，可能会影响其他元素的判断。可以采用<a href="http://wiki.corp.qunar.com/confluence/download/attachments/199003276/US9740797.pdf?version=1&modificationDate=1526538500000&api=v2" target="_blank" rel="noopener">Counting Bloom Filter</a></p></li></ul><h2 id="Guava本地实现"><a href="#Guava本地实现" class="headerlink" title="Guava本地实现"></a>Guava本地实现</h2><p>布隆过滤器有许多实现与优化，<code>Guava</code>中就提供了一种<code>Bloom Filter</code>的实现。</p><ul><li><p>在<strong>使用</strong>bloom filter时，绕不过的两点是<font color="red"><strong>预估数据量n</strong></font> 以及 <font color="red"><strong>期望的误判率fpp</strong></font>，</p></li><li><p>在实现bloom filter时，绕不过的两点就是<font color="red"><strong>hash函数的选取</strong></font> 以及 <font color="red"><strong>bit数组的大小</strong></font>。</p></li></ul><p>对于一个确定的场景，我们预估要存的数据量为n，期望的误判率为fpp，然后需要计算我们需要的Bit数组的大小m，以及hash函数的个数k，并选择hash函数</p><h3 id="Bit数组大小选择"><a href="#Bit数组大小选择" class="headerlink" title="Bit数组大小选择"></a>Bit数组大小选择</h3><p>根据预估数据量n以及误判率fpp，bit数组大小的m的计算方式：<br><img src="/images/bloom_array_calculate.jpg" alt="-w665"></p><h3 id="哈希函数选择"><a href="#哈希函数选择" class="headerlink" title="哈希函数选择"></a>哈希函数选择</h3><p>​由预估数据量n以及bit数组长度m，可以得到一个hash函数的个数k：<br>​<br>​<img src="/images/bloom_hash_num.jpg" alt><br>​<br>​哈希函数的选择对性能的影响应该是很大的，一个好的哈希函数要能<strong>近似等概率的将字符串映射到各个Bit</strong>。选择k个不同的哈希函数比较麻烦，一种简单的方法是选择一个哈希函数，然后送入k个不同的参数。</p><p>哈希函数个数k、位数组大小m、加入的字符串数量n的关系可以参考<a href="http://pages.cs.wisc.edu/~cao/papers/summary-cache/node8.html" target="_blank" rel="noopener">Bloom Filters - the math，Bloom_filter-wikipedia</a></p><p>要使用BloomFilter，需要引入guava包：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;com.google.guava&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;guava&lt;/artifactId&gt;</span><br><span class="line">           &lt;version&gt;23.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>测试分两步：</p><p>1、往过滤器中放一百万个数，然后去验证这一百万个数是否能通过过滤器</p><p>2、另外找一万个数，去检验漏网之鱼的数量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试布隆过滤器(可用于redis缓存穿透)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 敖丙</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBloomFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> total = <span class="number">1000000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> BloomFilter&lt;Integer&gt; bf = BloomFilter.create(Funnels.integerFunnel(), total);</span><br><span class="line"><span class="comment">//    private static BloomFilter&lt;Integer&gt; bf = BloomFilter.create(Funnels.integerFunnel(), total, 0.001);</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化1000000条数据到过滤器中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; total; i++) &#123;</span><br><span class="line">            bf.put(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 匹配已在过滤器中的值，是否有匹配不上的</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; total; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!bf.mightContain(i)) &#123;</span><br><span class="line">                System.out.println(<span class="string">"有坏人逃脱了~~~"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 匹配不在过滤器中的10000个值，有多少匹配出来</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = total; i &lt; total + <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bf.mightContain(i)) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"误伤的数量："</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/images/bloom_320.jpg" alt></p><p>运行结果表示，遍历这一百万个在过滤器中的数时，都被识别出来了。一万个不在过滤器中的数，误伤了320个，错误率是0.03左右。</p><p>看下BloomFilter的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">BloomFilter&lt;T&gt; <span class="title">create</span><span class="params">(Funnel&lt;? <span class="keyword">super</span> T&gt; funnel, <span class="keyword">int</span> expectedInsertions)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> create(funnel, (<span class="keyword">long</span>) expectedInsertions);</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">BloomFilter&lt;T&gt; <span class="title">create</span><span class="params">(Funnel&lt;? <span class="keyword">super</span> T&gt; funnel, <span class="keyword">long</span> expectedInsertions)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> create(funnel, expectedInsertions, <span class="number">0.03</span>); <span class="comment">// FYI, for 3%, we always get 5 hash functions</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">BloomFilter&lt;T&gt; <span class="title">create</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      Funnel&lt;? <span class="keyword">super</span> T&gt; funnel, <span class="keyword">long</span> expectedInsertions, <span class="keyword">double</span> fpp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> create(funnel, expectedInsertions, fpp, BloomFilterStrategies.MURMUR128_MITZ_64);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &lt;T&gt; <span class="function">BloomFilter&lt;T&gt; <span class="title">create</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  Funnel&lt;? <span class="keyword">super</span> T&gt; funnel, <span class="keyword">long</span> expectedInsertions, <span class="keyword">double</span> fpp, Strategy strategy)</span> </span>&#123;</span><br><span class="line"> ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BloomFilter一共四个create方法，不过最终都是走向第四个。看一下每个参数的含义：</p><ul><li><p>funnel：数据类型(一般是调用Funnels工具类中的)</p></li><li><p>expectedInsertions：期望插入的值的个数</p></li><li><p>fpp 错误率(默认值为0.03)</p></li><li><p>strategy 哈希算法(我也不懂啥意思)Bloom Filter的应用</p></li></ul><p>在最后一个create方法中，设置一个断点：</p><p><img src="/images/bloom_inteceptor.jpg" alt></p><p>上面的numBits，表示存一百万个int类型数字，需要的位数为7298440，700多万位。理论上存一百万个数，一个int是4字节32位，需要481000000=3200万位。如果使用HashMap去存，按HashMap50%的存储效率，需要6400万位。可以看出BloomFilter的存储空间很小，只有HashMap的1/10左右</p><p>上面的numHashFunctions，表示需要5个函数去存这些数字</p><p>使用第三个create方法，我们设置下错误率：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> BloomFilter&lt;Integer&gt; bf = BloomFilter.create(Funnels.integerFunnel(), total, <span class="number">0.0003</span>);</span><br></pre></td></tr></table></figure><p>再运行看看：</p><p><img src="/images/bloom_error_4.jpg" alt></p><p>此时误伤的数量为4，错误率为0.04%左右。<br><img src="/images/bloom_bit_num.jpg" alt></p><p>当错误率设为0.0003时，所需要的位数为16883499，1600万位，需要12个函数<br>和上面对比可以看出，<strong>错误率越大，所需空间和时间越小，错误率越小，所需空间和时间越大</strong>。</p><h2 id="Redis实现"><a href="#Redis实现" class="headerlink" title="Redis实现"></a>Redis实现</h2><h3 id="RedisBloom实现"><a href="#RedisBloom实现" class="headerlink" title="RedisBloom实现"></a>RedisBloom实现</h3><p>Redis的布隆过滤器不是原生自带的，而是要通过module加载进去。Redis在4.0的版本中加入了module功能。</p><ul><li><code>RedisBloom github</code> 主页地址： <a href="https://github.com/RedisBloom/RedisBloom" target="_blank" rel="noopener">https://github.com/RedisBloom/RedisBloom</a></li><li><code>RedisBloom客户端</code> 主页地址： <a href="https://github.com/RedisBloom/JRedisBloom" target="_blank" rel="noopener">https://github.com/RedisBloom/JRedisBloom</a></li></ul><p>上面有docker一键启动命令，可以很方便地实验。也有几种主流语言的客户端库的链接，比如Java语言的JReBloom。</p><p>RedisBloom模块还实现了<strong>布谷鸟过滤器</strong>，它算是对布隆过滤器的增强版。解决了布隆过滤器的一些比较明显的缺点，比如：不能删除元素，不能计数等。除此之外，布谷鸟过滤器不用使用多个hash函数，所以查询性能更高。除此之外，在相同的误判率下，布谷鸟过滤器的空间利用率要明显高于布隆，空间上大概能节省40%多。</p><ul><li>安装Rebloom插件</li></ul><p>1 下载并编译</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> git://github.com/RedisLabsModules/rebloom</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> rebloom</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make</span></span><br></pre></td></tr></table></figure><p>将Rebloom加载到Redis中，在redis.conf里面添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loadmodule /path/to/rebloom.so</span><br></pre></td></tr></table></figure><p>命令操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BF.ADD bloom redis</span><br><span class="line">BF.EXISTS bloom redis</span><br><span class="line">BF.EXISTS bloom nonxist</span><br></pre></td></tr></table></figure><p>命令行加载rebloom插件,并且设定每个bloomfilter key的容量和错误率：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/redis-4.0.11</span><br><span class="line"><span class="meta">#</span><span class="bash"> 容量100万, 容错率万分之一</span></span><br><span class="line">./src/redis-server redis.conf --loadmodule /usr/rebloom/rebloom.so INITIAL_SIZE 1000000 ERROR_RATE 0.0001</span><br></pre></td></tr></table></figure><ul><li>java-lua版操作(java代码不提供了，自己把脚本执行就行)</li></ul><blockquote><p>bloomFilterAdd.lua</p></blockquote><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> bloomName = KEYS[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">local</span> value = KEYS[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">-- bloomFilter</span></span><br><span class="line"><span class="keyword">local</span> result_1 = redis.call(<span class="string">'BF.ADD'</span>, bloomName, value)</span><br><span class="line"><span class="keyword">return</span> result_1</span><br></pre></td></tr></table></figure><blockquote><p>bloomFilterExist.lua</p></blockquote><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> bloomName = KEYS[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">local</span> value = KEYS[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">-- bloomFilter</span></span><br><span class="line"><span class="keyword">local</span> result_1 = redis.call(<span class="string">'BF.EXISTS'</span>, bloomName, value)</span><br><span class="line"><span class="keyword">return</span> result_1</span><br></pre></td></tr></table></figure><h3 id="Bitmap简单实现-原理版"><a href="#Bitmap简单实现-原理版" class="headerlink" title="Bitmap简单实现-原理版"></a>Bitmap简单实现-原理版</h3><p>Bitmap不是一个确切的数据类型，而是基于String类型定义的一系列面向位操作的方法。因为String是二进制安全的并且它们的最大长度是512MB，</p><p>所以String类型很合适去作为一个2^32 长度的位数组。</p><p>位操作方法可以被分为两组：<br>一、对单一位的操作，比如设置某一位为1或0，或者得到这一位的值；<br>二、对一组位的操作，比方说计算一定范围内的1的个数（比如计数）</p><p>bitmap一个最大的优势是它通常能在存储信息的时候节省大量空间。比方说一个用增量ID来辨别用户的系统，可以用仅仅512MB的空间来标识40亿个用户是否想要接受通知。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BloomFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> size = Math.pow(<span class="number">2</span>, <span class="number">32</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第一次加载的时候将数据加载到redis中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">saveDataToRedis</span><span class="params">(Jedis jedis)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; baseList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        baseList.add(<span class="string">"000"</span>);</span><br><span class="line">        baseList.add(<span class="string">"111"</span>);</span><br><span class="line">        baseList.add(<span class="string">"222"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; baseList.size(); i++) &#123;</span><br><span class="line">            <span class="comment">// 只做一次hash，实际中会计算多个hash位置，降低误差率</span></span><br><span class="line">            <span class="keyword">long</span> index = hashIndex(baseList.get(i)); </span><br><span class="line">            jedis.setbit(<span class="string">"orderId"</span>, index, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">hashIndex</span><span class="params">(String target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.abs((<span class="keyword">long</span>) (target.hashCode() % size));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断传入的数据是否在redis中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkEleIsContainBloomFilter</span><span class="params">(String target, Jedis jedis)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> index = hashIndex(target);</span><br><span class="line">        System.out.println(<span class="string">"index: "</span> + index + <span class="string">" size: "</span> + size);</span><br><span class="line">        <span class="keyword">boolean</span> checkResult = jedis.getbit(<span class="string">"orderId"</span>, index);</span><br><span class="line">        <span class="keyword">return</span> checkResult;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取redis链接</span></span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"xxxx"</span>, <span class="number">6379</span>);</span><br><span class="line">        jedis.auth(<span class="string">"xxxxx"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一次运行的时候调用，只运行一次</span></span><br><span class="line">        saveDataToRedis(jedis);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取比较后的值</span></span><br><span class="line">        System.out.println(checkEleIsContainBloomFilter(<span class="string">"000"</span>, jedis));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//释放redis链接</span></span><br><span class="line">        jedis.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常见应用场景"><a href="#常见应用场景" class="headerlink" title="常见应用场景"></a>常见应用场景</h2><ul><li><p>cerberus在收集监控数据的时候, 有的系统的监控项量会很大, 需要检查一个监控项的名字是否已经被记录到db过了, 如果没有的话就需要写入db.</p></li><li><p>爬虫过滤已抓到的url就不再抓，可用bloom filter过滤</p></li><li><p>垃圾邮件过滤。如果用哈希表，每存储一亿个 email地址，就需要 1.6GB的内存（用哈希表实现的具体办法是将每一个 email地址对应成一个八字节的信息指纹，然后将这些信息指纹存入哈希表，由于哈希表的存储效率一般只有 50%，因此一个 email地址需要占用十六个字节。一亿个地址大约要 1.6GB，即十六亿字节的内存）。因此存贮几十亿个邮件地址可能需要上百 GB的内存。而Bloom Filter只需要哈希表 1/8到 1/4 的大小就能解决同样的问题。</p></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1]  <a href="https://juejin.im/post/5db69365518825645656c0de" target="_blank" rel="noopener">Redis-避免缓存穿透的利器之BloomFilter</a></p><p>[2]  <a href="https://blog.csdn.net/sssbbbryj/article/details/84990589" target="_blank" rel="noopener">Java redis 模拟布隆过滤器</a></p><p>[3]  <a href="https://juejin.im/post/5d9c57485188257377312f0c" target="_blank" rel="noopener">redis-分布式布隆过滤器（Bloom Filter）详解（初版）</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;p&gt;布隆过滤器（英语：Bloom Filter）是1970年由一个叫布隆的小伙子提出的。它实际上是一个很长的二进制向量和一系列随机映射函数。布隆
      
    
    </summary>
    
      <category term="基础知识" scheme="http://yoursite.com/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="Bloom" scheme="http://yoursite.com/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Bloom/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
      <category term="布隆过滤器" scheme="http://yoursite.com/tags/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
    
      <category term="Bloom" scheme="http://yoursite.com/tags/Bloom/"/>
    
  </entry>
  
  <entry>
    <title>Redis过期键处理策略</title>
    <link href="http://yoursite.com/2019/11/22/Redis%E8%BF%87%E6%9C%9F%E9%94%AE%E5%A4%84%E7%90%86%E7%AD%96%E7%95%A5/"/>
    <id>http://yoursite.com/2019/11/22/Redis过期键处理策略/</id>
    <published>2019-11-22T09:44:56.000Z</published>
    <updated>2019-11-22T09:51:04.373Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis-Expire-Key基础"><a href="#Redis-Expire-Key基础" class="headerlink" title="Redis Expire Key基础"></a>Redis Expire Key基础</h2><p>redis数据库在数据库服务器中使用了 <code>redisDb</code> 数据结构，结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span></span><br><span class="line">     dict *dict;            <span class="comment">/* 键空间 key space */</span></span><br><span class="line">     dict *expires;         <span class="comment">/* 过期字典 */</span></span><br><span class="line">     dict *blocking_keys;   <span class="comment">/* Keys with clients waiting for data (BLPOP) */</span></span><br><span class="line">     dict *ready_keys;      <span class="comment">/* Blocked keys that received a PUSH */</span></span><br><span class="line">     dict *watched_keys;    <span class="comment">/* WATCHED keys for MULTI/EXEC CAS */</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">evictionPoolEntry</span> *<span class="title">eviction_pool</span>;</span> <span class="comment">/* Eviction pool of keys */</span></span><br><span class="line">     <span class="keyword">int</span> id;                <span class="comment">/* Database ID */</span></span><br><span class="line">     <span class="keyword">long</span> <span class="keyword">long</span> avg_ttl;     <span class="comment">/* Average TTL, just for stats */</span></span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure><p>其中:</p><ul><li><p><strong>键空间(<code>key space</code>):</strong><br>dict字典用来保存数据库中的所有键值对</p></li><li><p><strong>过期字典(<code>expires</code>):</strong><br>保存数据库中所有键的过期时间，过期时间用UNIX时间戳表示，且值为long long整数</p></li></ul><h3 id="设置过期时间命令"><a href="#设置过期时间命令" class="headerlink" title="设置过期时间命令"></a>设置过期时间命令</h3><ul><li><p><code>EXPIRE &lt;key&gt; &lt;ttl&gt;</code> 命令用于将键key的过期时间设置为ttl秒之后</p></li><li><p><code>PEXPIRE &lt;key&gt; &lt;ttl&gt;</code> 命令用于将键key的过期时间设置为ttl毫秒之后</p></li><li><p><code>EXPIREAT &lt;key&gt; &lt;timesramp&gt;</code> 命令用于将key的过期时间设置为timrestamp所指定的秒数时间戳</p></li><li><p><code>PEXPIREAT &lt;key&gt; &lt;timesramp&gt;</code> 命令用于将key的过期时间设置为timrestamp所指定的毫秒数时间戳</p></li></ul><p>设置过期时间：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; set Ccww   5 2 0  </span><br><span class="line">ok  </span><br><span class="line">redis&gt; expire Ccww 5  </span><br><span class="line">ok</span><br></pre></td></tr></table></figure><p>使用redisDb结构存储数据图表示：</p><p><img src="/images/redis_redisDb.jpg" alt></p><h3 id="过期时间保存以及判定"><a href="#过期时间保存以及判定" class="headerlink" title="过期时间保存以及判定"></a>过期时间保存以及判定</h3><p>过期键的判定，其实通过过期字典进行判定，步骤：</p><ul><li><p>检查给定键是否存在于过期字典，如果存在，取出键的过期时间</p></li><li><p>通过判断当前UNIX时间戳是否大于键的过期时间，是的话，键已过期，相反则键未过期。</p></li></ul><h2 id="过期键删除策略"><a href="#过期键删除策略" class="headerlink" title="过期键删除策略"></a>过期键删除策略</h2><h3 id="定时删除"><a href="#定时删除" class="headerlink" title="定时删除"></a>定时删除</h3><p>在设置键的过期时间的同时，创建一个定时任务，当键达到过期时间时，立即执行对键的删除操作.</p><ul><li><p>优点<br>对内存友好，定时删除策略可以保证过期键会尽可能快地被删除，并释放国期间所占用的内存</p></li><li><p>缺点<br>对cpu时间不友好，在过期键比较多时，删除任务会占用很大一部分cpu时间，在内存不紧张但cpu时间紧张的情况下，将cpu时间用在删除和当前任务无关的过期键上，影响服务器的响应时间和吞吐量</p></li></ul><h3 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h3><p>放任键过期不管，但在每次从键空间获取键时，都检查取得的键是否过期，如果过期的话，就删除该键，如果没有过期，就返回该键</p><ul><li><p>优点<br>对cpu时间友好，在每次从键空间获取键时进行过期键检查并是否删除，删除目标也仅限当前处理的键，这个策略不会在其他无关的删除任务上花费任何cpu时间。</p></li><li><p>缺点<br>对内存不友好，过期键过期也可能不会被删除，导致所占的内存也不会释放。甚至可能会出现内存泄露的现象，当存在很多过期键，而这些过期键又没有被访问到，这会可能导致它们会一直保存在内存中，造成内存泄露。</p></li></ul><h3 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a>定期删除</h3><p>由于定时删除会占用太多cpu时间，影响服务器的响应时间和吞吐量, 而惰性删除浪费太多内存，有内存泄露的危险，所以出现一种整合和折中这两种策略的定期删除策略:</p><blockquote><ol><li><p>定期删除策略每隔一段时间执行一次删除过期键操作，并通过<strong>限制删除操作执行的时长和频率</strong>来减少删除操作对CPU时间的影响;</p></li><li><p>至于要删除多少过期键，以及要检查多少个数据库，则由算法决定；</p></li><li><p>定时删除策略有效地减少了因为过期键带来的内存浪费;</p></li></ol></blockquote><p><strong>定时删除策略难点就是确定删除操作执行的时长和频率：</strong></p><ul><li>删除操作执行得太频繁。或者执行时间太长，定期删除策略就会退化成为定时删除策略，以至于将cpu时间过多地消耗在删除过期键上。  </li><li>相反，则与惰性删除策略一样，出现浪费内存的情况。</li></ul><p>所以使用定期删除策略，需要根据服务器的情况合理地设置删除操作的执行时长和执行频率。</p><h2 id="过期键删除策略实现"><a href="#过期键删除策略实现" class="headerlink" title="过期键删除策略实现"></a>过期键删除策略实现</h2><p>  Redis服务器结合惰性删除和定期删除两种策略一起使用，通过这两种策略之间的配合使用，使得服务器可以在合理使用CPU时间和浪费内存空间取得平衡点。  </p><h3 id="惰性删除策略的实现"><a href="#惰性删除策略的实现" class="headerlink" title="惰性删除策略的实现"></a>惰性删除策略的实现</h3><p>  Redis在执行任何读写命令时都会先找到这个key，惰性删除就作为一个切入点放在查找key之前，如果key过期了就删除这个key。<br>  <img src="/images/redis_key_delete.jpg" alt></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">robj *<span class="title">lookupKeyRead</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123;</span><br><span class="line">          robj *val;</span><br><span class="line"> expireIfNeeded(db,key); <span class="comment">// 切入点</span></span><br><span class="line"> val = lookupKey(db,key);</span><br><span class="line"> <span class="keyword">if</span> (val == <span class="literal">NULL</span>)</span><br><span class="line">  server.stat_keyspace_misses++;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line">  server.stat_keyspace_hits++;</span><br><span class="line"> <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过expireIfNeeded函数对输入键进行检查是否删除:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">expireIfNeeded</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123;</span><br><span class="line">     <span class="comment">/* 取出键的过期时间 */</span></span><br><span class="line">    <span class="keyword">mstime_t</span> when = getExpire(db,key);</span><br><span class="line">    <span class="keyword">mstime_t</span> now;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">/* 没有过期时间返回0*/</span></span><br><span class="line">    <span class="keyword">if</span> (when &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* No expire for this key */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 服务器loading时*/</span></span><br><span class="line">    <span class="keyword">if</span> (server.loading) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 根据一定规则获取当前时间*/</span></span><br><span class="line">    now = server.lua_caller ? server.lua_time_start : mstime();</span><br><span class="line">    <span class="comment">/* 如果当前的是从(Slave)服务器</span></span><br><span class="line"><span class="comment">     * 0 认为key为无效</span></span><br><span class="line"><span class="comment">     * 1 if we think the key is expired at this time. </span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">if</span> (server.masterhost != <span class="literal">NULL</span>) <span class="keyword">return</span> now &gt; when;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* key未过期，返回 0 */</span></span><br><span class="line">    <span class="keyword">if</span> (now &lt;= when) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* 删除键 */</span></span><br><span class="line">    server.stat_expiredkeys++;</span><br><span class="line">    propagateExpire(db,key,server.lazyfree_lazy_expire);</span><br><span class="line">    notifyKeyspaceEvent(NOTIFY_EXPIRED,</span><br><span class="line">        <span class="string">"expired"</span>,key,db-&gt;id);</span><br><span class="line">    <span class="keyword">return</span> server.lazyfree_lazy_expire ? dbAsyncDelete(db,key) :</span><br><span class="line">                                         dbSyncDelete(db,key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="定期删除策略的实现"><a href="#定期删除策略的实现" class="headerlink" title="定期删除策略的实现"></a>定期删除策略的实现</h3><p>  key的定期删除会在Redis的周期性执行任务（<code>serverCron</code>，默认每100ms执行一次）中进行，而且是发生Redis的<code>master</code>节点，因为slave节点会通过主节点的DEL命令同步过来达到删除key的目的。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; dbs_per_call; j++) &#123;</span><br><span class="line"> <span class="keyword">int</span> expired;</span><br><span class="line"> redisDb *db = server.db+(current_db % server.dbnum);</span><br><span class="line"> </span><br><span class="line"> current_db++;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/* 超过25％的key已过期，则继续. */</span></span><br><span class="line"> <span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> num, slots;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> now, ttl_sum;</span><br><span class="line">  <span class="keyword">int</span> ttl_samples;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* 如果该db没有设置过期key，则继续看下个db*/</span></span><br><span class="line">  <span class="keyword">if</span> ((num = dictSize(db-&gt;expires)) == <span class="number">0</span>) &#123;</span><br><span class="line">   db-&gt;avg_ttl = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  slots = dictSlots(db-&gt;expires);</span><br><span class="line">  now = mstime();</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/*但少于1%时，需要调整字典大小*/</span></span><br><span class="line">  <span class="keyword">if</span> (num &amp;&amp; slots &gt; DICT_HT_INITIAL_SIZE &amp;&amp;</span><br><span class="line">   (num*<span class="number">100</span>/slots &lt; <span class="number">1</span>)) <span class="keyword">break</span>;</span><br><span class="line"> </span><br><span class="line">  expired = <span class="number">0</span>;</span><br><span class="line">  ttl_sum = <span class="number">0</span>;</span><br><span class="line">  ttl_samples = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (num &gt; ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP)</span><br><span class="line">   num = ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP;<span class="comment">// 20</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">while</span> (num--) &#123;</span><br><span class="line">   dictEntry *de;</span><br><span class="line">   <span class="keyword">long</span> <span class="keyword">long</span> ttl;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">if</span> ((de = dictGetRandomKey(db-&gt;expires)) == <span class="literal">NULL</span>) <span class="keyword">break</span>;</span><br><span class="line">   ttl = dictGetSignedIntegerVal(de)-now;</span><br><span class="line">   <span class="keyword">if</span> (activeExpireCycleTryExpire(db,de,now)) expired++;</span><br><span class="line">   <span class="keyword">if</span> (ttl &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/* We want the average TTL of keys yet not expired. */</span></span><br><span class="line">    ttl_sum += ttl;</span><br><span class="line">    ttl_samples++;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Update the average TTL stats for this database. */</span></span><br><span class="line">  <span class="keyword">if</span> (ttl_samples) &#123;</span><br><span class="line">   <span class="keyword">long</span> <span class="keyword">long</span> avg_ttl = ttl_sum/ttl_samples;</span><br><span class="line"> </span><br><span class="line">   /样本获取移动平均值 */</span><br><span class="line">   <span class="keyword">if</span> (db-&gt;avg_ttl == <span class="number">0</span>) db-&gt;avg_ttl = avg_ttl;</span><br><span class="line">   db-&gt;avg_ttl = (db-&gt;avg_ttl/<span class="number">50</span>)*<span class="number">49</span> + (avg_ttl/<span class="number">50</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  iteration++;</span><br><span class="line">  <span class="keyword">if</span> ((iteration &amp; <span class="number">0xf</span>) == <span class="number">0</span>) &#123; <span class="comment">/* 每迭代16次检查一次 */</span></span><br><span class="line">   <span class="keyword">long</span> <span class="keyword">long</span> elapsed = ustime()-start;</span><br><span class="line"> </span><br><span class="line">   latencyAddSampleIfNeeded(<span class="string">"expire-cycle"</span>,elapsed/<span class="number">1000</span>);</span><br><span class="line">   <span class="keyword">if</span> (elapsed &gt; timelimit) timelimit_exit = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="comment">/* 超过时间限制则退出*/</span></span><br><span class="line">  <span class="keyword">if</span> (timelimit_exit) <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">/* 在当前db中，如果少于25%的key过期，则停止继续删除过期key */</span></span><br><span class="line"> &#125; <span class="keyword">while</span> (expired &gt; ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP/<span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color="red"><strong>依次遍历每个db（默认配置数是16），针对每个db，每次循环随机选择20个（ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP）key判断是否过期，如果一轮所选的key少于25%过期，则终止迭代</strong></font>，此外<strong>在迭代过程中如果超过了一定的时间限制</strong>则终止过期删除这一过程。</p><h2 id="Redis采用的过期策略"><a href="#Redis采用的过期策略" class="headerlink" title="Redis采用的过期策略"></a>Redis采用的过期策略</h2><p>redis 过期策略是：定期删除 + 惰性删除</p><p>假设 redis 里放了 10w 个 key，都设置了过期时间，你每隔几百毫秒，就检查 10w 个 key，那 redis 基本上就死了，cpu 负载会很高的，消耗在你的检查过期 key 上了。所以，这里可不是每隔 100ms 就遍历所有的设置过期时间的 key，那样就是一场性能上的灾难。<strong>实际上 redis 是每隔 100ms 随机抽取一些 key 来检查和删除的</strong>。</p><p>但是问题是，定期删除可能会导致很多过期 key 到了时间并没有被删除掉，那咋整呢？所以就需要结合<strong>惰性删除</strong>。</p><p>但是实际上这还是有问题的，如果定期删除漏掉了很多过期 key，然后你也没及时去查，也就没走惰性删除，此时会怎么样？如果大量过期 key 堆积在内存里，导致 redis 内存块耗尽了，咋整？</p><p>答案是：<strong>走内存淘汰机制</strong></p><h3 id="内存淘汰机制"><a href="#内存淘汰机制" class="headerlink" title="内存淘汰机制"></a>内存淘汰机制</h3><p>redis 内存淘汰机制有以下几个：</p><ul><li><p><strong>noeviction</strong>   当内存不足以容纳新写入数据时，新写入操作会报错，这个一般没人用吧，实在是太恶心了</p></li><li><p><strong>allkeys-lru</strong>  当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）；</p></li><li><p><strong>allkeys-random</strong>  当内存不足以容纳新写入数据时，在键空间中，随机移除某个 key，这个一般没人用吧，为啥要随机，肯定是把最近最少使用的 key 给干掉啊；</p></li><li><p><strong>volatile-lru</strong> 当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的 key（这个一般不太合适）；</p></li><li><p><strong>volatile-random</strong> 当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key；</p></li><li><p><strong>volatile-ttl</strong>  当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的 key 优先移除；</p></li></ul><p><strong>设置方式：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config set maxmemory-policy volatile-lru</span><br></pre></td></tr></table></figure><h2 id="AOF、RDB和复制功能对过期键的处理"><a href="#AOF、RDB和复制功能对过期键的处理" class="headerlink" title="AOF、RDB和复制功能对过期键的处理"></a>AOF、RDB和复制功能对过期键的处理</h2><h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><ul><li><p><strong>生成RDB文件</strong><br>程序会数据库中的键进行检查，已过期的键不会保存到新创建的RDB文件中</p></li><li><p><strong>载入RDB文件</strong></p><ul><li>主服务载入RDB文件，会对文件中保存的键进行检查会忽略过期键加载未过期键</li><li>从服务器载入RDB文件，会加载文件所保存的所有键（过期和未过期的），但从主服务器同步数据同时会清空从服务器的数据库。</li></ul></li></ul><h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><ul><li><p><strong>AOF文件写入</strong><br>当过期键被删除后，会在AOF文件增加一条DEL命令，来显式地记录该键已被删除。</p></li><li><p><strong>AOF重写</strong><br>已过期的键不会保存到重写的AOF文件中</p></li></ul><h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><p> 当服务器运行在复制模式下时，<strong>从服务器的过期键删除动作由主服务器控制的</strong>，这样的好处主要为了保持主从服务器数据一致性：</p><ul><li><p>主服务器在删除一个过期键之后，会显式地向所有的从服务器发送一个DEL命令，告知从服务器删除这个过期键；</p></li><li><p>从服务器在执行客户端发送的读取命令时，即使碰到过期键也不会将过期键删除，不作任何处理。<strong>只有接收到主服务器 DEL命令后，从服务器进行删除处理</strong>。</p></li></ul><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p>[1] <a href="https://juejin.im/post/5da7144ff265da5ba532b753?utm_source=gold_browser_extension" target="_blank" rel="noopener">当遇到美女面试官之如何理解Redis的Expire Key(过期键)</a></p><p>[2] <a href="https://juejin.im/post/5d8bf523e51d4577ff0d9e8c" target="_blank" rel="noopener">Redis的过期策略及内存淘汰机制</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Redis-Expire-Key基础&quot;&gt;&lt;a href=&quot;#Redis-Expire-Key基础&quot; class=&quot;headerlink&quot; title=&quot;Redis Expire Key基础&quot;&gt;&lt;/a&gt;Redis Expire Key基础&lt;/h2&gt;&lt;p&gt;redis数
      
    
    </summary>
    
      <category term="中间件" scheme="http://yoursite.com/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
      <category term="Redis" scheme="http://yoursite.com/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="入门" scheme="http://yoursite.com/tags/%E5%85%A5%E9%97%A8/"/>
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Netty性能优化</title>
    <link href="http://yoursite.com/2019/11/20/Netty%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2019/11/20/Netty性能优化/</id>
    <published>2019-11-20T12:12:30.000Z</published>
    <updated>2019-11-20T12:17:03.884Z</updated>
    
    <content type="html"><![CDATA[<h2 id="共享Handler"><a href="#共享Handler" class="headerlink" title="共享Handler"></a>共享Handler</h2><p>代码：<a href="https://github.com/austin-brant/netty-im" target="_blank" rel="noopener">https://github.com/austin-brant/netty-im</a></p><p>在使用 Netty 完成了一个 IM 系统的核心功能之后，我们再来仔细看一下服务端</p><blockquote><p>NettyServer.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">serverBootstrap</span><br><span class="line">.childHandler(<span class="keyword">new</span> ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(NioSocketChannel ch)</span> </span>&#123;</span><br><span class="line">        ch.pipeline().addLast(<span class="keyword">new</span> Spliter());</span><br><span class="line">        ch.pipeline().addLast(<span class="keyword">new</span> PacketDecoder());</span><br><span class="line">        ch.pipeline().addLast(<span class="keyword">new</span> LoginRequestHandler());</span><br><span class="line">        ch.pipeline().addLast(<span class="keyword">new</span> AuthHandler());</span><br><span class="line">        ch.pipeline().addLast(<span class="keyword">new</span> MessageRequestHandler());</span><br><span class="line">        ch.pipeline().addLast(<span class="keyword">new</span> CreateGroupRequestHandler());</span><br><span class="line">        ch.pipeline().addLast(<span class="keyword">new</span> JoinGroupRequestHandler());</span><br><span class="line">        ch.pipeline().addLast(<span class="keyword">new</span> QuitGroupRequestHandler());</span><br><span class="line">        ch.pipeline().addLast(<span class="keyword">new</span> ListGroupMembersRequestHandler());</span><br><span class="line">        ch.pipeline().addLast(<span class="keyword">new</span> GroupMessageRequestHandler());</span><br><span class="line">        ch.pipeline().addLast(<span class="keyword">new</span> LogoutRequestHandler());</span><br><span class="line">        ch.pipeline().addLast(<span class="keyword">new</span> PacketEncoder());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol><li><p>我们看到，服务端的 pipeline 链里面已经有 12 个 handler，其中，与指令相关的 handler 有 9 个。</p></li><li><p>Netty 在这里的逻辑是：<strong>每次有新连接到来的时候，都会调用 ChannelInitializer 的 initChannel() 方法，然后这里 9 个指令相关的 handler 都会被 new 一次</strong>。</p></li><li><p>其实这里的每一个指令 handler，他们内部都是没有成员变量的，也就是说是无状态的，我们完全可以使用单例模式，即调用 pipeline().addLast() 方法的时候，都直接使用单例，不需要每次都 new，提高效率，也避免了创建很多小的对象。</p></li></ol><p>比如，我们拿 LoginRequestHandler 举例，来看一下如何改造</p><blockquote><p>LoginRequestHandler.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 加上注解标识，表明该 handler 是可以多个 channel 共享的</span></span><br><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginRequestHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">LoginRequestPacket</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 构造单例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> LoginRequestHandler INSTANCE = <span class="keyword">new</span> LoginRequestHandler();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">LoginRequestHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>首先，非常重要的一点，如果一个 handler 要被多个 channel 进行共享，必须要加上 <strong><code>@ChannelHandler.Sharable</code></strong> 显示地告诉 Netty，这个 handler 是支持多个 channel 共享的，否则会报错，读者可以自行尝试一下。</p></li><li><p>然后，我们仿照 Netty 源码里面单例模式的写法，构造一个单例模式的类。</p></li></ol><p>接着，我们在服务端的代理里面就可以这么写</p><blockquote><p>NettyServer.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">serverBootstrap</span><br><span class="line">        .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(NioSocketChannel ch)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// ...单例模式，多个 channel 共享同一个 handler</span></span><br><span class="line">                ch.pipeline().addLast(LoginRequestHandler.INSTANCE);</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p>这样的话，每来一次新的连接，添加 handler 的时候就不需要每次都 new 了。</p><h2 id="压缩-handler-合并编解码器"><a href="#压缩-handler-合并编解码器" class="headerlink" title="压缩 handler - 合并编解码器"></a>压缩 handler - 合并编解码器</h2><p>当我们改造完了之后，我们再来看一下服务端代码</p><blockquote><p>NettyServer.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">serverBootstrap</span><br><span class="line">        .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(NioSocketChannel ch)</span> </span>&#123;</span><br><span class="line">                ch.pipeline().addLast(<span class="keyword">new</span> Spliter());</span><br><span class="line">                ch.pipeline().addLast(<span class="keyword">new</span> PacketDecoder());</span><br><span class="line">                ch.pipeline().addLast(LoginRequestHandler.INSTANCE);</span><br><span class="line">                ch.pipeline().addLast(AuthHandler.INSTANCE);</span><br><span class="line">                ch.pipeline().addLast(MessageRequestHandler.INSTANCE);</span><br><span class="line">                ch.pipeline().addLast(CreateGroupRequestHandler.INSTANCE);</span><br><span class="line">                ch.pipeline().addLast(JoinGroupRequestHandler.INSTANCE);</span><br><span class="line">                ch.pipeline().addLast(QuitGroupRequestHandler.INSTANCE);</span><br><span class="line">                ch.pipeline().addLast(ListGroupMembersRequestHandler.INSTANCE);</span><br><span class="line">                ch.pipeline().addLast(GroupMessageRequestHandler.INSTANCE);</span><br><span class="line">                ch.pipeline().addLast(LogoutRequestHandler.INSTANCE);</span><br><span class="line">                ch.pipeline().addLast(<span class="keyword">new</span> PacketEncoder());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p>pipeline 中第一个 handler - <code>Spliter</code>，我们是无法改动它的，因为他<strong>内部实现是与每个 channel 有关，每个 Spliter 需要维持每个 channel 当前读到的数据，也就是说他是有状态的</strong>。 而 PacketDecoder 与 PacketEncoder 我们是可以继续改造的，Netty 内部提供了一个类，叫做 <code>MessageToMessageCodec</code>，使用它可以让我们的编解码操作放到一个类里面去实现，首先我们定义一个 PacketCodecHandler:</p><blockquote><p>PacketCodecHandler.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PacketCodecHandler</span> <span class="keyword">extends</span> <span class="title">MessageToMessageCodec</span>&lt;<span class="title">ByteBuf</span>, <span class="title">Packet</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> PacketCodecHandler INSTANCE = <span class="keyword">new</span> PacketCodecHandler();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">PacketCodecHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf byteBuf, List&lt;Object&gt; out)</span> </span>&#123;</span><br><span class="line">        out.add(PacketCodec.INSTANCE.decode(byteBuf));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext ctx, Packet packet, List&lt;Object&gt; out)</span> </span>&#123;</span><br><span class="line">        ByteBuf byteBuf = ctx.channel().alloc().ioBuffer();</span><br><span class="line">        PacketCodec.INSTANCE.encode(byteBuf, packet);</span><br><span class="line">        out.add(byteBuf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>首先，这里 PacketCodecHandler，他是一个无状态的 handler，因此，同样可以使用单例模式来实现。</p></li><li><p>需要实现 decode() 和 encode() 方法，decode 是将二进制数据 ByteBuf 转换为 java 对象 Packet，而 encode 操作是一个相反的过程，在 encode() 方法里面，我们调用了 channel 的 内存分配器手工分配了 ByteBuf。</p></li></ol><p>接着，PacketDecoder 和 PacketEncoder都可以删掉，我们的 server 端代码就成了如下的样子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">serverBootstrap</span><br><span class="line">        .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(NioSocketChannel ch)</span> </span>&#123;</span><br><span class="line">                ch.pipeline().addLast(<span class="keyword">new</span> Spliter());</span><br><span class="line">                ch.pipeline().addLast(PacketCodecHandler.INSTANCE);</span><br><span class="line">                ch.pipeline().addLast(LoginRequestHandler.INSTANCE);</span><br><span class="line">                ch.pipeline().addLast(AuthHandler.INSTANCE);</span><br><span class="line">                ch.pipeline().addLast(MessageRequestHandler.INSTANCE);</span><br><span class="line">                ch.pipeline().addLast(CreateGroupRequestHandler.INSTANCE);</span><br><span class="line">                ch.pipeline().addLast(JoinGroupRequestHandler.INSTANCE);</span><br><span class="line">                ch.pipeline().addLast(QuitGroupRequestHandler.INSTANCE);</span><br><span class="line">                ch.pipeline().addLast(ListGroupMembersRequestHandler.INSTANCE);</span><br><span class="line">                ch.pipeline().addLast(GroupMessageRequestHandler.INSTANCE);</span><br><span class="line">                ch.pipeline().addLast(LogoutRequestHandler.INSTANCE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p>可以看到，除了拆包器，所有的 handler 都写成了单例，当然，如果你的 handler 里有与 channel 相关成员变量，那就不要写成单例的，不过，<font color="red"><strong>其实所有的状态都可以绑定在 channel 的属性上，依然是可以改造成单例模式</strong>。</font></p><h2 id="缩短事件传播路径"><a href="#缩短事件传播路径" class="headerlink" title="缩短事件传播路径"></a>缩短事件传播路径</h2><p>如果我们再仔细观察我们的服务端代码，发现，我们的 pipeline 链中，绝大部分都是与指令相关的 handler，我们把这些 handler 编排在一起，是为了逻辑简洁，但是随着指令相关的 handler 越来越多，handler 链越来越长，在事件传播过程中性能损耗会被逐渐放大，因为解码器解出来的每个 Packet 对象都要在每个 handler 上经过一遍，我们接下来来看一下如何缩短这个事件传播的路径。</p><h2 id="压缩handler-合并平行handler"><a href="#压缩handler-合并平行handler" class="headerlink" title="压缩handler - 合并平行handler"></a>压缩handler - 合并平行handler</h2><p>对我们这个应用程序来说，每次 decode 出来一个指令对象之后，其实只会在一个指令 handler 上进行处理，因此，我们其实可以把这么多的指令 handler 压缩为一个 handler，我们来看一下如何实现</p><p>我们定义一个 IMHandler，实现如下：</p><blockquote><p>IMHandler.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IMHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">Packet</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> IMHandler INSTANCE = <span class="keyword">new</span> IMHandler();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Byte, SimpleChannelInboundHandler&lt;? extends Packet&gt;&gt; handlerMap;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">IMHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        handlerMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        handlerMap.put(MESSAGE_REQUEST, MessageRequestHandler.INSTANCE);</span><br><span class="line">        handlerMap.put(CREATE_GROUP_REQUEST, CreateGroupRequestHandler.INSTANCE);</span><br><span class="line">        handlerMap.put(JOIN_GROUP_REQUEST, JoinGroupRequestHandler.INSTANCE);</span><br><span class="line">        handlerMap.put(QUIT_GROUP_REQUEST, QuitGroupRequestHandler.INSTANCE);</span><br><span class="line">        handlerMap.put(LIST_GROUP_MEMBERS_REQUEST, ListGroupMembersRequestHandler.INSTANCE);</span><br><span class="line">        handlerMap.put(GROUP_MESSAGE_REQUEST, GroupMessageRequestHandler.INSTANCE);</span><br><span class="line">        handlerMap.put(LOGOUT_REQUEST, LogoutRequestHandler.INSTANCE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, Packet packet)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        handlerMap.get(packet.getCommand()).channelRead(ctx, packet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>首先，IMHandler 是无状态的，依然是可以写成一个单例模式的类。</li><li>我们定义一个 map，存放指令到各个指令处理器的映射。</li><li><strong>每次回调到 IMHandler 的 <code>channelRead0()</code> 方法的时候，我们通过指令找到具体的 handler，然后调用指令 handler 的 <code>channelRead</code>，他内部会做指令类型转换，最终调用到每个指令 handler 的 <code>channelRead0()</code> 方法。</strong></li></ol><p>接下来，我们来看一下，如此压缩之后，我们的服务端代码</p><blockquote><p>NettyServer.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">serverBootstrap</span><br><span class="line">        .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(NioSocketChannel ch)</span> </span>&#123;</span><br><span class="line">                ch.pipeline().addLast(<span class="keyword">new</span> Spliter());</span><br><span class="line">                ch.pipeline().addLast(PacketCodecHandler.INSTANCE);</span><br><span class="line">                ch.pipeline().addLast(LoginRequestHandler.INSTANCE);</span><br><span class="line">                ch.pipeline().addLast(AuthHandler.INSTANCE);</span><br><span class="line">                ch.pipeline().addLast(IMHandler.INSTANCE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p>可以看到，现在，我们服务端的代码已经变得很清爽了，所有的平行指令处理 handler，我们都压缩到了一个 <code>IMHandler</code>，并且 <code>IMHandler</code> 和指令 handler 均为单例模式，在单机十几万甚至几十万的连接情况下，性能能得到一定程度的提升，创建的对象也大大减少了。</p><p>当然，如果你对性能要求没这么高，大可不必搞得这么复杂，还是按照我们前面小节的方式来实现即可，比如，我们的客户端多数情况下是单连接的，其实并不需要搞得如此复杂，还是保持原样即可。</p><h3 id="更改事件传播源"><a href="#更改事件传播源" class="headerlink" title="更改事件传播源"></a>更改事件传播源</h3><p>另外，关于缩短事件传播路径，除了压缩 handler，还有一个就是，如果你的 <code>outBound</code> 类型的 handler 较多，在写数据的时候能用 <code>ctx.writeAndFlush()</code> 就用这个方法。</p><blockquote><p>ctx.writeAndFlush() 事件传播路径</p></blockquote><p><code>ctx.writeAndFlush()</code> 是从 pipeline 链中的 <strong>当前节点开始往前找到第一个 outBound 类型的 handler 把对象往前进行传播</strong>，如果这个对象确认不需要经过其他 outBound 类型的 handler 处理，就使用这个方法。</p><p><img src="/images/netty_broadcast.png" alt></p><p>如上图，在某个 <code>inBound</code> 类型的 handler 处理完逻辑之后，调用 <code>ctx.writeAndFlush()</code> 可以直接一口气把对象送到 codec 中编码，然后写出去。</p><blockquote><p>ctx.channel().writeAndFlush() 事件传播路径</p></blockquote><p><code>ctx.channel().writeAndFlush()</code> 是 <font color="red"><strong>从<code>pipeline</code>链中的最后一个<code>outBound</code>类型的 <code>handler</code>开始，把对象往前进行传播</strong></font>，如果你确认当前创建的对象需要经过后面的 outBound 类型的 handler，那么就调用此方法。</p><p><img src="/images/netty_broadcast_writeflush.png" alt></p><p>如上图，在某个 <code>inBound</code> 类型的 handler 处理完逻辑之后，调用 <code>ctx.channel().writeAndFlush()</code>，对象会从最后一个 outBound 类型的 handler 开始，逐个往前进行传播，路径是要比 <code>ctx.writeAndFlush()</code> 要长的。</p><p>由此可见，在我们的应用程序中，当我们没有改造编解码之前，我们必须调用 <code>ctx.channel().writeAndFlush()</code>, 而经过改造之后，我们的编码器（既属于 inBound, 又属于 outBound 类型的 handler）已处于 pipeline 的最前面，因此，可以大胆使用 <code>ctx.writeAndFlush()</code>。</p><h2 id="减少阻塞主线程的操作"><a href="#减少阻塞主线程的操作" class="headerlink" title="减少阻塞主线程的操作"></a>减少阻塞主线程的操作</h2><p>通常我们的应用程序会涉及到数据库或者网络，比如以下这个例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, T packet)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. balabala 一些逻辑</span></span><br><span class="line">    <span class="comment">// 2. 数据库或者网络等一些耗时的操作</span></span><br><span class="line">    <span class="comment">// 3. writeAndFlush()</span></span><br><span class="line">    <span class="comment">// 4. balabala 其他的逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到，在 <code>channelRead0()</code> 这个方法里面，第二个过程中，我们有一些耗时的操作，这个时候，我们万万不能将这个操作直接就在这个方法中处理了，为什么？</p><p>默认情况下，Netty 在启动的时候会开启 <font color="red"><strong>2 倍的 cpu 核数个 NIO 线程</strong></font>，而通常情况下我们单机会有几万或者十几万的连接，因此，一条 NIO 线程会管理着几千或几万个连接，在传播事件的过程中，单条 NIO 线程的处理逻辑可以抽象成以下一个步骤，我们就拿 <code>channelRead0()</code> 举例</p><blockquote><p>单个 NIO 线程执行的抽象逻辑</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Channel&gt; channelList = 已有数据可读的 channel</span><br><span class="line"><span class="keyword">for</span> (Channel channel in channelist) &#123;</span><br><span class="line">   <span class="keyword">for</span> (ChannelHandler handler in channel.pipeline()) &#123;</span><br><span class="line">       handler.channelRead0();</span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的抽象逻辑中可以看到，其中<strong>只要有一个 channel 的一个 handler 中的 channelRead0() 方法阻塞了 NIO 线程，最终都会拖慢绑定在该 NIO 线程上的其他所有的 channel</strong>，当然，这里抽象的逻辑已经做了简化，想了解细节可以参考我关于 Netty 中 NIO 线程（即 reactor 线程）文章的分析， <a href="https://www.jianshu.com/p/0d0eece6d467" target="_blank" rel="noopener">「netty 源码分析之揭开 reactor 线程的面纱（一）」</a>， <a href="https://www.jianshu.com/p/467a9b41833e" target="_blank" rel="noopener">「netty 源码分析之揭开 reactor 线程的面纱（二）」</a>， <a href="https://www.jianshu.com/p/58fad8e42379" target="_blank" rel="noopener">「netty 源码分析之揭开 reactor 线程的面纱（三）」</a>。</p><p>而我们需要怎么做？对于耗时的操作，我们需要把这些耗时的操作丢到我们的业务线程池中去处理，下面是解决方案的伪代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ThreadPool threadPool = xxx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, T packet)</span> </span>&#123;</span><br><span class="line">    threadPool.submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="comment">// 1. balabala 一些逻辑</span></span><br><span class="line">        <span class="comment">// 2. 数据库或者网络等一些耗时的操作</span></span><br><span class="line">        <span class="comment">// 3. writeAndFlush()</span></span><br><span class="line">        <span class="comment">// 4. balabala 其他的逻辑</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，就可以避免一些耗时的操作影响 Netty 的 NIO 线程，从而影响其他的 channel。</p><h2 id="如何准确统计处理时长"><a href="#如何准确统计处理时长" class="headerlink" title="如何准确统计处理时长"></a>如何准确统计处理时长</h2><p>通常，应用程序都有统计某个操作响应时间的需求，比如，基于我们上面的栗子，我们会这么做</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, T packet)</span> </span>&#123;</span><br><span class="line">    threadPool.submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 1. balabala 一些逻辑</span></span><br><span class="line">        <span class="comment">// 2. 数据库或者网络等一些耗时的操作</span></span><br><span class="line">        <span class="comment">// 3. writeAndFlush()</span></span><br><span class="line">        <span class="comment">// 4. balabala 其他的逻辑</span></span><br><span class="line">        <span class="keyword">long</span> time =  System.currentTimeMillis() - begin;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种做法其实是不推荐的，为什么？</p><p>因为 writeAndFlush() 这个方法如果在非NIO线程（这里，我们其实是在业务线程中调用了该方法）中执行，它是一个异步的操作，调用之后，其实是会立即返回的，剩下的所有的操作，都是 Netty 内部有一个任务队列异步执行的，想了解底层细节的可以阅读一下我的这篇文章 <a href="https://www.jianshu.com/p/feaeaab2ce56" target="_blank" rel="noopener">「netty 源码分析之 writeAndFlush 全解析」</a>. 因此，这里的 writeAndFlush() 执行完毕之后，并不能代表相关的逻辑，比如事件传播、编码等逻辑执行完毕，只是表示 Netty 接收了这个任务，那么如何才能判断 writeAndFlush() 执行完毕呢？我们可以这么做</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, T packet)</span> </span>&#123;</span><br><span class="line">    threadPool.submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 1. balabala 一些逻辑</span></span><br><span class="line">        <span class="comment">// 2. 数据库或者网络等一些耗时的操作</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. writeAndFlush</span></span><br><span class="line">        xxx.writeAndFlush().addListener(future -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (future.isDone()) &#123;</span><br><span class="line">                <span class="comment">// 4. balabala 其他的逻辑</span></span><br><span class="line">                <span class="keyword">long</span> time =  System.currentTimeMillis() - begin;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>writeAndFlush()</code> 方法会返回一个 <code>ChannelFuture</code> 对象，我们给这个对象添加一个监听器，然后在回调方法里面，我们可以监听这个方法执行的结果，进而再执行其他逻辑，最后统计耗时，这样统计出来的耗时才是最准确的。</p><p>最后，需要提出的一点就是，Netty 里面很多方法都是异步的操作，在业务线程中如果要统计这部分操作的时间，都需要使用监听器回调的方式来统计耗时，如果在 NIO 线程中调用，就不需要这么干。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>摘自：<a href="https://juejin.im/book/5b4bc28bf265da0f60130116" target="_blank" rel="noopener">Netty 入门与实战：仿写微信 IM 即时通讯系统</a></p><p>参考文章：<br>[1] <a href="https://www.jianshu.com/p/0d0eece6d467" target="_blank" rel="noopener">netty 源码分析之揭开 reactor 线程的面纱（一）</a><br>[2] <a href="https://www.jianshu.com/p/467a9b41833e" target="_blank" rel="noopener">netty 源码分析之揭开 reactor 线程的面纱（二）</a><br>[3] <a href="https://www.jianshu.com/p/58fad8e42379" target="_blank" rel="noopener">netty 源码分析之揭开 reactor 线程的面纱（三）</a><br>[4] <a href="https://www.jianshu.com/p/feaeaab2ce56" target="_blank" rel="noopener">netty 源码分析之 writeAndFlush 全解析</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;共享Handler&quot;&gt;&lt;a href=&quot;#共享Handler&quot; class=&quot;headerlink&quot; title=&quot;共享Handler&quot;&gt;&lt;/a&gt;共享Handler&lt;/h2&gt;&lt;p&gt;代码：&lt;a href=&quot;https://github.com/austin-bran
      
    
    </summary>
    
      <category term="Netty" scheme="http://yoursite.com/categories/Netty/"/>
    
      <category term="基础" scheme="http://yoursite.com/categories/Netty/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Netty" scheme="http://yoursite.com/tags/Netty/"/>
    
      <category term="网络IO" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9CIO/"/>
    
  </entry>
  
  <entry>
    <title>Netty心跳与空闲检测</title>
    <link href="http://yoursite.com/2019/11/15/Netty%E5%BF%83%E8%B7%B3%E4%B8%8E%E7%A9%BA%E9%97%B2%E6%A3%80%E6%B5%8B/"/>
    <id>http://yoursite.com/2019/11/15/Netty心跳与空闲检测/</id>
    <published>2019-11-15T12:08:56.000Z</published>
    <updated>2019-11-20T12:20:20.579Z</updated>
    
    <content type="html"><![CDATA[<p>代码：<a href="https://github.com/austin-brant/netty-im" target="_blank" rel="noopener">https://github.com/austin-brant/netty-im</a></p><h2 id="网络问题"><a href="#网络问题" class="headerlink" title="网络问题"></a>网络问题</h2><p>下图是网络应用程序普遍会遇到的一个问题：连接假死<br><img src="/images/netty_jiasi.jpg" alt></p><p>连接假死的现象是：</p><blockquote><p>在某一端（服务端或者客户端）看来，底层的 TCP 连接已经断开了，但是应用程序并没有捕获到，因此会认为这条连接仍然是存在的，从 TCP 层面来说，只有收到四次握手数据包或者一个 RST 数据包，连接的状态才表示已断开。</p></blockquote><p>连接假死会带来以下两大问题:</p><ul><li><p>对于服务端来说，因为每条连接都会耗费 cpu 和内存资源，大量假死的连接会逐渐耗光服务器的资源，最终导致性能逐渐下降，程序奔溃。</p></li><li><p>对于客户端来说，连接假死会造成发送数据超时，影响用户体验。</p></li></ul><p>通常，连接假死由以下几个原因造成的</p><ul><li><p>应用程序出现线程堵塞，无法进行数据的读写。</p></li><li><p>客户端或者服务端网络相关的设备出现故障，比如网卡，机房故障。</p></li><li><p>公网丢包。公网环境相对内网而言，非常容易出现丢包，网络抖动等现象，如果在一段时间内用户接入的网络连续出现丢包现象，那么对客户端来说数据一直发送不出去，而服务端也是一直收不到客户端来的数据，连接就一直耗着。</p></li></ul><p>如果我们的应用是面向用户的，那么公网丢包这个问题出现的概率是非常大的。对于内网来说，内网丢包，抖动也是会有一定的概率发生。一旦出现此类问题，客户端和服务端都会受到影响，接下来，我们分别从服务端和客户端的角度来解决连接假死的问题。</p><h2 id="服务端空闲检测"><a href="#服务端空闲检测" class="headerlink" title="服务端空闲检测"></a>服务端空闲检测</h2><p>对于服务端来说，客户端的连接如果出现假死，那么服务端将无法收到客户端的数据，也就是说，如果能一直收到客户端发来的数据，那么可以说明这条连接还是活的，因此，服务端对于连接假死的应对策略就是空闲检测。</p><p>何为空闲检测？</p><blockquote><p>空闲检测指的是每隔一段时间，检测这段时间内是否有数据读写，简化一下，我们的服务端只需要检测一段时间内，是否收到过客户端发来的数据即可，Netty 自带的 IdleStateHandler 就可以实现这个功能。</p></blockquote><p>接下来，我们写一个类继承自 IdleStateHandler，来定义检测到假死连接之后的逻辑。</p><blockquote><p>IMIdleStateHandler.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IMIdleStateHandler</span> <span class="keyword">extends</span> <span class="title">IdleStateHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> READER_IDLE_TIME = <span class="number">15</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IMIdleStateHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(READER_IDLE_TIME, <span class="number">0</span>, <span class="number">0</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelIdle</span><span class="params">(ChannelHandlerContext ctx, IdleStateEvent evt)</span> </span>&#123;</span><br><span class="line">        System.out.println(READER_IDLE_TIME + <span class="string">"秒内未读到数据，关闭连接"</span>);</span><br><span class="line">        ctx.channel().close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>首先，我们观察一下 <code>IMIdleStateHandler</code> 的构造函数，他调用父类 <code>IdleStateHandler</code>的构造函数，有四个参数，其中:</p><ul><li><p>第一个表示读空闲时间，指的是在这段时间内如果没有数据读到，就表示连接假死；</p></li><li><p>第二个是写空闲时间，指的是 在这段时间如果没有写数据，就表示连接假死；</p></li><li><p>第三个参数是读写空闲时间，表示在这段时间内如果没有产生数据读或者写，就表示连接假死。写空闲和读写空闲为0，表示我们不关心者两类条件；</p></li><li><p>最后一个参数表示时间单位。在我们的例子中，表示的是：如果 15 秒内没有读到数据，就表示连接假死。</p></li></ul></li><li><p>连接假死之后会回调 <code>channelIdle()</code> 方法，我们这个方法里面打印消息，并手动关闭连接。</p></li></ol><p>接下来，我们把这个 handler 插入到服务端 pipeline 的最前面</p><blockquote><p>NettyServer.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">serverBootstrap</span><br><span class="line">        .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(NioSocketChannel ch)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 空闲检测</span></span><br><span class="line">                ch.pipeline().addLast(<span class="keyword">new</span> IMIdleStateHandler());</span><br><span class="line">                ch.pipeline().addLast(<span class="keyword">new</span> Spliter());</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p>为什么要插入到最前面？</p><blockquote><p>因为如果插入到最后面的话，如果这条连接读到了数据，但是在 <code>inBound</code> 传播的过程中出错了或者数据处理完完毕就不往后传递了（我们的应用程序属于这类），那么最终 <code>IMIdleStateHandler</code> 就不会读到数据，最终导致误判。</p></blockquote><p>服务端的空闲检测时间完毕之后，接下来我们再思考一下，在一段时间之内没有读到客户端的数据，是否一定能判断连接假死呢？并不能，如果在这段时间之内客户端确实是没有发送数据过来，但是连接是 ok 的，那么这个时候服务端也是不能关闭这条连接的，为了防止服务端误判，我们还需要在客户端做点什么。</p><h2 id="客户端定时发送心跳"><a href="#客户端定时发送心跳" class="headerlink" title="客户端定时发送心跳"></a>客户端定时发送心跳</h2><p>服务端在一段时间内没有收到客户端的数据，这个现象产生的原因可以分为以下两种：</p><ul><li>连接假死。</li><li>非假死状态下确实没有发送数据。</li></ul><p>我们只需要排除掉第二种可能性，那么连接自然就是假死的。要排查第二种情况，我们可以在客户端定期发送数据到服务端，通常这个数据包称为心跳数据包，接下来，我们定义一个 handler，定期发送心跳给服务端</p><blockquote><p>HeartBeatTimerHandler.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeartBeatTimerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HEARTBEAT_INTERVAL = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        scheduleSendHeartBeat(ctx);</span><br><span class="line">        <span class="keyword">super</span>.channelActive(ctx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scheduleSendHeartBeat</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">        ctx.executor().scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (ctx.channel().isActive()) &#123;</span><br><span class="line">                System.out.println(<span class="string">"发送心跳信息 : "</span> + <span class="keyword">new</span> Date());</span><br><span class="line">                ctx.writeAndFlush(<span class="keyword">new</span> HeartBeatRequestPacket());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">0</span>, HEARTBEAT_INTERVAL, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ctx.executor()</code> 返回的是当前的 <code>channel</code> 绑定的 NIO 线程，不理解没关系，只要记住就行，然后，NIO线程有一个方法，schedule()，类似 jdk 的延时任务机制，可以隔一段时间之后执行一个任务，而我们这边是实现了每隔 5 秒，向服务端发送一个心跳数据包，这个时间段通常要比服务端的空闲检测时间的一半要短一些，我们这里直接定义为空闲检测时间的三分之一，主要是为了排除公网偶发的秒级抖动。</p><p>实际在生产环境中，我们的发送心跳间隔时间和空闲检测时间可以略长一些，可以设置为几分钟级别，具体应用可以具体对待，没有强制的规定。</p><p>我们上面其实解决了服务端的空闲检测问题，服务端这个时候是能够在一定时间段之内关掉假死的连接，释放连接的资源了，但是对于客户端来说，我们也需要检测到假死的连接。</p><h2 id="服务端回复心跳与客户端空闲检测"><a href="#服务端回复心跳与客户端空闲检测" class="headerlink" title="服务端回复心跳与客户端空闲检测"></a>服务端回复心跳与客户端空闲检测</h2><p>客户端的空闲检测其实和服务端一样，依旧是在客户端 pipeline 的最前方插入 IMIdleStateHandler</p><blockquote><p>NettyClient.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">bootstrap.handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 空闲检测</span></span><br><span class="line">                ch.pipeline().addLast(<span class="keyword">new</span> IMIdleStateHandler());</span><br><span class="line">                ch.pipeline().addLast(<span class="keyword">new</span> Spliter());</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>然后为了排除是否是因为服务端在非假死状态下确实没有发送数据，<strong>服务端也要定期发送心跳给客户端</strong>。</p><p>而其实在前面我们已经实现了客户端向服务端定期发送心跳，服务端这边其实只要在收到心跳之后回复客户端，给客户端发送一个心跳响应包即可。如果在一段时间之内客户端没有收到服务端发来的数据，也可以判定这条连接为假死状态。</p><p>因此，服务端的 pipeline 中需要再加上如下一个 handler - <code>HeartBeatRequestHandler</code>，<strong>由于这个 handler 的处理其实是无需登录的</strong>，所以，我们将该 handler 放置在 AuthHandler 前面</p><blockquote><p>NettyServer.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">serverBootstrap</span><br><span class="line">                ch.pipeline().addLast(<span class="keyword">new</span> IMIdleStateHandler());</span><br><span class="line">                ch.pipeline().addLast(<span class="keyword">new</span> Spliter());</span><br><span class="line">                ch.pipeline().addLast(PacketCodecHandler.INSTANCE);</span><br><span class="line">                ch.pipeline().addLast(LoginRequestHandler.INSTANCE);</span><br><span class="line">                <span class="comment">// 加在这里</span></span><br><span class="line">                ch.pipeline().addLast(HeartBeatRequestHandler.INSTANCE);</span><br><span class="line">                ch.pipeline().addLast(AuthHandler.INSTANCE);</span><br><span class="line">                ch.pipeline().addLast(IMHandler.INSTANCE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p><code>HeartBeatRequestHandler</code> 相应的实现为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeartBeatRequestHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">HeartBeatRequestPacket</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> HeartBeatRequestHandler INSTANCE = <span class="keyword">new</span> HeartBeatRequestHandler();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HeartBeatRequestHandler</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, HeartBeatRequestPacket requestPacket)</span> </span>&#123;</span><br><span class="line">        ctx.writeAndFlush(<span class="keyword">new</span> HeartBeatResponsePacket());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现非常简单，只是简单地回复一个 <code>HeartBeatResponsePacket</code> 数据包。客户端在检测到假死连接之后，断开连接，然后可以有一定的策略去重连，重新登录等等。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>首先讨论了连接假死相关的现象以及产生的原因</p></li><li><p>要处理假死问题首先我们要实现客户端与服务端定期发送心跳，在这里，其实服务端只需要对客户端的定时心跳包进行回复</p></li><li><p>客户端与服务端如果都需要检测假死，那么直接在 pipeline 的最前方插入一个自定义 <code>IdleStateHandler</code>，在 <code>channelIdle()</code> 方法里面自定义连接假死之后的逻辑</p></li><li><p>通常空闲检测时间要比发送心跳的时间的两倍要长一些，这也是为了排除偶发的公网抖动，防止误判</p></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>摘自：<a href="https://juejin.im/book/5b4bc28bf265da0f60130116" target="_blank" rel="noopener">Netty 入门与实战：仿写微信 IM 即时通讯系统</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;代码：&lt;a href=&quot;https://github.com/austin-brant/netty-im&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/austin-brant/netty-im&lt;/a&gt;&lt;/p&gt;
&lt;h2
      
    
    </summary>
    
      <category term="Netty" scheme="http://yoursite.com/categories/Netty/"/>
    
      <category term="基础" scheme="http://yoursite.com/categories/Netty/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Netty" scheme="http://yoursite.com/tags/Netty/"/>
    
      <category term="网络IO" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9CIO/"/>
    
  </entry>
  
  <entry>
    <title>Netty ChannelHandler生命周期</title>
    <link href="http://yoursite.com/2019/11/14/Netty-ChannelHandler%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://yoursite.com/2019/11/14/Netty-ChannelHandler生命周期/</id>
    <published>2019-11-14T11:18:09.000Z</published>
    <updated>2019-11-20T12:20:18.440Z</updated>
    
    <content type="html"><![CDATA[<p>ChannelHandler有很多回调方法，这些回调方法的执行是有顺序的，而这个执行顺序可以称为 ChannelHandler 的生命周期。</p><p> 代码：<a href="https://github.com/austin-brant/netty-im" target="_blank" rel="noopener">https://github.com/austin-brant/netty-im</a></p><h2 id="生命周期详解"><a href="#生命周期详解" class="headerlink" title="生命周期详解"></a>生命周期详解</h2><p>对于服务端应用程序来说，我们这里讨论 ChannelHandler 更多的指的是 ChannelInboundHandler，在本小节，我们基于 ChannelInboundHandlerAdapter，自定义了一个 handler:  LifeCyCleTestHandler</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LifeCyCleTestHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerAdded</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"逻辑处理器被添加：handlerAdded()"</span>);</span><br><span class="line">        <span class="keyword">super</span>.handlerAdded(ctx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRegistered</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"channel 绑定到线程(NioEventLoop)：channelRegistered()"</span>);</span><br><span class="line">        <span class="keyword">super</span>.channelRegistered(ctx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"channel 准备就绪：channelActive()"</span>);</span><br><span class="line">        <span class="keyword">super</span>.channelActive(ctx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"channel 有数据可读：channelRead()"</span>);</span><br><span class="line">        <span class="keyword">super</span>.channelRead(ctx, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"channel 某次数据读完：channelReadComplete()"</span>);</span><br><span class="line">        <span class="keyword">super</span>.channelReadComplete(ctx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"channel 被关闭：channelInactive()"</span>);</span><br><span class="line">        <span class="keyword">super</span>.channelInactive(ctx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelUnregistered</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"channel 取消线程(NioEventLoop) 的绑定: channelUnregistered()"</span>);</span><br><span class="line">        <span class="keyword">super</span>.channelUnregistered(ctx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerRemoved</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"逻辑处理器被移除：handlerRemoved()"</span>);</span><br><span class="line">        <span class="keyword">super</span>.handlerRemoved(ctx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码可以看到，我们在每个方法被调用的时候都会打印一段文字，然后把这个事件继续往下传播。最后，我们把这个 handler 添加到构建的 pipeline 中.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前面代码略</span></span><br><span class="line">.childHandler(<span class="keyword">new</span> ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(NioSocketChannel ch)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 添加到第一个</span></span><br><span class="line">        ch.pipeline().addLast(<span class="keyword">new</span> LifeCyCleTestHandler());</span><br><span class="line">        ch.pipeline().addLast(<span class="keyword">new</span> PacketDecoder());</span><br><span class="line">        ch.pipeline().addLast(<span class="keyword">new</span> LoginRequestHandler());</span><br><span class="line">        ch.pipeline().addLast(<span class="keyword">new</span> MessageRequestHandler());</span><br><span class="line">        ch.pipeline().addLast(<span class="keyword">new</span> PacketEncoder());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>接着，我们先运行 NettyServer.java，然后再运行 NettyClient.java，这个时候，Server 端 控制台的输出为<br><img src="/images/netty_server_handler_life.jpg" alt></p><p>可以看到 ChannelHandler 回调方法的执行顺序为</p><blockquote><p>handlerAdded() -&gt; channelRegistered() -&gt; channelActive() -&gt; channelRead() -&gt; channelReadComplete()</p></blockquote><p>下面，我们来逐个解释一下每个回调方法的含义</p><ul><li><p>handlerAdded()<br>指的是当检测到新连接之后，调用 ch.pipeline().addLast(new LifeCyCleTestHandler()); 之后的回调，表示在当前的 channel 中，已经成功添加了一个 handler 处理器。</p></li><li><p>channelRegistered()<br>这个回调方法，表示当前的 channel 的所有的逻辑处理已经和某个 NIO 线程建立了绑定关系，类似我们在Netty 是什么？这小节中 BIO 编程中，accept 到新的连接，然后创建一个线程来处理这条连接的读写，只不过 Netty 里面是使用了线程池的方式，只需要从线程池里面去抓一个线程绑定在这个 channel 上即可，这里的 NIO 线程通常指的是 NioEventLoop,不理解没关系，后面我们还会讲到。</p></li><li><p>channelActive()<br>当 channel 的所有的业务逻辑链准备完毕（也就是说 channel 的 pipeline 中已经添加完所有的 handler）以及绑定好一个 NIO 线程之后，这条连接算是真正激活了，接下来就会回调到此方法。</p></li><li><p>channelRead()<br>客户端向服务端发来数据，每次都会回调此方法，表示有数据可读。</p></li><li><p>channelReadComplete()<br>服务端每次读完一次完整的数据之后，回调该方法，表示数据读取完毕。</p></li></ul><p>接下来，我们再把客户端关闭，这个时候对于服务端来说，其实就是 channel 被关闭， </p><p><img src="/images/netty_channel_close.jpg" alt></p><p>ChannelHandler 回调方法的执行顺序为</p><blockquote><p>channelInactive() -&gt; channelUnregistered() -&gt; handlerRemoved()</p></blockquote><p>这里的回调方法的执行顺序是新连接建立时候的逆操作，下面我们还是来解释一下每个方法的含义:</p><ul><li><p>channelInactive(): 表面这条连接已经被关闭了，这条连接在 TCP 层面已经不再是 ESTABLISH 状态了</p></li><li><p>channelUnregistered(): 既然连接已经被关闭，那么与这条连接绑定的线程就不需要对这条连接负责了，这个回调就表明与这条连接对应的 NIO 线程移除掉对这条连接的处理</p></li><li><p>handlerRemoved()：最后，我们给这条连接上添加的所有的业务逻辑处理器都给移除掉。</p></li></ul><p>最后，我们用一幅图来标识 ChannelHandler 的生命周期</p><p><img src="/images/netty_handler_lifecycle.png" alt></p><h2 id="ChannelHandler-生命周期各回调方法用法举例"><a href="#ChannelHandler-生命周期各回调方法用法举例" class="headerlink" title="ChannelHandler 生命周期各回调方法用法举例"></a>ChannelHandler 生命周期各回调方法用法举例</h2><p>Netty 对于一条连接的在各个不同状态下回调方法的定义还是蛮细致的，这个好处就在于我们能够基于这个机制写出扩展性较好的应用程序。</p><h3 id="ChannelInitializer-的实现原理"><a href="#ChannelInitializer-的实现原理" class="headerlink" title="ChannelInitializer 的实现原理"></a>ChannelInitializer 的实现原理</h3><p>仔细翻看一下我们的服务端启动代码，我们在给新连接定义 handler 的时候，其实只是通过 childHandler() 方法给新连接设置了一个 handler，这个 handler 就是 ChannelInitializer，而在 ChannelInitializer 的 initChannel() 方法里面，我们通过拿到 channel 对应的 pipeline，然后往里面塞 handler</p><blockquote><p>NettyServer.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.childHandler(<span class="keyword">new</span> ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(NioSocketChannel ch)</span> </span>&#123;</span><br><span class="line">        ch.pipeline().addLast(<span class="keyword">new</span> LifeCyCleTestHandler());</span><br><span class="line">        ch.pipeline().addLast(<span class="keyword">new</span> PacketDecoder());</span><br><span class="line">        ch.pipeline().addLast(<span class="keyword">new</span> LoginRequestHandler());</span><br><span class="line">        ch.pipeline().addLast(<span class="keyword">new</span> MessageRequestHandler());</span><br><span class="line">        ch.pipeline().addLast(<span class="keyword">new</span> PacketEncoder());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这里的 ChannelInitializer 其实就利用了 Netty 的 handler 生命周期中 channelRegistered() 与 handlerAdded() 两个特性，我们简单翻一翻 ChannelInitializer 这个类的源代码：</p><blockquote><p>ChannelInitializer.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(C ch)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">channelRegistered</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    initChannel(ctx);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerAdded</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (ctx.channel().isRegistered()) &#123;</span><br><span class="line">        initChannel(ctx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">initChannel</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initMap.putIfAbsent(ctx, Boolean.TRUE) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        initChannel((C) ctx.channel());</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，我把非重点代码略去，逻辑会更加清晰一些</p><ul><li><p>ChannelInitializer 定义了一个抽象的方法 initChannel()，这个抽象方法由我们自行实现，我们在服务端启动的流程里面的实现逻辑就是往 pipeline 里面塞我们的 handler 链</p></li><li><p>handlerAdded() 和 channelRegistered() 方法，都会尝试去调用 initChannel() 方法，initChannel() 使用 putIfAbsent() 来防止 initChannel() 被调用多次</p></li><li><p>如果你 debug 了 ChannelInitializer 的上述两个方法，你会发现，在 handlerAdded() 方法被调用的时候，channel 其实已经和某个线程绑定上了，所以，就我们的应用程序来说，这里的 channelRegistered() 其实是多余的，那为什么这里还要尝试调用一次呢？ 猜测应该是担心我们自己写了个类继承自 ChannelInitializer，然后覆盖掉了 handlerAdded() 方法，这样即使覆盖掉，在 channelRegistered() 方法里面还有机会再调一次 initChannel()，把我们自定义的 handler 都添加到 pipeline 中去。</p></li></ul><h3 id="handlerAdded-与-handlerRemoved"><a href="#handlerAdded-与-handlerRemoved" class="headerlink" title="handlerAdded() 与 handlerRemoved()"></a>handlerAdded() 与 handlerRemoved()</h3><p>这两个方法通常可以用在一些资源的申请和释放</p><h3 id="channelActive-与-channelInActive"><a href="#channelActive-与-channelInActive" class="headerlink" title="channelActive() 与 channelInActive()"></a>channelActive() 与 channelInActive()</h3><p>对我们的应用程序来说，这两个方法表明的含义是 TCP 连接的建立与释放，通常我们在这两个回调里面统计单机的连接数，channelActive() 被调用，连接数加一，channelInActive() 被调用，连接数减一</p><p>另外，我们也可以在 channelActive() 方法中，实现对客户端连接 ip 黑白名单的过滤，具体这里就不展开了</p><h3 id="channelRead"><a href="#channelRead" class="headerlink" title="channelRead()"></a>channelRead()</h3><p>我们在前面小节讲拆包粘包原理，服务端根据自定义协议来进行拆包，其实就是在这个方法里面，每次读到一定的数据，都会累加到一个容器里面，然后判断是否能够拆出来一个完整的数据包，如果够的话就拆了之后，往下进行传递，这里就不过多展开，感兴趣的同学可以阅读一下: <a href="https://www.jianshu.com/p/dc26e944da95" target="_blank" rel="noopener">netty源码分析之拆包器的奥秘</a></p><h3 id="channelReadComplete"><a href="#channelReadComplete" class="headerlink" title="channelReadComplete()"></a>channelReadComplete()</h3><p>每次向客户端写数据的时候，都通过 writeAndFlush() 的方法写并刷新到底层，其实这种方式不是特别高效，我们可以在之前调用 writeAndFlush() 的地方都调用 write() 方法，然后在这个方面里面调用 ctx.channel().flush() 方法，相当于一个批量刷新的机制，当然，如果你对性能要求没那么高，writeAndFlush() 足矣。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>摘自：<a href="https://juejin.im/book/5b4bc28bf265da0f60130116" target="_blank" rel="noopener">Netty 入门与实战：仿写微信 IM 即时通讯系统</a></p><p>参考：<br><a href="https://www.jianshu.com/p/dc26e944da95" target="_blank" rel="noopener">netty源码分析之拆包器的奥秘</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ChannelHandler有很多回调方法，这些回调方法的执行是有顺序的，而这个执行顺序可以称为 ChannelHandler 的生命周期。&lt;/p&gt;
&lt;p&gt; 代码：&lt;a href=&quot;https://github.com/austin-brant/netty-im&quot; targ
      
    
    </summary>
    
      <category term="Netty" scheme="http://yoursite.com/categories/Netty/"/>
    
      <category term="基础" scheme="http://yoursite.com/categories/Netty/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Netty" scheme="http://yoursite.com/tags/Netty/"/>
    
      <category term="网络IO" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9CIO/"/>
    
  </entry>
  
  <entry>
    <title>Netty数据传输载体ByteBuf简介</title>
    <link href="http://yoursite.com/2019/11/12/Netty%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E8%BD%BD%E4%BD%93ByteBuf%E7%AE%80%E4%BB%8B/"/>
    <id>http://yoursite.com/2019/11/12/Netty数据传输载体ByteBuf简介/</id>
    <published>2019-11-12T11:39:55.000Z</published>
    <updated>2019-11-20T12:20:20.620Z</updated>
    
    <content type="html"><![CDATA[<p>代码：<a href="https://github.com/austin-brant/netty-im" target="_blank" rel="noopener">https://github.com/austin-brant/netty-im</a></p><h2 id="ByteBuf结构"><a href="#ByteBuf结构" class="headerlink" title="ByteBuf结构"></a>ByteBuf结构</h2><p>首先，我们先来了解一下 ByteBuf 的结构<br><img src="/images/netty_bytebuf.png" alt></p><p>以上就是一个 ByteBuf 的结构图，从上面这幅图可以看到</p><ul><li><p>ByteBuf 是一个字节容器，容器里面的的数据分为三个部分:</p><ul><li><p>第一个部分是已经丢弃的字节，这部分数据是无效的；</p></li><li><p>第二部分是可读字节，这部分数据是 ByteBuf 的主体数据， 从 ByteBuf 里面读取的数据都来自这一部分;最后一部分的数据是可写字节，所有写到 ByteBuf 的数据都会写到这一段。</p></li><li><p>第三部分虚线表示的是该 ByteBuf 最多还能扩容多少容量</p></li></ul></li><li><p>以上三段内容是被两个指针给划分出来的，从左到右，依次是<code>读指针（readerIndex）</code>、<code>写指针（writerIndex）</code>，然后还有一个变量 <code>capacity</code>，表示 ByteBuf 底层内存的总容量;</p></li><li><p>从 ByteBuf 中每读取一个字节，readerIndex 自增1，ByteBuf 里面总共有 <code>writerIndex-readerIndex</code> 个字节可读, 由此可以推论出当 <code>readerIndex</code> 与 <code>writerIndex</code> 相等的时候，ByteBuf 不可读</p></li><li><p>写数据是从 <code>writerIndex</code> 指向的部分开始写，每写一个字节，<code>writerIndex</code> 自增1，直到增到 <code>capacity</code>，这个时候，表示 ByteBuf 已经不可写了</p></li><li><p>ByteBuf 里面其实还有一个参数 <code>maxCapacity</code>，当向 ByteBuf 写数据的时候，如果容量不足，那么这个时候可以进行扩容，直到 capacity 扩容到 maxCapacity，超过 maxCapacity 就会报错</p></li></ul><p>Netty使用ByteBuf这个数据结构可以有效地区分可读数据和可写数据，读写之间相互没有冲突，当然，ByteBuf只是对二进制数据的抽象, Netty关于数据读写只认ByteBuf，下面，我们就来学习一下 ByteBuf 常用的 API.</p><h2 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h2><h3 id="容量-API"><a href="#容量-API" class="headerlink" title="容量 API"></a>容量 API</h3><pre><code>capacity()</code></pre><p>表示 ByteBuf 底层占用了多少字节的内存（包括丢弃的字节、可读字节、可写字节），不同的底层实现机制有不同的计算方式，后面我们讲 ByteBuf 的分类的时候会讲到</p><pre><code>maxCapacity()</code></pre><p>表示 ByteBuf 底层最大能够占用多少字节的内存，当向 ByteBuf 中写数据的时候，如果发现容量不足，则进行扩容，直到扩容到 maxCapacity，超过这个数，就抛异常</p><pre><code>readableBytes() 与 isReadable()</code></pre><p>readableBytes() 表示 ByteBuf 当前可读的字节数，它的值等于 writerIndex-readerIndex，如果两者相等，则不可读，isReadable() 方法返回 false</p><pre><code>writableBytes()、 isWritable() 与 maxWritableBytes()</code></pre><p>writableBytes() 表示 ByteBuf 当前可写的字节数，它的值等于 capacity - writerIndex，如果两者相等，则表示不可写，isWritable() 返回 false，但是这个时候，并不代表不能往 ByteBuf 中写数据了， 如果发现往 ByteBuf 中写数据写不进去的话，Netty 会自动扩容 ByteBuf，直到扩容到底层的内存大小为 maxCapacity，而 maxWritableBytes() 就表示可写的最大字节数，它的值等于 maxCapacity - writerIndex。</p><h3 id="读写指针相关的API"><a href="#读写指针相关的API" class="headerlink" title="读写指针相关的API"></a>读写指针相关的API</h3><pre><code>readerIndex() 与 readerIndex(int)</code></pre><p>前者表示返回当前的读指针 readerIndex, 后者表示设置读指针</p><pre><code>writeIndex() 与 writeIndex(int)</code></pre><p>前者表示返回当前的写指针 writerIndex, 后者表示设置写指针</p><pre><code>markReaderIndex() 与 resetReaderIndex()</code></pre><p>前者表示把当前的读指针保存起来，后者表示把当前的读指针恢复到之前保存的值，下面两段代码是等价的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码片段1</span></span><br><span class="line"><span class="keyword">int</span> readerIndex = buffer.readerIndex();</span><br><span class="line"><span class="comment">// .. 其他操作</span></span><br><span class="line">buffer.readerIndex(readerIndex);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 代码片段二</span></span><br><span class="line">buffer.markReaderIndex();</span><br><span class="line"><span class="comment">// .. 其他操作</span></span><br><span class="line">buffer.resetReaderIndex();</span><br></pre></td></tr></table></figure><p>希望大家多多使用代码片段二这种方式，不需要自己定义变量，无论 buffer 当作参数传递到哪里，调用 resetReaderIndex() 都可以恢复到之前的状态，在解析自定义协议的数据包的时候非常常见，推荐大家使用这一对API.</p><pre><code>markWriterIndex() 与 resetWriterIndex()</code></pre><p>这一对 API 的作用与上述一对 API 类似，这里不再赘述.</p><h3 id="读写API"><a href="#读写API" class="headerlink" title="读写API"></a>读写API</h3><p>本质上，关于ByteBuf的读写都可以看作从指针开始的地方开始读写数据</p><pre><code>writeBytes(byte[] src) 与 buffer.readBytes(byte[] dst)</code></pre><p>writeBytes() 表示把字节数组 src 里面的数据全部写到 ByteBuf，而 readBytes() 指的是把 ByteBuf 里面的数据全部读取到 dst，这里 dst 字节数组的大小通常等于 readableBytes()，而 src 字节数组大小的长度通常小于等于 writableBytes()</p><pre><code>writeByte(byte b) 与 buffer.readByte()</code></pre><p>writeByte() 表示往 ByteBuf 中写一个字节，而 buffer.readByte() 表示从 ByteBuf 中读取一个字节，类似的 API 还有 <code>writeBoolean()</code>、<code>writeChar()</code>、<code>writeShort()</code>、<code>writeInt()</code>、<code>writeLong()</code>、<code>writeFloat()</code>、<code>writeDouble()</code> 与 <code>readBoolean()</code>、<code>readChar()</code>、<code>readShort()</code>、<code>readInt()</code>、<code>readLong()</code>、<code>readFloat()</code>、<code>readDouble()</code> 这里就不一一赘述.</p><p>与读写 API 类似的 API 还有 <code>getBytes</code>、<code>getByte()</code> 与 <code>setBytes()</code>、<code>setByte()</code> 系列，唯一的区别就是 <font color="red"><strong>get/set 不会改变读写指针，而 read/write 会改变读写指针</strong></font>，这点在解析数据的时候千万要注意</p><pre><code>release() 与 retain()</code></pre><p>由于 Netty 使用了堆外内存，而堆外内存是不被 jvm 直接管理的，也就是说申请到的内存无法被垃圾回收器直接回收，所以需要我们手动回收。有点类似于c语言里面，申请到的内存必须手工释放，否则会造成内存泄漏。</p><p>Netty 的 ByteBuf 是通过 <strong>引用计数</strong> 的方式管理的，如果一个 ByteBuf 没有地方被引用到，需要回收底层内存。默认情况下，<strong>当创建完一个 ByteBuf，它的引用为1，然后每次调用 retain() 方法， 它的引用就加一， release() 方法原理是将引用计数减一</strong>，减完之后如果发现引用计数为0，则直接回收 ByteBuf 底层的内存。</p><pre><code>slice()、duplicate()、copy()</code></pre><p>这三个方法通常情况会放到一起比较，这三者的返回值都是一个新的 ByteBuf 对象</p><ul><li><p>slice() 方法从原始 ByteBuf 中截取一段，这段数据是从 readerIndex 到 writeIndex，同时，返回的新的 ByteBuf 的最大容量 maxCapacity 为原始 ByteBuf 的 <code>readableBytes()</code></p></li><li><p>duplicate() 方法把整个 ByteBuf 都截取出来，包括所有的数据，指针信息</p></li><li><p>slice() 方法与 duplicate() 方法比较：</p><ul><li><p><strong>相同点：</strong> <strong>底层内存以及引用计数与原始的 ByteBuf 共享</strong>，也就是说经过 slice() 或者 duplicate() 返回的 ByteBuf 调用 write 系列方法都会影响到 原始的 ByteBuf，但是它们都<strong>维持着与原始 ByteBuf 相同的内存引用计数和不同的读写指针</strong></p></li><li><p><strong>不同点：</strong>slice() 只截取从 readerIndex 到 writerIndex 之间的数据，它返回的 ByteBuf 的最大容量被限制到 原始 ByteBuf 的 readableBytes(), 而 duplicate() 是把整个 ByteBuf 都与原始的 ByteBuf 共享</p></li></ul></li><li><p>slice() 方法与 duplicate() 方法不会拷贝数据，它们只是通过改变读写指针来改变读写的行为，而 copy() 会直接从原始的 ByteBuf 中拷贝所有的信息，包括读写指针以及底层对应的数据，因此， <strong>copy() 返回的 ByteBuf 中写数据不会影响到原始的 ByteBuf</strong></p></li><li><p>slice() 和 duplicate() 不会改变 ByteBuf 的引用计数，所以原始的 ByteBuf 调用 release() 之后发现引用计数为零，就开始释放内存，调用这两个方法返回的 ByteBuf 也会被释放，这个时候如果再对它们进行读写，就会报错。因此，我们可以通过调用一次 retain() 方法 来增加引用，表示它们对应的底层的内存多了一次引用，引用计数为2，在释放内存的时候，需要调用两次 release() 方法，将引用计数降到零，才会释放内存</p></li><li><p>这三个方法均维护着自己的读写指针，与原始的 ByteBuf 的读写指针无关，相互之间不受影响</p></li></ul><blockquote><p>retainedSlice() 与 retainedDuplicate()</p></blockquote><p>它们的作用是在截取内存片段的同时，增加内存的引用计数，分别与下面两段代码等价</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// retainedSlice 等价于</span></span><br><span class="line">slice().retain();</span><br><span class="line"></span><br><span class="line"><span class="comment">// retainedDuplicate() 等价于</span></span><br><span class="line">duplicate().retain()</span><br></pre></td></tr></table></figure><p>使用到 slice 和 duplicate 方法的时候，千万要理清 <strong>内存共享，引用计数共享，读写指针不共享</strong> 几个概念，下面举两个常见的易犯错的例子</p><ul><li>多次释放</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Buffer buffer = xxx;</span><br><span class="line">doWith(buffer);</span><br><span class="line"><span class="comment">// 一次释放</span></span><br><span class="line">buffer.release();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWith</span><span class="params">(Bytebuf buffer)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...    </span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 没有增加引用计数</span></span><br><span class="line">    Buffer slice = buffer.slice();</span><br><span class="line">    </span><br><span class="line">    foo(slice);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(ByteBuf buffer)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// read from buffer</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重复释放</span></span><br><span class="line">    buffer.release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 doWith 有的时候是用户自定义的方法，有的时候是 Netty 的回调方法，比如 channelRead() 等等</p><ul><li>不释放造成内存泄漏</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Buffer buffer = xxx;</span><br><span class="line">doWith(buffer);</span><br><span class="line"><span class="comment">// 引用计数为2，调用 release 方法之后，引用计数为1，无法释放内存 </span></span><br><span class="line">buffer.release();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWith</span><span class="params">(Bytebuf buffer)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...       </span></span><br><span class="line">    <span class="comment">// 增加引用计数</span></span><br><span class="line">    Buffer slice = buffer.retainedSlice();</span><br><span class="line">    foo(slice);</span><br><span class="line">    <span class="comment">// 没有调用 release</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(ByteBuf buffer)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// read from buffer</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想要避免以上两种情况发生，大家只需要记得一点，在一个函数体里面，只要增加了引用计数（包括 ByteBuf 的创建和手动调用 retain() 方法），就必须调用 release() 方法.</p><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p>了解了以上 API 之后，最后我们使用上述 API 来 写一个简单的 demo。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteBufTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ByteBuf buffer = ByteBufAllocator.DEFAULT.buffer(<span class="number">9</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        print(<span class="string">"allocate ByteBuf(9, 100)"</span>, buffer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// write 方法改变写指针，写完之后写指针未到 capacity 的时候，buffer 仍然可写</span></span><br><span class="line">        buffer.writeBytes(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;);</span><br><span class="line">        print(<span class="string">"writeBytes(1,2,3,4)"</span>, buffer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// write 方法改变写指针，写完之后写指针未到 capacity 的时候，buffer 仍然可写, 写完 int 类型之后，写指针增加4</span></span><br><span class="line">        buffer.writeInt(<span class="number">12</span>);</span><br><span class="line">        print(<span class="string">"writeInt(12)"</span>, buffer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// write 方法改变写指针, 写完之后写指针等于 capacity 的时候，buffer 不可写</span></span><br><span class="line">        buffer.writeBytes(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">5</span>&#125;);</span><br><span class="line">        print(<span class="string">"writeBytes(5)"</span>, buffer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// write 方法改变写指针，写的时候发现 buffer 不可写则开始扩容，扩容之后 capacity 随即改变</span></span><br><span class="line">        buffer.writeBytes(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">6</span>&#125;);</span><br><span class="line">        print(<span class="string">"writeBytes(6)"</span>, buffer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// get 方法不改变读写指针</span></span><br><span class="line">        System.out.println(<span class="string">"getByte(3) return: "</span> + buffer.getByte(<span class="number">3</span>));</span><br><span class="line">        System.out.println(<span class="string">"getShort(3) return: "</span> + buffer.getShort(<span class="number">3</span>));</span><br><span class="line">        System.out.println(<span class="string">"getInt(3) return: "</span> + buffer.getInt(<span class="number">3</span>));</span><br><span class="line">        print(<span class="string">"getByte()"</span>, buffer);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// set 方法不改变读写指针</span></span><br><span class="line">        buffer.setByte(buffer.readableBytes() + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        print(<span class="string">"setByte()"</span>, buffer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// read 方法改变读指针</span></span><br><span class="line">        <span class="keyword">byte</span>[] dst = <span class="keyword">new</span> <span class="keyword">byte</span>[buffer.readableBytes()];</span><br><span class="line">        buffer.readBytes(dst);</span><br><span class="line">        print(<span class="string">"readBytes("</span> + dst.length + <span class="string">")"</span>, buffer);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String action, ByteBuf buffer)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"after ==========="</span> + action + <span class="string">"============"</span>);</span><br><span class="line">        System.out.println(<span class="string">"capacity(): "</span> + buffer.capacity());</span><br><span class="line">        System.out.println(<span class="string">"maxCapacity(): "</span> + buffer.maxCapacity());</span><br><span class="line">        System.out.println(<span class="string">"readerIndex(): "</span> + buffer.readerIndex());</span><br><span class="line">        System.out.println(<span class="string">"readableBytes(): "</span> + buffer.readableBytes());</span><br><span class="line">        System.out.println(<span class="string">"isReadable(): "</span> + buffer.isReadable());</span><br><span class="line">        System.out.println(<span class="string">"writerIndex(): "</span> + buffer.writerIndex());</span><br><span class="line">        System.out.println(<span class="string">"writableBytes(): "</span> + buffer.writableBytes());</span><br><span class="line">        System.out.println(<span class="string">"isWritable(): "</span> + buffer.isWritable());</span><br><span class="line">        System.out.println(<span class="string">"maxWritableBytes(): "</span> + buffer.maxWritableBytes());</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">after ===========allocate ByteBuf(9, 100)============</span><br><span class="line">capacity(): 9</span><br><span class="line">maxCapacity(): 100</span><br><span class="line">readerIndex(): 0</span><br><span class="line">readableBytes(): 0</span><br><span class="line">isReadable(): false</span><br><span class="line">writerIndex(): 0</span><br><span class="line">writableBytes(): 9</span><br><span class="line">isWritable(): true</span><br><span class="line">maxWritableBytes(): 100</span><br><span class="line"></span><br><span class="line">after ===========writeBytes(1,2,3,4)============</span><br><span class="line">capacity(): 9</span><br><span class="line">maxCapacity(): 100</span><br><span class="line">readerIndex(): 0</span><br><span class="line">readableBytes(): 4</span><br><span class="line">isReadable(): true</span><br><span class="line">writerIndex(): 4</span><br><span class="line">writableBytes(): 5</span><br><span class="line">isWritable(): true</span><br><span class="line">maxWritableBytes(): 96</span><br><span class="line"></span><br><span class="line">after ===========writeInt(12)============</span><br><span class="line">capacity(): 9</span><br><span class="line">maxCapacity(): 100</span><br><span class="line">readerIndex(): 0</span><br><span class="line">readableBytes(): 8</span><br><span class="line">isReadable(): true</span><br><span class="line">writerIndex(): 8</span><br><span class="line">writableBytes(): 1</span><br><span class="line">isWritable(): true</span><br><span class="line">maxWritableBytes(): 92</span><br><span class="line"></span><br><span class="line">after ===========writeBytes(5)============</span><br><span class="line">capacity(): 9</span><br><span class="line">maxCapacity(): 100</span><br><span class="line">readerIndex(): 0</span><br><span class="line">readableBytes(): 9</span><br><span class="line">isReadable(): true</span><br><span class="line">writerIndex(): 9</span><br><span class="line">writableBytes(): 0</span><br><span class="line">isWritable(): false</span><br><span class="line">maxWritableBytes(): 91</span><br><span class="line"></span><br><span class="line">after ===========writeBytes(6)============</span><br><span class="line">capacity(): 64</span><br><span class="line">maxCapacity(): 100</span><br><span class="line">readerIndex(): 0</span><br><span class="line">readableBytes(): 10</span><br><span class="line">isReadable(): true</span><br><span class="line">writerIndex(): 10</span><br><span class="line">writableBytes(): 54</span><br><span class="line">isWritable(): true</span><br><span class="line">maxWritableBytes(): 90</span><br><span class="line"></span><br><span class="line">getByte(3) return: 4</span><br><span class="line">getShort(3) return: 1024</span><br><span class="line">getInt(3) return: 67108864</span><br><span class="line">after ===========getByte()============</span><br><span class="line">capacity(): 64</span><br><span class="line">maxCapacity(): 100</span><br><span class="line">readerIndex(): 0</span><br><span class="line">readableBytes(): 10</span><br><span class="line">isReadable(): true</span><br><span class="line">writerIndex(): 10</span><br><span class="line">writableBytes(): 54</span><br><span class="line">isWritable(): true</span><br><span class="line">maxWritableBytes(): 90</span><br><span class="line"></span><br><span class="line">after ===========setByte()============</span><br><span class="line">capacity(): 64</span><br><span class="line">maxCapacity(): 100</span><br><span class="line">readerIndex(): 0</span><br><span class="line">readableBytes(): 10</span><br><span class="line">isReadable(): true</span><br><span class="line">writerIndex(): 10</span><br><span class="line">writableBytes(): 54</span><br><span class="line">isWritable(): true</span><br><span class="line">maxWritableBytes(): 90</span><br><span class="line"></span><br><span class="line">after ===========readBytes(10)============</span><br><span class="line">capacity(): 64</span><br><span class="line">maxCapacity(): 100</span><br><span class="line">readerIndex(): 10</span><br><span class="line">readableBytes(): 0</span><br><span class="line">isReadable(): false</span><br><span class="line">writerIndex(): 10</span><br><span class="line">writableBytes(): 54</span><br><span class="line">isWritable(): true</span><br><span class="line">maxWritableBytes(): 90</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>Netty 对二进制数据的抽象 ByteBuf 的结构，本质原理就是，它引用了一段内存，这段内存可以是堆内也可以是堆外的，然后用引用计数来控制这段内存是否需要被释放，使用读写指针来控制对 ByteBuf 的读写，可以理解为是外观模式的一种使用</p></li><li><p>基于读写指针和容量、最大可扩容容量，衍生出一系列的读写方法，要注意 read/write 与 get/set 的区别</p></li><li><p>多个 ByteBuf 可以引用同一段内存，通过引用计数来控制内存的释放，遵循谁 retain() 谁 release() 的原则</p></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[转载] <a href="https://juejin.im/book/5b4bc28bf265da0f60130116/section/5b6a1a9cf265da0f87595521" target="_blank" rel="noopener">数据传输载体 ByteBuf 介绍</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;代码：&lt;a href=&quot;https://github.com/austin-brant/netty-im&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/austin-brant/netty-im&lt;/a&gt;&lt;/p&gt;
&lt;h2
      
    
    </summary>
    
      <category term="Netty" scheme="http://yoursite.com/categories/Netty/"/>
    
      <category term="基础" scheme="http://yoursite.com/categories/Netty/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Netty" scheme="http://yoursite.com/tags/Netty/"/>
    
      <category term="网络IO" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9CIO/"/>
    
  </entry>
  
  <entry>
    <title>Mysql性能分析工具</title>
    <link href="http://yoursite.com/2019/10/09/Mysql%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/"/>
    <id>http://yoursite.com/2019/10/09/Mysql性能分析工具/</id>
    <published>2019-10-09T06:47:36.000Z</published>
    <updated>2019-10-09T07:29:07.357Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>MySQL 提供了一个 EXPLAIN 命令, 它可以对 <font color="red"><strong>SELECT</strong></font> 语句进行分析, 并输出 <font color="red"><strong>SELECT</strong></font> 执行的详细信息, 以供开发人员针对性优化.</p><p>EXPLAIN 命令用法十分简单, 在 SELECT 语句前加上 Explain 就可以了, 例如:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">from</span> user_info <span class="keyword">WHERE</span> <span class="keyword">id</span> &lt; <span class="number">300</span>;</span><br></pre></td></tr></table></figure><h2 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `user_info` (</span><br><span class="line">  `id` bigint(20) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `name` varchar(50) NOT NULL DEFAULT &apos;&apos;,</span><br><span class="line">  `age` int(11) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  KEY `name_index` (`name`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;</span><br><span class="line"></span><br><span class="line">INSERT INTO user_info (name, age) VALUES (&apos;xys&apos;, 20);</span><br><span class="line">INSERT INTO user_info (name, age) VALUES (&apos;a&apos;, 21);</span><br><span class="line">INSERT INTO user_info (name, age) VALUES (&apos;b&apos;, 23);</span><br><span class="line">INSERT INTO user_info (name, age) VALUES (&apos;c&apos;, 50);</span><br><span class="line">INSERT INTO user_info (name, age) VALUES (&apos;d&apos;, 15);</span><br><span class="line">INSERT INTO user_info (name, age) VALUES (&apos;e&apos;, 20);</span><br><span class="line">INSERT INTO user_info (name, age) VALUES (&apos;f&apos;, 21);</span><br><span class="line">INSERT INTO user_info (name, age) VALUES (&apos;g&apos;, 23);</span><br><span class="line">INSERT INTO user_info (name, age) VALUES (&apos;h&apos;, 50);</span><br><span class="line">INSERT INTO user_info (name, age) VALUES (&apos;i&apos;, 15);</span><br><span class="line"></span><br><span class="line">CREATE TABLE `order_info` (</span><br><span class="line">  `id` bigint(20) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `user_id` bigint(20) DEFAULT NULL,</span><br><span class="line">  `product_name` varchar(50) NOT NULL DEFAULT &apos;&apos;,</span><br><span class="line">  `productor` varchar(30) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  KEY `user_product_detail_index` (`user_id`,`product_name`,`productor`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;</span><br><span class="line"></span><br><span class="line">INSERT INTO order_info (user_id, product_name, productor) VALUES (1, &apos;p1&apos;, &apos;WHH&apos;);</span><br><span class="line">INSERT INTO order_info (user_id, product_name, productor) VALUES (1, &apos;p2&apos;, &apos;WL&apos;);</span><br><span class="line">INSERT INTO order_info (user_id, product_name, productor) VALUES (1, &apos;p1&apos;, &apos;DX&apos;);</span><br><span class="line">INSERT INTO order_info (user_id, product_name, productor) VALUES (2, &apos;p1&apos;, &apos;WHH&apos;);</span><br><span class="line">INSERT INTO order_info (user_id, product_name, productor) VALUES (2, &apos;p5&apos;, &apos;WL&apos;);</span><br><span class="line">INSERT INTO order_info (user_id, product_name, productor) VALUES (3, &apos;p3&apos;, &apos;MA&apos;);</span><br><span class="line">INSERT INTO order_info (user_id, product_name, productor) VALUES (4, &apos;p1&apos;, &apos;WHH&apos;);</span><br><span class="line">INSERT INTO order_info (user_id, product_name, productor) VALUES (6, &apos;p1&apos;, &apos;WHH&apos;);</span><br><span class="line">INSERT INTO order_info (user_id, product_name, productor) VALUES (9, &apos;p8&apos;, &apos;TE&apos;);</span><br></pre></td></tr></table></figure><h2 id="EXPLAIN-输出格式"><a href="#EXPLAIN-输出格式" class="headerlink" title="EXPLAIN 输出格式"></a>EXPLAIN 输出格式</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from user_info where id = 2;</span><br><span class="line">+<span class="comment">----+-------------+-----------+-------+---------------+---------+---------+-------+------+-------+</span></span><br><span class="line">| id | select_type | table     | type  | possible_keys | key     | key_len | ref   | rows | Extra |</span><br><span class="line">+<span class="comment">----+-------------+-----------+-------+---------------+---------+---------+-------+------+-------+</span></span><br><span class="line">|  1 | SIMPLE      | user_info | const | PRIMARY       | PRIMARY | 8       | const |    1 |       |</span><br><span class="line">+<span class="comment">----+-------------+-----------+-------+---------------+---------+---------+-------+------+-------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>各列的含义如下:</p><ul><li><p><strong>id</strong>: SELECT 查询的标识符. 每个 SELECT 都会自动分配一个唯一的标识符.</p></li><li><p><strong>select_type</strong>: SELECT 查询的类型.</p></li><li><p><strong>table</strong>: 表示查询涉及的表或衍生表</p></li><li><p><em>partitions</em>: 匹配的分区</p></li><li><p><strong>type</strong>: join 类型</p></li><li><p><strong>possible_keys</strong>: 表示 MySQL 在查询时, 能够使用到的索引. 注意, 即使有些索引在 possible_keys 中出现, 但是并不表示此索引会真正地被 MySQL 使用到. MySQL 在查询时具体使用了哪些索引, 由 key 字段决定.</p></li><li><p><strong>key</strong>: 此次查询中真正使用到的索引.</p></li><li><p><strong>ref</strong>: 哪个字段或常数与 key 一起被使用</p></li><li><p><strong>rows</strong>: MySQL查询优化器根据统计信息, 估算SQL要查找到结果集需要扫描读取的数据行数.<br>这个值非常直观显示 SQL 的效率好坏, 原则上 rows 越少越好.</p></li><li><p><em>filtered</em>: 表示此查询条件所过滤的数据的百分比</p></li><li><p><strong>extra</strong>: 额外的信息</p></li></ul><h2 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h2><h3 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h3><p>select_type 表示了查询的类型, 它的常用取值有:</p><ul><li><p>SIMPLE, 表示此查询不包含 UNION 查询或子查询</p></li><li><p>PRIMARY, 表示此查询是最外层的查询</p></li><li><p>UNION, 表示此查询是 UNION 的第二个或随后的查询</p></li><li><p>DEPENDENT UNION, UNION 中的第二个或后面的查询语句, 取决于外面的查询</p></li><li><p>UNION RESULT, UNION 的结果</p></li><li><p>SUBQUERY, 子查询中的第一个 SELECT</p></li><li><p>DEPENDENT SUBQUERY: 子查询中的第一个 SELECT, 取决于外面的查询. 即子查询依赖于外层查询的结果.</p></li></ul><p>最常见的查询类别应该是 SIMPLE 了, 比如当我们的查询没有子查询, 也没有 UNION 查询时, 那么通常就是 SIMPLE 类型, 例如:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from user_info where id = 2;</span><br><span class="line">+<span class="comment">----+-------------+-----------+-------+---------------+---------+---------+-------+------+-------+</span></span><br><span class="line">| id | select_type | table     | type  | possible_keys | key     | key_len | ref   | rows | Extra |</span><br><span class="line">+<span class="comment">----+-------------+-----------+-------+---------------+---------+---------+-------+------+-------+</span></span><br><span class="line">|  1 | SIMPLE      | user_info | const | PRIMARY       | PRIMARY | 8       | const |    1 |       |</span><br><span class="line">+<span class="comment">----+-------------+-----------+-------+---------------+---------+---------+-------+------+-------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>如果我们使用了 UNION 查询, 那么 EXPLAIN 输出 的结果类似如下:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN (SELECT * FROM user_info  WHERE id IN (1, 2, 3)) UNION (SELECT * FROM user_info WHERE id IN (3, 4, 5));</span><br><span class="line">+<span class="comment">----+--------------+------------+-------+---------------+---------+---------+------+------+-------------+</span></span><br><span class="line">| id | select_type  | table      | type  | possible_keys | key     | key_len | ref  | rows | Extra       |</span><br><span class="line">+<span class="comment">----+--------------+------------+-------+---------------+---------+---------+------+------+-------------+</span></span><br><span class="line">|  1 | PRIMARY      | user_info  | range | PRIMARY       | PRIMARY | 8       | NULL |    3 | Using where |</span><br><span class="line">|  2 | UNION        | user_info  | range | PRIMARY       | PRIMARY | 8       | NULL |    3 | Using where |</span><br><span class="line">| NULL | UNION RESULT | &lt;union1,2&gt; | ALL   | NULL   | NULL    | NULL    | NULL | NULL   |             |</span><br><span class="line">+<span class="comment">----+--------------+------------+-------+---------------+---------+---------+------+------+-------------+</span></span><br><span class="line">3 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p>type 字段比较重要, 它提供了判断查询是否高效的重要依据依据. 通过 type 字段, 我们判断此次查询是 <strong>全表扫描</strong> 还是 <strong>索引扫描</strong> 等.</p><p>type 常用类型取值有:</p><ul><li><p><strong>system</strong>: 表中只有一条数据. 这个类型是特殊的 const 类型.</p></li><li><p><strong>const</strong>: 针对主键或唯一索引的等值查询扫描, 最多只返回一行数据. const 查询速度非常快, 因为它仅仅读取一次即可.<br>例如下面的这个查询, 它使用了主键索引, 因此 type 就是 const 类型的.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from user_info where id = 2;</span><br><span class="line">+<span class="comment">----+-------------+-----------+-------+---------------+---------+---------+-------+------+-------+</span></span><br><span class="line">| id | select_type | table     | type  | possible_keys | key     | key_len | ref   | rows | Extra |</span><br><span class="line">+<span class="comment">----+-------------+-----------+-------+---------------+---------+---------+-------+------+-------+</span></span><br><span class="line">|  1 | SIMPLE      | user_info | const | PRIMARY       | PRIMARY | 8       | const |    1 |       |</span><br><span class="line">+<span class="comment">----+-------------+-----------+-------+---------------+---------+---------+-------+------+-------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></li><li><p><strong>eq_ref</strong>: 此类型通常出现在多表的 join 查询, 表示对于前表的每一个结果, 都只能匹配到后表的一行结果. 并且查询的比较操作通常是 =, 查询效率较高. 例如:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM user_info, order_info WHERE user_info.id = order_info.user_id;</span><br><span class="line">+<span class="comment">----+-------------+------------+--------+---------------------------+---------------------------+---------+-------------------------+------+-------------+</span></span><br><span class="line">| id | select_type | table      | type   | possible_keys             | key                       | key_len | ref                     | rows | Extra       |</span><br><span class="line">+<span class="comment">----+-------------+------------+--------+---------------------------+---------------------------+---------+-------------------------+------+-------------+</span></span><br><span class="line">|  1 | SIMPLE      | order_info | index  | user_product_detail_index | user_product_detail_index | 254     | NULL                    |    9 | Using index |</span><br><span class="line">|  1 | SIMPLE      | user_info  | eq_ref | PRIMARY                   | PRIMARY                   | 8       | test.order_info.user_id |    1 |             |</span><br><span class="line">+<span class="comment">----+-------------+------------+--------+---------------------------+---------------------------+---------+-------------------------+------+-------------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></li><li><p><strong>ref</strong>: 此类型通常出现在多表的 join 查询, 针对于非唯一或非主键索引, 或者是使用了 <strong>最左前缀</strong> 规则索引的查询.<br>例如下面这个例子中, 就使用到了 ref 类型的查询:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM user_info, order_info WHERE user_info.id = order_info.user_id AND order_info.user_id = 5; </span><br><span class="line">+<span class="comment">----+-------------+------------+-------+---------------------------+---------------------------+---------+-------+------+--------------------------+</span></span><br><span class="line">| id | select_type | table      | type  | possible_keys             | key                       | key_len | ref   | rows | Extra                    |</span><br><span class="line">+<span class="comment">----+-------------+------------+-------+---------------------------+---------------------------+---------+-------+------+--------------------------+</span></span><br><span class="line">|  1 | SIMPLE      | user_info  | const | PRIMARY                   | PRIMARY                   | 8       | const |    1 |                          |</span><br><span class="line">|  1 | SIMPLE      | order_info | ref   | user_product_detail_index | user_product_detail_index | 9       | const |    1 | Using where; Using index |</span><br><span class="line">+<span class="comment">----+-------------+------------+-------+---------------------------+---------------------------+---------+-------+------+--------------------------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure></li><li><p><strong>range</strong>: 表示使用索引范围查询, 通过索引字段范围获取表中部分数据记录. 这个类型通常出现在 =, &lt;&gt;, &gt;, &gt;=, &lt;, &lt;=, IS NULL, &lt;=&gt;, BETWEEN, IN() 操作中.</p><p>  当 type 是 range 时, 那么 EXPLAIN 输出的 ref 字段为 NULL, 并且 key_len 字段是此次查询中使用到的索引的最长的那个.</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    mysql&gt; EXPLAIN SELECT * FROM user_info WHERE id BETWEEN 2 AND 8;</span><br><span class="line">+<span class="comment">----+-------------+-----------+-------+---------------+---------+---------+------+------+-------------+</span></span><br><span class="line">| id | select_type | table     | type  | possible_keys | key     | key_len | ref  | rows | Extra       |</span><br><span class="line">+<span class="comment">----+-------------+-----------+-------+---------------+---------+---------+------+------+-------------+</span></span><br><span class="line">|  1 | SIMPLE      | user_info | range | PRIMARY       | PRIMARY | 8       | NULL |    7 | Using where |</span><br><span class="line">+<span class="comment">----+-------------+-----------+-------+---------------+---------+---------+------+------+-------------+</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p><strong>index</strong>: 表示全索引扫描(full index scan), 和 ALL 类型类似, 只不过 ALL 类型是全表扫描, 而 index 类型则仅仅扫描所有的索引, 而不扫描数据.</p><p>  index 类型通常出现在: 所要查询的数据直接在索引树中就可以获取到, 而不需要扫描数据. 当是这种情况时, Extra 字段 会显示 <strong>Using index</strong>.例如:</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    mysql&gt; EXPLAIN SELECT name FROM  user_info;</span><br><span class="line">+<span class="comment">----+-------------+-----------+-------+---------------+------------+---------+------+------+-------------+</span></span><br><span class="line">| id | select_type | table     | type  | possible_keys | key        | key_len | ref  | rows | Extra       |</span><br><span class="line">+<span class="comment">----+-------------+-----------+-------+---------------+------------+---------+------+------+-------------+</span></span><br><span class="line">|  1 | SIMPLE      | user_info | index | NULL          | name_index | 152     | NULL |   10 | Using index |</span><br><span class="line">+<span class="comment">----+-------------+-----------+-------+---------------+------------+---------+------+------+-------------+</span></span><br></pre></td></tr></table></figure><p>  上面的例子中, 我们查询的 name 字段恰好是一个索引, 因此我们直接从索引中获取数据就可以满足查询的需求了, 而不需要查询表中的数据. 因此这样的情况下, type 的值是 index, 并且 Extra 的值是 Using index.</p></li><li><p><strong>ALL</strong>: 表示全表扫描, 这个类型的查询是性能最差的查询之一. 通常来说, 我们的查询不应该出现 ALL 类型的查询, 因为这样的查询在数据量大的情况下, 对数据库的性能是巨大的灾难. 如一个查询是 ALL 类型查询, 那么一般来说可以对相应的字段添加索引来避免.</p><p>  下面是一个全表扫描的例子, 可以看到, 在全表扫描时, possible_keys 和 key 字段都是 NULL, 表示没有使用到索引, 并且 rows 十分巨大, 因此整个查询效率是十分低下的.</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    mysql&gt; EXPLAIN SELECT age FROM  user_info WHERE age = 20;</span><br><span class="line">+<span class="comment">----+-------------+-----------+------+---------------+------+---------+------+------+-------------+</span></span><br><span class="line">| id | select_type | table     | type | possible_keys | key  | key_len | ref  | rows | Extra       |</span><br><span class="line">+<span class="comment">----+-------------+-----------+------+---------------+------+---------+------+------+-------------+</span></span><br><span class="line">|  1 | SIMPLE      | user_info | ALL  | NULL          | NULL | NULL    | NULL |   10 | Using where |</span><br><span class="line">+<span class="comment">----+-------------+-----------+------+---------------+------+---------+------+------+-------------+</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>type 类型的性能比较</strong></p><p>通常来说, 不同的 type 类型的性能关系如下:</p><blockquote><p>ALL &lt; index &lt; range ~ index_merge &lt; ref &lt; eq_ref &lt; const &lt; system</p></blockquote><p>ALL 类型因为是全表扫描, 因此在相同的查询条件下, 它是速度最慢的.</p><p>而 index 类型的查询虽然不是全表扫描, 但是它扫描了所有的索引, 因此比 ALL 类型的稍快.</p><p>后面的几种类型都是利用了索引来查询数据, 因此可以过滤部分或大部分数据, 因此查询效率就比较高了.</p><h3 id="key-len"><a href="#key-len" class="headerlink" title="key_len"></a>key_len</h3><p>表示查询优化器使用了索引的字节数. 这个字段可以评估组合索引是否完全被使用, 或只有最左部分字段被使用到.<br>key_len 的计算规则如下:</p><ul><li><p>字符串</p><ul><li><p>char(n): n字节长度</p></li><li><p>varchar(n): 如果是 utf8 编码, 则是 (3n + 2) 字节; 如果是 utf8mb4 编码, 则是 (4n + 2） 字节.</p></li></ul></li><li><p>数值类型:</p><ul><li><p>TINYINT: 1字节</p></li><li><p>SMALLINT: 2字节</p></li><li><p>MEDIUMINT: 3字节</p></li><li><p>INT: 4字节</p></li><li><p>BIGINT: 8字节</p></li></ul></li><li><p>时间类型</p><ul><li><p>DATE: 3字节</p></li><li><p>TIMESTAMP: 4字节</p></li><li><p>DATETIME: 8字节</p></li></ul></li><li><p>字段属性: NULL 属性 占用一个字节. 如果一个字段是 NOT NULL 的, 则没有此属性.</p></li></ul><p>我们来举两个简单的例子:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM order_info WHERE user_id &lt; 3 AND product_name = 'p1' AND productor = 'WHH';</span><br><span class="line">+<span class="comment">----+-------------+------------+-------+---------------------------+---------------------------+---------+------+------+--------------------------+</span></span><br><span class="line">| id | select_type | table      | type  | possible_keys             | key                       | key_len | ref  | rows | Extra                    |</span><br><span class="line">+<span class="comment">----+-------------+------------+-------+---------------------------+---------------------------+---------+------+------+--------------------------+</span></span><br><span class="line">|  1 | SIMPLE      | order_info | range | user_product_detail_index | user_product_detail_index | 9       | NULL |    4 | Using where; Using index |</span><br><span class="line">+<span class="comment">----+-------------+------------+-------+---------------------------+---------------------------+---------+------+------+--------------------------+</span></span><br></pre></td></tr></table></figure><p>上面的例子是从表 order_info 中查询指定的内容, 而我们从此表的建表语句中可以知道, 表 order_info 有一个联合索引:</p><blockquote><p>KEY <code>user_product_detail_index</code> (<code>user_id</code>, <code>product_name</code>, <code>productor</code>)</p></blockquote><p>不过此查询语句 <code>WHERE user_id &lt; 3 AND product_name = &#39;p1&#39; AND productor = &#39;WHH&#39;</code> 中, 因为先进行 user_id 的范围查询, 而根据 最左前缀匹配 原则, 当遇到范围查询时, 就停止索引的匹配, 因此实际上我们使用到的索引的字段只有 <code>user_id</code>, 因此在 EXPLAIN 中, 显示的 key_len 为 9. </p><p>因为 user_id 字段是 BIGINT, 占用 8 字节, 而 NULL 属性占用一个字节, 因此总共是 9 个字节. 若我们将user_id 字段改为 BIGINT(20) NOT NULL DEFAULT ‘0’, 则 key_length 应该是8.</p><p>上面因为 最左前缀匹配 原则, 我们的查询仅仅使用到了联合索引的 user_id 字段, 因此效率不算高.</p><p>接下来我们来看一下下一个例子:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM order_info WHERE user_id = 1 AND product_name = 'p1';</span><br><span class="line">+<span class="comment">----+-------------+------------+------+---------------------------+---------------------------+---------+-------------+------+--------------------------+</span></span><br><span class="line">| id | select_type | table      | type | possible_keys             | key                       | key_len | ref         | rows | Extra                    |</span><br><span class="line">+<span class="comment">----+-------------+------------+------+---------------------------+---------------------------+---------+-------------+------+--------------------------+</span></span><br><span class="line">|  1 | SIMPLE      | order_info | ref  | user_product_detail_index | user_product_detail_index | 161     | const,const |    2 | Using where; Using index |</span><br><span class="line">+<span class="comment">----+-------------+------------+------+---------------------------+---------------------------+---------+-------------+------+--------------------------+</span></span><br></pre></td></tr></table></figure><p>这次的查询中, 我们没有使用到范围查询, <code>key_len</code> 的值为 161. 为什么呢? </p><p>因为我们的查询条件 <code>WHERE user_id = 1 AND product_name = &#39;p1&#39;</code> 中, 仅仅使用到了联合索引中的前两个字段, 因此 keyLen(user_id) + keyLen(product_name) = 9 + 50 * 3 + 2 = 161</p><h3 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h3><p>EXplain 中的很多额外的信息会在 Extra 字段显示, 常见的有以下几种内容:</p><ul><li><p>Using filesort<br>当 Extra 中有 Using filesort 时, 表示 MySQL 需额外的排序操作, 不能通过索引顺序达到排序效果. 一般有 Using filesort, 都建议优化去掉, 因为这样的查询 CPU 资源消耗大.</p><p>  例如下面的例子:</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    mysql&gt; EXPLAIN SELECT * FROM order_info ORDER BY product_name;</span><br><span class="line">+<span class="comment">----+-------------+------------+-------+---------------+---------------------------+---------+------+------+-----------------------------+</span></span><br><span class="line">| id | select_type | table      | type  | possible_keys | key                       | key_len | ref  | rows | Extra                       |</span><br><span class="line">+<span class="comment">----+-------------+------------+-------+---------------+---------------------------+---------+------+------+-----------------------------+</span></span><br><span class="line">|  1 | SIMPLE      | order_info | index | NULL          | user_product_detail_index | 254     | NULL |    9 | Using index; Using filesort |</span><br><span class="line">+<span class="comment">----+-------------+------------+-------+---------------+---------------------------+---------+------+------+-----------------------------+</span></span><br></pre></td></tr></table></figure><p>  我们的索引是</p><blockquote><p>KEY <code>user_product_detail_index</code> (<code>user_id</code>, <code>product_name</code>, <code>productor</code>)</p></blockquote><p>  但是上面的查询中根据 <code>product_name</code> 来排序, 因此不能使用索引进行优化, 进而会产生 Using filesort.<br>如果我们将排序依据改为 <code>ORDER BY user_id, product_name</code>, 那么就不会出现 <code>Using filesort</code> 了. 例如:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM order_info ORDER BY user_id, product_name;</span><br><span class="line">+<span class="comment">----+-------------+------------+-------+---------------+---------------------------+---------+------+------+-------------+</span></span><br><span class="line">| id | select_type | table      | type  | possible_keys | key                       | key_len | ref  | rows | Extra       |</span><br><span class="line">+<span class="comment">----+-------------+------------+-------+---------------+---------------------------+---------+------+------+-------------+</span></span><br><span class="line">|  1 | SIMPLE      | order_info | index | NULL          | user_product_detail_index | 254     | NULL |    9 | Using index |</span><br><span class="line">+<span class="comment">----+-------------+------------+-------+---------------+---------------------------+---------+------+------+-------------+</span></span><br></pre></td></tr></table></figure></li><li><p>Using index<br>“覆盖索引扫描”, 表示查询在索引树中就可查找所需数据, 不用扫描表数据文件, 往往说明性能不错</p></li><li><p>Using temporary<br>查询有使用临时表, 一般出现于排序, 分组和多表 join 的情况, 查询效率不高, 建议优化.</p></li></ul><h1 id="Profiling"><a href="#Profiling" class="headerlink" title="Profiling"></a>Profiling</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>当我们要对某一条sql的性能进行分析时，可以使用它。</p><p>Profiling是从 mysql5.0.3版本以后才开放的。<br>启动profile之后，<strong>所有查询包括错误的语句</strong>都会记录在内。<br>关闭会话或者set profiling=0 就关闭了。（如果将profiling_history_size参数设置为0，同样具有关闭MySQL的profiling效果。）</p><p>此工具可用来查询SQL执行状态，System lock和Table lock 花多少时间等等，</p><p>对定位一条语句的<strong>I/O、CPU、IPC，Memory</strong>消耗 非常重要。(SQL 语句执行所消耗的最大两部分资源就是IO和CPU)</p><blockquote><p><em>在mysql5.7之后，profile信息将逐渐被废弃，mysql推荐使用performance schema</em></p></blockquote><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p><strong>简易流程大概如下：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> profiling=<span class="number">1</span>;  //打开分析，默认值为0（off），可以通过设置profiling为1或ON开启</span><br><span class="line"> </span><br><span class="line">run your sql1;</span><br><span class="line"> </span><br><span class="line">run your sql2;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">show</span> <span class="keyword">profiles</span>;//查看sql1, sql2的语句分析</span><br><span class="line"> </span><br><span class="line"><span class="keyword">show</span> profile <span class="keyword">for</span> <span class="keyword">query</span> <span class="number">1</span>;//查看sql1的具体分析</span><br><span class="line"> </span><br><span class="line"><span class="keyword">show</span> profile <span class="keyword">ALL</span> <span class="keyword">for</span> <span class="keyword">query</span> <span class="number">1</span>;//查看sql1相关的所有分析【主要看i/o与cpu,下边分析中有各项意义介绍】</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> profiling=<span class="number">0</span>;  //关闭分析</span><br></pre></td></tr></table></figure><p><strong>语法：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SHOW PROFILE [type [, type] ... ]</span><br><span class="line">   [FOR QUERY n]</span><br><span class="line">   [LIMIT row_count [OFFSET offset]]</span><br></pre></td></tr></table></figure><blockquote><p>type:</p><p>ALL | BLOCK IO | CONTEXT SWITCHES | CPU | IPC | MEMORY | PAGE FAULTS | SOURCE | SWAPS</p></blockquote><p><img src="/images/mysql_profiling_params.png" alt></p><p>SOURCE：显示和Source_function,Source_file,Source_line相关的开销信息</p><p><strong><em>注意：profiling被应用在每一个会话中，当前会话关闭后，profiling统计的信息将丢失。</em></strong></p><p><strong>实例：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like '%profil%';   ## 查看mysql profiling相关配置</span><br><span class="line">+<span class="comment">------------------------+-------+</span></span><br><span class="line">| Variable_name          | Value |</span><br><span class="line">+<span class="comment">------------------------+-------+</span></span><br><span class="line">| have_profiling         | YES   |</span><br><span class="line">| profiling              | OFF   | <span class="comment">## 是否开启</span></span><br><span class="line">| profiling_history_size | 15    | <span class="comment">## 记录历史条数</span></span><br><span class="line">+<span class="comment">------------------------+-------+</span></span><br><span class="line">3 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">set</span> profiling = <span class="keyword">ON</span>;  <span class="comment">## 开启分析</span></span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like '%profil%';</span><br><span class="line">+<span class="comment">------------------------+-------+</span></span><br><span class="line">| Variable_name          | Value |</span><br><span class="line">+<span class="comment">------------------------+-------+</span></span><br><span class="line">| have_profiling         | YES   |</span><br><span class="line">| profiling              | ON    |</span><br><span class="line">| profiling_history_size | 15    |</span><br><span class="line">+<span class="comment">------------------------+-------+</span></span><br><span class="line">3 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">show</span> <span class="keyword">tables</span>;                   </span><br><span class="line">+<span class="comment">-------------------------------------+</span></span><br><span class="line">| Tables_in_bigdata_new               |</span><br><span class="line">+<span class="comment">-------------------------------------+</span></span><br><span class="line">| TblDataShoppingRecord               |</span><br><span class="line">| TblDataViewRecord                   |</span><br><span class="line">| TblEmailNotifyRecord                |</span><br><span class="line">+<span class="comment">-------------------------------------+</span></span><br><span class="line">3 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">select</span> * <span class="keyword">from</span> TblDataShoppingRecord <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">id</span> <span class="keyword">desc</span> <span class="keyword">limit</span> <span class="number">1</span>\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">                id: 1263</span><br><span class="line">            status: off</span><br><span class="line">              name: mapdata_meta_27</span><br><span class="line">           creator: zhangsan</span><br><span class="line">        createTime: 2019-10-08 15:20:20</span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"><span class="keyword">ERROR</span>: </span><br><span class="line"><span class="keyword">No</span> <span class="keyword">query</span> specified</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">select</span> * <span class="keyword">from</span> TblDataShoppingRecord <span class="keyword">where</span> creator = <span class="string">'austin'</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">id</span> <span class="keyword">desc</span> <span class="keyword">limit</span> <span class="number">1</span>\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">                id: 1285</span><br><span class="line">            status: off</span><br><span class="line">              name: metadata_30</span><br><span class="line">           creator: austin</span><br><span class="line">        createTime: 2019-10-08 15:20:20</span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line"><span class="keyword">ERROR</span>: </span><br><span class="line"><span class="keyword">No</span> <span class="keyword">query</span> specified</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">show</span> <span class="keyword">profiles</span>;</span><br><span class="line">+<span class="comment">----------+------------+---------------------------------------------------------------------------------------------+</span></span><br><span class="line">| Query_ID | Duration   | Query                                                                                       |</span><br><span class="line">+<span class="comment">----------+------------+---------------------------------------------------------------------------------------------+</span></span><br><span class="line">|        1 | 0.00045400 | <span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'%profil%'</span>                                                              |</span><br><span class="line">|        <span class="number">2</span> | <span class="number">0.00086200</span> | <span class="keyword">show</span> <span class="keyword">tables</span>                                                                                 |</span><br><span class="line">|        <span class="number">3</span> | <span class="number">0.00034900</span> | <span class="keyword">select</span> * <span class="keyword">from</span> TblDataShoppingRecord <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">id</span> <span class="keyword">desc</span> <span class="keyword">limit</span> <span class="number">1</span>                                |</span><br><span class="line">|        <span class="number">4</span> | <span class="number">0.00040000</span> | <span class="keyword">select</span> * <span class="keyword">from</span> TblDataShoppingRecord <span class="keyword">where</span> creator = <span class="string">'austin'</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">id</span> <span class="keyword">desc</span> <span class="keyword">limit</span> <span class="number">1</span>       |</span><br><span class="line">+<span class="comment">----------+------------+---------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">show</span> profile <span class="keyword">for</span> <span class="keyword">query</span> <span class="number">4</span>;</span><br><span class="line">+<span class="comment">--------------------------------+----------+</span></span><br><span class="line">| Status                         | Duration |</span><br><span class="line">+<span class="comment">--------------------------------+----------+</span></span><br><span class="line">| starting                       | 0.000039 |</span><br><span class="line">| checking query <span class="keyword">cache</span> <span class="keyword">for</span> <span class="keyword">query</span> | <span class="number">0.000052</span> |</span><br><span class="line">| Opening <span class="keyword">tables</span>                 | <span class="number">0.000015</span> |</span><br><span class="line">| <span class="keyword">System</span> <span class="keyword">lock</span>                    | <span class="number">0.000005</span> |</span><br><span class="line">| <span class="keyword">Table</span> <span class="keyword">lock</span>                     | <span class="number">0.000037</span> |</span><br><span class="line">| init                           | <span class="number">0.000031</span> |</span><br><span class="line">| optimizing                     | <span class="number">0.000009</span> |</span><br><span class="line">| <span class="keyword">statistics</span>                     | <span class="number">0.000073</span> |</span><br><span class="line">| preparing                      | <span class="number">0.000016</span> |</span><br><span class="line">| executing                      | <span class="number">0.000005</span> |</span><br><span class="line">| Sorting <span class="keyword">result</span>                 | <span class="number">0.000006</span> |</span><br><span class="line">| Sending <span class="keyword">data</span>                   | <span class="number">0.000050</span> |</span><br><span class="line">| <span class="keyword">end</span>                            | <span class="number">0.000007</span> |</span><br><span class="line">| <span class="keyword">query</span> <span class="keyword">end</span>                      | <span class="number">0.000004</span> |</span><br><span class="line">| freeing items                  | <span class="number">0.000027</span> |</span><br><span class="line">| storing <span class="keyword">result</span> <span class="keyword">in</span> <span class="keyword">query</span> <span class="keyword">cache</span>  | <span class="number">0.000015</span> |</span><br><span class="line">| <span class="keyword">logging</span> slow <span class="keyword">query</span>             | <span class="number">0.000004</span> |</span><br><span class="line">| cleaning up                    | <span class="number">0.000005</span> |</span><br><span class="line">+<span class="comment">--------------------------------+----------+</span></span><br><span class="line"><span class="number">18</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">show</span> profile cpu <span class="keyword">for</span> <span class="keyword">query</span> <span class="number">4</span>;</span><br><span class="line">+<span class="comment">--------------------------------+----------+----------+------------+</span></span><br><span class="line">| Status                         | Duration | CPU_user | CPU_system |</span><br><span class="line">+<span class="comment">--------------------------------+----------+----------+------------+</span></span><br><span class="line">| starting                       | 0.000039 | 0.000000 |   0.000000 |</span><br><span class="line">| checking query <span class="keyword">cache</span> <span class="keyword">for</span> <span class="keyword">query</span> | <span class="number">0.000052</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |</span><br><span class="line">| Opening <span class="keyword">tables</span>                 | <span class="number">0.000015</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |</span><br><span class="line">| <span class="keyword">System</span> <span class="keyword">lock</span>                    | <span class="number">0.000005</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |</span><br><span class="line">| <span class="keyword">Table</span> <span class="keyword">lock</span>                     | <span class="number">0.000037</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |</span><br><span class="line">| init                           | <span class="number">0.000031</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |</span><br><span class="line">| optimizing                     | <span class="number">0.000009</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |</span><br><span class="line">| <span class="keyword">statistics</span>                     | <span class="number">0.000073</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |</span><br><span class="line">| preparing                      | <span class="number">0.000016</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |</span><br><span class="line">| executing                      | <span class="number">0.000005</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |</span><br><span class="line">| Sorting <span class="keyword">result</span>                 | <span class="number">0.000006</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |</span><br><span class="line">| Sending <span class="keyword">data</span>                   | <span class="number">0.000050</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |</span><br><span class="line">| <span class="keyword">end</span>                            | <span class="number">0.000007</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |</span><br><span class="line">| <span class="keyword">query</span> <span class="keyword">end</span>                      | <span class="number">0.000004</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |</span><br><span class="line">| freeing items                  | <span class="number">0.000027</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |</span><br><span class="line">| storing <span class="keyword">result</span> <span class="keyword">in</span> <span class="keyword">query</span> <span class="keyword">cache</span>  | <span class="number">0.000015</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |</span><br><span class="line">| <span class="keyword">logging</span> slow <span class="keyword">query</span>             | <span class="number">0.000004</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |</span><br><span class="line">| cleaning up                    | <span class="number">0.000005</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |</span><br><span class="line">+<span class="comment">--------------------------------+----------+----------+------------+</span></span><br><span class="line"><span class="number">18</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">show</span> profile <span class="keyword">BLOCK</span> IO, CPU, IPC, <span class="keyword">MEMORY</span>, <span class="keyword">SOURCE</span>, SWAPS  <span class="keyword">for</span> <span class="keyword">query</span> <span class="number">4</span>;   </span><br><span class="line">+<span class="comment">--------------------------------+----------+----------+------------+--------------+---------------+---------------+-------------------+-------+------------------+---------------+-------------+</span></span><br><span class="line">| Status                         | Duration | CPU_user | CPU_system | Block_ops_in | Block_ops_out | Messages_sent | Messages_received | Swaps | Source_function  | Source_file   | Source_line |</span><br><span class="line">+<span class="comment">--------------------------------+----------+----------+------------+--------------+---------------+---------------+-------------------+-------+------------------+---------------+-------------+</span></span><br><span class="line">| starting                       | 0.000039 | 0.000000 |   0.000000 |            0 |             0 |             0 |                 0 |     0 | NULL             | NULL          |        NULL |</span><br><span class="line">| checking query <span class="keyword">cache</span> <span class="keyword">for</span> <span class="keyword">query</span> | <span class="number">0.000052</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |            <span class="number">0</span> |             <span class="number">0</span> |             <span class="number">0</span> |                 <span class="number">0</span> |     <span class="number">0</span> | <span class="literal">unknown</span> <span class="keyword">function</span> | sql_cache.cc  |        <span class="number">1523</span> |</span><br><span class="line">| Opening <span class="keyword">tables</span>                 | <span class="number">0.000015</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |            <span class="number">0</span> |             <span class="number">0</span> |             <span class="number">0</span> |                 <span class="number">0</span> |     <span class="number">0</span> | <span class="literal">unknown</span> <span class="keyword">function</span> | sql_base.cc   |        <span class="number">4618</span> |</span><br><span class="line">| <span class="keyword">System</span> <span class="keyword">lock</span>                    | <span class="number">0.000005</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |            <span class="number">0</span> |             <span class="number">0</span> |             <span class="number">0</span> |                 <span class="number">0</span> |     <span class="number">0</span> | <span class="literal">unknown</span> <span class="keyword">function</span> | lock.cc       |         <span class="number">260</span> |</span><br><span class="line">| <span class="keyword">Table</span> <span class="keyword">lock</span>                     | <span class="number">0.000037</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |            <span class="number">0</span> |             <span class="number">0</span> |             <span class="number">0</span> |                 <span class="number">0</span> |     <span class="number">0</span> | <span class="literal">unknown</span> <span class="keyword">function</span> | lock.cc       |         <span class="number">271</span> |</span><br><span class="line">| init                           | <span class="number">0.000031</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |            <span class="number">0</span> |             <span class="number">0</span> |             <span class="number">0</span> |                 <span class="number">0</span> |     <span class="number">0</span> | <span class="literal">unknown</span> <span class="keyword">function</span> | sql_select.cc |        <span class="number">2528</span> |</span><br><span class="line">| optimizing                     | <span class="number">0.000009</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |            <span class="number">0</span> |             <span class="number">0</span> |             <span class="number">0</span> |                 <span class="number">0</span> |     <span class="number">0</span> | <span class="literal">unknown</span> <span class="keyword">function</span> | sql_select.cc |         <span class="number">833</span> |</span><br><span class="line">| <span class="keyword">statistics</span>                     | <span class="number">0.000073</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |            <span class="number">0</span> |             <span class="number">0</span> |             <span class="number">0</span> |                 <span class="number">0</span> |     <span class="number">0</span> | <span class="literal">unknown</span> <span class="keyword">function</span> | sql_select.cc |        <span class="number">1024</span> |</span><br><span class="line">| preparing                      | <span class="number">0.000016</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |            <span class="number">0</span> |             <span class="number">0</span> |             <span class="number">0</span> |                 <span class="number">0</span> |     <span class="number">0</span> | <span class="literal">unknown</span> <span class="keyword">function</span> | sql_select.cc |        <span class="number">1046</span> |</span><br><span class="line">| executing                      | <span class="number">0.000005</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |            <span class="number">0</span> |             <span class="number">0</span> |             <span class="number">0</span> |                 <span class="number">0</span> |     <span class="number">0</span> | <span class="literal">unknown</span> <span class="keyword">function</span> | sql_select.cc |        <span class="number">1780</span> |</span><br><span class="line">| Sorting <span class="keyword">result</span>                 | <span class="number">0.000006</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |            <span class="number">0</span> |             <span class="number">0</span> |             <span class="number">0</span> |                 <span class="number">0</span> |     <span class="number">0</span> | <span class="literal">unknown</span> <span class="keyword">function</span> | sql_select.cc |        <span class="number">2205</span> |</span><br><span class="line">| Sending <span class="keyword">data</span>                   | <span class="number">0.000050</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |            <span class="number">0</span> |             <span class="number">0</span> |             <span class="number">0</span> |                 <span class="number">0</span> |     <span class="number">0</span> | <span class="literal">unknown</span> <span class="keyword">function</span> | sql_select.cc |        <span class="number">2338</span> |</span><br><span class="line">| <span class="keyword">end</span>                            | <span class="number">0.000007</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |            <span class="number">0</span> |             <span class="number">0</span> |             <span class="number">0</span> |                 <span class="number">0</span> |     <span class="number">0</span> | <span class="literal">unknown</span> <span class="keyword">function</span> | sql_select.cc |        <span class="number">2574</span> |</span><br><span class="line">| <span class="keyword">query</span> <span class="keyword">end</span>                      | <span class="number">0.000004</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |            <span class="number">0</span> |             <span class="number">0</span> |             <span class="number">0</span> |                 <span class="number">0</span> |     <span class="number">0</span> | <span class="literal">unknown</span> <span class="keyword">function</span> | sql_parse.cc  |        <span class="number">5118</span> |</span><br><span class="line">| freeing items                  | <span class="number">0.000027</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |            <span class="number">0</span> |             <span class="number">0</span> |             <span class="number">0</span> |                 <span class="number">0</span> |     <span class="number">0</span> | <span class="literal">unknown</span> <span class="keyword">function</span> | sql_parse.cc  |        <span class="number">6142</span> |</span><br><span class="line">| storing <span class="keyword">result</span> <span class="keyword">in</span> <span class="keyword">query</span> <span class="keyword">cache</span>  | <span class="number">0.000015</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |            <span class="number">0</span> |             <span class="number">0</span> |             <span class="number">0</span> |                 <span class="number">0</span> |     <span class="number">0</span> | <span class="literal">unknown</span> <span class="keyword">function</span> | sql_cache.cc  |         <span class="number">985</span> |</span><br><span class="line">| <span class="keyword">logging</span> slow <span class="keyword">query</span>             | <span class="number">0.000004</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |            <span class="number">0</span> |             <span class="number">0</span> |             <span class="number">0</span> |                 <span class="number">0</span> |     <span class="number">0</span> | <span class="literal">unknown</span> <span class="keyword">function</span> | sql_parse.cc  |        <span class="number">1735</span> |</span><br><span class="line">| cleaning up                    | <span class="number">0.000005</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |            <span class="number">0</span> |             <span class="number">0</span> |             <span class="number">0</span> |                 <span class="number">0</span> |     <span class="number">0</span> | <span class="literal">unknown</span> <span class="keyword">function</span> | sql_parse.cc  |        <span class="number">1703</span> |</span><br><span class="line">+<span class="comment">--------------------------------+----------+----------+------------+--------------+---------------+---------------+-------------------+-------+------------------+---------------+-------------+</span></span><br><span class="line"><span class="number">18</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">set</span> profiling=<span class="number">0</span>;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like '%profil%';</span><br><span class="line">+<span class="comment">------------------------+-------+</span></span><br><span class="line">| Variable_name          | Value |</span><br><span class="line">+<span class="comment">------------------------+-------+</span></span><br><span class="line">| have_profiling         | YES   |</span><br><span class="line">| profiling              | OFF   |</span><br><span class="line">| profiling_history_size | 15    |</span><br><span class="line">+<span class="comment">------------------------+-------+</span></span><br><span class="line">3 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h2 id="结果参数说明"><a href="#结果参数说明" class="headerlink" title="结果参数说明"></a>结果参数说明</h2><p>其中标题含义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&quot;Status&quot;: &quot;query end&quot;,  状态</span><br><span class="line">&quot;Duration&quot;: &quot;1.751142&quot;, 持续时间</span><br><span class="line">&quot;CPU_user&quot;: &quot;0.008999&quot;, cpu用户</span><br><span class="line">&quot;CPU_system&quot;: &quot;0.003999&quot;, cpu系统</span><br><span class="line">&quot;Context_voluntary&quot;: &quot;98&quot;, 上下文主动切换</span><br><span class="line">&quot;Context_involuntary&quot;: &quot;0&quot;, 上下文被动切换</span><br><span class="line">&quot;Block_ops_in&quot;: &quot;8&quot;, 阻塞的输入操作</span><br><span class="line">&quot;Block_ops_out&quot;: &quot;32&quot;, 阻塞的输出操作</span><br><span class="line">&quot;Messages_sent&quot;: &quot;0&quot;, 消息发出</span><br><span class="line">&quot;Messages_received&quot;: &quot;0&quot;, 消息接受</span><br><span class="line">&quot;Page_faults_major&quot;: &quot;0&quot;, 主分页错误</span><br><span class="line">&quot;Page_faults_minor&quot;: &quot;0&quot;, 次分页错误</span><br><span class="line">&quot;Swaps&quot;: &quot;0&quot;, 交换次数</span><br><span class="line">&quot;Source_function&quot;: &quot;mysql_execute_command&quot;, 源功能</span><br><span class="line">&quot;Source_file&quot;: &quot;sql_parse.cc&quot;, 源文件</span><br><span class="line">&quot;Source_line&quot;: &quot;4465&quot; 源代码行</span><br></pre></td></tr></table></figure><p>不同阶段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">starting：开始</span><br><span class="line">checking permissions：检查权限</span><br><span class="line">Opening tables：打开表</span><br><span class="line">init ： 初始化</span><br><span class="line">System lock ：系统锁</span><br><span class="line">optimizing ： 优化</span><br><span class="line">statistics ： 统计</span><br><span class="line">preparing ：准备</span><br><span class="line">executing ：执行</span><br><span class="line">Sending data ：发送数据</span><br><span class="line">Sorting result ：排序</span><br><span class="line">end ：结束</span><br><span class="line">query end ：查询 结束</span><br><span class="line">closing tables ： 关闭表 ／去除TMP 表</span><br><span class="line">freeing items ： 释放物品</span><br><span class="line">cleaning up ：清理</span><br></pre></td></tr></table></figure><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>显示的记录数由变量“profiling_history_size”控制,默认15条，最大值为100，可以手动设置该参数值。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mysql&gt; set profiling_history_size = 30;  </span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like '%profil%';</span><br><span class="line">+<span class="comment">------------------------+-------+</span></span><br><span class="line">| Variable_name          | Value |</span><br><span class="line">+<span class="comment">------------------------+-------+</span></span><br><span class="line">| have_profiling         | YES   |</span><br><span class="line">| profiling              | OFF   |</span><br><span class="line">| profiling_history_size | 30    |</span><br><span class="line">+<span class="comment">------------------------+-------+</span></span><br><span class="line">3 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h1 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h1><p>[1] <a href="https://segmentfault.com/a/1190000008131735#articleHeader8" target="_blank" rel="noopener">MySQL 性能优化神器 Explain 使用分析</a><br>[2] <a href="https://blog.csdn.net/ty_hf/article/details/54895026" target="_blank" rel="noopener">Mysql分析-profile详解</a><br>[3] <a href="https://blog.csdn.net/Field_Yang/article/details/80629663" target="_blank" rel="noopener">MySQL性能分析工具profiling</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Explain&quot;&gt;&lt;a href=&quot;#Explain&quot; class=&quot;headerlink&quot; title=&quot;Explain&quot;&gt;&lt;/a&gt;Explain&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简
      
    
    </summary>
    
      <category term="Mysql" scheme="http://yoursite.com/categories/Mysql/"/>
    
      <category term="性能" scheme="http://yoursite.com/categories/Mysql/%E6%80%A7%E8%83%BD/"/>
    
    
      <category term="Mysql" scheme="http://yoursite.com/tags/Mysql/"/>
    
      <category term="工具" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Mysql索引底层原理</title>
    <link href="http://yoursite.com/2019/09/28/Mysql%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2019/09/28/Mysql索引底层原理/</id>
    <published>2019-09-28T07:32:15.000Z</published>
    <updated>2019-10-09T07:55:31.228Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常用引擎"><a href="#常用引擎" class="headerlink" title="常用引擎"></a>常用引擎</h2><h3 id="InnoDB（聚集索引）"><a href="#InnoDB（聚集索引）" class="headerlink" title="InnoDB（聚集索引）"></a>InnoDB（聚集索引）</h3><ul><li><p>InnoDB的存储文件有两个，后缀名分别是.frm 和.idb，其中.frm是表的定义文件，而.idb是索引和数据文件。</p></li><li><p>InnoDB 中存在表锁和行锁，不过行锁是在命中索引的情况下才会起作用。</p></li><li><p>InnoDB 支持事务，且支持四种隔离级别（读未提交、读已提交、可重复读、串行化），默认的为可重复读；而在 Oracle 数据库中，只支持串行化级别和读已提交这两种级别，其中默认的为读已提交级别。</p></li></ul><h3 id="MyISAM（非聚集索引）"><a href="#MyISAM（非聚集索引）" class="headerlink" title="MyISAM（非聚集索引）"></a>MyISAM（非聚集索引）</h3><ul><li><p>Myisam 的存储文件有三个，后缀名分别是.frm、.MYD、MYI，其中.frm是表的定义文件，.MYD是数据文件，.MYI是索引文件。</p></li><li><p>Myisam只支持表锁，且不支持事务。Myisam 由于有单独的索引文件，在读取数据方面的性能很高 。</p></li></ul><h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><p>可以用来优化查询的数据结构有哈希表，完全平衡二叉树，B树，B+树。我们使用最多的是B+树，InnoDB和Myisam都是用 <strong>B+Tree</strong> 来存储数据的。</p><p>数据结构可视化网站： </p><blockquote><p><a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html" target="_blank" rel="noopener">https://www.cs.usfca.edu/~galles/visualization/Algorithms.html</a></p></blockquote><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p><strong>为什么很少使用hash?</strong></p><ul><li><p>优点：直接计算下标，查询单一数据非常快。</p></li><li><p>缺点：如果是进行的范围查询的话，哈希索引就必须全表遍历，获得age数据，然后再依次进行比较，也就是相当于没有索引了。这样就不能优化查询效率了。</p></li></ul><h3 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h3><p><img src="/images/mysql_b_tree.jpg" alt></p><blockquote><p><strong>d</strong> 为大于1的一个正整数，称为B-Tree的度，表示节点的数据存储个数；</p><p><strong>h</strong> 为一个正整数，称为B-Tree的高度；</p><p>每个非叶子节点由n-1个key和n个指针组成，其中 d &lt;= n &lt;= 2d；</p><p>每个叶子节点最少包含一个key和两个指针，最多包含2d-1个key和2d个指针，叶节点的指针均为null；</p><p>所有叶节点具有相同的深度，等于树高h;</p><p>key和指针互相间隔，节点两端是指针;</p><p>一个节点中的key从左到右非递减排列;</p><p>所有节点组成树结构;</p><p>每个指针要么为null，要么指向另外一个节点;</p></blockquote><p>关于B-Tree有一系列有趣的性质，例如一个度为 d 的B-Tree，设其索引 N 个key，则其树高h的上限为 <strong>logd((N+1)/2)</strong> ，检索一个key，其查找节点个数的线性复杂度为 <strong>O(logdN)</strong> 。从这点可以看出，B-Tree是一个非常有效率的索引数据结构。</p><h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><p>B-Tree有许多变种，其中最常见的是B+Tree。</p><p><img src="/images/mysql_bplus_tree.jpg" alt></p><p>与B-Tree相比，B+Tree有以下不同点：</p><blockquote><ol><li><p>每个节点的指针上限为2d而不是2d+1;</p></li><li><p>非叶子节点不存储data，只存储key，可节省空间，增大 <strong>度</strong>;</p></li><li><p>叶子节点不存储指针;</p></li><li><p>带有顺序访问指针，提高了区间访问性能;</p></li></ol></blockquote><h3 id="局部性原理与磁盘预读"><a href="#局部性原理与磁盘预读" class="headerlink" title="局部性原理与磁盘预读"></a>局部性原理与磁盘预读</h3><p>由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分分之一，因此为了提高效率，要尽量减少磁盘I/O。</p><p>为了达到这个目的，磁盘往往<strong>不是严格按需读取，而是每次都会预读</strong>，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的局部性原理：</p><blockquote><p>当一个数据被用到时，其附近的数据也通常会马上被使用。程序运行期间所需要的数据通常比较集中。</p></blockquote><blockquote><p>由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，<strong>预读</strong>可以提高I/O效率。</p></blockquote><p>预读的长度<strong>一般为页（page）的整倍数</strong>。页是计算机<strong>管理存储器的最小逻辑块</strong>，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k），<strong>主存和磁盘以页为单位交换数据</strong>。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。</p><h3 id="mysql页文件配置"><a href="#mysql页文件配置" class="headerlink" title="mysql页文件配置"></a>mysql页文件配置</h3><h4 id="查看mysql页文件大小"><a href="#查看mysql页文件大小" class="headerlink" title="查看mysql页文件大小"></a>查看mysql页文件大小</h4><blockquote><p>SHOW GLOBAL STATUS like ‘Innodb_page_size’;</p></blockquote><h4 id="为什么Mysql页文件默认16kb就够了呢"><a href="#为什么Mysql页文件默认16kb就够了呢" class="headerlink" title="为什么Mysql页文件默认16kb就够了呢"></a>为什么Mysql页文件默认16kb就够了呢</h4><ul><li><p>假设我们一行数据大小为1K,那么一页就能存16条数据，也就是一个叶子节点能存16条数据;</p></li><li><p>再看非叶子节点，假设主键ID为bigint类型, 那么长度为8B，指针大小在Innodb源码中为6B，-共就是14B,那么一页里就可以存储16K/14=1170个(主键+指针)，那么：</p><ul><li>一颗高度 为2的B+树能存储的数据为: 1170 * 16 = 18720条</li><li>一 颗高度为3的B+树能存储的数据为: 1170 * 1170 * 16 = 21902400 (千万级条)。</li></ul></li></ul><p>所以在InnoDB中B+树高度一般为1-3层， 它就能满足千万级的数据存储。在查找数据时一次页的查找代表一次I/O, 所以通过主键索引查询通常只需要1-3次IO操作即可查找到数据。所以也就回答了我们的问题，1 页=16k这么设置是比较合适的，是适用大多数的企业的，当然这个值是可以修改的，所以也能根据业务的时间情况进行调整。</p><h3 id="B-Tree索引的性能分析"><a href="#B-Tree索引的性能分析" class="headerlink" title="B-/+Tree索引的性能分析"></a>B-/+Tree索引的性能分析</h3><p>一般以使用磁盘I/O次数评价索引结构的优劣。</p><p>先从B-Tree分析，根据B-Tree的定义，可知检索一次最多需要访问h个节点。数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。</p><p>为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：</p><blockquote><p>每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。</p><p>B-Tree中一次检索最多需要h-1次I/O（根节点常驻内存），渐进复杂度为O(h)=O(logdN)。一般实际应用中，度d是非常大的数字，通常超过100，因此h非常小（通常不超过3）。</p></blockquote><p>综上所述，用B-Tree作为索引结构效率是非常高的。B+Tree之所以更适合外存索引，原因和内节点度d有关。从上面分析可以看到，d越大索引的性能越好，而度的上限取决于节点内key和data的大小：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmax = floor(pagesize/(keysize+datasize+pointsize))</span><br></pre></td></tr></table></figure><p>floor表示向下取整。由于B+Tree内节点去掉了data域，因此可以拥有更大的度，拥有更好的性能。</p><h2 id="MySQL索引实现"><a href="#MySQL索引实现" class="headerlink" title="MySQL索引实现"></a>MySQL索引实现</h2><p>在MySQL中，索引属于存储引擎级别的概念，不同存储引擎对索引的实现方式是不同的。</p><h3 id="MyISAM索引实现"><a href="#MyISAM索引实现" class="headerlink" title="MyISAM索引实现"></a>MyISAM索引实现</h3><p><img src="/images/mysql_myisam_index.jpg" alt></p><ul><li><p>索引文件仅仅保存数据记录的地址，索引文件和数据文件是分离的；</p></li><li><p>主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复；</p></li><li><p>索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。</p></li></ul><h3 id="InnoDB索引实现"><a href="#InnoDB索引实现" class="headerlink" title="InnoDB索引实现"></a>InnoDB索引实现</h3><p>虽然InnoDB也使用B+Tree作为索引结构，但具体实现方式却与MyISAM截然不同。</p><p><img src="/images/mysql_innodb_index.jpg" alt></p><ul><li><p>数据文件本身就是索引文件，都存储在后缀为.idb的文件中；</p></li><li><p>叶节点data域保存了完整的数据记录, 而不是行地址；</p></li><li><p>因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求<strong>表必须有主键</strong>（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形；</p></li><li><p>聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：<strong>首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录</strong>；</p></li></ul><h3 id="InnodeDB主键选择与插入优化"><a href="#InnodeDB主键选择与插入优化" class="headerlink" title="InnodeDB主键选择与插入优化"></a>InnodeDB主键选择与插入优化</h3><p>基于以上特点就很容易理解为什么不建议使用过长的字段作为主键？而且推荐使用整形自增主键？</p><ul><li><p>所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大；</p></li><li><p>InnoDB数据文件本身是一颗B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择；</p></li></ul><h3 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h3><p>有如下数据表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> People (</span><br><span class="line">    last_name <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    first_name <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    dob <span class="built_in">date</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    gender enum(<span class="string">'m'</span>,<span class="string">'f'</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    <span class="keyword">key</span>(last_name,first_name,dob)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>这个建表语句在last_name、first_name、dob列上建立了一个联合索引，下图展示了该索引的存储结构。</p><p><img src="/images/mysql_union_indxe.jpg" alt></p><p>可以看到，联合索引中的索引项会先根据第一个索引列进行排序，第一个索引列相同的情况下，会再按照第二个索引列进行排序，依次类推。根据这种存储特点，B-Tree索引对如下类型的查找有效：</p><ul><li><p>全值匹配：查找条件和索引中的所有列相匹配</p></li><li><p>匹配最左前缀：查找条件只有索引中的第一列</p></li><li><p>匹配列前缀：只匹配某一列值的开头部分。这里并不一定只能匹配第一个索引列的前缀。例如在确定第一个索引列的值时，也可以在第二个索引列上匹配列前缀。在上面例子中，对于查找姓为Allen，名为J开头的人，也可以应用到索引。</p></li><li><p>匹配范围值，或者精确匹配某一列并范围匹配另外一列：例如查找姓在Allen和Barrymore之间的人，或者查找姓为Allen，名字在某一个范围内的人。</p></li><li><p>只访问索引的查询，即要查询的值在索引中都包含，只需要访问索引就行了，无需访问数据行。这种索引被称作<strong>覆盖索引</strong>。</p></li><li><p>对于上面列出的查询类型，索引除了可以用来查询外，还可以用来排序。</p></li></ul><p>下面是B-Tree索引的一些限制：</p><ul><li><p>如果不是从索引的最左列开始查找，则无法使用索引。例如直接查找名字为Bill的人，或查找某个生日的人都无法应用到上面的索引，因为都跳过了索引的第一个列。此外查找姓以某个字母结尾的人，也无法使用到上面的索引。</p></li><li><p>不能在中间跳过索引中的某个列，例如不能查找姓为Smith，生日为某个特定日期的类。这样的查询只能使用到索引的第一列。</p></li><li><p>如果查询中有某个列的范围查询，则该列右边的所有列都无法使用索引优化查找。例如有查询WHERE last_name=’Smith’ AND first_name LIKE ‘J%’ AND dob=’1976-12-23’，这个查询只能使用到索引的前两列，而不能使用整个索引。</p></li></ul><p>通过上面列出的这些条件，可见对于一个B-TREE联合索引，索引列的顺序非常重要。</p><blockquote><p> InnoDB中有一个功能叫“自适应哈希索引”，当InnoDB注意到某些索引值使用的非常频繁时，会在B-Tree索引之上再建立一层哈希索引，以加速查找效率。这是完全自动的内部行为，用户无法干预。</p></blockquote><h2 id="索引查询"><a href="#索引查询" class="headerlink" title="索引查询"></a>索引查询</h2><h3 id="多列索引"><a href="#多列索引" class="headerlink" title="多列索引"></a>多列索引</h3><p>当出现对多个索引列做相交(AND)操作的查询时，代表需要一个包含所有相关列的联合索引，而不是多个独立的单列索引。</p><p>在MySql官方提供的示例数据库sakila中，表film_actor在字段film_id和actor_id上各有一个单列索引，对于下面这条查询语句，这两个单列索引都不是很好的选择：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> film_id,actor_id <span class="keyword">FROM</span> film_actor <span class="keyword">WHERE</span> actor_id=<span class="number">1</span> <span class="keyword">OR</span> film_id=<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>在老的MySql版本中，这个查询会使用全表扫描。但在MySql5.0之后，查询能够同时使用这两个单列索引进行扫描，然后将结果合并，相当于转换成下面这条查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> film_id,actor_id <span class="keyword">FROM</span> film_actor <span class="keyword">WHERE</span> actor_id=<span class="number">1</span> </span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> film_id,actor_id <span class="keyword">FROM</span> film_actor <span class="keyword">WHERE</span> film_id=<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>在MySql5.7中，执行上面查询的执行计划如下图所示：</p><p><img src="/images/mysql_muti_cols_index.jpg" alt></p><p>从执行计划的type字段可以看到，MySql同时使用了两个索引，并将各自的查询结果合并。并且Extra字段描述了使用索引的详细信息。</p><p>虽然MySql在背后对查询进行了优化，使其可以同时利用两个单列索引。但是这需要耗费大量的CPU和内存资源，所以<strong>直接将查询改写成UNION的方式会更好</strong>。像这种两个列上都有索引的情况，用union代替or会得到更好的效果(注意要求两个列上都建有索引，如果没有索引，用union代替or反而会降低效率)。</p><p>如果在EXPLAIN中看到有索引合并，那就应该好好检查一下查询和表的结构，看看是不是已经是最优的。</p><h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p>如果一个索引包含所有需要查询的字段，就称之为“<strong>覆盖索引</strong>”。由于在索引的叶子节点中已经包含了要查询的全部数据，所以就可以从索引中直接获取查询结果，而没必要再回表查询。</p><p>索引一般远远小于数据行的大小，如果只需要访问索引，就会极大减少数据访问量。而且索引是按照顺序存储，所以在进行范围查询时会比随机从磁盘读取每一条数据的I/O要少的多。由此看出，覆盖索引能够极大的提高查询性能。</p><p>sakila数据库中包含了由store_id和film_id组成的一个联合索引，如下图所示：<br><img src="/images/mysql_union_index.jpg" alt></p><p>如果只查询store_id和film_id这两列，就可以使用这个索引做覆盖索引。</p><p><img src="/images/mysql_cover_index.jpg" alt></p><p>EXPLAIN的Extra列如果是Using index，则代表这个查询使用到了覆盖索引。注意type字段和是否为覆盖索引毫无关系。</p><h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><p>[1] <a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="noopener">MySQL索引背后的数据结构及算法原理</a></p><p>[2] <a href="https://segmentfault.com/a/1190000010991930#articleHeader3" target="_blank" rel="noopener">MySql索引</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;常用引擎&quot;&gt;&lt;a href=&quot;#常用引擎&quot; class=&quot;headerlink&quot; title=&quot;常用引擎&quot;&gt;&lt;/a&gt;常用引擎&lt;/h2&gt;&lt;h3 id=&quot;InnoDB（聚集索引）&quot;&gt;&lt;a href=&quot;#InnoDB（聚集索引）&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="Mysql" scheme="http://yoursite.com/categories/Mysql/"/>
    
      <category term="索引" scheme="http://yoursite.com/categories/Mysql/%E7%B4%A2%E5%BC%95/"/>
    
    
      <category term="Mysql" scheme="http://yoursite.com/tags/Mysql/"/>
    
      <category term="索引" scheme="http://yoursite.com/tags/%E7%B4%A2%E5%BC%95/"/>
    
      <category term="优化" scheme="http://yoursite.com/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Kafka快速入门</title>
    <link href="http://yoursite.com/2019/09/23/Kafka%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2019/09/23/Kafka快速入门/</id>
    <published>2019-09-23T11:46:50.000Z</published>
    <updated>2019-09-23T12:16:42.532Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Apache Kafka® 是 一个分布式流处理平台.<br>我们知道流处理平台有以下三种特性:</p><ol><li>可以让你发布和订阅流式的记录。这一方面与消息队列或者企业消息系统类似。</li><li>可以储存流式的记录，并且有较好的容错性。</li><li>可以在流式记录产生时就进行处理。</li></ol><p>Kafka适合什么样的场景?</p><p>它可以用于两大类别的应用:</p><ol><li>构造实时流数据管道，它可以在系统或应用之间可靠地获取数据。 (相当于message queue)</li><li>构建实时流式应用程序，对这些流数据进行转换或者影响。 (就是流处理，通过kafka stream topic和topic之间内部进行变化)</li></ol><p>首先是一些概念:</p><ul><li>Kafka作为一个集群，运行在一台或者多台服务器上.</li><li>Kafka 通过 topic 对存储的流数据进行分类。</li><li>每条记录中包含一个key，一个value和一个timestamp（时间戳）。</li></ul><h2 id="Topics和日志"><a href="#Topics和日志" class="headerlink" title="Topics和日志"></a>Topics和日志</h2><p>让我们首先深入了解下Kafka的核心概念:提供一串流式的记录— topic 。</p><p>Topic 就是数据主题，是数据记录发布的地方,可以用来区分业务系统。Kafka中的Topics总是多订阅者模式，一个topic可以拥有一个或者多个消费者来订阅它的数据。</p><p>对于每一个topic， Kafka集群都会维持一个分区日志，如下所示：</p><p><img src="/images/kafka_partition_log.jpg" alt></p><p>每个分区都是有序且顺序不可变的记录集，并且不断地追加到结构化的commit log文件。分区中的每一个记录都会分配一个id号来表示顺序，我们称之为offset，offset用来唯一的标识分区中每一条记录。</p><p><strong>Kafka 集群保留所有发布的记录—无论他们是否已被消费—并通过一个可配置的参数——保留期限来控制</strong>. 举个例子， 如果保留策略设置为2天，一条记录发布后两天内，可以随时被消费，两天过后这条记录会被抛弃并释放磁盘空间。<strong>Kafka的性能和数据大小无关，所以长时间存储数据没有什么问题</strong>.</p><p>日志中的 partition（分区）有以下几个用途。</p><ul><li>第一，当日志大小超过了单台服务器的限制，允许日志进行扩展。每个单独的分区都必须受限于主机的文件限制，不过一个主题可能有多个分区，因此可以处理无限量的数据。</li><li>第二，可以作为并行的单元集</li></ul><h2 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h2><p>日志的分区partition （分布）在Kafka集群的服务器上。每个服务器在处理数据和请求时，共享这些分区。每一个分区都会在已配置的服务器上进行备份，确保容错性.</p><p>每个分区都有一台 server 作为 “leader”，零台或者多台server作为 follwers 。leader server 处理一切对 partition （分区）的读写请求，而follwers只需被动的同步leader上的数据。当leader宕机了，followers 中的一台服务器会自动成为新的 leader。每台 server 都会成为某些分区的 leader 和某些分区的 follower，因此集群的负载是平衡的。</p><h2 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h2><p>如果所有的消费者实例在同一消费组中，消息记录会负载平衡到每一个消费者实例.</p><p>如果所有的消费者实例在不同的消费组中，每条消息记录会广播到所有的消费者进程.</p><p><img src="/images/kafka_consumer_group.jpg" alt></p><p>在Kafka中实现消费的方式是<strong>将日志中的分区划分到每一个消费者实例上</strong>，以便在任何时间，<strong>每个实例都是分区唯一的消费者</strong>。维护消费组中的消费关系由Kafka协议动态处理。如果新的实例加入组，他们将从组中其他成员处接管一些 partition 分区;如果一个实例消失，拥有的分区将被分发到剩余的实例。</p><p>Kafka 只保证分区内的记录是有序的，而不保证主题中不同分区的顺序。每个 partition 分区按照key值排序足以满足大多数应用程序的需求。但如果你需要总记录在所有记录的上面，可使用仅有一个分区的主题来实现，这意味着每个消费者组只有一个消费者进程。</p><p>Kafka的 topic 被分割成了一组完全有序的 partition，其中每一个 partition 在任意给定的时间内只能被每个订阅了这个 topic 的 consumer 组中的一个 consumer 消费。这意味着 partition 中 每一个 consumer 的位置仅仅是一个数字，即下一条要消费的消息的offset。这使得被消费的消息的状态信息相当少，每个 partition 只需要一个数字。这个状态信息还可以作为周期性的 checkpoint。这以非常低的代价实现了和消息确认机制等同的效果。</p><p>这种方式还有一个附加的好处。consumer 可以回退到之前的 offset 来再次消费之前的数据，这个操作违反了队列的基本原则，但事实证明对大多数 consumer 来说这是一个必不可少的特性。 例如，如果 consumer 的代码有 bug，并且在 bug 被发现前已经有一部分数据被消费了， 那么 consumer 可以在 bug 修复后通过回退到之前的 offset 来再次消费这些数据。</p><h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><p>Kafka 对消息的存储和缓存严重依赖于文件系统。现代操作系统提供了 read-ahead 和 write-behind 技术，read-ahead 是以大的 data block 为单位预先读取数据，而 write-behind 是将多个小型的逻辑写合并成一次大型的物理磁盘写入。关于该问题的进一步讨论可以参考 <a href="http://queue.acm.org/detail.cfm?id=1563874" target="_blank" rel="noopener">ACM Queue article</a>，他们发现实际上<a href="http://deliveryimages.acm.org/10.1145/1570000/1563874/jacobs3.jpg" target="_blank" rel="noopener">顺序磁盘访问在某些情况下比随机内存访问还要快</a>！</p><p>这里给出了一个非常简单的设计：相比于维护尽可能多的 in-memory cache，并且在空间不足的时候匆忙将数据 flush 到文件系统，我们把这个过程倒过来。所有数据一开始就被写入到文件系统的持久化日志中，而不用在 cache 空间不足的时候 flush 到磁盘。实际上，这表明数据被转移到了内核的 pagecache 中。 </p><p>使用文件系统和 pagecache 显得更有优势–我们可以通过自动访问所有空闲内存将可用缓存的容量至少翻倍，并且通过存储紧凑的字节结构而不是独立的对象，有望将缓存容量再翻一番。 这样使得32GB的机器缓存容量可以达到28-30GB,并且不会产生额外的 GC 负担。此外，即使服务重新启动，缓存依旧可用，而 in-process cache 则需要在内存中重建(重建一个10GB的缓存可能需要10分钟)，否则进程就要从 cold cache 的状态开始(这意味着进程最初的性能表现十分糟糕)。 这同时也极大的简化了代码，因为所有保持 cache 和文件系统之间一致性的逻辑现在都被放到了 OS 中，这样做比一次性的进程内缓存更准确、更高效。如果你的磁盘使用更倾向于顺序读取，那么 read-ahead 可以有效的使用每次从磁盘中读取到的有用数据预先填充 cache。</p><p><strong>持久化队列可以建立在简单的读取和向文件后追加两种操作之上</strong>，这和日志解决方案相同。这种架构的优点在于所有的操作复杂度都是O(1)，而且读操作不会阻塞写操作，读操作之间也不会互相影响。这有着明显的性能优势，在不产生任何性能损失的情况下能够访问几乎无限的硬盘空间，这意味着我们可以提供一些其它消息系统不常见的特性。例如：在 Kafka 中，我们可以让消息保留相对较长的一段时间(比如一周)，而不是试图在被消费后立即删除。正如我们后面将要提到的，这给消费者带来了很大的灵活性。</p><p><strong>优化</strong></p><ul><li><p>减少数据拷贝<br>使用 sendfile 方法，可以允许操作系统将数据从 pagecache 直接发送到网络，这样避免重新复制数据。所以这种优化方式，只需要最后一步的copy操作，将数据复制到 NIC 缓冲区。pagecache 和 sendfile 的组合使用意味着，在一个kafka集群中，大多数 consumer 消费时，您将看不到磁盘上的读取活动，因为数据将完全由缓存提供。</p></li><li><p>端到端批量压缩<br>Kafka 以高效的批处理格式支持一批消息可以压缩在一起发送到服务器。这批消息将以压缩格式写入，并且在日志中保持压缩，只会在 consumer 消费时解压缩。</p></li></ul><h2 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h2><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>生产者直接发送数据到主分区的服务器上，不需要经过任何中间路由。为了让生产者实现这个功能，所有的 kafka 服务器节点都能响应这样的元数据请求： 哪些服务器是活着的，主题的哪些分区是主分区，分配在哪个服务器上，这样生产者就能适当地直接发送它的请求到服务器上。</p><p><strong>客户端控制消息发送数据到哪个分区，这个可以实现随机的负载均衡方式, 或者使用一些特定语义的分区函数</strong>。 我们有提供特定分区的接口让用于根据指定的键值进行hash分区(当然也有选项可以重写分区函数)，例如，如果使用用户ID作为key，则用户相关的所有数据都会被分发到同一个分区上。</p><h3 id="异步发送"><a href="#异步发送" class="headerlink" title="异步发送"></a>异步发送</h3><p>批处理是提升性能的一个主要驱动，为了允许批量处理，kafka 生产者会尝试<strong>在内存中汇总数据，并用一次请求批次提交信息</strong>。 批处理，不仅仅可以配置指定的<strong>消息数量</strong>，也可以指定等待特定的<strong>延迟时间</strong>(如64k 或10ms)，这允许汇总更多的数据后再发送，在服务器端也会减少更多的IO操作。 该缓冲是可配置的，并给出了一个机制，通过权衡少量额外的延迟时间获取更好的吞吐量。</p><h2 id="消息交互语义"><a href="#消息交互语义" class="headerlink" title="消息交互语义"></a>消息交互语义</h2><p>Kafka可以提供的消息交付语义保证有多种：</p><ul><li><p>At most once——消息可能会丢失但绝不重传。</p></li><li><p>At least once——消息可以重传但绝不丢失。<br>在 0.11.0.0 之前的版本中, 如果 producer 没有收到表明消息已经被提交的响应, 那么 producer 除了将消息重传之外别无选择。 这里提供的是 at-least-once 的消息交付语义，因为如果最初的请求事实上执行成功了，那么重传过程中该消息就会被再次写入到 log 当中。</p></li><li><p>Exactly once——这正是人们想要的, 每一条消息只被传递一次.</p><p>从 0.11.0.0 版本开始，Kafka producer新增了幂等性的传递选项，该选项保证重传不会在 log 中产生重复条目。 为实现这个目的, broker 给每个 producer 都分配了一个 ID ，并且 producer 给每条被发送的消息分配了一个序列号来避免产生重复的消息。 同样也是从 0.11.0.0 版本开始, producer 新增了使用类似事务性的语义将消息发送到多个 topic partition 的功能： 也就是说，要么所有的消息都被成功的写入到了 log，要么一个都没写进去。这种语义的主要应用场景就是 Kafka topic 之间的 exactly-once 的数据传递。</p><p>并非所有使用场景都需要这么强的保证。对于延迟敏感的应用场景，我们允许生产者指定它需要的持久性级别。如果 producer 指定了它想要等待消息被提交，则可以使用10ms的量级。然而， producer 也可以指定它想要完全异步地执行发送，或者它只想等待直到 leader 节点拥有该消息（follower 节点有没有无所谓）。</p><p>现在让我们从 consumer 的视角来描述语义。 </p></li></ul><p>假设 consumer 要读取一些消息——它有几个处理消息和更新位置的选项。</p><ol><li><p>Consumer 可以先读取消息，然后将它的位置保存到 log 中，最后再对消息进行处理。在这种情况下，消费者进程可能会在保存其位置之后，带还没有保存消息处理的输出之前发生崩溃。而在这种情况下，即使在此位置之前的一些消息没有被处理，接管处理的进程将从保存的位置开始。在 consumer 发生故障的情况下，这对应于“at-most-once”的语义，可能会有消息得不到处理。</p></li><li><p>Consumer 可以先读取消息，然后处理消息，最后再保存它的位置。在这种情况下，消费者进程可能会在处理了消息之后，但还没有保存位置之前发生崩溃。而在这种情况下，当新的进程接管后，它最初收到的一部分消息都已经被处理过了。在 consumer 发生故障的情况下，这对应于“at-least-once”的语义。 在许多应用场景中，消息都设有一个主键，所以更新操作是幂等的（相同的消息接收两次时，第二次写入会覆盖掉第一次写入的记录）。</p></li></ol><h2 id="多副本"><a href="#多副本" class="headerlink" title="多副本"></a>多副本</h2><p>创建副本的单位是 topic 的 partition ，正常情况下， 每个分区都有一个 leader 和零或多个 followers 。 总的副本数是包含 leader 的总和。 所有的读写操作都由 leader 处理，一般 partition 的数量都比 broker 的数量多的多，各分区的 leader 均 匀的分布在brokers 中。所有的 followers 节点都同步 leader 节点的日志，日志中的消息和偏移量都和 leader 中的一致。（当然, 在任何给定时间, leader 节点的日志末尾时可能有几个消息尚未被备份完成）。</p><p>Followers 节点就像普通的 consumer 那样从 leader 节点那里拉取消息并保存在自己的日志文件中。Followers 节点可以从 leader 节点那里批量拉取消息日志到自己的日志文件中。</p><p>与大多数分布式系统一样，自动处理故障需要精确定义节点 “alive” 的概念。Kafka 判断节点是否存活有两种方式。</p><ol><li>节点必须可以维护和 ZooKeeper 的连接，Zookeeper 通过心跳机制检查每个节点的连接。</li><li>如果节点是个 follower ，它必须能及时的同步 leader 的写操作，并且延时不能太久。</li></ol><p>我们认为满足这两个条件的节点处于 “in sync” 状态，区别于 “alive” 和 “failed” 。 Leader会追踪所有 “in sync” 的节点。如果有节点挂掉了, 或是写超时, 或是心跳超时, leader 就会把它从同步副本列表中移除。 同步超时和写超时的时间由 replica.lag.time.max.ms 配置确定。</p><p>在所有时间里，Kafka 保证只要有至少一个同步中的节点存活，提交的消息就不会丢失。</p><p>Kafka分配Replica的算法如下：</p><ol><li>将所有Broker（假设共n个Broker）和待分配的Partition排序</li><li>将第i个Partition分配到第（i mod n）个Broker上</li><li>将第i个Partition的第j个Replica分配到第（(i + j) mod n）个Broker上</li></ol><h2 id="可用性和持久性保证"><a href="#可用性和持久性保证" class="headerlink" title="可用性和持久性保证"></a>可用性和持久性保证</h2><p>向 Kafka 写数据时，producers 设置 ack 是否提交完成， </p><ul><li>0：不等待broker返回确认消息,</li><li>1: leader保存成功返回或,</li><li>-1(all): 所有备份都保存成功返回.</li></ul><p>请注意. 设置 “ack = all” 并不能保证所有的副本都写入了消息。默认情况下，当 acks = all 时，只要 ISR 副本同步完成，就会返回消息已经写入。例如，一个 topic 仅仅设置了两个副本，那么只有一个 ISR 副本，那么当设置acks = all时返回写入成功时，剩下了的那个副本数据也可能数据没有写入。 尽管这确保了分区的最大可用性，但是对于偏好数据持久性而不是可用性的一些用户，可能不想用这种策略，因此，我们提供了两个topic 配置，可用于优先配置消息数据持久性：</p><ol><li><p>禁用 unclean leader 选举机制 - 如果所有的备份节点都挂了,分区数据就会不可用，直到最近的 leader 恢复正常。这种策略优先于数据丢失的风险， 参看上一节的 unclean leader 选举机制。</p></li><li><p>指定最小的 ISR 集合大小，只有当 ISR 的大小大于最小值，分区才能接受写入操作，以防止仅写入单个备份的消息丢失造成消息不可用的情况，这个设置只有在生产者使用 acks = all 的情况下才会生效，这至少保证消息被 ISR 副本写入。此设置是一致性和可用性 之间的折衷，对于设置更大的最小ISR大小保证了更好的一致性，因为它保证将消息被写入了更多的备份，减少了消息丢失的可能性。但是，这会降低可用性，因为如果 ISR 副本的数量低于最小阈值，那么分区将无法写入。</p></li></ol><h2 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h2><h3 id="ISR"><a href="#ISR" class="headerlink" title="ISR"></a>ISR</h3><p>Kafka 动态维护了一个同步状态的备份的集合 （a set of in-sync replicas）， 简称 ISR ，在这个集合中的节点都是和 leader 保持高度一致的，只有这个集合的成员才 有资格被选举为 leader，一条消息必须被这个集合 所有 节点读取并追加到日志中了，这条消息才能视为提交。这个 ISR 集合发生变化会在 ZooKeeper 持久化，正因为如此，这个集合中的任何一个节点都有资格被选为 leader 。因为 ISR 模型和 f+1 副本，一个 Kafka topic 冗余 f 个节点故障而不会丢失任何已经提交的消息。</p><p>Kafka 对于数据不会丢失的保证，是基于至少一个节点在保持同步状态，一旦分区上的所有备份节点都挂了，就无法保证了。但是，实际在运行的系统需要去考虑假设一旦所有的备份都挂了，怎么去保证数据不会丢失，这里有两种实现的方法</p><ol><li>等待一个 ISR 的副本重新恢复正常服务，并选择这个副本作为领 leader （它有极大可能拥有全部数据）。</li><li>选择第一个重新恢复正常服务的副本（不一定是 ISR 中的）作为leader。</li></ol><p>kafka 默认选择第二种策略，当所有的 ISR 副本都挂掉时，会选择一个可能不同步的备份作为 leader ，可以配置属性 unclean.leader.election.enable 禁用此策略，那么就会使用第 一种策略即停机时间优于不同步。</p><h3 id="如何选举Leader"><a href="#如何选举Leader" class="headerlink" title="如何选举Leader"></a>如何选举Leader</h3><p>　　最简单最直观的方案是，所有Follower都在Zookeeper上设置一个Watch，一旦Leader宕机，其对应的ephemeral znode会自动删除，此时所有Follower都尝试创建该节点，而创建成功者（Zookeeper保证只有一个能创建成功）即是新的Leader，其它Replica即为Follower。<br>　　但是该方法会有3个问题： 　　</p><ul><li><p>split-brain 这是由Zookeeper的特性引起的，虽然Zookeeper能保证所有Watch按顺序触发，但并不能保证同一时刻所有Replica“看”到的状态是一样的，这就可能造成不同Replica的响应不一致</p></li><li><p>herd effect 如果宕机的那个Broker上的Partition比较多，会造成多个Watch被触发，造成集群内大量的调整</p></li><li><p>Zookeeper负载过重 每个Replica都要为此在Zookeeper上注册一个Watch，当集群规模增加到几千个Partition时Zookeeper负载会过重。</p></li></ul><p>Kafka 0.8.* 的Leader Election方案解决了上述问题，它 <strong>在所有broker中选出一个controller</strong>，所有Partition的Leader选举都由controller决定。controller会将Leader的改变直接通过RPC的方式（比Zookeeper Queue的方式更高效）通知需为此作出响应的Broker。同时controller也负责增删Topic以及Replica的重新分配。如果 controller 节点挂了，其他 存活的 broker 都可能成为新的 controller 节点。</p><p>【更详细的分析可看】<a href="http://www.jasongj.com/2015/04/24/KafkaColumn2/" target="_blank" rel="noopener">Kafka设计解析（二）- Kafka High Availability （上）</a></p><h2 id="Custom-Rebalance"><a href="#Custom-Rebalance" class="headerlink" title="Custom Rebalance"></a>Custom Rebalance</h2><p>Consumer Rebalance 的算法如下：</p><ul><li>将目标 Topic 下的所有 Partirtion 排序，存于 PT</li><li>对某 Consumer Group 下所有 Consumer 排序，存于 CG，第 i 个 Consumer 记为 Ci</li><li>N=size(PT)/size(CG)，向上取整</li><li>解除 Ci 对原来分配的 Partition 的消费权（i 从 0 开始）</li><li>将第 i * N 到（i+1）* N−1 个 Partition 分配给 Ci</li></ul><p>根据 Kafka 社区 wiki，Kafka 作者正在考虑在还未发布的 0.9.x 版本中使用中心协调器 (Coordinator) 。大体思想是为所有 Consumer Group 的子集选举出一个 Broker 作为 Coordinator，由它 Watch Zookeeper，从而判断是否有 Partition 或者 Consumer 的增减，然后生成 Rebalance 命令，并检查是否这些 Rebalance 在所有相关的 Consumer 中被执行成功，如果不成功则重试，若成功则认为此次 Rebalance 成功（这个过程跟 Replication Controller 非常类似）:</p><h3 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h3><ul><li><p>1) Consumer 启动时，先向 Broker 列表中的任意一个 Broker 发送 ConsumerMetadataRequest，并通过 ConsumerMetadataResponse 获取它所在 Group 的 Coordinator 信息。</p></li><li><p>2）Consumer 连接到 Coordinator 并发送 HeartbeatRequest:</p><ul><li><p>如果返回的 HeartbeatResponse 没有任何错误码，Consumer 继续 fetch 数据。</p></li><li><p>若其中包含 IllegalGeneration 错误码，即说明 Coordinator 已经发起了 Rebalance 操作，此时 Consumer 停止 fetch 数据，commit offset，并发送 JoinGroupRequest 给它的 Coordinator，并在 JoinGroupResponse 中获得它应该拥有的所有 Partition 列表和它所属的 Group 的新的 Generation ID。此时 Rebalance 完成，Consumer 开始 fetch 数据。 </p></li></ul></li></ul><h3 id="故障检测机制"><a href="#故障检测机制" class="headerlink" title="故障检测机制"></a>故障检测机制</h3><p>Consumer 成功加入 Group 后，Consumer 和相应的 Coordinator 同时开始故障探测程序。</p><p>Consumer 向 Coordinator 发起周期性的 Heartbeat（HeartbeatRequest）并等待响应，该<br>周期为 session.timeout.ms/heartbeat.frequency。</p><ul><li><p>若 Consumer 在 session.timeout.ms 内未收到 HeartbeatResponse，或者发现相应的 Socket channel 断开，它即认为 Coordinator 已宕机并启动 Coordinator 探测程序。</p></li><li><p>若 Coordinator 在 session.timeout.ms 内没有收到一次 HeartbeatRequest，则它将该 Consumer 标记为宕机状态并为其所在 Group 触发一次 Rebalance 操作。</p></li></ul><p>Coordinator Failover 过程中，Consumer 可能会在新的 Coordinator 完成 Failover 过程之前或之后发现新的 Coordinator 并向其发送 HeatbeatRequest。</p><ul><li><p>对于后者，新的 Cooodinator 可能拒绝该请求，致使该 Consumer 重新探测 Coordinator 并发起新的连接请求。</p></li><li><p>如果该 Consumer 向新的 Coordinator 发送连接请求太晚，新的 Coordinator 可能已经在此之前将其标记为宕机状态而将之视为新加入的 Consumer 并触发一次 Rebalance 操作。 </p></li></ul><h3 id="Coordinator"><a href="#Coordinator" class="headerlink" title="Coordinator"></a>Coordinator</h3><p>1）稳定状态下，Coordinator 通过上述故障探测机制跟踪其所管理的每个 Group 下的每个 Consumer 的健康状态。</p><p>2）刚启动时或选举完成后，Coordinator 从 Zookeeper 读取它所管理的 Group 列表及这些 Group 的成员列表。如果没有获取到 Group 成员信息，它不会做任何事情直到某个 Group 中有成员注册进来。</p><p>3）在 Coordinator 完成加载其管理的 Group 列表及其相应的成员信息之前，它将为 HeartbeatRequest，OffsetCommitRequest 和 JoinGroupRequests 返回 CoordinatorStartupNotComplete 错误码。此时，Consumer 会重新发送请求。</p><p>4）Coordinator 会跟踪被其所管理的任何 Consumer Group 注册的 Topic 的 Partition 的变化，并为该变化触发 Rebalance 操作。创建新的 Topic 也可能触发 Rebalance，因为 Consumer 可以在 Topic 被创建之前就已经订阅它了。</p><p>Coordinator 发起 Rebalance 操作流程如下所示。</p><p><img src="/images/kafka_rebalance.jpg" alt></p><h2 id="Coordinator-Failover"><a href="#Coordinator-Failover" class="headerlink" title="Coordinator Failover"></a>Coordinator Failover</h2><p>如前文所述，Rebalance 操作需要经历如下几个阶段</p><p>1）Topic/Partition 的改变或者新 Consumer 的加入或者已有 Consumer 停止，触发 Coordinator 注册在 Zookeeper 上的 watch，Coordinator 收到通知准备发起 Rebalance 操作。</p><p>2）Coordinator 通过在 HeartbeatResponse 中返回 IllegalGeneration 错误码发起 Rebalance 操作。</p><p>3）Consumer 发送 JoinGroupRequest</p><p>4）Coordinator 在 Zookeeper 中增加 Group 的 Generation ID 并将新的 Partition 分配情况写入 Zookeeper</p><p>5）Coordinator 发送 JoinGroupResponse</p><p>【摘自】<a href="https://www.infoq.cn/article/kafka-analysis-part-4" target="_blank" rel="noopener">Kafka 设计解析（四）：Kafka Consumer 解析</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;Apache Kafka® 是 一个分布式流处理平台.&lt;br&gt;我们知道流处理平台有以下三种特性:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;可以让你发布和订
      
    
    </summary>
    
      <category term="中间件" scheme="http://yoursite.com/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
      <category term="Kafka" scheme="http://yoursite.com/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/Kafka/"/>
    
    
      <category term="kafka" scheme="http://yoursite.com/tags/kafka/"/>
    
      <category term="入门" scheme="http://yoursite.com/tags/%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>Mysql入门</title>
    <link href="http://yoursite.com/2019/09/22/Mysql%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2019/09/22/Mysql入门/</id>
    <published>2019-09-22T10:01:32.000Z</published>
    <updated>2019-11-22T11:36:54.350Z</updated>
    
    <content type="html"><![CDATA[<h2 id="重识Count"><a href="#重识Count" class="headerlink" title="重识Count()"></a>重识Count()</h2><h3 id="COUNT-列名-、COUNT-常量-和COUNT-之间区别"><a href="#COUNT-列名-、COUNT-常量-和COUNT-之间区别" class="headerlink" title="COUNT(列名)、COUNT(常量)和COUNT(*)之间区别"></a>COUNT(列名)、COUNT(常量)和COUNT(*)之间区别</h3><p>前面我们提到过 <code>COUNT(expr)</code> 用于做行数统计，统计的是expr不为NULL的行数，那么 <code>COUNT(列名)</code>、 <code>COUNT(常量)</code> 和 <code>COUNT(*)</code> 这三种语法中，expr分别是<code>列名</code>、 <code>常量</code> 和 <code>*</code>。</p><p>那么<code>列名</code>、 <code>常量</code> 和 <code>*</code> 这三个条件中，<code>常量</code> 是一个固定值，肯定不为NULL。<code>*</code> 可以理解为查询整行，所以肯定也不为NULL，那么就只有<code>列名</code>的查询结果有可能是NULL了。</p><p><strong>所以， COUNT(常量) 和 COUNT(*)表示的是直接查询符合条件的数据库表的行数。而COUNT(列名)表示的是查询符合条件的列的值不为NULL的行数。</strong></p><p>除了查询得到结果集有区别之外，<code>COUNT(*)</code>相比<code>COUNT(常量)</code> 和 <code>COUNT(列名)</code>来讲，<code>COUNT(*)</code>是SQL92定义的标准统计行数的语法，因为他是标准语法，所以MySQL数据库对他进行过很多优化。</p><h3 id="COUNT-的优化"><a href="#COUNT-的优化" class="headerlink" title="COUNT(*)的优化"></a>COUNT(*)的优化</h3><p>MyISAM和InnoDB有很多区别，其中有一个关键的区别和我们接下来要介绍的<code>COUNT(*)</code>有关，那就是:</p><ul><li>MyISAM不支持事务，MyISAM中的锁是表级锁；</li><li>而InnoDB支持事务，并且支持行级锁;</li></ul><p>因为MyISAM的锁是表级锁，同一张表上面的操作需要串行进行，所以，MyISAM做了一个简单的优化:</p><blockquote><p>它可以把表的总行数单独记录下来，如果从一张表中使用<code>COUNT(*)</code>进行查询的时候，可以直接返回这个记录下来的数值就可以了，当然，前提是不能有where条件。</p></blockquote><p>MyISAM之所以可以把表中的总行数记录下来供<code>COUNT(*)</code>查询使用，那是因为MyISAM数据库是表级锁，不会有并发的数据库行数修改，所以查询得到的行数是准确的。</p><p>但是，对于InnoDB来说，就不能做这种缓存操作了，因为InnoDB支持事务，其中大部分操作都是行级锁，所以可能表的行数可能会被并发修改，那么缓存记录下来的总行数就不准确了。</p><p>在InnoDB中，使用<code>COUNT(*)</code>查询行数的时候，不可避免的要进行扫表了，那么，就可以在扫表过程中下功夫来优化效率了。<br>从MySQL 8.0.13开始，针对InnoDB的 <code>SELECT COUNT(*) FROM tbl_name</code> 语句，确实在扫表的过程中做了一些优化。<strong>前提是查询语句中不包含WHERE或GROUP BY等条件。</strong></p><p><strong><code>COUNT(*)</code>的目的只是为了统计总行数，所以，他根本不关心自己查到的具体值，所以，他如果能够在扫表的过程中，选择一个成本较低的索引进行的话，那就可以大大节省时间。</strong></p><p>我们知道，InnoDB中索引分为<code>聚簇索引（主键索引）</code>和<code>非聚簇索引（非主键索引）</code>，聚簇索引的叶子节点中保存的是整行记录，而非聚簇索引的叶子节点中保存的是该行记录的主键的值。</p><blockquote><p>相比之下，非聚簇索引要比聚簇索引小很多，所以MySQL会优先选择最小的非聚簇索引来扫表。所以，当我们建表的时候，除了主键索引以外，创建一个非主键索引还是有必要的。</p></blockquote><p>至此，我们介绍完了MySQL数据库对于COUNT(*)的优化，这些优化的前提都是查询语句中不包含WHERE以及GROUP BY条件。</p><h3 id="COUNT-和COUNT-1"><a href="#COUNT-和COUNT-1" class="headerlink" title="COUNT(*)和COUNT(1)"></a>COUNT(*)和COUNT(1)</h3><p>看下MySQL官方文档是怎么说的：</p><blockquote><p>InnoDB handles SELECT COUNT(*) and SELECT COUNT(1) operations in the same way. There is no performance difference.</p></blockquote><p>画重点：<code>same way , no performance difference</code>。所以，<strong>对于COUNT(1)和COUNT(*)，MySQL的优化是完全一样的，根本不存在谁比谁快！</strong></p><p>建议使用COUNT(*)！因为这个是SQL92定义的标准统计行数的语法。</p><h3 id="COUNT-字段"><a href="#COUNT-字段" class="headerlink" title="COUNT(字段)"></a>COUNT(字段)</h3><p>最后，就是我们一直还没提到的COUNT(字段)，他的查询就比较简单粗暴了，就是进行全表扫描，然后判断指定字段的值是不是为NULL，不为NULL则累加。<br>相比<code>COUNT(*)</code>，<code>COUNT(字段)</code>多了一个步骤就是判断所查询的字段是否为NULL，所以他的性能要比COUNT(*)慢。</p><h2 id="事务及原理"><a href="#事务及原理" class="headerlink" title="事务及原理"></a>事务及原理</h2><p><a href="https://juejin.im/post/5d7dd7e7f265da03d60f2f56?utm_source=gold_browser_extension#heading-1" target="_blank" rel="noopener">Mysql事务及其原理</a></p><h3 id="事务的-ACID-属性"><a href="#事务的-ACID-属性" class="headerlink" title="事务的 ACID 属性"></a>事务的 ACID 属性</h3><ul><li><p><strong>原子性（Atomicity）</strong>：作为逻辑工作单元，一个事务里的所有操作的执行，要么全部成功，要么全部失败。</p></li><li><p><strong>一致性（Consistency）</strong>：数据库从一个一致性状态变换到另外一个一致性状态，数据库的完整性不会受到破坏。</p></li><li><p><strong>隔离性（Isolation）</strong>：通常来说，一个事务所做的修改在最终提交前，对其他事务是不可见的。为什么是通常来说，为了提高事务的并发引出不同的隔离级别，具体参考下一章节。</p></li><li><p><strong>持久性（Durability）</strong>：一旦事务提交，则其所做的修改就会永久保存到数据库中，即使系统故障，修改的数据也不会丢失。</p></li></ul><h3 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h3><p>为了尽可能的高并发，事务的隔离性被分为四个级别：读未提交、读已提交、可重复读和串行化。用户可以根据需要选择不同的级别。</p><ul><li><p><strong>未提交读（READ UNCOMMITTED）</strong>：一个事务还未提交，它的变更就能被别的事务看到。</p><p>  <strong>例</strong>：事务 A 可以读到事务 B 修改的但还未提交的数据，会导致脏读（可能事务 B 在提交后失败了，事务 A 读到的数据是脏的）。</p></li><li><p><strong>提交读（READ COMMITTED）</strong>：一个事务提交后，它的变更才能被其他事务看到。大多数据库系统的默认级别，但 Mysql 不是。</p><p>  <strong>例</strong>：事务 A 只能读到事务 B 修改并提交后的数据，会导致不可重复读（事务 A 中执行两次查询，一次在事务 B 提交过程中，一次在事务 B 提交之后，会导致两次读取的结果不一致）。</p></li><li><p><strong>可重复读（REPEATABLE READ）</strong>：未提交的事务的变更不能被其他事务看到，同时一次事务过程中多次读取同样记录的结果是一致的。</p><p>  <strong>例</strong>：事务 A 在执行过程中多次获取某范围内的记录，事务 B 提交后在此范围内插入或者删除 N条记录，事务 A 执行过程中多次范围读会存在不一致，即幻读（Mysql 的默认级别，InnoDB 通过 MVVC 解决了幻读的问题）。</p></li><li><p><strong>可串行化（SERIALIZABLE）</strong>：当两个事务间存在读写冲突时，数据库通过加锁强制事务串行执行，解决了前面所说的所有问题（脏读、不可重复读、幻读）。是最高隔离的隔离级别。</p></li></ul><p>用表格可以更清晰的描述四种隔离级别的定义和可能存在的问题：<br><img src="/images/mysql_isolate_level.jpg" alt></p><p>以上是对四种隔离级别的定义和初步认识，看<a href="https://juejin.im/post/5c9756296fb9a070ad504a05" target="_blank" rel="noopener">《十分钟搞懂MySQL四种事务隔离级别》</a>这篇文章可以彻底弄清楚他们之间的区别。</p><h2 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li><p><strong>分表 - 解决单表数据过大</strong><br>比如你单表都几千万数据了，你确定你能扛住么？绝对不行，<strong>单表数据量太大，会极大影响你的 sql 执行的性能</strong>，到了后面你的 sql 可能就跑的很慢了。一般来说，就以我的经验来看，单表到几百万的时候，性能就会相对差一些了，你就得分表了。</p><p>  分表就是把一个表的数据放到多个表中，然后查询的时候你就查一个表。比如按照用户 id 来分表，将一个用户的数据就放在一个表中。然后操作的时候你对一个用户就操作那个表就好了。这样可以控制每个表的数据量在可控的范围内，比如每个表就固定在 200 万以内。</p></li><li><p><strong>分库 - 解决单库并发压力太大</strong><br>一个库一般我们经验而言，最多支撑到并发 2000，一定要扩容了，而且一个健康的单库并发值你最好保持在每秒 1000 左右，不要太大。那么你可以<strong>将一个库的数据拆分到多个库中</strong>，访问的时候就访问一个库好了。</p><table><thead><tr><th></th><th>分库分表前</th><th>分库分表后</th></tr></thead><tbody><tr><td>并发支撑情况</td><td>MySQL 单机部署，扛不住高并发</td><td>MySQL从单机到多机，能承受的并发增加了多倍</td></tr><tr><td>磁盘使用情况</td><td>MySQL 单机磁盘容量几乎撑满</td><td>拆分为多个库，数据库服务器磁盘使用率大大降低</td></tr><tr><td>SQL 执行性能</td><td>单表数据量太大，SQL 越跑越慢</td><td>单表数据量减少，SQL 执行效率明显提升</td></tr></tbody></table></li></ul><h3 id="水平拆分"><a href="#水平拆分" class="headerlink" title="水平拆分"></a>水平拆分</h3><p>水平拆分的意思，就是把一个表的数据给弄到<strong>多个库的多个表里</strong>去，但是<strong>每个库的表结构都一样</strong>，只不过每个库表放的数据是不同的，<strong>所有库表的数据加起来就是全部数据</strong>。水平拆分的意义，就是<font color="red"><strong>将数据均匀放更多的库里，然后用多个库来扛更高的并发，还有就是用多个库的存储容量来进行扩容</strong></font>。</p><p><img src="/images/mysql_veri_split.jpg" alt></p><h3 id="垂直拆分"><a href="#垂直拆分" class="headerlink" title="垂直拆分"></a>垂直拆分</h3><p>垂直拆分的意思，就是<strong>把一个有很多字段的表给拆分成多个表，或者是多个库上去</strong>。<strong>每个库表的结构都不一样，每个库表都包含部分字段</strong>。一般来说，<strong>会将较少的访问频率很高的字段放到一个表里去，然后将较多的访问频率很低的字段放到另外一个表里去</strong>。因为数据库是有缓存的，你访问频率高的行字段越少，就可以在缓存里缓存更多的行，性能就越好。这个一般在表层面做的较多一些。<br>    <img src="/images/mysql_horize_split.jpg" alt></p><p>这个其实挺常见的，不一定我说，大家很多同学可能自己都做过，把一个大表拆开，订单表、订单支付表、订单商品表。</p><h3 id="拆表不拆库"><a href="#拆表不拆库" class="headerlink" title="拆表不拆库"></a>拆表不拆库</h3><p>还有<strong>表层面的拆分</strong>，就是分表，将一个表变成 N 个表，就是让每个表的数据量控制在一定范围内，保证 SQL 的性能。否则单表数据量越大，SQL 性能就越差。一般是 200 万行左右，不要太多，但是也得看具体你怎么操作，也可能是 500 万，或者是 100 万。你的SQL越复杂，就最好让单表行数越少。</p><p><strong>分库分表策略</strong></p><ul><li><p>垂直拆分，你可以在表层面来做，对一些字段特别多的表做一下拆分；</p></li><li><p>水平拆分，你可以说是并发承载不了，或者是数据量太大，容量承载不了，你给拆了，按什么字段来拆，你自己想好；</p></li><li><p>分表，你考虑一下，你如果哪怕是拆到每个库里去，并发和容量都 ok 了，但是每个库的表还是太大了，那么你就分表不分库，将这个表分开，保证每个表的数据量并不是很大。</p></li></ul><p>而且这儿还有两种<strong>分库分表的方式</strong>：</p><ul><li><p>按照 range 来分，就是每个库一段连续的数据，这个一般是按比如时间范围来的，但是这种一般较少用。</p><ul><li><p>优点： 扩容的时候很简单，因为你只要预备好，给每个月都准备一个库就可以了，到了一个新的月份的时候，自然而然，就会写新的库了</p></li><li><p>缺点：很容易产生热点问题，大量的流量都打在最新的数据上。实际生产用 range，要看场景；</p></li></ul></li><li><p>按照某个字段 hash 一下均匀分散，这个较为常用。</p><ul><li><p>优点：可以平均分配每个库的数据量和请求压力；</p></li><li><p>缺点：扩容起来比较麻烦，会有一个数据迁移的过程，之前的数据需要重新计算 hash 值重新分配到不同的库或表。</p></li></ul></li></ul><h2 id="分库分表中间件"><a href="#分库分表中间件" class="headerlink" title="分库分表中间件"></a>分库分表中间件</h2><p>比较常见的包括：</p><h3 id="Cobar"><a href="#Cobar" class="headerlink" title="Cobar"></a>Cobar</h3><p>阿里 b2b 团队开发和开源的，属于 proxy 层方案，就是介于应用服务器和数据库服务器之间。应用程序通过 JDBC 驱动访问 Cobar 集群，Cobar 根据 SQL 和分库规则对 SQL 做分解，然后分发到 MySQL 集群不同的数据库实例上执行。早些年还可以用，但是最近几年都没更新了，基本没啥人用，差不多算是被抛弃的状态吧。而且不支持读写分离、存储过程、跨库 join 和分页等操作。</p><h3 id="TDDL"><a href="#TDDL" class="headerlink" title="TDDL"></a>TDDL</h3><p>淘宝团队开发的，属于 client 层方案。支持基本的 crud 语法和读写分离，但不支持 join、多表查询等语法。目前使用的也不多，因为还依赖淘宝的 diamond 配置管理系统。</p><h3 id="Atlas"><a href="#Atlas" class="headerlink" title="Atlas"></a>Atlas</h3><p>360 开源的，属于 proxy 层方案，以前是有一些公司在用的，但是确实有一个很大的问题就是社区最新的维护都在 5 年前了。所以，现在用的公司基本也很少了。</p><h3 id="Sharding-jdbc"><a href="#Sharding-jdbc" class="headerlink" title="Sharding-jdbc"></a>Sharding-jdbc</h3><p>当当开源的，属于 client 层方案，目前已经更名为 ShardingSphere（后文所提到的 Sharding-jdbc，等同于 ShardingSphere）。确实之前用的还比较多一些，因为 SQL 语法支持也比较多，没有太多限制，而且截至 2019.4，已经推出到了 4.0.0-RC1 版本，支持分库分表、读写分离、分布式 id 生成、柔性事务（最大努力送达型事务、TCC 事务）。而且确实之前使用的公司会比较多一些（这个在官网有登记使用的公司，可以看到从 2017 年一直到现在，是有不少公司在用的），目前社区也还一直在开发和维护，还算是比较活跃，个人认为算是一个现在也可以选择的方案。</p><h3 id="Mycat"><a href="#Mycat" class="headerlink" title="Mycat"></a>Mycat</h3><p>基于 Cobar 改造的，属于 proxy 层方案，支持的功能非常完善，而且目前应该是非常火的而且不断流行的数据库中间件，社区很活跃，也有一些公司开始在用了。但是确实相比于 Sharding jdbc 来说，年轻一些，经历的锤炼少一些。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>综上，现在其实建议考量的，就是 <strong>Sharding-jdbc 和 Mycat</strong>，这两个都可以去考虑使用。</p><ul><li><p>Sharding-jdbc </p><ul><li><p>优点： 这种 <strong>client</strong> 层方案的优点在于不用部署，运维成本低，不需要代理层的二次转发请求，性能很高，建议中小型公司选用;</p></li><li><p>缺点： 如果遇到升级啥的需要各个系统都重新升级版本再发布，各个系统都需要耦合 Sharding-jdbc 的依赖；</p></li></ul></li><li><p>Mycat </p><ul><li><p>优点： 对于各个项目是透明的，如果遇到升级之类的都是自己中间件那里搞定就行；</p></li><li><p>优点： 这种 proxy 层方案的缺点在于需要部署，自己运维一套中间件，运维成本高，最好是专门弄个人来研究和维护 Mycat，然后大量项目直接透明使用即;</p></li></ul></li></ul><h2 id="Mysql主从复制"><a href="#Mysql主从复制" class="headerlink" title="Mysql主从复制"></a>Mysql主从复制</h2><h3 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h3><p>其实很简单，就是基于主从复制架构，简单来说，就搞一个主库，挂多个从库，然后我们就单单只是写主库，然后主库会自动把数据给同步到从库上去。</p><h3 id="主从复制原理"><a href="#主从复制原理" class="headerlink" title="主从复制原理"></a>主从复制原理</h3><p>主库将变更写入 binlog 日志，然后从库连接到主库之后，从库有一个 IO 线程，将主库的 binlog 日志拷贝到自己本地，写入一个 relay 中继日志中。接着从库中有一个 SQL 线程会从中继日志读取 binlog，然后执行 binlog 日志中的内容，也就是在自己本地再次执行一遍 SQL，这样就可以保证自己跟主库的数据是一样的。<br><img src="/images/mysql_master_slave_copy.jpg" alt></p><p>这里有一个非常重要的一点，就是<strong>从库同步主库数据的过程是串行化的</strong>，也就是说<strong>主库上并行的操作，在从库上会串行执行</strong>。所以这就是一个非常重要的点了，由于从库从主库拷贝日志以及串行执行 SQL 的特点，在高并发场景下，从库的数据一定会比主库慢一些，是有延时的。所以经常出现，刚写入主库的数据可能是读不到的，要过几十毫秒，甚至几百毫秒才能读取到。</p><p>而且这里还有另外一个问题，就是如果主库突然宕机，然后恰好数据还没同步到从库，那么有些数据可能在从库上是没有的，有些数据可能就丢失了。</p><p>所以 MySQL 实际上在这一块有两个机制，一个是<strong>半同步复制</strong>，用来解决主库数据丢失问题；一个是<strong>并行复制</strong>，用来解决主从同步延时问题。</p><ul><li><p><strong>半同步复制</strong><br>也叫 <strong>semi-sync</strong> 复制，指的就是主库写入 binlog 日志之后，<strong>强制立即</strong>将数据同步到从库，从库将日志写入自己本地的 relay log 之后，接着会返回一个 ack 给主库，主库接收到<strong>至少一个从库的 ack 之后</strong>才会认为写操作完成了；</p></li><li><p><strong>并行复制</strong><br>从库开启多个线程，<strong>并行读取 relay log 中不同库的日志，然后并行重放不同库的日志</strong>，这是<strong>库级别</strong>的并行。</p></li></ul><h3 id="主从同步延时问题"><a href="#主从同步延时问题" class="headerlink" title="主从同步延时问题"></a>主从同步延时问题</h3><p>一般来说，如果主从延迟较为严重，有以下解决方案：</p><ul><li><p><strong>分库，</strong>将一个主库拆分为多个主库，每个主库的写并发就减少了几倍，此时主从延迟可以忽略不计；</p></li><li><p>打开MySQL支持的<strong>并行复制</strong>，多个库并行复制。如果说某个库的写入并发就是特别高，单库写并发达到了 2000/s，并行复制还是没意义；</p></li><li><p>重写代码，写代码的同学，要慎重，插入数据时立马查询可能查不到;</p></li><li><p>如果确实是存在必须先插入，立马要求就查询到，然后立马就要反过来执行一些操作，对这个查询<strong>设置直连主库</strong>。不推荐这种方法，如果这么做，读写分离的意义就丧失了。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;重识Count&quot;&gt;&lt;a href=&quot;#重识Count&quot; class=&quot;headerlink&quot; title=&quot;重识Count()&quot;&gt;&lt;/a&gt;重识Count()&lt;/h2&gt;&lt;h3 id=&quot;COUNT-列名-、COUNT-常量-和COUNT-之间区别&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="Mysql" scheme="http://yoursite.com/categories/Mysql/"/>
    
      <category term="入门" scheme="http://yoursite.com/categories/Mysql/%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="基础" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="Mysql" scheme="http://yoursite.com/tags/Mysql/"/>
    
  </entry>
  
</feed>
