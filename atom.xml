<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Austin Brant</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-01-10T12:57:31.108Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Austin Brant</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SpringBoot基本原理</title>
    <link href="http://yoursite.com/2020/01/10/SpringBoot%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2020/01/10/SpringBoot基本原理/</id>
    <published>2020-01-10T12:51:16.000Z</published>
    <updated>2020-01-10T12:57:31.108Z</updated>
    
    <content type="html"><![CDATA[<h2 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h2><p>启动类代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringBootDemoApplication</span> <span class="keyword">extends</span> <span class="title">SpringBootServletInitializer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringBootDemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对照上面的典型代码，这个两个元素分别是：</p><blockquote><p>@SpringBootApplication<br>SpringApplication 以及 run() 方法</p></blockquote><p>SpringApplication 这个类应该算是 SpringBoot 框架 的“创新”产物了，原始的 Spring中并没有这个类，SpringApplication 里面封装了一套 Spring 应用的启动流程，然而这对用户完全透明，因此我们上手 SpringBoot 时感觉简洁、轻量。</p><p>一般来说默认的 SpringApplication 执行流程已经可以满足大部分需求，但是 若用户想干预这个过程，则可以通过 SpringApplication 在流程某些地方开启的 扩展点 来完成对流程的扩展，典型的扩展方案那就是使用 set 方法。<br>我们来举一个栗子，把我们天天司空见惯的 SpringBoot 应用的启动类来拆解一下写出来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringBootDemoApplication</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 这是传统SpringBoot应用的启动，一行代码搞定，内部默认做了很多事</span></span><br><span class="line"><span class="comment">// SpringApplication.run( SpringBootDemoApplication args ); </span></span><br><span class="line">SpringApplication app = <span class="keyword">new</span> SpringApplication(SpringBootDemoApplication );</span><br><span class="line">app.setXXX( ... ); <span class="comment">// 用户自定的扩展在此 ！！！</span></span><br><span class="line">app.run( args );</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一拆解后我们发现，我们也需要先构造 SpringApplication 类对象，然后调用该对象的 run() 方法。那么接下来就讲讲 SpringApplication 的构造过程 以及其 run() 方法的流程，搞清楚了这个，那么也就搞清楚了SpringBoot应用是如何运行起来的！</p><h3 id="SpringApplication-实例的初始化"><a href="#SpringApplication-实例的初始化" class="headerlink" title="SpringApplication 实例的初始化"></a>SpringApplication 实例的初始化</h3><p>首先看下SpringApplication的构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SpringApplication</span><span class="params">(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">Assert.notNull(primarySources, <span class="string">"PrimarySources must not be null"</span>);</span><br><span class="line"><span class="keyword">this</span>.primarySources = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(Arrays.asList(primarySources));</span><br><span class="line"><span class="comment">// (1) 推断应用的类型</span></span><br><span class="line"><span class="keyword">this</span>.webApplicationType = WebApplicationType.deduceFromClasspath();</span><br><span class="line"><span class="comment">// (2) 查找并加载 classpath下 META-INF/spring.factories文件中所有可用的 ApplicationContextInitializer</span></span><br><span class="line">setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));</span><br><span class="line"><span class="comment">// (3) 查找并加载 classpath下 META-INF/spring.factories文件中的所有可用的 ApplicationListener</span></span><br><span class="line">setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));</span><br><span class="line"><span class="comment">// (4) 推断并设置 main方法的定义类</span></span><br><span class="line"><span class="keyword">this</span>.mainApplicationClass = deduceMainApplicationClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>详细过程如下：</p><ul><li>（1）推断应用的类型：根据你classpath 下是否能找到对应的class文件， 推断应用类型， 优先级依次是：REACTIVE 、NONE、SERVLET(默认)。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> WebApplicationType <span class="title">deduceFromClasspath</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (ClassUtils.isPresent(WEBFLUX_INDICATOR_CLASS, <span class="keyword">null</span>) &amp;&amp; !ClassUtils.isPresent(WEBMVC_INDICATOR_CLASS, <span class="keyword">null</span>)</span><br><span class="line">&amp;&amp; !ClassUtils.isPresent(JERSEY_INDICATOR_CLASS, <span class="keyword">null</span>)) &#123;</span><br><span class="line"><span class="keyword">return</span> WebApplicationType.REACTIVE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (String className : SERVLET_INDICATOR_CLASSES) &#123;</span><br><span class="line"><span class="keyword">if</span> (!ClassUtils.isPresent(className, <span class="keyword">null</span>)) &#123;</span><br><span class="line"><span class="keyword">return</span> WebApplicationType.NONE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> WebApplicationType.SERVLET;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>（2）使用 SpringFactoriesLoader查找并加载 classpath下 <code>META-INF/spring.factories</code>文件中所有可用的 ApplicationContextInitializer</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Initializers</span><br><span class="line">org.springframework.context.ApplicationContextInitializer=\</span><br><span class="line">org.springframework.boot.autoconfigure.SharedMetadataReaderFactoryContextInitializer,\</span><br><span class="line">org.springframework.boot.autoconfigure.logging.ConditionEvaluationReportLoggingListener</span><br></pre></td></tr></table></figure><ul><li>(3) 使用 SpringFactoriesLoader查找并加载 classpath下 <code>META-INF/spring.factories</code>文件中的所有可用的 ApplicationListener</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Application Listeners</span><br><span class="line">org.springframework.context.ApplicationListener=\</span><br><span class="line">org.springframework.boot.autoconfigure.BackgroundPreinitializer</span><br></pre></td></tr></table></figure><ul><li>(4) 推断并设置main方法的定义类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Class&lt;?&gt; deduceMainApplicationClass() &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">StackTraceElement[] stackTrace = <span class="keyword">new</span> RuntimeException().getStackTrace();</span><br><span class="line"><span class="keyword">for</span> (StackTraceElement stackTraceElement : stackTrace) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="string">"main"</span>.equals(stackTraceElement.getMethodName())) &#123;</span><br><span class="line"><span class="keyword">return</span> Class.forName(stackTraceElement.getClassName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line"><span class="comment">// Swallow and continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SpringApplication-的run-方法"><a href="#SpringApplication-的run-方法" class="headerlink" title="SpringApplication 的run()方法"></a>SpringApplication 的run()方法</h3><p>先看代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">    StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">stopWatch.start();</span><br><span class="line">ConfigurableApplicationContext context = <span class="keyword">null</span>;</span><br><span class="line">Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">configureHeadlessProperty();</span><br><span class="line"><span class="comment">// 通过 SpringFactoriesLoader 加载META-INF/spring.factories文件，获取并创建 SpringApplicationRunListener对象</span></span><br><span class="line">SpringApplicationRunListeners listeners = getRunListeners(args);</span><br><span class="line"><span class="comment">// 然后由 SpringApplicationRunListener 来发出 starting 消息</span></span><br><span class="line">listeners.starting();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="comment">// 创建参数，并配置当前 SpringBoot 应用将要使用的 Environment</span></span><br><span class="line">ApplicationArguments applicationArguments = <span class="keyword">new</span> DefaultApplicationArguments(args);</span><br><span class="line"><span class="comment">// 完成之后，依然由 SpringApplicationRunListener 来发出 environmentPrepared 消息</span></span><br><span class="line">ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments);</span><br><span class="line">configureIgnoreBeanInfo(environment);</span><br><span class="line"><span class="comment">// 打印欢迎页信息</span></span><br><span class="line">Banner printedBanner = printBanner(environment);</span><br><span class="line">context = createApplicationContext();</span><br><span class="line">exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter.class,</span><br><span class="line"><span class="keyword">new</span> Class[] &#123; ConfigurableApplicationContext.class &#125;, context);</span><br><span class="line"><span class="comment">// 初始化 ApplicationContext，并设置 Environment，加载相关配置等</span></span><br><span class="line">prepareContext(context, environment, listeners, applicationArguments, printedBanner);</span><br><span class="line"><span class="comment">// 刷新context，最重要的一步，完成IOC容器注入整个过程</span></span><br><span class="line">refreshContext(context);</span><br><span class="line">afterRefresh(context, applicationArguments);</span><br><span class="line">stopWatch.stop();</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</span><br><span class="line"><span class="keyword">new</span> StartupInfoLogger(<span class="keyword">this</span>.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);</span><br><span class="line">&#125;</span><br><span class="line">listeners.started(context);</span><br><span class="line">callRunners(context, applicationArguments);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">handleRunFailure(context, ex, exceptionReporters, listeners);</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">listeners.running(context);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">handleRunFailure(context, ex, exceptionReporters, <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>流程图如下：<br><img src="/images/spring_boot_starter_pro.png" alt></p><h2 id="自动装配原理"><a href="#自动装配原理" class="headerlink" title="自动装配原理"></a>自动装配原理</h2><h3 id="自动装配过程分析"><a href="#自动装配过程分析" class="headerlink" title="自动装配过程分析"></a>自动装配过程分析</h3><p>自动装配原理得从 <code>@SpringbootApplication</code> 入手分析</p><p><img src="/images/spring_boot_application.png" alt></p><p><code>@SpringbootApplication</code>包含了<code>@SpringBootConfiguration</code>，<code>@EnableAutoConfiguration</code>，<code>@ComponentScan</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(excludeFilters = &#123;</span><br><span class="line">        <span class="meta">@Filter</span>(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span><br><span class="line">        <span class="meta">@Filter</span>(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</span><br></pre></td></tr></table></figure><ul><li><p><code>@ComponentScan</code>如果没有指定扫描包，因此它默认扫描的是与该类同级的类或者同级包下的所有类;</p></li><li><p><code>@SpringBootConfiguration</code>通过源码得知它是一个<code>@Configuration</code>;</p></li><li><p><code>@EnableAutoConfiguration</code> 一旦加上此注解，那么将会开启自动装配功能，简单点讲，Spring会试图在你的classpath下找到所有配置的Bean然后进行装配。当然装配Bean时，会根据若干个<code>@Conditional</code>定制规则来进行初始化;</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"deprecation"</span>)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import</span>(EnableAutoConfigurationImportSelector.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br><span class="line"></span><br><span class="line">    String ENABLED_OVERRIDE_PROPERTY = <span class="string">"spring.boot.enableautoconfiguration"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Exclude specific auto-configuration classes such that they will never be applied.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the classes to exclude</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Class&lt;?&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Exclude specific auto-configuration class names such that they will never be</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String[] excludeName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>根据文档注释的说明它指点我们去看<code>EnableAutoConfigurationImportSelector</code>。但是该类在SpringBoot1.5.X版本已经过时了，因此我们看一下它的父类<code>AutoConfigurationImportSelector</code>;</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AutoConfigurationImportSelector</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">DeferredImportSelector</span>, <span class="title">BeanClassLoaderAware</span>, <span class="title">ResourceLoaderAware</span>,</span></span><br><span class="line"><span class="class">        <span class="title">BeanFactoryAware</span>, <span class="title">EnvironmentAware</span>, <span class="title">Ordered</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] NO_IMPORTS = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log logger = LogFactory</span><br><span class="line">            .getLog(AutoConfigurationImportSelector.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ConfigurableListableBeanFactory beanFactory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Environment environment;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ClassLoader beanClassLoader;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ResourceLoader resourceLoader;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isEnabled(annotationMetadata)) &#123;</span><br><span class="line">            <span class="keyword">return</span> NO_IMPORTS;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 读取mata-info/spring-autoconfigure-metadata.properties元数据与元数据的相关属性</span></span><br><span class="line">            AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader</span><br><span class="line">                    .loadMetadata(<span class="keyword">this</span>.beanClassLoader);</span><br><span class="line">            AnnotationAttributes attributes = getAttributes(annotationMetadata);</span><br><span class="line">            <span class="comment">// 去 mata-info/spring.factories 文件中查询 EnableAutoConfiguration值</span></span><br><span class="line">            List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata,</span><br><span class="line">                    attributes);</span><br><span class="line">            <span class="comment">// 去除重复的配置类，若我们自己写的starter可能存在重复的</span></span><br><span class="line">            configurations = removeDuplicates(configurations);</span><br><span class="line">            configurations = sort(configurations, autoConfigurationMetadata);</span><br><span class="line">            Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);</span><br><span class="line">            checkExcludedClasses(configurations, exclusions);</span><br><span class="line">            configurations.removeAll(exclusions);</span><br><span class="line">            <span class="comment">// 根据maven导入的启动器过滤出需要导入的配置类</span></span><br><span class="line">            configurations = filter(configurations, autoConfigurationMetadata);</span><br><span class="line">            fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line">            <span class="keyword">return</span> configurations.toArray(<span class="keyword">new</span> String[configurations.size()]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isEnabled</span><span class="params">(AnnotationMetadata metadata)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先该类实现了<code>DeferredImportSelector</code>接口，这个接口继承了<code>ImportSelector</code>, 该接口主要是为了导入 <code>@Configuration</code> 的配置项，而 <code>DeferredImportSelector</code> 是延期导入，当所有的<code>@Configuration</code>都处理过后才会执行;</p><ul><li>回过头来我们看一下 <code>AutoConfigurationImportSelector</code> 的<code>selectImport</code>方法, 该方法刚开始会先判断是否进行自动装配，而后会从 <code>META-INF/spring-autoconfigure-metadata.properties</code> 读取元数据与元数据的相关属性，紧接着会调用<code>getCandidateConfigurations</code>方法：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;String&gt; <span class="title">getCandidateConfigurations</span><span class="params">(AnnotationMetadata metadata,</span></span></span><br><span class="line"><span class="function"><span class="params">            AnnotationAttributes attributes)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(</span><br><span class="line">                getSpringFactoriesLoaderFactoryClass(), getBeanClassLoader());</span><br><span class="line">        Assert.notEmpty(configurations,</span><br><span class="line">                <span class="string">"No auto configuration classes found in META-INF/spring.factories. If you "</span></span><br><span class="line">                        + <span class="string">"are using a custom packaging, make sure that file is correct."</span>);</span><br><span class="line">        <span class="keyword">return</span> configurations;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the class used by &#123;<span class="doctag">@link</span> SpringFactoriesLoader&#125; to load configuration candidates.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; getSpringFactoriesLoaderFactoryClass() &#123;</span><br><span class="line">    <span class="keyword">return</span> EnableAutoConfiguration.class;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里又遇到<code>SpringFactoryiesLoader</code>, 它会读取<code>META-INF/spring.factories</code>下的<code>EnableAutoConfiguration</code>的配置，紧接着在进行排除与过滤，进而得到需要装配的类。最后让所有配置在<code>META-INF/spring.factories</code>下的<code>AutoConfigurationImportListener</code>执行<code>AutoConfigurationImportEvent</code>事件，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fireAutoConfigurationImportEvents</span><span class="params">(List&lt;String&gt; configurations,</span></span></span><br><span class="line"><span class="function"><span class="params">            Set&lt;String&gt; exclusions)</span> </span>&#123;</span><br><span class="line">    List&lt;AutoConfigurationImportListener&gt; listeners = getAutoConfigurationImportListeners();</span><br><span class="line">    <span class="keyword">if</span> (!listeners.isEmpty()) &#123;</span><br><span class="line">        AutoConfigurationImportEvent event = <span class="keyword">new</span> AutoConfigurationImportEvent(<span class="keyword">this</span>,</span><br><span class="line">                configurations, exclusions);</span><br><span class="line">        <span class="keyword">for</span> (AutoConfigurationImportListener listener : listeners) &#123;</span><br><span class="line">            invokeAwareMethods(listener);</span><br><span class="line">            listener.onAutoConfigurationImportEvent(event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;AutoConfigurationImportListener&gt; <span class="title">getAutoConfigurationImportListeners</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> SpringFactoriesLoader.loadFactories(AutoConfigurationImportListener.class,</span><br><span class="line">            <span class="keyword">this</span>.beanClassLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>1）自动装配还是利用了 <code>SpringFactoriesLoader</code> 来加载<code>META-INF/spring.factoires</code>文件里所有配置的<code>EnableAutoConfgruation</code>，它会经过<code>exclude</code>和<code>filter</code>等操作，最终确定要装配的类</p><p>2)  处理<code>@Configuration</code>的核心还是<code>ConfigurationClassPostProcessor</code>，这个类实现了<code>BeanFactoryPostProcessor</code>, 因此当<code>AbstractApplicationContext</code>执行<code>refresh()</code>方法里的<code>invokeBeanFactoryPostProcessors(beanFactory)</code>方法时会执行自动装配</p><p><img src="/images/springboot_st1.png" alt="-w974"><br><img src="/images/springboot_st2.png" alt="-w595"></p><h2 id="自定义starter"><a href="#自定义starter" class="headerlink" title="自定义starter"></a>自定义starter</h2><h2 id="Tomcat启动流程"><a href="#Tomcat启动流程" class="headerlink" title="Tomcat启动流程"></a>Tomcat启动流程</h2><p><img src="/images/spring_boot_tomcat_st.png" alt="-w1222"></p><p><code>EmbeddedWebServerFactoryCustomizerAutoConfiguration</code> 内嵌web容器工厂自定义定制器装配类</p><p>org.springframework.context.support.AbstractApplicationContext#refresh</p><h2 id="如何扫描自定义组件"><a href="#如何扫描自定义组件" class="headerlink" title="如何扫描自定义组件"></a>如何扫描自定义组件</h2><h2 id="Conditional注解"><a href="#Conditional注解" class="headerlink" title="Conditional注解"></a>Conditional注解</h2><p>常见的注解解释：</p><ul><li><p><code>@ConditionalOnBean</code><br>匹配给定的class类型或者Bean的名字是否在SpringBeanFactory中存在</p></li><li><p><code>@ConditionalOnClass</code><br>匹配给定的class类型是否在类路径(classpath)中存在</p></li><li><p><code>@ConditionalOnExpression</code><br>匹配给定springEL表达式的值返回true时</p></li><li><p><code>@ConditionalOnJava</code><br>匹配JDK的版本，其中range属性是枚举类型有两个值可以选择 </p><ul><li>EQUAL_OR_NEWER 不小于</li><li>OLDER_THAN 小于</li></ul><p>value属性用于设置jdk版本</p></li><li><p><code>ConditionalOnMissingBean</code><br>spring上下文中不存在指定bean时</p></li><li><p><code>ConditionalOnWebApplication</code><br>在web环境下创建 </p></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/niechen/p/8306376.html" target="_blank" rel="noopener">SpringBoot学习之自动装配</a><br><a href="https://www.cnblogs.com/niechen/p/9027804.html" target="_blank" rel="noopener">深入理解SpringBoot之自动装配</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;启动流程&quot;&gt;&lt;a href=&quot;#启动流程&quot; class=&quot;headerlink&quot; title=&quot;启动流程&quot;&gt;&lt;/a&gt;启动流程&lt;/h2&gt;&lt;p&gt;启动类代码&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=
      
    
    </summary>
    
      <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
      <category term="SpringBoot" scheme="http://yoursite.com/categories/Spring/SpringBoot/"/>
    
    
      <category term="原理" scheme="http://yoursite.com/tags/%E5%8E%9F%E7%90%86/"/>
    
      <category term="SpringBoot" scheme="http://yoursite.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Netty快速入门</title>
    <link href="http://yoursite.com/2020/01/08/Netty%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2020/01/08/Netty快速入门/</id>
    <published>2020-01-08T12:20:17.000Z</published>
    <updated>2020-01-10T13:01:56.941Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-NIO-核心概念"><a href="#Java-NIO-核心概念" class="headerlink" title="Java NIO 核心概念"></a>Java NIO 核心概念</h1><hr><h2 id="Linux五种I-O模型比较"><a href="#Linux五种I-O模型比较" class="headerlink" title="Linux五种I/O模型比较"></a>Linux五种I/O模型比较</h2><p><img src="/images/linux_five_io.png" alt></p><h2 id="Socket通信模型"><a href="#Socket通信模型" class="headerlink" title="Socket通信模型"></a>Socket通信模型</h2><p><img src="/images/socket_com_model.png" alt></p><h2 id="Java-NIO-Buffer"><a href="#Java-NIO-Buffer" class="headerlink" title="Java NIO Buffer"></a>Java NIO Buffer</h2><blockquote><p>一个Buffer本质上是内存中的一块， 可以将数据写入这块内存， 从这块内存获取数据 </p></blockquote><p><code>java.nio</code> 定义了以下几个Buffer的实现:</p><p><img src="/images/java_nio_buffer.png" alt></p><p>Java NIO Buffer三大核心概念：<strong>position</strong>、<strong>limit</strong>、<strong>capacity</strong></p><ul><li><p>最好理解的当然是 <code>capacity</code>，它代表这个缓冲区的容量，一旦设定就不可以更改。比如 <code>capacity</code> 为 <code>1024</code> 的 <code>IntBuffer</code>，代表其一次可以存放 <code>1024</code> 个 <code>int</code> 类型的值。</p></li><li><p>一旦 Buffer 的容量达到 capacity，需要清空 Buffer，才能重新写入值<br><img src="/images/java_nio_pos_cap.png" alt></p></li><li><p>从写操作模式到读操作模式切换的时候（flip），<code>position</code> 都会归零，这样就可以从头开始读写了。</p></li><li><p>写操作模式下，<code>limit</code> 代表的是最大能写入的数据，这个时候 <code>limit</code> 等于 <code>capacity</code>。</p></li><li><p>写结束后，切换到读模式，此时的 <code>limit</code> 等于 Buffer 中实际的数据大小，因为 Buffer 不一定被写满了</p></li></ul><p><img src="/images/java_nio_buffer_op.png" alt></p><p><strong>DirectByteBuffer &amp; HeapByteBuffer</strong></p><table><thead><tr><th></th><th>DirectByteBuffer</th><th>HeapByteBuffer</th></tr></thead><tbody><tr><td>描述</td><td>底层存储在非JVM堆上，通过native代码操作 -神器:MaxDirectMemorySize=<size></size></td><td>标准java类，维护一份byte[]在JVM堆上</td></tr><tr><td>创建开销</td><td>大</td><td>小</td></tr><tr><td>存储位置</td><td>Native Heap</td><td>Java Heap</td></tr><tr><td>数据拷贝</td><td>无需临时缓冲区做拷贝</td><td>拷贝到临时DirectByteBuffer,但临时缓冲区使用缓存， 聚集写/发散读时没有缓存临时缓冲区</td></tr><tr><td>GC影响</td><td>每次创建或者释放的时候都调用一次System.gc()</td><td>java垃圾回收机制自动回收</td></tr></tbody></table><h2 id="JAVA-NIO-Channel"><a href="#JAVA-NIO-Channel" class="headerlink" title="JAVA NIO Channel"></a>JAVA NIO Channel</h2><p>所有的NIO操作始于通道，<strong>通道是数据来源或数据写入的目的地</strong>，<code>java.nio</code> 包中主要实现的以下几个 Channel：<br><img src="/images/java_nio_channel.png" alt></p><ul><li><strong>FileChannel</strong>：文件通道，用于文件的读和写</li><li><strong>DatagramChannel</strong>：用于 UDP 连接的接收和发送</li><li><strong>SocketChannel</strong>：把它理解为 TCP 连接通道，简单理解就是 TCP 客户端</li><li><strong>ServerSocketChannel</strong>：TCP 对应的服务端，用于监听某个端口进来的请求</li></ul><h2 id="Java-NIO-Selector"><a href="#Java-NIO-Selector" class="headerlink" title="Java NIO Selector"></a>Java NIO Selector</h2><p><img src="/images/java_nio_selector.png" alt></p><ul><li><p><code>java.nio.channels.Selector</code></p></li><li><p>支持IO多路复用的抽象实体</p></li><li><p>注册<code>Selectable Channel</code></p></li><li><p>SelectionKey —— 表示Selector和被注册的channel之间关系的一份凭证</p><ul><li>SelectionKey保存channel感兴趣的事件</li></ul></li><li><p><code>Selector.select</code> 更新所有就绪的 <code>SelectionKey</code> 的状态, 并返回就绪的channel个数</p><ul><li>迭代Selected Key集合并处理就绪channel</li></ul></li></ul><p><strong>Selector基本操作</strong></p><ul><li>创建Selector   </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Selector selector = Selector.open();</span><br></pre></td></tr></table></figure><ul><li>注册Channel到Selector</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SocketChannel channel = SocketChannel.open();</span><br><span class="line">channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">SelectionKey key = channel.register(selector, SelectionKey.OP_READ);</span><br></pre></td></tr></table></figure><ul><li>register的第二个参数是一个“关注集合”，代表关注的channel状态，有四种基础类型可供监听, 用SelectionKey中的常量表示如下：  </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SelectionKey.OP_CONNECT</span><br><span class="line">SelectionKey.OP_ACCEPT</span><br><span class="line">SelectionKey.OP_READ</span><br><span class="line">SelectionKey.OP_WRITE</span><br></pre></td></tr></table></figure><ul><li>从Selector中选择channel<br>一旦向Selector注册了一个或多个channel后，就可以调用select来获取channel, <code>select()</code>方法会返回所有处于就绪状态的channel, select方法具体如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">long</span> timeout)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">selectNow</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>select()方法的返回值是一个int，代表有多少channel处于就绪了。也就是自上一次select后有多少channel进入就绪。</p><ul><li>selectedKeys()<br>在调用select并返回了有channel就绪之后，可以通过选中的key集合来获取channel，这个操作通过调用selectedKeys()方法：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</span><br></pre></td></tr></table></figure><ul><li>Selector编程模板</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</span><br><span class="line"></span><br><span class="line">Iterator&lt;SelectionKey&gt; keyIterator = selectedKeys.iterator();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(keyIterator.hasNext()) &#123;</span><br><span class="line"></span><br><span class="line">    SelectionKey key = keyIterator.next();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(key.isAcceptable()) &#123;</span><br><span class="line">        <span class="comment">// a connection was accepted by a ServerSocketChannel.</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isConnectable()) &#123;</span><br><span class="line">        <span class="comment">// a connection was established with a remote server.</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">        <span class="comment">// a channel is ready for reading</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line">        <span class="comment">// a channel is ready for writing</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    keyIterator.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Netty核心概念"><a href="#Netty核心概念" class="headerlink" title="Netty核心概念"></a>Netty核心概念</h1><p>Netty 提供<strong>异步的、事件驱动的网络应用程序框架和工具</strong>,用以快速开发高性能、高可靠性的网络服务器和客户端程序。</p><hr><h2 id="Netty主要组件"><a href="#Netty主要组件" class="headerlink" title="Netty主要组件"></a>Netty主要组件</h2><p><img src="/images/netty_total_structure.png" alt></p><ul><li><p>Netty Server启动主要流程</p><ul><li><p>设置服务端ServerBootStrap启动参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">group(parentGroup, childGroup):</span><br><span class="line">channel(NioServerSocketChannel): 设置通道类型</span><br><span class="line">handler()：设置NioServerSocketChannel的ChannelHandlerPipeline</span><br><span class="line">childHandler(): 设置NioSocketChannel的ChannelHandlerPipeline</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>通过ServerBootStrap的bind方法启动服务端，bind方法会在parentGroup中注册NioServerScoketChannel，监听客户端的连接请求</p><ul><li>会创建一个NioServerSocketChannel实例，并将其在parentGroup中进行注册</li></ul></li></ul></li><li><p>Netty Server执行主要流程</p><ul><li><p>Client发起连接CONNECT请求，parentGroup中的NioEventLoop不断轮循是否有新的客户端请求，如果有，ACCEPT事件触发</p></li><li><p>ACCEPT事件触发后，parentGroup中NioEventLoop会通过NioServerSocketChannel获取到对应的代表客户端的NioSocketChannel，并将其注册到childGroup中</p></li><li><p>childGroup中的NioEventLoop不断检测自己管理的NioSocketChannel是否有读写事件准备好，如果有的话，调用对应的ChannelHandler进行处理</p></li></ul></li></ul><h2 id="Netty-EventLoop"><a href="#Netty-EventLoop" class="headerlink" title="Netty EventLoop"></a>Netty EventLoop</h2><p><img src="/images/netty_ev_loop.png" alt></p><p><img src="/images/netty_ev_lp_grp.png" alt></p><ul><li><p>EventLoopGroup</p><ul><li>包括多个EventLoop</li><li>多个EventLoop之间不交互</li></ul></li><li><p>EventLoop</p><ul><li>每个EventLoop对应一个线程</li><li>所有连接(channel)都将注册到一个EventLoop，并且只注册到一个，整个生命周期中都不会变化</li><li>每个EventLoop管理着多个连接(channel)</li><li>EventLoop来处理连接(Channel)上的读写事件</li></ul></li><li><p>ServerBootstrap</p><ul><li>包括2个不同类型的EventLoopGroup:<ul><li>Parent EventLoop: 负责处理Accept事件，接收请求</li><li>Child EventLoop：负责处理读写事件</li></ul></li></ul></li></ul><p><strong>EventExecutor视图</strong><br><img src="/images/event_executor_view.png" alt></p><ol><li><code>EventExecutorGroup</code>里面有一个<code>EventExecutor</code>数组，保存了多个<code>EventExecutor</code>;<ol start="2"><li><code>EventExecutorGroup</code>是不干什么事情的，当收到一个请后，他就调用<code>next()</code>获得一个它里面的<code>EventExecutor</code>，再调用这个<code>executor</code>的方法；</li><li><code>next()</code>: <code>EventExecutorChooser.next()</code>定义选择<code>EventExecutor</code>的策略；</li></ol></li></ol><h2 id="ByteBuf类型"><a href="#ByteBuf类型" class="headerlink" title="ByteBuf类型"></a>ByteBuf类型</h2><ul><li><p>根据内存的位置</p><ul><li><p>HeapByteBuf </p><ul><li>基于数组- 内部为一个字节数组 (byte array)</li><li>hasArray()返回True</li><li>array()返回其内部的数组，可以对数组进行直接操作</li></ul></li><li><p>DirectByteBuf </p><ul><li>堆外内存</li><li>具有更好的性能</li><li>创建和释放开销更大</li></ul></li></ul></li><li><p>根据是否使用内存池</p><ul><li>Pooled vs Unpooled</li></ul></li><li><p>根据是否使用Unsafe操作(Unsafe)</p><ul><li>Safe vs Unsafe</li></ul></li></ul><p><strong>复合缓冲区（CompositeByteBuf）</strong></p><ul><li>多个ByteBuf组合的视图</li><li>一个ByteBuf列表，可动态的添加和删除其中的 ByteBuf</li><li>可能既包含堆缓冲区，也包含直接缓冲区<br><img src="/images/composite_buf.png" alt></li></ul><h2 id="ByteBuf分配"><a href="#ByteBuf分配" class="headerlink" title="ByteBuf分配"></a>ByteBuf分配</h2><p>不直接通过new来创建，而是通过ByteBufAllocator来创建</p><ul><li>UnpooledByteBufAllocator</li><li>PooledByteBufAllocator<br><img src="/images/byte_buf_uml.png" alt></li></ul><p><img src="/images/byte_buf_allocator.png" alt></p><p><img src="/images/unpooled_allocator.png" alt></p><h2 id="ChannelHandler"><a href="#ChannelHandler" class="headerlink" title="ChannelHandler"></a>ChannelHandler</h2><p>业务处理核心逻辑，用户自定义, Netty 提供2个重要的 ChannelHandler 子接口：</p><ul><li>ChannelInboundHandler - 处理进站数据和所有状态更改事件</li><li>ChannelOutboundHandler - 处理出站数据，允许拦截各种操作</li></ul><p><img src="/images/netty_chan_handler.png" alt></p><p><img src="/images/netty_chanelInbound.png" alt></p><p><img src="/images/channel_outboud_hd.png" alt></p><h2 id="ChannelPipline"><a href="#ChannelPipline" class="headerlink" title="ChannelPipline"></a>ChannelPipline</h2><p>ChannelPipeline是ChannelHandler容器</p><ul><li><p>包括一系列的ChannelHandler实例,用于拦截流经一个 Channel 的入站和出站事件</p></li><li><p>每个Channel都有一个其ChannelPipeline</p></li><li><p>可以修改 ChannelPipeline 通过动态添加和删除 ChannelHandler</p></li><li><p>定义了丰富的API调用来回应入站和出站事件</p></li></ul><p><img src="/images/netty_channel_pipeline.png" alt></p><h2 id="ChannelHandlerContext"><a href="#ChannelHandlerContext" class="headerlink" title="ChannelHandlerContext"></a>ChannelHandlerContext</h2><p>ChannelHandlerContext表示 ChannelHandler 和 ChannelPipeline 之间的关联，在 ChannelHandler 添加到 ChannelPipeline 时创建<br><img src="/images/netty_channel_context.png" alt></p><h1 id="Netty线程模型"><a href="#Netty线程模型" class="headerlink" title="Netty线程模型"></a>Netty线程模型</h1><hr><h2 id="Reactor模式-Doug-Lea"><a href="#Reactor模式-Doug-Lea" class="headerlink" title="Reactor模式 - Doug Lea"></a>Reactor模式 - Doug Lea</h2><ul><li>单线程Reactor<br><img src="/images/reactor_single_thread.png" alt="-w822"></li></ul><ul><li>多线程Reactor<br><img src="/images/reactor_multi_thread.png" alt></li></ul><p>所有逻辑都在I/O线程中完成，不开启单独线程。图中对应的TheadPool是在io处理handler中额外开启的业务线程池。</p><ul><li>Multiple Reactor<br><img src="/images/reactor_multi_reactor.png" alt="-w735"></li></ul><p><img src="/images/netty_reactor.png" alt></p><h2 id="Netty与Reactor模式"><a href="#Netty与Reactor模式" class="headerlink" title="Netty与Reactor模式"></a>Netty与Reactor模式</h2><ul><li>单线程Reactor</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">ServerBootStrap bootStrap = <span class="keyword">new</span> ServerBootStrap();</span><br><span class="line">bootStrap.group(bossGroup, bossGroup); <span class="comment">// 监听和处理都由一个线程完成</span></span><br></pre></td></tr></table></figure><ul><li>多线程Reactor</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">ServerBootStrap bootStrap = <span class="keyword">new</span> ServerBootStrap();</span><br><span class="line">bootStrap.group(bossGroup, bossGroup); <span class="comment">// 监听和处理都由一个线程完成</span></span><br><span class="line"><span class="comment">// 在handler中额外使用线程池处理业务</span></span><br></pre></td></tr></table></figure><ul><li>Multiple Reactor</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">ServerBootStrap bootStrap = <span class="keyword">new</span> ServerBootStrap();</span><br><span class="line">bootStrap.group(bossGroup, workerGroup); </span><br><span class="line"><span class="comment">// 在handler中额外使用线程池处理业务</span></span><br></pre></td></tr></table></figure><h2 id="Boss-EventLoopGroup"><a href="#Boss-EventLoopGroup" class="headerlink" title="Boss EventLoopGroup"></a>Boss EventLoopGroup</h2><p><img src="/images/Boss_EventLoopGroup.png" alt></p><p><img src="/images/NioEventLoop_Creation.png" alt></p><h2 id="Worker-EventLoopGroup"><a href="#Worker-EventLoopGroup" class="headerlink" title="Worker EventLoopGroup"></a>Worker EventLoopGroup</h2><p><img src="/images/Worker_EventLoopGroup.png" alt></p><h2 id="Netty-Start-Process"><a href="#Netty-Start-Process" class="headerlink" title="Netty Start Process"></a>Netty Start Process</h2><p><img src="/images/netty_start_process.png" alt></p><h2 id="ServerBootStrap"><a href="#ServerBootStrap" class="headerlink" title="ServerBootStrap"></a>ServerBootStrap</h2><p><img src="/images/serverbootstrap.png" alt></p><h1 id="Netty编码解码"><a href="#Netty编码解码" class="headerlink" title="Netty编码解码"></a>Netty编码解码</h1><hr><h2 id="半包粘包问题"><a href="#半包粘包问题" class="headerlink" title="半包粘包问题"></a>半包粘包问题</h2><ul><li>TCP/IP协议<ul><li>面向“流”协议</li><li>MSS: Maxitum Segment Size 最大分段大小，表示TCP数据包每次能够传输的最大数据分段</li><li>发送方/接收方缓冲区 （Nagle算法）</li></ul></li></ul><p><img src="/images/netty_tcp_frame.png" alt></p><p><strong>解决思路</strong></p><ul><li><p>基本思路就是不断从TCP缓冲区中读取数据，每次读取完都需要判断是否是一个完整的数据包</p><ul><li><p>若当前读取的数据不足以拼接成一个完整的业务数据包，那就保留该数据，继续从tcp缓冲区中读取，直到得到一个完整的数据包</p><ul><li>定长</li><li>分隔符</li><li>基于长度的变长包</li></ul></li><li><p>若当前读到的数据加上已经读取的数据足够拼接成一个数据包，那就将已经读取的数据拼接上本次读取的数据，够成一个完整的业务数据包传递到业务逻辑，多余的数据仍然保留，以便和下次读到的数据尝试拼接</p></li></ul></li></ul><h2 id="常用编码解码器"><a href="#常用编码解码器" class="headerlink" title="常用编码解码器"></a>常用编码解码器</h2><p>编码解码器的作用就是将原始的字节数据与自定义的消息对象进行互相转换，目前业界主流的序列化框架有：</p><ul><li>ProtoBuf</li><li>Jboss Marshalling</li><li>Java Serialization </li></ul><p>Netty常用的自带编解码器有：</p><ul><li><p><strong>LineBasedFrameDecoder</strong>（\n, \r\n)  </p><ul><li>回车换行解码器</li><li>配合StringDecoder</li></ul></li><li><p><strong>DelimiterBasedFrameDecoder</strong></p><ul><li>分隔符解码器</li></ul></li><li><p><strong>FixedLengthFrameDecoder</strong></p><ul><li>固定长度解码器</li></ul></li><li><p><strong>LengthFieldBasedFrameDecoder</strong></p><ul><li>基于包头’<strong>不固定长度</strong>‘解码器(私有协议最常用)</li><li>参数说明<ul><li><strong>maxFrameLength</strong>：包的最大长度</li><li><strong>lengthFieldOffset</strong>：长度属性的起始位（偏移位），包中存放长度属性字段的起始位置</li><li><strong>lengthFieldLength</strong>：长度属性的长度 </li><li><strong>lengthAdjustment</strong>：长度调节值，在总长被定义为包含包头长度时，修正信息长度</li><li><strong>initialBytesToStrip</strong>：跳过的字节数，根据需要跳过lengthFieldLength个字节，以便接收端直接接受到不含“长度属性”的内容</li></ul></li></ul></li></ul><h2 id="Netty拆包的基类-ByteToMessageDecoder"><a href="#Netty拆包的基类-ByteToMessageDecoder" class="headerlink" title="Netty拆包的基类 - ByteToMessageDecoder"></a>Netty拆包的基类 - ByteToMessageDecoder</h2><ul><li><p>内部维护了一个数据累积器<code>cumulation</code>，每次读取到数据都会不断累加，然后尝试对累加到的数据进行拆包，拆成一个完整的业务数据包</p></li><li><p>每次都将读取到的数据通过内存拷贝的方式， 累积到<code>cumulation</code>中</p></li><li><p>调用子类的decode方法对累积的数据尝试进行拆包</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java-NIO-核心概念&quot;&gt;&lt;a href=&quot;#Java-NIO-核心概念&quot; class=&quot;headerlink&quot; title=&quot;Java NIO 核心概念&quot;&gt;&lt;/a&gt;Java NIO 核心概念&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;Linux五种I-O模型比较&quot;&gt;
      
    
    </summary>
    
      <category term="Netty" scheme="http://yoursite.com/categories/Netty/"/>
    
      <category term="基础" scheme="http://yoursite.com/categories/Netty/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Netty" scheme="http://yoursite.com/tags/Netty/"/>
    
      <category term="网络IO" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9CIO/"/>
    
  </entry>
  
  <entry>
    <title>Spring mvc 设计思想与体系结构</title>
    <link href="http://yoursite.com/2020/01/06/Spring-mvc-%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%E4%B8%8E%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2020/01/06/Spring-mvc-设计思想与体系结构/</id>
    <published>2020-01-06T11:22:37.000Z</published>
    <updated>2020-01-10T13:01:56.634Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、spring-mvc-设计思想与体系结构组成"><a href="#一、spring-mvc-设计思想与体系结构组成" class="headerlink" title="一、spring mvc 设计思想与体系结构组成"></a>一、spring mvc 设计思想与体系结构组成</h2><hr><h3 id="回顾servlet-与jsp-执行过程"><a href="#回顾servlet-与jsp-执行过程" class="headerlink" title="回顾servlet 与jsp 执行过程"></a>回顾servlet 与jsp 执行过程</h3><p><img src="/images/servlet_work_process.png" alt="图片"></p><p><strong>流程说明：</strong></p><ol><li>请求Servlet</li><li>处理业务逻辑</li><li>设置业务Model</li><li>forward jsp Servlet</li><li>jsp Servlet 解析封装html 返回</li></ol><p>提问：这个是一个MVC应用场景吗？</p><p>spring mvc本质上还是在使用Servlet处理，并在其基础上进行了封装简化了开发流程，提高易用性、并使用程序逻辑结构变得更清晰</p><ol><li>基于注解的URL映谢</li><li>http表单参数转换</li><li>全局统一异常处理</li><li>拦截器的实现</li></ol><h3 id="spring-mvc-执行流程"><a href="#spring-mvc-执行流程" class="headerlink" title="spring mvc 执行流程"></a>spring mvc 执行流程</h3><p><img src="/images/spring_mvc_work_pro.png" alt="图片"></p><p><strong>整个过程是如何实现的？</strong></p><ol><li>dispatchServlet 如何找到对应的Control？</li><li>如何执行调用Control 当中的业务方法？</li></ol><p>回答这些问题之前我们先来认识一下spring mvc 体系结构</p><h3 id="spring-mvc-体系结构"><a href="#spring-mvc-体系结构" class="headerlink" title="spring mvc 体系结构"></a>spring mvc 体系结构</h3><ul><li><strong>HandlerMapping</strong> <ul><li>url与控制器的映谢</li></ul></li><li><strong>HandlerAdapter</strong><ul><li>控制器执行适配器</li></ul></li><li><strong>ViewResolver</strong><ul><li>视图仓库</li></ul></li><li><strong>view</strong><ul><li>具体解析视图</li></ul></li><li><strong>HandlerExceptionResolver</strong><ul><li>异常捕捕捉器</li></ul></li><li><strong>HandlerInterceptor</strong><ul><li>拦截器</li></ul></li></ul><p><strong>体系结构UML</strong><br><img src="/images/spring_mvc_uml.png" alt="图片"></p><h2 id="二、mvc-执行流程解析"><a href="#二、mvc-执行流程解析" class="headerlink" title="二、mvc 执行流程解析"></a>二、mvc 执行流程解析</h2><hr><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><ol><li>mvc 具体执行流程</li><li>HandlerMapping详解</li><li>HandlerAdapter 详解</li><li>ViewResolver与View详解</li><li>HandlerExceptionResolver详解</li><li>HandlerInterceptor 详解</li></ol><p>mvc 各组件执行流程</p><p><img src="/images/spring_mvc_execute_pro.png" alt="图片"></p><h3 id="HandlerMapping详解"><a href="#HandlerMapping详解" class="headerlink" title="HandlerMapping详解"></a>HandlerMapping详解</h3><p>其为mvc中url路径与Control对像的映射，DispatcherServlet 就是基于此组件来寻找对应的Control，如果找不到就会报<code>Not Found mapping</code> 的异常。</p><p>HandlerMapping 接口方法<br><img src="/images/hendler_mapping_in.png" alt="图片"></p><p>HandlerMapping 接口结构<br><img src="/images/handler_mapping_uml.png" alt="图片"></p><p>目前主流的三种mapping 如下：</p><ul><li><p>BeanNameUrlHandlerMapping<br>基于ioc name 中以 <code>/</code> 开头的Bean时行 注册至映谢.</p></li><li><p>SimpleUrlHandlerMapping<br>基于手动配置 url 与control 映谢</p></li><li><p>RequestMappingHandlerMapping<br>基于<code>@RequestMapping</code>注解配置对应映谢</p></li></ul><p>演示基于 BeanNameUrlHandlerMapping  配置映谢。</p><p>编写mvc 文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--简单控制器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"/user.do"</span> <span class="attr">class</span>=<span class="string">"com.tuling.mvc.control.BeanNameControl"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>beanname control 控制器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanNameControl</span> <span class="keyword">implements</span> <span class="title">HttpRequestHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        request.getRequestDispatcher(<span class="string">"/WEB-INF/page/userView.jsp"</span>).forward(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当IOC 中实例化这些类之后 DispatcherServlet 就会通过<code>org.springframework.web.servlet.DispatcherServlet#getHandler()</code> 方法基于request查找对应Handler。 但找到对应的Handler之后我们发现他是一个Object类型，并没有实现特定接口。如何调用Handler呢？</p><h3 id="HandlerAdapter详解"><a href="#HandlerAdapter详解" class="headerlink" title="HandlerAdapter详解"></a>HandlerAdapter详解</h3><p>这里spring mvc 采用适配器模式来适配调用指定Handler，根据Handler的不同种类采用不同的Adapter, 其Handler与 HandlerAdapter 对应关系如下:</p><table><thead><tr><th align="left">Handler类别</th><th align="left">对应适配器</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">Controller</td><td align="left">SimpleControllerHandlerAdapter</td><td align="left">标准控制器，返回ModelAndView</td></tr><tr><td align="left">HttpRequestHandler</td><td align="left">HttpRequestHandlerAdapter</td><td align="left">业务自行处理 请求，不需要通过modelAndView 转到视图</td></tr><tr><td align="left">Servlet</td><td align="left">SimpleServletHandlerAdapter</td><td align="left">基于标准的servlet 处理</td></tr><tr><td align="left">HandlerMethod</td><td align="left">RequestMappingHandlerAdapter</td><td align="left">基于@requestMapping对应方法处理</td></tr></tbody></table><p>HandlerAdapter  接口方法<br><img src="/images/handler_adapter_interface.png" alt="图片"></p><p>HandlerAdapter  接口结构图<br><img src="/images/handler_adapter_uml.png" alt="图片"></p><p>演示基于Servlet 处理  SimpleServletHandlerAdapter</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置控制器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"/hello.do"</span> <span class="attr">class</span>=<span class="string">"com.tuling.mvc.control.HelloServlet"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 配置适配器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.handler.SimpleServletHandlerAdapter"</span>/&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 标准Servlet</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        resp.getWriter().println(<span class="string">"hello luban "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述例子中当IOC 中实例化这些类之后 DispatcherServlet 就会通过<br>org.springframework.web.servlet.DispatcherServlet#getHandlerAdapter() 方法查找对应handler的适配器 ，如果找不到就会报 <code>No adapter for handler</code> 。</p><h3 id="ViewResolver-与View-详解"><a href="#ViewResolver-与View-详解" class="headerlink" title="ViewResolver 与View 详解"></a>ViewResolver 与View 详解</h3><p>找到应的Adapter 之后就会基于适配器调用业务处理，处理完之后业务方会返回一个ModelAndView ，在去查找对应的视图进行处理。其在<code>org.springframework.web.servlet.DispatcherServlet#resolveViewName()</code> 中遍历 <code>viewResolvers</code> 列表查找，如果找不到就会报一个 <code>Could not resolve view with name</code>异常。</p><p><img src="/images/view_resolver_interface.png" alt="图片"></p><p>下一步就是基于<code>ViewResolver.resolveViewName()</code>获取对应View来解析生成Html并返回 。对应VIEW结构如下：<br><img src="/images/view_resolver_uml.png" alt="图片"></p><p>至此整个正向流程就已经走完了，如果此时程序处理异常 MVC 该如何处理呢？</p><h3 id="HandlerExceptionResolver详解"><a href="#HandlerExceptionResolver详解" class="headerlink" title="HandlerExceptionResolver详解"></a>HandlerExceptionResolver详解</h3><p>该组件用于指示当出现异常时 mvc 该如何处理。 dispatcherServlet 会调用<code>org.springframework.web.servlet.DispatcherServlet#processHandlerException()</code> 方法，遍历 <code>handlerExceptionResolvers</code> 处理异常，处理完成之后返回errorView 跳转到异常视图。</p><p>演示自定义异常捕捉</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleExceptionHandle</span> <span class="keyword">implements</span> <span class="title">HandlerExceptionResolver</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">resolveException</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ModelAndView(<span class="string">"error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 演示异常配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.tuling.mvc.control.SimpleExceptionHandle"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>HandlerExceptionResolver 结构<br><img src="/images/hend_exception_resolver.png" alt="图片"></p><p>除了上述组件之外 spring 中还引入了  我Interceptor 拦截器 机制，类似于Filter。</p><h3 id="HandlerInterceptor详解"><a href="#HandlerInterceptor详解" class="headerlink" title="HandlerInterceptor详解"></a>HandlerInterceptor详解</h3><p>演示HandlerInterceptor </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleHandlerInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"preHandle"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"postHandle"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"afterCompletion"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置interceptor 组件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.tuling.mvc.control.SimpleHandlerInterceptor"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其实现机制是基于 HandlerExecutionChain 分别在 doDispatch 方法中执行以下方法：</p><ul><li>preHandle ：业务处理前执行</li><li>postHandle：业务处理后（异常则不执行）</li><li>afterCompletion：视图处理后</li></ul><p>具体逻辑源码参见：<code>org.springframework.web.servlet.DispatcherServlet#doDispatch</code> 方法。</p><h2 id="三、注解配置"><a href="#三、注解配置" class="headerlink" title="三、注解配置"></a>三、注解配置</h2><hr><p>演示基于注解配置mvc mapping </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.tuling.mvc.control"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 注解驱动 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 视图仓库 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span>  <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/page/"</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">".jsp"</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"viewClass"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">value</span>=<span class="string">"org.springframework.web.servlet.view.JstlView"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注解方法</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/hello.do"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ModelAndView mv = <span class="keyword">new</span> ModelAndView(<span class="string">"userView"</span>);</span><br><span class="line">    mv.addObject(<span class="string">"name"</span>, <span class="string">"luban"</span>);</span><br><span class="line">    <span class="keyword">return</span> mv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提问 为什么基于 <code>&lt;mvc:annotation-driven/&gt;</code> 配置就能实现mvc 的整个配置了，之前所提到的 <code>handlerMapping</code> 、与 <code>handlerAdapter</code> 组件都不适用了？</p><p>只要查看以类的源就可以知晓其中原因：</p><ul><li><input disabled type="checkbox"> 认识 NamespaceHandler 接口</li><li><input disabled type="checkbox"> 查看 MvcNamespaceHandler</li><li><input disabled type="checkbox"> 查看AnnotationDrivenBeanDefinitionParser</li></ul><p><strong>结论</strong><br>在 <code>&lt;mvc:annotation-driven /&gt;</code>  对应的解析器，自动向 ioc  里面注册了两个BeanDefinition。分别是：<code>RequestMappingHandlerMapping</code> 与<code>BeanNameUrlHandlerMapping</code>.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、spring-mvc-设计思想与体系结构组成&quot;&gt;&lt;a href=&quot;#一、spring-mvc-设计思想与体系结构组成&quot; class=&quot;headerlink&quot; title=&quot;一、spring mvc 设计思想与体系结构组成&quot;&gt;&lt;/a&gt;一、spring mvc 设
      
    
    </summary>
    
      <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
      <category term="Spring Mvc" scheme="http://yoursite.com/categories/Spring/Spring-Mvc/"/>
    
    
      <category term="原理" scheme="http://yoursite.com/tags/%E5%8E%9F%E7%90%86/"/>
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring事务底层基本原理</title>
    <link href="http://yoursite.com/2020/01/03/Spring%E4%BA%8B%E5%8A%A1%E5%BA%95%E5%B1%82%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2020/01/03/Spring事务底层基本原理/</id>
    <published>2020-01-03T13:14:14.000Z</published>
    <updated>2020-01-10T13:01:56.584Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据库的事务基本特性"><a href="#数据库的事务基本特性" class="headerlink" title="数据库的事务基本特性"></a>数据库的事务基本特性</h2><p>事物是区分文件存储系统与Nosql数据库重要特性之一，其存在的意义是为了保证即使在并发情况下也能正确的执行crud操作。怎样才算是正确的呢？这时提出了事物需要保证的四个特性即ACID：</p><ul><li><p>A: 原子性(atomicity)<br>事物中各项操作，要么全做要么全不做，任何一项操作的失败都会导致整个事物的失败；</p></li><li><p>C: 一致性(consistency)<br>事物结束后系统状态是一致的；</p></li><li><p>I:  隔离性(isolation)<br>并发执行的事物彼此无法看到对方的中间状态；</p></li><li><p>D: 持久性(durability)<br>事物完成后所做的改动都会被持久化，即使发生灾难性的失败。</p></li></ul><p>在高并发的情况下，要完全保证其ACID特性是非常困难的，除非把所有的事物串行化执行，但带来的负面的影响将是性能大打折扣。很多时候我们有些业务对事物的要求是不一样的，所以数据库中设计了四种隔离级别，供用户基于业务进行选择。</p><p><img src="/images/mysql_tx_isolation.png" alt></p><ul><li><p>脏读 :<br>一个事物读取到另一事物未提交的更新数据</p></li><li><p>不可重复读 :<br>在同一事物中,多次读取同一数据返回的结果有所不同, 换句话说, 后续读取可以读到另一事物已提交的更新数据. 相反, “可重复读”在同一事物中多次读取数据时, 能够保证所读数据一样, 也就是后续读取不能读到另一事物已提交的更新数据。</p></li><li><p>幻读 :<br>查询表中一条数据如果不存在就插入一条，并发的时候却发现，里面居然有两条相同的数据。这就幻读的问题。</p></li></ul><p><strong>数据库默认隔离级别：</strong></p><ul><li>Oracle中默认级别是 Read committed</li><li>mysql 中默认级别 Repeatable read。另外要注意的是mysql 执行一条查询语句默认是一个独立的事物，所以看上去效果跟Read committed一样。</li></ul><p><strong>查看mysql 的默认隔离级别</strong>  </p><blockquote><p>SELECT @@tx_isolation</p></blockquote><h2 id="Spring对事务的支持与使用"><a href="#Spring对事务的支持与使用" class="headerlink" title="Spring对事务的支持与使用"></a>Spring对事务的支持与使用</h2><h3 id="spring-事物相关API说明"><a href="#spring-事物相关API说明" class="headerlink" title="spring 事物相关API说明"></a>spring 事物相关API说明</h3><p>spring 事物是在数据库事物的基础上进行封装扩展，其主要特性如下：</p><ul><li>支持原有的数据事物的隔离级别；</li><li>加入了事物传播的概念，提供多个事物的合并或隔离的功能；</li><li>提供声明式事物，让业务代码与事物分离，事物变得更易用；</li></ul><p>怎么样去使用Spring事物呢？spring提供了三个接口供使用事物。分别是：</p><ul><li><p><code>TransactionDefinition</code><br>事物定义</p></li><li><p><code>PlatformTransactionManager</code><br>事物管理</p></li><li><p><code>TransactionStatus</code><br>事物运行时状态</p></li></ul><p>接口结构图：</p><p><img src="/images/spring_tx_stucture.png" alt></p><h3 id="基于API实现事物"><a href="#基于API实现事物" class="headerlink" title="基于API实现事物"></a>基于API实现事物</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringTransactionExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String url = <span class="string">"jdbc:mysql://192.168.0.147:3306/luban2"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String user = <span class="string">"root"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String password = <span class="string">"123456"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">openConnection</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException, SQLException </span>&#123;</span><br><span class="line">        Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">        Connection conn = DriverManager.getConnection(<span class="string">"jdbc:mysql://192.168.0.147:3306/luban2"</span>, <span class="string">"root"</span>, <span class="string">"123456"</span>);</span><br><span class="line">        <span class="keyword">return</span> conn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> DataSource ds = <span class="keyword">new</span> DriverManagerDataSource(url, user, password);</span><br><span class="line">        <span class="keyword">final</span> TransactionTemplate template = <span class="keyword">new</span> TransactionTemplate();</span><br><span class="line">        template.setTransactionManager(<span class="keyword">new</span> DataSourceTransactionManager(ds));</span><br><span class="line">        template.execute(<span class="keyword">new</span> TransactionCallback&lt;Object&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">doInTransaction</span><span class="params">(TransactionStatus status)</span> </span>&#123;</span><br><span class="line">                Connection conn = DataSourceUtils.getConnection(ds);</span><br><span class="line">                Object savePoint = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// 插入</span></span><br><span class="line">                        PreparedStatement prepare = conn.</span><br><span class="line">                                prepareStatement(<span class="string">"insert INTO account (accountName,user,money) VALUES (?,?,?)"</span>);</span><br><span class="line">                        prepare.setString(<span class="number">1</span>, <span class="string">"111"</span>);</span><br><span class="line">                        prepare.setString(<span class="number">2</span>, <span class="string">"aaaa"</span>);</span><br><span class="line">                        prepare.setInt(<span class="number">3</span>, <span class="number">10000</span>);</span><br><span class="line">                        prepare.executeUpdate();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 设置保存点</span></span><br><span class="line">                    savePoint = status.createSavepoint();</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// 插入</span></span><br><span class="line">                        PreparedStatement prepare = conn.</span><br><span class="line">                                prepareStatement(<span class="string">"insert INTO account (accountName,user,money) VALUES (?,?,?)"</span>);</span><br><span class="line">                        prepare.setString(<span class="number">1</span>, <span class="string">"222"</span>);</span><br><span class="line">                        prepare.setString(<span class="number">2</span>, <span class="string">"bbb"</span>);</span><br><span class="line">                        prepare.setInt(<span class="number">3</span>, <span class="number">10000</span>);</span><br><span class="line">                        prepare.executeUpdate();</span><br><span class="line">                    &#125;</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// 更新</span></span><br><span class="line">                        PreparedStatement prepare = conn.</span><br><span class="line">                                prepareStatement(<span class="string">"UPDATE account SET money= money+1 where user=?"</span>);</span><br><span class="line">                        prepare.setString(<span class="number">1</span>, <span class="string">"asdflkjaf"</span>);</span><br><span class="line">                        Assert.isTrue(prepare.executeUpdate() &gt; <span class="number">0</span>, <span class="string">""</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"更新失败"</span>);</span><br><span class="line">                    <span class="keyword">if</span> (savePoint != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        status.rollbackToSavepoint(savePoint);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        status.setRollbackOnly();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="声明示事物"><a href="#声明示事物" class="headerlink" title="声明示事物"></a>声明示事物</h3><p>我们前面是通过调用API来实现对事物的控制，这非常的繁琐，与直接操作JDBC事物并没有太多的改善，所以Spring提出了声明示事物，使我们对事物的操作变得非常简单，甚至不需要关心它。</p><ul><li>配置spring.xml</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/tx/spring-tx.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/aop/spring-aop.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.tuling.service.**"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.core.JdbcTemplate"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- similarly, don't forget the PlatformTransactionManager --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"txManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- don't forget the DataSource --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DriverManagerDataSource"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://192.168.0.147/luban2"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"123456"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">"txManager"</span>&gt;</span><span class="tag">&lt;/<span class="name">tx:annotation-driven</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>编写服务类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAccount</span><span class="params">(String name, <span class="keyword">int</span> initMenoy)</span> </span>&#123;</span><br><span class="line">    String accountid = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyyMMddhhmmss"</span>).format(<span class="keyword">new</span> Date());</span><br><span class="line">    jdbcTemplate.update(<span class="string">"insert INTO account (accountName,user,money) VALUES (?,?,?)"</span>, accountid, name, initMenoy);</span><br><span class="line">    <span class="comment">// 人为报错, 触发回滚</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="事物传播机制"><a href="#事物传播机制" class="headerlink" title="事物传播机制"></a>事物传播机制</h2><table>    <tr>        <td><b>类别</b></td>         <td><b>事务传播类型</b></td>         <td><b>说明</b></td>    </tr>    <tr>        <td rowspan="3">支持当前事务</td>            <td>PROPAGATION_REQUIRED         （必须的）</td>          <td>如果当前没有事物，就新建一个事物，如果已经存在一个事物中，          加入到这个事物中。这是最常见的选择</td>      </tr>    <tr>        <td>PROPAGATION_SUPPORTS（支持）</td>          <td>支持当前事物，如果当前没有事物，就以非事物方式执行</td>      </tr>    <tr>        <td>PROPAGATION_MANDATORY（强制）</td>          <td>使用当前的事物，如果当前没有事物，就抛出异常</td>      </tr>    <tr>        <td rowspan="3">不支持当前事物</td>            <td>PROPAGATION_REQUIRES_NEW(隔离)</td>          <td>新建事物，如果当前存在事物，把当前事物挂起</td>      </tr>    <tr>        <td>PROPAGATION_NOT_SUPPORTED(不支持)</td>          <td>以非事物方式执行操作，如果当前存在事物，就把当前事物挂起</td>      </tr>    <tr>        <td>PROPAGATION_NEVER(强制非事物)</td>          <td>以非事物方式执行，如果当前存在事物，则抛出异常</td>      </tr>    <tr>        <td>嵌套事物</td>          <td>PROPAGATION_NESTED（嵌套事物）</td>          <td>如果当前存在事物，则在嵌套事物内执行。如果当前没有事物，        则执行与PROPAGATION_REQUIRED类似的操作。</td>      </tr></table><p>常用事物传播机制：</p><ul><li><p><strong>PROPAGATION_REQUIRED</strong><br>这个也是默认的传播机制；</p></li><li><p><strong>PROPAGATION_NOT_SUPPORTED</strong><br>可以用于发送提示消息，站内信、短信、邮件提示等。不属于并且不应当影响主体业务逻辑，即使发送失败也不应该对主体业务逻辑回滚；</p></li><li><p><strong>PROPAGATION_REQUIRES_NEW</strong><br>总是新启一个事物，这个传播机制适用于不受父方法事物影响的操作，比如某些业务场景下需要记录业务日志，用于异步反查，那么不管主体业务逻辑是否完成，日志都需要记录下来，不能因为主体业务逻辑报错而丢失日志；</p></li></ul><p><strong>演示常用事物的传播机制</strong></p><p>用例1:<br>创建用户时初始化一个帐户，表结构和服务类如下。</p><table><thead><tr><th>表结构</th><th>服务类</th><th>功能描述</th></tr></thead><tbody><tr><td>user</td><td>UserService</td><td>创建用户并添加账户</td></tr><tr><td>account</td><td>AccountService</td><td>添加账户</td></tr></tbody></table><p><code>UserSerivce.createUser(name)</code> 实现代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createUser</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 新增用户基本信息</span></span><br><span class="line">    jdbcTemplate.update(<span class="string">"INSERT INTO `user` (name) VALUES(?)"</span>, name);</span><br><span class="line">    <span class="comment">//调用accountService添加帐户</span></span><br><span class="line">    accountService.addAccount(name, <span class="number">10000</span>);</span><br><span class="line"> ｝</span><br></pre></td></tr></table></figure><p><code>AccountService.addAccount(name,initMoney)</code> 实现代码（方法的最后有一个异常）:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span>(propagation = Propagation.REQUIRED)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAccount</span><span class="params">(String name, <span class="keyword">int</span> initMoney)</span> </span>&#123;</span><br><span class="line">    String accountid = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyyMMddhhmmss"</span>).format(<span class="keyword">new</span> Date());</span><br><span class="line">    jdbcTemplate.update(<span class="string">"insert INTO account (accountName,user,money) VALUES (?,?,?)"</span>, accountid, name, initMenoy);</span><br><span class="line">    <span class="comment">// 出现分母为零的异常</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实验预测：</p><p><img src="/images/spring_tx_test.png" alt></p><h2 id="AOP事务底层实现原理"><a href="#AOP事务底层实现原理" class="headerlink" title="AOP事务底层实现原理"></a>AOP事务底层实现原理</h2><p>讲事物原理之前我们先来做一个实验，当场景五的环境改变，把 <code>addAccount</code> 方法移至<code>UserService</code>类下，其它配置和代码不变：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createUser</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    jdbcTemplate.update(<span class="string">"INSERT INTO `user` (name) VALUES(?)"</span>, name);</span><br><span class="line">    addAccount(name, <span class="number">10000</span>);</span><br><span class="line">    <span class="comment">// 人为报错</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional</span>(propagation = Propagation.REQUIRES_NEW)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAccount</span><span class="params">(String name, <span class="keyword">int</span> initMoney)</span> </span>&#123;</span><br><span class="line">    String accountid = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyyMMddhhmmss"</span>).format(<span class="keyword">new</span> Date());</span><br><span class="line">    jdbcTemplate.update(<span class="string">"insert INTO account (accountName,user,money) VALUES (?,?,?)"</span>, accountid, name, initMoney);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过测试我们发现得出的结果与场景五并不一至，<code>required_new</code> 没有起到其对应的作用。原因在于 <strong>spring 声明示事物使用动态代理实现</strong>，而<strong>当调用同一个类的方法时，是会不会走代理逻辑的，自然事物的配置也会失效</strong>。</p><p>通过一个动态代理的实现来模拟这种场景</p><blockquote><p>UserService.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createUser</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addAccount</span><span class="params">(String name, <span class="keyword">int</span> initMoney)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>UserServiceImpl.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String url = <span class="string">"jdbc:mysql://10.101.38.255:8036/tuling"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String user = <span class="string">"root"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String password = <span class="string">"xxxxx"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DataSource dataSource;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        dataSource = <span class="keyword">new</span> DriverManagerDataSource(url, user, password);</span><br><span class="line">        jdbcTemplate = <span class="keyword">new</span> JdbcTemplate(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createUser</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        jdbcTemplate.update(<span class="string">"INSERT INTO `user` (name) VALUES(?)"</span>, name);</span><br><span class="line">        addAccount(name, <span class="number">10000</span>);</span><br><span class="line">        <span class="comment">// 人为报错</span></span><br><span class="line">        <span class="comment">//        int i = 1 / 0;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAccount</span><span class="params">(String name, <span class="keyword">int</span> initMoney)</span> </span>&#123;</span><br><span class="line">        String accountid = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyyMMddhhmmss"</span>).format(<span class="keyword">new</span> Date());</span><br><span class="line">        jdbcTemplate.update(<span class="string">"insert INTO account (accountName,user,money) VALUES (?,?,?)"</span>, accountid, name, initMoney);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>TransactionProxy.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionProxy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> UserService userSerivce = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        UserService proxyUserService = (UserService) Proxy.newProxyInstance(TransactionProxy.class.getClassLoader(),</span><br><span class="line">                <span class="keyword">new</span> Class[] &#123;UserService.class&#125;, <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            System.out.println(<span class="string">"开启事物:"</span> + method.getName());</span><br><span class="line">                            <span class="keyword">return</span> method.invoke(userSerivce, args);</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            System.out.println(<span class="string">"关闭事物:"</span> + method.getName());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        proxyUserService.createUser(<span class="string">"luban"</span>);</span><br><span class="line">        proxyUserService.addAccount(<span class="string">"austin"</span>, <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们调用 <code>createUser</code> 方法时, 仅打印了 <code>createUser</code>  的事物开启、关闭，并没有打印<code>addAccount</code>方法的事物开启、关闭，由此可见 <code>addAccount</code>  的事物配置是失效的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;数据库的事务基本特性&quot;&gt;&lt;a href=&quot;#数据库的事务基本特性&quot; class=&quot;headerlink&quot; title=&quot;数据库的事务基本特性&quot;&gt;&lt;/a&gt;数据库的事务基本特性&lt;/h2&gt;&lt;p&gt;事物是区分文件存储系统与Nosql数据库重要特性之一，其存在的意义是为了保证
      
    
    </summary>
    
      <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
      <category term="Spring Mvc" scheme="http://yoursite.com/categories/Spring/Spring-Mvc/"/>
    
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
      <category term="事务" scheme="http://yoursite.com/tags/%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>Spring 核心组件</title>
    <link href="http://yoursite.com/2020/01/02/Spring-%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/"/>
    <id>http://yoursite.com/2020/01/02/Spring-核心组件/</id>
    <published>2020-01-02T11:38:35.000Z</published>
    <updated>2020-01-10T13:01:56.802Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实体Bean的创建"><a href="#实体Bean的创建" class="headerlink" title="实体Bean的创建"></a>实体Bean的创建</h2><h3 id="基于Class构建"><a href="#基于Class构建" class="headerlink" title="基于Class构建"></a>基于Class构建</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean class=&quot;com.tuling.spring.HelloSpring&quot;&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>这是最常规的方法，其原理是在spring底层会基于class属性通过反射进行构建。</p><h3 id="构造方法构建"><a href="#构造方法构建" class="headerlink" title="构造方法构建"></a>构造方法构建</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean class=&quot;com.tuling.spring.HelloSpring&quot;&gt;</span><br><span class="line">    &lt;constructor-arg name=&quot;name&quot; type=&quot;java.lang.String&quot; value=&quot;luban&quot;/&gt;</span><br><span class="line">    &lt;constructor-arg index=&quot;1&quot; type=&quot;java.lang.String&quot; value=&quot;sex&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>如果需要基于参数进行构建，就采用构造方法构建，其对应属性如下：<br><strong>name:</strong> 构造方法参数变量名称<br><strong>type:</strong> 参数类型<br><strong>index:</strong> 参数索引，从0开始<br><strong>value:</strong> 参数值，spring 会自动转换成参数实际类型值<br><strong>ref:</strong> 引用容器的其它对象</p><h3 id="静态工厂方法创建"><a href="#静态工厂方法创建" class="headerlink" title="静态工厂方法创建"></a>静态工厂方法创建</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.tuling.spring.HelloSpring"</span> <span class="attr">factory-method</span>=<span class="string">"build"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"type"</span> <span class="attr">type</span>=<span class="string">"java.lang.String"</span> <span class="attr">value</span>=<span class="string">"B"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果你正在对一个对象进行A/B测试 ，就可以采用静态工厂方法的方式创建，其于策略创建不同的对像或填充不同的属性。<br>该模式下必须创建一个静态工厂方法，并且方法返回该实例，spring 会调用该静态方法创建对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HelloSpring <span class="title">build</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (type.equals(<span class="string">"A"</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HelloSpring(<span class="string">"luban"</span>, <span class="string">"man"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="string">"B"</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HelloSpring(<span class="string">"diaocan"</span>, <span class="string">"woman"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"type must A or B"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="FactoryBean创建"><a href="#FactoryBean创建" class="headerlink" title="FactoryBean创建"></a>FactoryBean创建</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 返回的并不是LubanFactoryBean实例，而是被LubanFactoryBean包装的实例 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.tuling.spring.LubanFactoryBean"</span> <span class="attr">id</span>=<span class="string">"lubanFactoryBean"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>指定一个Bean工厂来创建对象，对象构建初始化完全交给该工厂来实现。配置Bean时指定该工厂类的类名。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LubanFactoryBean只是起到一层包装代理作用 </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LubanFactoryBean</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 真正创建的bean实例</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HelloSpring();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> HelloSpring.class;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Bean的基本特性"><a href="#Bean的基本特性" class="headerlink" title="Bean的基本特性"></a>Bean的基本特性</h2><h3 id="作用范围"><a href="#作用范围" class="headerlink" title="作用范围"></a>作用范围</h3><p>很多时候Bean对象是无状态的 ，而有些又是有状态的, 无状态的对象我们采用单例即可，而有状态则必须是多例的模式，通过scope即可创建</p><blockquote><p>scope=“prototype”<br>scope=“singleton”</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.tuling.spring.HelloSpring"</span> <span class="attr">scope</span>=<span class="string">"prototype"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果一个Bean设置成<code>prototype</code>我们可以 通过<code>BeanFactoryAware</code>获取 <code>BeanFactory</code>对象即可每次获取的都是新对像。</p><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>Bean对象的<strong>创建</strong>、<strong>初始化</strong>、<strong>销毁</strong>即是Bean的生命周期。通过 <code>init-method</code>、<code>destroy-method</code>属性可以分别指定期构建方法与初始方法。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.tuling.spring.HelloSpring"</span> <span class="attr">init-method</span>=<span class="string">"init"</span> <span class="attr">destroy-method</span>=<span class="string">"destroy"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果觉得麻烦，可以让Bean去实现 <code>InitializingBean.afterPropertiesSet()</code>、<code>DisposableBean.destroy()</code>方法。分别对应初始和销毁方法。</p><h3 id="加载机制"><a href="#加载机制" class="headerlink" title="加载机制"></a>加载机制</h3><p>指示Bean在何时进行加载。设置<code>lazy-init</code>即可，其值如下：</p><blockquote><p>true: 懒加载，即延迟加载<br>false: 非懒加载，容器启动时即创建对象<br>default: 默认，采用default-lazy-init中指定值，如果default-lazy-init 没指定就是false</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span></span></span><br><span class="line"><span class="tag"><span class="attr">default-lazy-init</span>=<span class="string">"true"</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>什么时候使用懒加载？</strong><br>懒加载会容器启动的更快，而非懒加载可以容器启动时更快的发现程序当中的错误 ，选择哪一个就看追求的是启动速度，还是希望更早的发现错误，一般我们会选择后者。</p><h2 id="Bean的构建过程"><a href="#Bean的构建过程" class="headerlink" title="Bean的构建过程"></a>Bean的构建过程</h2><p><code>spring.xml</code>文件中保存了我们对Bean的描述配置，<code>BeanFactory</code>会读取这些配置然后生成对应的Bean。这是我们对ioc原理的一般理解。但在深入一些我们会有更多的问题:</p><ol><li>配置信息最后是谁JAVA中哪个对象承载的？</li><li>这些承载对象是谁业读取XML文件并装载的？</li><li>这些承载对象又是保存在哪里？</li></ol><h3 id="BeanDefinition（Bean定义）"><a href="#BeanDefinition（Bean定义）" class="headerlink" title="BeanDefinition（Bean定义）"></a>BeanDefinition（Bean定义）</h3><p>ioc实现中我们在xml中描述的Bean信息最后都将保存至<code>BeanDefinition</code> （定义）对象中，其中<code>xml bean</code> 与<code>BeanDefinition</code> 是一对一的关系。</p><p><img src="/images/spring_bean_definition.png" alt></p><p>由此可见，xml  bean中设置的属性最后都会体现在BeanDefinition中。如:</p><table><thead><tr><th align="left">XML-bean</th><th align="left"><strong>BeanDefinition</strong></th></tr></thead><tbody><tr><td align="left">class</td><td align="left">beanClassName</td></tr><tr><td align="left">scope</td><td align="left">scope</td></tr><tr><td align="left">lazy-init</td><td align="left">lazyInit</td></tr><tr><td align="left">constructor-arg</td><td align="left">ConstructorArgument</td></tr><tr><td align="left">property</td><td align="left">MutablePropertyValues</td></tr><tr><td align="left">factory-method</td><td align="left">factoryMethodName</td></tr><tr><td align="left">destroy-method</td><td align="left">AbstractBeanDefinition.destroyMethodName</td></tr><tr><td align="left">init-method</td><td align="left">AbstractBeanDefinition.initMethodName</td></tr><tr><td align="left">autowire</td><td align="left">AbstractBeanDefinition.autowireMode</td></tr><tr><td align="left">id</td><td align="left"></td></tr><tr><td align="left">name</td><td align="left"></td></tr></tbody></table><p>BeanDefinition属性结构<br><img src="/images/bean_definition_property_structure.png" alt></p><h3 id="BeanDefinitionRegistry（Bean注册器）"><a href="#BeanDefinitionRegistry（Bean注册器）" class="headerlink" title="BeanDefinitionRegistry（Bean注册器）"></a>BeanDefinitionRegistry（Bean注册器）</h3><p>在上表中我们并没有看到 <code>xml bean</code> 中的 <code>id</code>  和<code>name</code>属性， 没有体现在定义中，原因是ID其作为当前Bean的存储key注册到了<code>BeanDefinitionRegistry</code> 注册器中。<code>name</code> 作为<strong>别名key</strong> 注册到了 <code>AliasRegistry</code> 注册中心。其最后都是指向其对应的<code>BeanDefinition</code>。</p><p><img src="/images/bean_definition_register.png" alt></p><h3 id="BeanDefinitionReader（Bean定义读取）"><a href="#BeanDefinitionReader（Bean定义读取）" class="headerlink" title="BeanDefinitionReader（Bean定义读取）"></a>BeanDefinitionReader（Bean定义读取）</h3><p>至此我们学习了 <code>BeanDefinition</code> 中存储了<code>Xml Bean</code>信息，而<code>BeanDefinitionRegister</code> 基于<code>ID</code>和<code>name</code> 保存了Bean的定义。接下要学习的是从<code>xml Bean</code>到<code>BeanDefinition</code>然后在注册至<code>BeanDefinitionRegister</code> 整个过程。</p><p><img src="/images/bean_definition_reader.png" alt></p><p>上图中可以看出Bean的定义是由<code>BeanDefinitionReader</code> 从xml 中读取配置并构建出 <code>BeanDefinitionReader</code>, 然后在基于别名注册到<code>BeanDefinitionRegister</code>中.</p><p>BeanDefinitionReader结构<br><img src="/images/bena_definition_read_st.png" alt></p><p>方法说明：</p><ul><li><p><strong>loadBeanDefinitions(Resource resource)</strong></p><ul><li>基于资源装载Bean定义并注册至注册器</li></ul></li><li><p><strong>int loadBeanDefinitions(String location)</strong></p><ul><li>基于资源路径装载Bean定义并注册至注册器</li></ul></li><li><p><strong>BeanDefinitionRegistry getRegistry()</strong></p><ul><li>获取注册器</li></ul></li><li><p><strong>ResourceLoader getResourceLoader()</strong></p><ul><li>获取资源装载器</li></ul></li></ul><p>BeanDefinitionReader装载过程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个简单注册器</span></span><br><span class="line">BeanDefinitionRegistry register = <span class="keyword">new</span> SimpleBeanDefinitionRegistry();</span><br><span class="line"><span class="comment">//创建bean定义读取器</span></span><br><span class="line">BeanDefinitionReader reader = <span class="keyword">new</span> XmlBeanDefinitionReader(register);</span><br><span class="line"><span class="comment">// 创建资源读取器</span></span><br><span class="line">DefaultResourceLoader resourceLoader = <span class="keyword">new</span> DefaultResourceLoader();</span><br><span class="line"><span class="comment">// 获取资源</span></span><br><span class="line">Resource xmlResource = resourceLoader.getResource(<span class="string">"spring.xml"</span>);</span><br><span class="line"><span class="comment">// 装载Bean的定义</span></span><br><span class="line">reader.loadBeanDefinitions(xmlResource);</span><br><span class="line"><span class="comment">// 打印构建的Bean 名称</span></span><br><span class="line">System.out.println(Arrays.toString(register.getBeanDefinitionNames());</span><br></pre></td></tr></table></figure><h3 id="Beanfactory-bean-工厂"><a href="#Beanfactory-bean-工厂" class="headerlink" title="Beanfactory(bean 工厂)"></a>Beanfactory(bean 工厂)</h3><p>有了Bean的定义就相当于有了产品的配方，接下来就是要把这个配方送到工厂进行生产了。在ioc当中Bean的构建是由 <code>BeanFactory</code> 负责的。其结构如下：<br><img src="/images/bean_factory.png" alt></p><p>方法说明：</p><ul><li><p><strong>getBean(String)</strong></p><ul><li>基于ID或name 获取一个Bean</li></ul></li><li><p>**<t> T getBean(Class<t> requiredType) **</t></t></p><ul><li>基于Bean的类别获取一个Bean（如果出现多个该类的实例，将会报错。但可以指定 primary=“true” 调整优先级来解决该错误 ）</li></ul></li><li><p><strong>Object getBean(String name, Object… args)</strong></p><ul><li>基于名称获取一个Bean，并覆盖默认的构造参数</li></ul></li><li><p><strong>boolean isTypeMatch(String name, Class&lt;?&gt; typeToMatch)</strong></p><ul><li>指定Bean与指定Class 是否匹配</li></ul></li></ul><p>以上方法中重点要关注getBean，当用户调用getBean的时候就会触发 Bean的创建动作:</p><p>基本BeanFactory获取一个Bean, 以下是运行时的栈信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 其反射实例化Bean</span></span><br><span class="line">java.lang.reflect.Constructor.newInstance(Unknown Source:-<span class="number">1</span>)</span><br><span class="line">BeanUtils.instantiateClass()</span><br><span class="line"><span class="comment">//基于实例化策略 实例化Bean</span></span><br><span class="line">SimpleInstantiationStrategy.instantiate()</span><br><span class="line">AbstractAutowireCapableBeanFactory.instantiateBean()</span><br><span class="line"><span class="comment">// 执行Bean的实例化方法</span></span><br><span class="line">AbstractAutowireCapableBeanFactory.createBeanInstance()</span><br><span class="line">AbstractAutowireCapableBeanFactory.doCreateBean()</span><br><span class="line"><span class="comment">// 执行Bean的创建</span></span><br><span class="line">AbstractAutowireCapableBeanFactory.createBean()</span><br><span class="line"><span class="comment">// 缓存中没有，调用指定Bean工厂创建Bean</span></span><br><span class="line">AbstractBeanFactory$<span class="number">1</span>.getObject()</span><br><span class="line"><span class="comment">// 从单例注册中心获取Bean缓存</span></span><br><span class="line">DefaultSingletonBeanRegistry.getSingleton()</span><br><span class="line">AbstractBeanFactory.doGetBean()</span><br><span class="line"><span class="comment">// 获取Bean</span></span><br><span class="line">AbstractBeanFactory.getBean()</span><br><span class="line"><span class="comment">// 调用的客户类</span></span><br><span class="line">com.tuling.spring.BeanFactoryExample.main()</span><br></pre></td></tr></table></figure><h3 id="Bean创建时序图"><a href="#Bean创建时序图" class="headerlink" title="Bean创建时序图"></a>Bean创建时序图</h3><p><img src="/images/bean_creation_process.png" alt></p><p>从调用过程可以总结出以下几点：</p><ol><li>调用 <code>BeanFactory.getBean()</code> 会触发Bean的实例化</li><li><code>DefaultSingletonBeanRegistry</code> 中缓存了单例Bean</li><li><code>Bean</code>的创建与初始化是由<code>AbstractAutowireCapableBeanFactory</code>完成的</li></ol><h2 id="BeanFactory-与-ApplicationContext区别"><a href="#BeanFactory-与-ApplicationContext区别" class="headerlink" title="BeanFactory 与 ApplicationContext区别"></a>BeanFactory 与 ApplicationContext区别</h2><p><code>BeanFactory</code> 可以去做IOC当中的大部分事情，为什么还要去定义一个ApplicationContext 呢？</p><p>ApplicationContext 结构图<br><img src="/images/bean_factory_context.png" alt></p><p>从图中可以看到 <code>ApplicationContext</code> 它由 <code>BeanFactory</code> 接口派生而来，因而提供了<code>BeanFactory</code> 所有的功能。除此之外<code>context</code>包还提供了以下的功能：</p><ol><li><code>MessageSource</code>, 提供国际化的消息访问</li><li>资源访问，如URL和文件</li><li>事件传播，实现了<code>ApplicationEventPublisher</code>接口的bean</li><li>载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的web层</li></ol><h2 id="Spring-advice执行顺序"><a href="#Spring-advice执行顺序" class="headerlink" title="Spring advice执行顺序"></a>Spring advice执行顺序</h2><p>advice执行顺序，就是拦截器链的执行顺序 </p><p><img src="/images/spring_advice.png" alt></p><ul><li><p>1、单个切面的场景，<code>around</code>开始 –&gt;  <code>before</code> –&gt; <code>aound</code>结束–&gt; <code>after</code> –&gt; <code>AfterReturning</code></p></li><li><p>2、对于多个切面的场景，可以通过 <code>@order</code>(序号)，来调整执行顺序。</p></li></ul><p>demo参考： <a href="https://blog.csdn.net/hxpjava1/article/details/55504513/" target="_blank" rel="noopener">Spring多个AOP执行先后顺序</a></p><p>源码分析：<br>前置通知拦截器： <code>MethodBeforeAdviceInterceptor#invoke</code><br>拦截器链：<code>ReflectiveMethodInvocation#proceed</code><br><code>proceed</code> 根据 <code>currentInterceptorIndex</code> 来确定当前应执行哪个拦截器，并在调用拦截器的 <code>invoke</code> 方法时，将自己作为参数传给该方法</p><p><img src="/images/spring_advive_procced.png" alt></p><p>参考资料<br><a href="https://www.coolblog.xyz/2018/06/22/Spring-AOP-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E6%8B%A6%E6%88%AA%E5%99%A8%E9%93%BE%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/" target="_blank" rel="noopener">Spring AOP 源码分析 - 拦截器链的执行过程</a><br><a href="https://blog.csdn.net/zly9923218/article/details/51348583" target="_blank" rel="noopener">Spring AOP 源码分析（生成代理对象）</a></p><h2 id="IOC-容器只存放单例bean吗"><a href="#IOC-容器只存放单例bean吗" class="headerlink" title="IOC 容器只存放单例bean吗"></a>IOC 容器只存放单例bean吗</h2><p><strong>结论：IOC 容器只存放单例bean</strong></p><p>IOC容器初始化的时候，会将所有bean初始化在 <code>singletonObjects</code> 这个<code>CurrentHashMap</code> 中， bean是单例的。</p><p>在获取bean的时候，首先会从<code>singletonObjects</code>去取值，通过debug，发现如果scope是单例，则可以获取到bean，如果scope是多例，则获取不到bean，需要 从一个叫 <code>mergedBeanDefinitions</code> 的<code>CurrentHashMap</code>中去获取bean的定义，然后再根据bean的scope去决定如何创建bean，如果<code>scope=prototype</code>，则每次都会创建一个新的实例。</p><p>猜想：IOC在初始化时，只会将 <code>scope = singleton</code>（单例）的对象进行实例化，而不会去实例化<code>scope=prototype</code>的对象（多例）；</p><p>证实：找到<code>singletonObjects.put</code>方法，debug看一下<code>singletonObjects.put</code>的前提条件是什么</p><p><strong>源码分析</strong>：<code>AbstractBeanFactory#doGetBean</code></p><p>单例的场景，直接从 <code>singletonObjects</code> 这个Map中获取bean</p><p><img src="/images/spring_get_bean_sigle.png" alt></p><p>多例的场景，发现从 <code>singletonObjects</code> 中拿不到值</p><p><img src="/images/spring_get_bean_sigle2.png" alt></p><p>接下来，发现它是从一个叫 <code>mergedBeanDefinitions</code>  的<code>HashMap</code>中获取了<code>RootBeanDefinition</code>，里面包含了bean的一些基础信息。</p><p><img src="/images/spring_get_bean_prototype.png" alt></p><p>最后根据 <code>bean的scope</code>属性,来做处理，如果作用域是单例，则直接从容器中获取，如果作用域是多例，则创建一个实例，当然，作用域还有其它，自己可以一一去验证</p><p><img src="/images/spring_get_bean_prototype2.png" alt></p><h2 id="Scope为request的bean是否会放入IOC容器"><a href="#Scope为request的bean是否会放入IOC容器" class="headerlink" title="Scope为request的bean是否会放入IOC容器"></a>Scope为request的bean是否会放入IOC容器</h2><p>这个应该和IOC没有关系，request对象只是一个参数。<br>场景分析：SpringMVC在接受一个http请求后，会根据URl去匹配具体的bean（可以这样理解：<code>bean=Map.get(url)</code>，这个map是在容器初始化的时候创建的），然后通过反射获取class实例，最终执行<code>method.invoke</code>方法的时候，会将request对象的值封装到args数组中，当然args可能还包含<strong>response对象、注解参数、非注解参数的值</strong>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;实体Bean的创建&quot;&gt;&lt;a href=&quot;#实体Bean的创建&quot; class=&quot;headerlink&quot; title=&quot;实体Bean的创建&quot;&gt;&lt;/a&gt;实体Bean的创建&lt;/h2&gt;&lt;h3 id=&quot;基于Class构建&quot;&gt;&lt;a href=&quot;#基于Class构建&quot; class
      
    
    </summary>
    
      <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
      <category term="Spring Mvc" scheme="http://yoursite.com/categories/Spring/Spring-Mvc/"/>
    
    
      <category term="基础" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Java堆默认大小</title>
    <link href="http://yoursite.com/2019/12/31/Java%E5%A0%86%E9%BB%98%E8%AE%A4%E5%A4%A7%E5%B0%8F/"/>
    <id>http://yoursite.com/2019/12/31/Java堆默认大小/</id>
    <published>2019-12-31T11:18:01.000Z</published>
    <updated>2020-01-10T13:01:56.740Z</updated>
    
    <content type="html"><![CDATA[<h2 id="PrintFlagsFinal"><a href="#PrintFlagsFinal" class="headerlink" title="PrintFlagsFinal"></a>PrintFlagsFinal</h2><blockquote><p>-XX:+PrintFlagsFinal<br>打印所有可设置的参数及它们的默认值(从JDK 6 update 21开始才可以用)</p></blockquote><p>示例：16G内存的Centos系统</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> java -XX:+PrintFlagsFinal -version  | grep -E 'HeapSize|PermSize|ThreadStackSize'</span><br><span class="line">     intx CompilerThreadStackSize                   = 0                                   &#123;pd product&#125;</span><br><span class="line">    uintx ErgoHeapSizeLimit                         = 0                                   &#123;product&#125;</span><br><span class="line">    uintx HeapSizePerGCThread                       = 87241520                            &#123;product&#125;</span><br><span class="line">    uintx InitialHeapSize                          := 264241152                           &#123;product&#125;</span><br><span class="line">    uintx LargePageHeapSizeThreshold                = 134217728                           &#123;product&#125;</span><br><span class="line">    uintx MaxHeapSize                              := 4215275520                          &#123;product&#125;</span><br><span class="line">     intx ThreadStackSize                           = 1024                                &#123;pd product&#125;</span><br><span class="line">     intx VMThreadStackSize                         = 1024                                &#123;pd product&#125;</span><br><span class="line">java version "1.8.0_152"</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_152-b16)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.152-b16, mixed mode)</span><br></pre></td></tr></table></figure><p>可以看出默认的:<br>堆最大大小(MaxHeapSize)：4215275520/(1024.0 * 1024 * 1024) = 3.93G<br>初始堆大小(InitialHeapSiz): 266338304/(1024.0 * 1024) = 254M<br>HeapSizePerGCThread: 87241520 / (1024.0 * 1024) = 83.20M</p><h2 id="PrintCommandLineFlags"><a href="#PrintCommandLineFlags" class="headerlink" title="PrintCommandLineFlags"></a>PrintCommandLineFlags</h2><blockquote><p>-XX:+PrintCommandLineFlags</p><p>打印出所有出现在命令行上的可选JVM参数。可用来了解JVM的参数设置，例如堆空间大小、垃圾收集器等。默认情况下，此选项是禁用的，并且不打印标记。</p></blockquote><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> java -XX:+PrintCommandLineFlags -version</span><br><span class="line">-XX:InitialHeapSize=263453376 -XX:MaxHeapSize=4215254016 -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseParallelGC </span><br><span class="line">java version "1.8.0_152"</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_152-b16)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.152-b16, mixed mode)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;PrintFlagsFinal&quot;&gt;&lt;a href=&quot;#PrintFlagsFinal&quot; class=&quot;headerlink&quot; title=&quot;PrintFlagsFinal&quot;&gt;&lt;/a&gt;PrintFlagsFinal&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;-XX:+
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
      <category term="JVM" scheme="http://yoursite.com/categories/Java/JVM/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Spring Bean生命周期</title>
    <link href="http://yoursite.com/2019/12/30/Spring-Bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://yoursite.com/2019/12/30/Spring-Bean生命周期/</id>
    <published>2019-12-30T11:03:22.000Z</published>
    <updated>2020-01-10T13:01:56.820Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring-Bean生命周期"><a href="#Spring-Bean生命周期" class="headerlink" title="Spring Bean生命周期"></a>Spring Bean生命周期</h1><h2 id="生命周期流程"><a href="#生命周期流程" class="headerlink" title="生命周期流程"></a>生命周期流程</h2><p>首先看下生命周期图：<br><img src="/images/spring_bean_process.png" alt></p><p>再来一张执行过程：</p><p><img src="/images/spring_bean_life_process.png" alt></p><p>Spring Bean的生命周期只有四个阶段。要彻底搞清楚Spring的生命周期，首先要把这四个阶段牢牢记住。实例化和属性赋值对应<strong>构造方法</strong>和<strong>setter方法</strong>的注入，<strong>初始化和销毁是用户能自定义扩展的两个阶段</strong>。在这四步之间穿插的各种扩展点。</p><ul><li><p>实例化 Instantiation</p></li><li><p>属性赋值 Populate</p></li><li><p>初始化 Initialization</p></li><li><p>销毁 Destruction</p></li></ul><p><code>实例化 -&gt; 属性赋值 -&gt; 初始化 -&gt; 销毁</code></p><p>主要逻辑都在<code>doCreateBean()</code>方法中，逻辑很清晰，就是顺序调用以下三个方法，这三个方法与三个生命周期阶段一一对应，非常重要，在后续扩展接口分析中也会涉及。</p><blockquote><p><code>createBeanInstance()</code> -&gt; 实例化<br><code>populateBean()</code> -&gt; 属性赋值<br><code>initializeBean()</code> -&gt; 初始化</p></blockquote><p>源码如下，能证明实例化，属性赋值和初始化这三个生命周期的存在。关于本文的Spring源码都将忽略无关部分，便于理解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 忽略了无关代码</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> @Nullable Object[] args)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Instantiate the bean.</span></span><br><span class="line">   BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line">   <span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="comment">// 实例化阶段！</span></span><br><span class="line">      instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Initialize the bean instance.</span></span><br><span class="line">   Object exposedObject = bean;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">// 属性赋值阶段！</span></span><br><span class="line">      populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">       <span class="comment">// 初始化阶段！</span></span><br><span class="line">      exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于销毁，是在容器关闭时调用的，详见<code>ConfigurableApplicationContext#close()</code></p><p>在谈生命周期之前有一点需要先明确：</p><blockquote><p>Spring 只帮我们管理单例模式 Bean 的完整生命周期，对于 prototype 的 bean ，Spring 在创建好交给使用者之后则不会再管理后续的生命周期。</p></blockquote><h2 id="AOP扩展bean生命周期"><a href="#AOP扩展bean生命周期" class="headerlink" title="AOP扩展bean生命周期"></a>AOP扩展bean生命周期</h2><p>Spring生命周期相关的常用切入方式非常多，主要有下列方式：</p><h3 id="注解方式"><a href="#注解方式" class="headerlink" title="注解方式"></a>注解方式</h3><p>在 bean 初始化时会经历几个阶段，首先可以使用注解 @PostConstruct, @PreDestroy 来在 bean 的创建和销毁阶段进行调用。</p><h3 id="两个生命周期接口InitializingBean-DisposableBean"><a href="#两个生命周期接口InitializingBean-DisposableBean" class="headerlink" title="两个生命周期接口InitializingBean, DisposableBean"></a>两个生命周期接口InitializingBean, DisposableBean</h3><p>还可以实现 <code>InitializingBean</code>, <code>DisposableBean</code> 这两个接口，也是在初始化以及销毁阶段调用。实例化和属性赋值都是Spring帮助我们做的，能够自己实现的就只有 <strong>初始化</strong> 和 <strong>销毁</strong> 两个生命周期阶段.</p><ul><li><p><strong>InitializingBean</strong><br>对应生命周期的初始化阶段，在源码的 <code>invokeInitMethods(beanName, wrappedBean, mbd)</code> 方法中调用。</p><p>  有一点需要注意，因为<code>Aware</code>方法都是执行在初始化方法之前，所以可以在初始化方法中放心大胆的使用Aware接口获取的资源，这也是我们自定义扩展Spring的常用方式。<br>  除了实现<code>InitializingBean</code>接口之外还能通过注解或者xml配置的方式指定初始化方法，至于这几种定义方式的调用顺序其实没有必要记。因为这几个方法对应的都是同一个生命周期，只是实现方式不同，我们一般只采用其中一种方式。</p></li><li><p><strong>DisposableBean</strong><br>类似于<code>InitializingBean</code>，对应生命周期的销毁阶段，以<code>ConfigurableApplicationContext#close()</code> 方法作为入口，实现是通过循环取所有实现了<code>DisposableBean</code>接口的Bean然后调用其`destroy() 方法;</p></li></ul><h3 id="自定义初始化和销毁方法"><a href="#自定义初始化和销毁方法" class="headerlink" title="自定义初始化和销毁方法"></a>自定义初始化和销毁方法</h3><p>也可以自定义方法用于在初始化、销毁阶段调用</p><h3 id="实现-Aware-接口"><a href="#实现-Aware-接口" class="headerlink" title="实现 Aware 接口"></a>实现 Aware 接口</h3><p>Aware类型的接口的作用就是让我们能够拿到Spring容器中的一些资源。基本都能够见名知意，Aware之前的名字就是可以拿到什么资源，例如<code>BeanNameAware</code>可以拿到<code>BeanName</code>，以此类推。调用时机需要注意：<strong>所有的Aware方法都是在初始化阶段之前调用的！</strong></p><p>Aware接口具体可以分为两组。如下排列顺序同样也是Aware接口的执行顺序:</p><ul><li><p>Aware Group1</p><blockquote><p>BeanNameAware</p><p>BeanClassLoaderAware</p><p>BeanFactoryAware</p></blockquote></li><li><p>Aware Group2</p><blockquote><p>EnvironmentAware</p></blockquote><p>EmbeddedValueResolverAware 实现该接口能够获取Spring EL解析器，用户的自定义注解需要支持spel表达式的时候可以使用，非常方便。</p><blockquote><p>ApplicationContextAware(ResourceLoaderAware、ApplicationEventPublisherAware、MessageSourceAware) 这几个接口可能让人有点懵，实际上这几个接口可以一起记，其返回值实质上都是当前的ApplicationContext对象，因为ApplicationContext是一个复合接口</p></blockquote></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationContext</span> <span class="keyword">extends</span> <span class="title">EnvironmentCapable</span>, <span class="title">ListableBeanFactory</span>, <span class="title">HierarchicalBeanFactory</span>,</span></span><br><span class="line"><span class="class">        <span class="title">MessageSource</span>, <span class="title">ApplicationEventPublisher</span>, <span class="title">ResourcePatternResolver</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>这里涉及一道面试题，<code>ApplicationContext</code> 和 <code>BeanFactory</code>的区别，可以从<code>ApplicationContext</code> 继承的这几个接口入手，除去 <code>BeanFactory</code> 相关的两个接口就是<code>ApplicationContext</code>独有的功能.</p><h3 id="BeanPostProcessor-InstantiationAwareBeanPostProcessor接口"><a href="#BeanPostProcessor-InstantiationAwareBeanPostProcessor接口" class="headerlink" title="BeanPostProcessor, InstantiationAwareBeanPostProcessor接口"></a>BeanPostProcessor, InstantiationAwareBeanPostProcessor接口</h3><p>增强处理器(<font color="red">容器级别</font>)，实现 BeanPostProcessor 接口，<strong>Spring 中所有 bean 在做初始化时都会调用该接口中的两个方法，</strong>， 正因为如此，这些接口的功能非常强大，Spring内部扩展也经常使用这些接口，例如自动注入以及AOP的实现都和他们有关。</p><p>这是Spring扩展中最重要的两个接口！</p><ul><li><p><code>InstantiationAwareBeanPostProcessor</code>作用于<strong>实例化阶段</strong>的前后；</p></li><li><p><code>BeanPostProcessor</code>作用于<strong>初始化阶段</strong>的前后；</p></li><li><p><code>InstantiationAwareBeanPostProcessor</code>实际上继承了 <code>BeanPostProcessor</code>接口，严格意义上来看他们是两父子;</p></li></ul><h2 id="Aware调用时机源码分析"><a href="#Aware调用时机源码分析" class="headerlink" title="Aware调用时机源码分析"></a>Aware调用时机源码分析</h2><p>详情如下，忽略了部分无关代码。代码位置就是<code>initializeBean</code>方法详情，这也说明了Aware都是在初始化阶段之前调用的！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 见名知意，初始化阶段调用的方法</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">initializeBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Object bean, @Nullable RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里调用的是Group1中的三个Bean开头的Aware</span></span><br><span class="line">        invokeAwareMethods(beanName, bean);</span><br><span class="line"></span><br><span class="line">        Object wrappedBean = bean;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 这里调用的是Group2中的几个Aware，</span></span><br><span class="line">        <span class="comment">// 而实质上这里就是前面所说的BeanPostProcessor的调用点！</span></span><br><span class="line">        <span class="comment">// 也就是说与Group1中的Aware不同，这里是通过BeanPostProcessor（ApplicationContextAwareProcessor）实现的。</span></span><br><span class="line">        wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">        <span class="comment">// 下文即将介绍的InitializingBean调用点</span></span><br><span class="line">        invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">        <span class="comment">// BeanPostProcessor的另一个调用点</span></span><br><span class="line">        wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> wrappedBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到并不是所有的Aware接口都使用同样的方式调用。</p><ul><li>Bean××Aware都是在代码中直接调用的;</li><li>ApplicationContext相关的Aware都是通过<code>BeanPostProcessor#postProcessBeforeInitialization()</code>实现的。</li></ul><p>具体流程可以看一下 <code>ApplicationContextAwareProcessor</code> 这个类的源码，就是判断当前创建的Bean是否实现了相关的Aware方法，如果实现了会调用回调方法将资源传递给Bean。</p><p>至于Spring为什么这么实现，应该没什么特殊的考量。也许和Spring的版本升级有关。基于对修改关闭，对扩展开放的原则，Spring对一些新的Aware采用了扩展的方式添加。</p><p>BeanPostProcessor的调用时机也能在这里体现，包围住 <code>invokeInitMethods</code> 方法，也就说明了在初始化阶段的前后执行。</p><p>关于Aware接口的执行顺序，其实只需要记住第一组在第二组执行之前就行了.</p><h2 id="实例Demo"><a href="#实例Demo" class="headerlink" title="实例Demo"></a>实例Demo</h2><h3 id="User-java"><a href="#User-java" class="headerlink" title="User.java"></a>User.java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Austin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2019/12/2 21:01   Mon</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span>, <span class="title">DisposableBean</span>, <span class="title">BeanNameAware</span>, <span class="title">ApplicationContextAware</span>,</span></span><br><span class="line"><span class="class">        <span class="title">BeanClassLoaderAware</span>, <span class="title">BeanFactoryAware</span>, <span class="title">EnvironmentAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义方法用于在初始化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"调用Bean的函数(initMethod)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postConstructor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"调用Bean的函数(postConstruct)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"调用Bean的函数(constructor)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"调用Bean的函数(setName/setAttribute)"</span>);</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"调用Bean的函数(preDestroy)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"调用Bean的函数(destroy())"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroyMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"调用Bean的函数(destroyMethod)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"调用Bean的函数(afterPropertiesSet)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"调用BeanNameAware的(setBeanName)函数"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"调用ApplicationContextAware的(setApplicationContext)函数"</span>);</span><br><span class="line">        <span class="keyword">this</span>.applicationContext = applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanClassLoader</span><span class="params">(ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"调用BeanClassLoaderAware的(setBeanClassLoader)函数"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanFactory</span><span class="params">(BeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"调用BeanFactoryAware的(setBeanFactory)函数"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEnvironment</span><span class="params">(Environment environment)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"调用EnvironmentAware的(setEnvironment)函数"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CustomBeanPostProcessor-java"><a href="#CustomBeanPostProcessor-java" class="headerlink" title="CustomBeanPostProcessor.java"></a>CustomBeanPostProcessor.java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Austin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2019/12/2 21:10   Mon</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">InstantiationAwareBeanPostProcessor</span>, <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实例化之前调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (beanClass == User.class)&#123;</span><br><span class="line">            System.out.println(<span class="string">"调用InstantiationAwareBeanPostProcessor的postProcessBeforeInstantiation()函数"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实例化之后调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">postProcessAfterInstantiation</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (bean.getClass() == User.class)&#123;</span><br><span class="line">            System.out.println(<span class="string">"调用InstantiationAwareBeanPostProcessor的postProcessAfterInstantiation()函数"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 预初始化，初始化之前调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (bean.getClass() == User.class) &#123;</span><br><span class="line">            System.out.println(<span class="string">"调用BeanPostProcessor的postProcessBeforeInitialization()函数"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 后初始化  bean 初始化完成调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (bean.getClass() == User.class) &#123;</span><br><span class="line">            System.out.println(<span class="string">"调用BeanPostProcessor的postProcessAfterInitialization()函数"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BootStrap-java"><a href="#BootStrap-java" class="headerlink" title="BootStrap.java"></a>BootStrap.java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Austin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2019/12/2 21:13   Mon</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BootStrap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(BootStrap.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(initMethod = <span class="string">"initMethod"</span>, destroyMethod = <span class="string">"destroyMethod"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">user</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setUsername(<span class="string">"xxxx"</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">调用InstantiationAwareBeanPostProcessor的postProcessBeforeInstantiation()函数</span><br><span class="line"></span><br><span class="line">调用Bean的函数(constructor)</span><br><span class="line">调用Bean的函数(setName/setAttribute)</span><br><span class="line"></span><br><span class="line">调用InstantiationAwareBeanPostProcessor的postProcessAfterInstantiation()函数</span><br><span class="line"></span><br><span class="line">调用BeanNameAware的(setBeanName)函数</span><br><span class="line">调用BeanClassLoaderAware的(setBeanClassLoader)函数</span><br><span class="line">调用BeanFactoryAware的(setBeanFactory)函数</span><br><span class="line"></span><br><span class="line">调用EnvironmentAware的(setEnvironment)函数</span><br><span class="line">调用ApplicationContextAware的(setApplicationContext)函数</span><br><span class="line"></span><br><span class="line">调用BeanPostProcessor的postProcessBeforeInitialization()函数</span><br><span class="line"></span><br><span class="line">调用Bean的函数(postConstruct)</span><br><span class="line">调用Bean的函数(afterPropertiesSet)</span><br><span class="line">调用Bean的函数(initMethod)</span><br><span class="line"></span><br><span class="line">调用BeanPostProcessor的postProcessAfterInitialization()函数</span><br><span class="line"></span><br><span class="line">调用Bean的函数(preDestroy)</span><br><span class="line">调用Bean的函数(destroy())</span><br><span class="line">调用Bean的函数(destroyMethod)</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Spring Bean的生命周期分为<strong>四个阶段</strong>和<strong>多个扩展点</strong>。扩展点又可以分为<strong>影响多个Bean</strong>和<strong>影响单个Bean</strong>。整理如下：</p><h3 id="四个阶段"><a href="#四个阶段" class="headerlink" title="四个阶段"></a>四个阶段</h3><ul><li>实例化 Instantiation</li><li>属性赋值 Populate</li><li>初始化 Initialization</li><li>销毁 Destruction</li></ul><h3 id="多个扩展点"><a href="#多个扩展点" class="headerlink" title="多个扩展点"></a>多个扩展点</h3><ul><li><p>影响多个Bean</p><ul><li>BeanPostProcessor</li><li>InstantiationAwareBeanPostProcessor</li></ul></li><li><p>影响单个Bean</p><ul><li><p>Aware</p><ul><li><p>Aware Group1</p><ul><li>BeanNameAware</li><li>BeanClassLoaderAware</li><li>BeanFactoryAware</li></ul></li><li><p>Aware Group2</p><ul><li>EnvironmentAware</li><li>EmbeddedValueResolverAware</li><li>ApplicationContextAware (ResourceLoaderAware、ApplicationEventPublisherAware、MessageSourceAware)</li></ul></li></ul></li><li><p>生命周期</p><ul><li>InitializingBean</li><li>DisposableBean</li></ul></li></ul></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.jianshu.com/p/1dec08d290c1" target="_blank" rel="noopener">请别再问Spring Bean的生命周期了！</a><br><a href="https://juejin.im/post/5ab1bf19f265da23771947f1" target="_blank" rel="noopener">Spring Bean 生命周期</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Spring-Bean生命周期&quot;&gt;&lt;a href=&quot;#Spring-Bean生命周期&quot; class=&quot;headerlink&quot; title=&quot;Spring Bean生命周期&quot;&gt;&lt;/a&gt;Spring Bean生命周期&lt;/h1&gt;&lt;h2 id=&quot;生命周期流程&quot;&gt;&lt;a hr
      
    
    </summary>
    
      <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
      <category term="Spring Boot" scheme="http://yoursite.com/categories/Spring/Spring-Boot/"/>
    
    
      <category term="Springboot" scheme="http://yoursite.com/tags/Springboot/"/>
    
      <category term="Bean" scheme="http://yoursite.com/tags/Bean/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis核心组件及常见问题总结</title>
    <link href="http://yoursite.com/2019/12/27/Mybatis%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E5%8F%8A%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/12/27/Mybatis核心组件及常见问题总结/</id>
    <published>2019-12-27T11:13:56.000Z</published>
    <updated>2020-01-10T13:01:56.877Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mybatis核心组件"><a href="#mybatis核心组件" class="headerlink" title="mybatis核心组件"></a>mybatis核心组件</h1><h2 id="mybatis-config-xml"><a href="#mybatis-config-xml" class="headerlink" title="mybatis-config.xml"></a>mybatis-config.xml</h2><p>XML 配置文件（configuration XML）中包含了对 MyBatis 系统的核心设置，包含获取数据库连接实例的数据源（DataSource）和决定事务作用域和控制方式的事务管理器（TransactionManager）</p><h2 id="SqlSessionFactoryBuilder"><a href="#SqlSessionFactoryBuilder" class="headerlink" title="SqlSessionFactoryBuilder"></a>SqlSessionFactoryBuilder</h2><ul><li><p>作用<br>SqlSessionFactoryBuilder通过类名就可以看出这个类的主要作用就是创建一个SqlSessionFactory，通过输入mybatis配置文件的字节流或者字符流，生成XMLConfigBuilder，XMLConfigBuilder创建一个Configuration，Configuration这个类中包含了mybatis的配置的一切信息，mybatis进行的所有操作都需要根据Configuration中的信息来进行。</p></li><li><p>作用域（Scope）和生命周期<br>可以重用 SqlSessionFactoryBuilder 来创建多个 SqlSessionFactory 实例，但是最好还是不要让其一直存在 ,以保证所有的 XML 解析资源开放给更重要的事情, 这个类可以被实例化、使用和丢弃，一旦创建了 SqlSessionFactory，就不再需要它了。因此 SqlSessionFactoryBuilder 实例的最佳作用域是方法作用域（也就是局部方法变量）</p></li></ul><h2 id="SqlSessionFactory接口"><a href="#SqlSessionFactory接口" class="headerlink" title="SqlSessionFactory接口"></a>SqlSessionFactory接口</h2><ul><li><p>概念<br>sql会话工厂，用于创建SqlSession</p></li><li><p>作用域（Scope）和生命周期<br>SqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在，没有任何理由对它进行清除或重建，最佳作用域是应用作用域。有很多方法可以做到，最简单的就是使用单例模式或者静态单例模式。</p></li><li><p>如何创建<br>使用xml构建</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String resource = <span class="string">"org/mybatis/example/mybatis-config.xml"</span>;</span><br><span class="line">InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br></pre></td></tr></table></figure><p>java代码构建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DataSource dataSource = BlogDataSourceFactory.getBlogDataSource();</span><br><span class="line">TransactionFactory transactionFactory = <span class="keyword">new</span> JdbcTransactionFactory();</span><br><span class="line">Environment environment = <span class="keyword">new</span> Environment(<span class="string">"development"</span>, transactionFactory, dataSource);</span><br><span class="line">Configuration configuration = <span class="keyword">new</span> Configuration(environment);</span><br><span class="line">configuration.addMapper(BlogMapper.class);</span><br><span class="line">SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(configuration);</span><br></pre></td></tr></table></figure><h2 id="SqlSession接口"><a href="#SqlSession接口" class="headerlink" title="SqlSession接口"></a>SqlSession接口</h2><ul><li><p>概念<br>SqlSession是MyBatis的一个重要接口，定义了数据库的增删改查以及事务管理的常用方法。SqlSession还提供了查找Mapper接口的有关方法。</p></li><li><p>作用域（Scope）和生命周期<br>每个线程都应该有它自己的 SqlSession 实例, SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域，每次收到的 HTTP请求，就可以打开一个 SqlSession，返回一个响应，就关闭它。</p></li><li><p>如何创建</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SqlSession session = sqlSessionFactory.openSession();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// do work</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Mapper接口"><a href="#Mapper接口" class="headerlink" title="Mapper接口"></a>Mapper接口</h2><ul><li><p>概念<br>承载了实际的业务逻辑，其生命周期比较短，由SqlSession创建,用于将Java对象和实际的SQL语句对应起来。Mapper接口是指程序员自行定义的一个数据操纵接口，类似于通常所说的DAO接口。跟DAO不同的地方在于Mapper接口只需要程序员定义，不需要程序员去实现，MyBatis会自动为Mapper接口创建动态代理对象。Mapper接口的方法通常与Mapper配置文件中的select、insert、update、delete等XML结点存在一一对应关系。</p></li><li><p>实现方式</p><ul><li>(1)使用XML配置文件的方式。</li><li>(2)使用注解方式。</li><li>(3)直接使用MyBatis提供的API。</li></ul></li></ul><h2 id="mybatis的优缺点"><a href="#mybatis的优缺点" class="headerlink" title="mybatis的优缺点"></a>mybatis的优缺点</h2><p><strong>优点</strong></p><ul><li><ol><li>易于上手和掌握。</li></ol></li><li><ol start="2"><li>sql写在xml里，便于统一管理和优化。</li></ol></li><li><ol start="3"><li>解除sql与程序代码的耦合。</li></ol></li><li><ol start="4"><li>提供映射标签，支持对象与数据库的orm字段关系映射</li></ol></li><li><ol start="5"><li>提供对象关系映射标签，支持对象关系组建维护</li></ol></li><li><ol start="6"><li>提供xml标签，支持编写动态sql。</li></ol></li></ul><p><strong>缺点</strong></p><ul><li><p>sql工作量很大，尤其是字段多、关联表多时，更是如此。</p></li><li><p>sql依赖于数据库，导致数据库移植性差。</p></li><li><p>由于xml里标签id必须唯一，导致DAO中方法不支持方法重载。</p></li><li><p>字段映射标签和对象关系映射标签仅仅是对映射关系的描述，具体实现仍然依赖于sql。（比如配置了一对多Collection标签，如果sql里没有join子表或查询子表的话，查询后返回的对象是不具备对象关系的，即Collection的对象为null）</p></li><li><p>DAO层过于简单，对象组装的工作量较大。</p></li><li><p>不支持级联更新、级联删除。</p></li><li><p>编写动态sql时,不方便调试，尤其逻辑复杂时。</p></li><li><p>提供的写动态sql的xml标签功能简单（连struts都比不上），编写动态sql仍然受限，且可读性低。</p></li><li><p>若不查询主键字段，容易造成查询出的对象有“覆盖”现象。</p></li><li><p>参数的数据类型支持不完善。（如参数为Date类型时，容易报没有get、set方法，需在参数上加@param）</p></li><li><p>多参数时，使用不方便，功能不够强大。（目前支持的方法有map、对象、注解@param以及默认采用012索引位的方式）</p></li><li><p>缓存使用不当，容易产生脏数据。</p></li></ul><h1 id="Mybatis常见问题"><a href="#Mybatis常见问题" class="headerlink" title="Mybatis常见问题"></a>Mybatis常见问题</h1><h2 id="传统-JDBC-的弊端"><a href="#传统-JDBC-的弊端" class="headerlink" title="传统 JDBC 的弊端"></a>传统 JDBC 的弊端</h2><ul><li><p>1、jdbc 底层没有用连接池、操作数据库需要频繁的创建和关联链接。消耗很大的资源</p></li><li><p>2、写原生的 jdbc 代码在 java 中，一旦我们要修改 sql 的话，java 需要整体编译，不利于系 统维护</p></li><li><p>3、使用 PreparedStatement 预编译的话对变量进行设置 123 数字，这样的序号不利于维护 4、返回 result 结果集也需要硬编码。</p></li></ul><h2 id="什么是Mybatis？"><a href="#什么是Mybatis？" class="headerlink" title="什么是Mybatis？"></a>什么是Mybatis？</h2><ul><li><p>1、Mybatis是一个半ORM（对象关系映射）框架，它内部封装了JDBC，开发时只需要关注SQL语句本身，不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。程序员直接编写原生态sql，可以严格控制sql执行性能，灵活度高。</p></li><li><p>2、MyBatis 可以使用 XML 或注解来配置和映射原生信息，将 POJO映射成数据库中的记录，避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。</p></li><li><p>3、通过xml 文件或注解的方式将要执行的各种 statement 配置起来，并通过java对象和 statement中sql的动态参数进行映射生成最终执行的sql语句，最后由mybatis框架执行sql并将结果映射为java对象并返回。（从执行sql到返回result的过程）。</p></li></ul><h2 id="Mybatis执行流程"><a href="#Mybatis执行流程" class="headerlink" title="Mybatis执行流程"></a>Mybatis执行流程</h2><p><img src="/images/mybatis_work_process.png" alt></p><h2 id="mybatis核心概念"><a href="#mybatis核心概念" class="headerlink" title="mybatis核心概念"></a>mybatis核心概念</h2><table><thead><tr><th>名称</th><th>意义</th></tr></thead><tbody><tr><td>Configuration</td><td>管理 mysql-config.xml全局配置关系类</td></tr><tr><td>SqlSessionFactory</td><td>Session 管理工厂接口</td></tr><tr><td>Session</td><td><code>SqlSession</code>是一个面向用户(程序员)的接口。SqlSession 中提 供了很多操作数据库的方法</td></tr><tr><td>Executor</td><td>执行器是一个接口(基本执行器、缓存执行器)  作用:SqlSession 内部通过执行器操作数据库</td></tr><tr><td>MappedStatement</td><td>底层封装对象 作用:对操作数据库存储封装，包括 <code>sql</code> 语句、输入输出参数</td></tr><tr><td>StatementHandler</td><td>具体操作数据库相关的 <code>handler</code> 接口</td></tr><tr><td>ResultSetHandler</td><td>具体操作数据库返回结果的 <code>handler</code> 接口</td></tr></tbody></table><h2 id="Mybatis-全局配置详解"><a href="#Mybatis-全局配置详解" class="headerlink" title="Mybatis 全局配置详解"></a>Mybatis 全局配置详解</h2><p> <img src="/images/mybatis_global_config.png" alt></p><h2 id="MyBatis与Hibernate有哪些不同？"><a href="#MyBatis与Hibernate有哪些不同？" class="headerlink" title="MyBatis与Hibernate有哪些不同？"></a>MyBatis与Hibernate有哪些不同？</h2><p>1、Mybatis和hibernate不同，它<strong>不完全是一个ORM框架</strong>，因为MyBatis需要程序员自己编写Sql语句。</p><p>2、<strong>Mybatis直接编写原生态sql，可以严格控制sql执行性能，灵活度高</strong>，非常适合对关系数据模型要求不高的软件开发，因为这类软件需求变化频繁，一但需求变化要求迅速输出成果。但是灵活的前提是mybatis无法做到数据库无关性，如果需要实现支持多种数据库的软件，则需要自定义多套sql映射文件，工作量大。</p><p>3、Hibernate对象/关系映射能力强，<strong>数据库无关性好</strong>，对于关系模型要求高的软件，如果用hibernate开发可以节省很多代码，提高效率。</p><h2 id="和-的区别是什么？"><a href="#和-的区别是什么？" class="headerlink" title="#{} 和 ${} 的区别是什么？"></a><code>#{}</code> 和 <code>${}</code> 的区别是什么？</h2><ul><li><p><code>#{}</code> 是<strong>预编译处理</strong>，Mybatis在处理<code>#{}</code>时，会将sql中的<code>#{}</code>替换为<code>?</code>号，调用<code>PreparedStatement</code>的<code>set</code>方法来赋值；</p></li><li><p><code>${}</code>是<strong>字符串替换</strong>，Mybatis在处理<code>${}</code>时，就是把<code>${}</code>替换成变量的值原样拼接在SQL中；</p></li><li><p>使用<code>#{}</code>可以有效的防止SQL注入，提高系统安全性</p></li></ul><h2 id="Dao接口的工作原理是什么？Dao接口里的方法能重载吗？"><a href="#Dao接口的工作原理是什么？Dao接口里的方法能重载吗？" class="headerlink" title="Dao接口的工作原理是什么？Dao接口里的方法能重载吗？"></a>Dao接口的工作原理是什么？Dao接口里的方法能重载吗？</h2><p>Dao接口即Mapper接口。接口的全限名，就是mapper映射文件中的<code>namespace</code>的值；</p><p>接口的方法名，就是映射文件中Mapper的<code>Statement</code>的<code>id</code>值；接口方法内的参数，就是传递给sql的参数。</p><p>Mapper接口是没有实现类的，当调用接口方法时，<strong>接口全限名+方法名</strong>拼接字符串作为key值，可唯一定位一个<code>MapperStatement</code>。</p><p>在Mybatis中，每一个 <code>&lt;select&gt;</code>、<code>&lt;insert&gt;</code>、<code>&lt;update&gt;</code>、<code>&lt;delete&gt;</code> 标签，都会被解析为一个<code>MapperStatement</code>对象。举例： <code>com.mybatis3.mappers.StudentDao.findStudentById</code> ，可以唯一找到<code>namespace</code>为 <code>com.mybatis3.mappers.StudentDao</code> 下面 <code>id</code> 为 <code>findStudentById</code> 的 <code>MapperStatement</code>。</p><p><strong>Mapper接口里的方法，是不能重载的</strong>，因为是使用 <strong>全限名+方法名</strong> 的保存和寻找策略。 </p><p>Mapper接口的工作原理是<strong>JDK动态代理</strong>，<strong>Mybatis运行时会使用JDK动态代理为Mapper接口生成代理对象proxy，代理对象会拦截接口方法，转而执行MapperStatement所代表的sql，然后将sql执行结果返回</strong>。</p><h2 id="Mybatis是如何进行分页的？分页插件的原理是什么？"><a href="#Mybatis是如何进行分页的？分页插件的原理是什么？" class="headerlink" title="Mybatis是如何进行分页的？分页插件的原理是什么？"></a>Mybatis是如何进行分页的？分页插件的原理是什么？</h2><p>Mybatis使用<code>RowBounds</code>对象进行分页，它是针对<code>ResultSet</code>结果集执行的<strong>内存分页，而非物理分页</strong>。可以在sql内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。</p><p>分页插件的基本原理是<strong>使用Mybatis提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql，根据dialect方言，添加对应的物理分页语句和物理分页参数.</strong></p><h2 id="Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？"><a href="#Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？" class="headerlink" title="Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？"></a>Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？</h2><p><code>Mybatis</code>仅支持<code>association</code>关联对象和<code>collection</code>关联集合对象的延迟加载，<code>association</code>指的就是一对一，<code>collection</code>指的就是一对多查询。</p><p>在Mybatis配置文件中，可以配置是否启用延迟加载<code>lazyLoadingEnabled=true|false</code>。</p><p>它的原理是，<strong>使用<code>CGLIB</code>创建目标对象的代理对象</strong>，当调用目标方法时，进入拦截器方法，比如调用<code>a.getB().getName()</code>，拦截器<code>invoke()</code>方法发现<code>a.getB()</code>是null值，那么就会单独发送事先保存好的查询关联B对象的sql，把B查询上来，然后调用<code>a.setB(b)</code>，于是a的对象b属性就有值了，接着完成<code>a.getB().getName()</code>方法的调用。这就是延迟加载的基本原理。</p><p>当然了，不光是<code>Mybatis</code>，几乎所有的包括<code>Hibernate</code>，支持延迟加载的原理都是一样的</p><h2 id="Mybatis的一级、二级缓存"><a href="#Mybatis的一级、二级缓存" class="headerlink" title="Mybatis的一级、二级缓存"></a>Mybatis的一级、二级缓存</h2><p>1）一级缓存: 基于 <code>PerpetualCache</code> 的 HashMap 本地缓存，其存储作用域为 <code>Session</code>，当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，<strong>默认打开一级缓存</strong>。</p><p>2）二级缓存与一级缓存其机制相同，默认也是采用 <code>PerpetualCache</code>，HashMap 存储，不同在于其存储作用域为 <code>Mapper(Namespace)</code>，并且可自定义存储源，如 <code>Ehcache</code>。<strong>默认不打开二级缓存</strong>，要开启二级缓存，使用二级缓存属性类需要实现<code>Serializable</code>序列化接口(可用来保存对象的状态), 可在它的映射文件中配置 <code>&lt;cache/&gt;</code> ；</p><p>3）对于缓存数据更新机制，当某一个作用域(一级缓存 Session/二级缓存Namespaces)的进行了C/U/D 操作后，默认该作用域下所有 <code>select</code> 中的缓存将被 <code>clear</code>。</p><h2 id="Mybatis都有哪些Executor执行器？"><a href="#Mybatis都有哪些Executor执行器？" class="headerlink" title="Mybatis都有哪些Executor执行器？"></a>Mybatis都有哪些Executor执行器？</h2><p>Mybatis有三种基本的Executor执行器，<code>SimpleExecutor</code>、<code>ReuseExecutor</code>、<code>BatchExecutor</code>。</p><ul><li><p><strong>SimpleExecutor</strong>：每执行一次<code>update</code>或<code>select</code>，就开启一个<code>Statement</code>对象，<strong>用完立刻关闭<code>Statement</code>对象</strong>。</p></li><li><p><strong>ReuseExecutor</strong>：执行<code>update</code>或<code>select</code>，<strong>以<code>sql</code>作为key查找<code>Statement</code>对象，存在就使用，不存在就创建，用完后，不关闭<code>Statement</code>对象，而是放置于<code>Map&lt;String, Statement&gt;</code>内，供下一次使用</strong>。简言之，就是重复使用<code>Statement</code>对象。</p></li><li><p><strong>BatchExecutor</strong>：执行<code>update</code>（没有select，JDBC批处理不支持select），将所有sql都添加到批处理中（<code>addBatch()</code>），等待统一执行（<code>executeBatch()</code>），它缓存了多个<code>Statement</code>对象，每个<code>Statement</code>对象都是<code>addBatch()</code>完毕后，等待逐一执行<code>executeBatch()</code>批处理。与JDBC批处理相同。</p></li></ul><p>作用范围：Executor的这些特点，都<strong>严格限制在SqlSession生命周期范围内</strong>。</p><h2 id="简述Mybatis的插件运行原理，以及如何编写一个插件。"><a href="#简述Mybatis的插件运行原理，以及如何编写一个插件。" class="headerlink" title="简述Mybatis的插件运行原理，以及如何编写一个插件。"></a>简述Mybatis的插件运行原理，以及如何编写一个插件。</h2><p>Mybatis仅可以编写针对： </p><ul><li><code>ParameterHandler</code></li><li><code>ResultSetHandler</code></li><li><code>StatementHandler</code></li><li><code>Executor</code>  </li></ul><p>这4种接口的插件，<strong>Mybatis使用JDK的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能</strong>，每当执行这4种接口对象的方法时，就会进入拦截方法，具体就是<code>InvocationHandler</code>的<code>invoke()</code>方法，当然，只会拦截那些你指定需要拦截的方法。</p><p>编写插件：</p><ul><li>① 实现Mybatis的<code>Interceptor</code>接口并覆写<code>intercept()</code>方法；</li><li>② 给插件编写注解，指定要拦截哪一个接口的哪些方法即可；</li><li>③ 在配置文件中配置你编写的插件。</li></ul><h2 id="如何获取自动生成的-主-键值"><a href="#如何获取自动生成的-主-键值" class="headerlink" title="如何获取自动生成的(主)键值"></a>如何获取自动生成的(主)键值</h2><p>一般插入数据的话，如果我们想要知道刚刚插入的数据的主键是多少，我们可以通过以下的方式来获取</p><p>需求：</p><blockquote><p>user对象插入到数据库后，新记录的主键要通过user对象返回，通过user获取主键值。</p></blockquote><p>解决思路：</p><p>通过<code>LAST_INSERT_ID()</code>获取刚插入记录的自增主键值，在<code>insert</code>语句执行后，执行<code>select LAST_INSERT_ID()</code> 就可以获取自增主键。</p><p>mysql:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;insert id="insertUser" parameterType="cn.itcast.mybatis.po.User"&gt;</span><br><span class="line">    &lt;selectKey keyProperty="id" order="AFTER" resultType="int"&gt;</span><br><span class="line">        <span class="keyword">select</span> <span class="keyword">LAST_INSERT_ID</span>()</span><br><span class="line">    &lt;/selectKey&gt;</span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">USER</span>(username,birthday,sex,address) <span class="keyword">VALUES</span>(<span class="comment">#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;)</span></span><br><span class="line">&lt;/<span class="keyword">insert</span>&gt;</span><br></pre></td></tr></table></figure><h2 id="Mybatis动态sql"><a href="#Mybatis动态sql" class="headerlink" title="Mybatis动态sql"></a>Mybatis动态sql</h2><ul><li><p>Mybatis动态sql可以让我们在Xml映射文件内，以标签的形式编写动态sql，完成逻辑判断和动态拼接sql的功能;</p></li><li><p>Mybatis提供了9种动态sql标签：<code>trim|where|set|foreach|if|choose|when|otherwise|bind</code>。</p></li><li><p>其执行原理为，使用<code>OGNL</code> 从 sql 参数对象中计算表达式的值，根据表达式的值动态拼接sql，以此来完成动态sql的功能;</p></li></ul><h2 id="Mybatis比IBatis比较大的几个改进"><a href="#Mybatis比IBatis比较大的几个改进" class="headerlink" title="Mybatis比IBatis比较大的几个改进"></a>Mybatis比IBatis比较大的几个改进</h2><ul><li><p>a.增加接口绑定,包括注解绑定sql和xml绑定Sql ,</p></li><li><p>b.动态sql由原来的节点配置变成OGNL表达式,</p></li><li><p>c. 在一对一,一对多的时候引进了<code>association</code>, 在一对多的时候引入了<code>collection</code>节点, 不过都是在<code>resultMap</code>里面配置</p></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.im/post/5ce25058e51d45105773e63f" target="_blank" rel="noopener">面试官都会问的Mybatis面试题</a></p><p><a href="https://segmentfault.com/a/1190000013678579" target="_blank" rel="noopener">Mybatis常见面试题</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;mybatis核心组件&quot;&gt;&lt;a href=&quot;#mybatis核心组件&quot; class=&quot;headerlink&quot; title=&quot;mybatis核心组件&quot;&gt;&lt;/a&gt;mybatis核心组件&lt;/h1&gt;&lt;h2 id=&quot;mybatis-config-xml&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="数据库中间件" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
      <category term="Mybatis" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E9%97%B4%E4%BB%B6/Mybatis/"/>
    
    
      <category term="Mybatis" scheme="http://yoursite.com/tags/Mybatis/"/>
    
  </entry>
  
  <entry>
    <title>分布式ID生成器</title>
    <link href="http://yoursite.com/2019/12/20/%E5%88%86%E5%B8%83%E5%BC%8FID%E7%94%9F%E6%88%90%E5%99%A8/"/>
    <id>http://yoursite.com/2019/12/20/分布式ID生成器/</id>
    <published>2019-12-20T12:31:12.000Z</published>
    <updated>2019-12-20T12:39:22.126Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本要求"><a href="#基本要求" class="headerlink" title="基本要求"></a>基本要求</h2><ul><li>全局唯一  </li><li>趋势递增  </li><li>效率高（生成、使用、索引）</li><li>控制并发</li></ul><h2 id="常用策略"><a href="#常用策略" class="headerlink" title="常用策略"></a>常用策略</h2><p><img src="/images/distribute_uuid.jpg" alt></p><p><img src="/images/distribute_mysql_autoincrement.jpg" alt></p><p><img src="/images/distribute_mysql_ad.jpg" alt></p><p><img src="/images/distribute_snowflower.jpg" alt></p><p><img src="/images/distribute_snow_ad.jpg" alt></p><p><img src="/images/distribute_id_redis.jpg" alt></p><p><img src="/images/distribute_redis_advantage.jpg" alt></p><p><img src="/images/distribute_id_pk.jpg" alt></p><p><img src="/images/distribute_id_topk.jpg" alt></p><h2 id="Twitter雪花算法SnowFlake"><a href="#Twitter雪花算法SnowFlake" class="headerlink" title="Twitter雪花算法SnowFlake"></a>Twitter雪花算法SnowFlake</h2><p><img src="/images/distribute_snow_flower.jpg" alt></p><ul><li><p>1) 1位，不用。二进制中最高位为1的都是负数，但是我们生成的id一般都使用整数，所以这个最高位固定是0</p></li><li><p>2) 41位，用来记录时间戳（毫秒）。</p></li><li><p>3) 41位可以表示2^41−1个数字，如果只用来表示正整数（计算机中正数包含0），可以表示的数值范围是：0 至 2^41−1，减1是因为可表示的数值范围是从0开始算的，而不是1。<br>也就是说41位可以表示2^41−1个毫秒的值，转化成单位年则是(2^41−1)/(1000∗60∗60∗24∗365)=69年</p></li><li><p>4) 10位，用来记录工作机器id。<br>可以部署在2^10=1024个节点，包括5位datacenterId和5位workerId</p></li><li><p>5) 5位（bit）可以表示的最大正整数是2^5−1=31，即可以用0、1、2、3、….31这32个数字，来表示不同的datecenterId或workerId</p></li><li><p>6) 12位，序列号，用来记录同毫秒内产生的不同id。<br>12位（bit）可以表示的最大正整数是2^12−1=4095，即可以用0、1、2、3、….4094这4095个数字，来表示同一机器同一时间截（毫秒)内产生的4095个ID序号<br>由于在Java中64bit的整数是long类型，所以在Java中SnowFlake算法生成的id就是long来存储的。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基本要求&quot;&gt;&lt;a href=&quot;#基本要求&quot; class=&quot;headerlink&quot; title=&quot;基本要求&quot;&gt;&lt;/a&gt;基本要求&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;全局唯一  &lt;/li&gt;
&lt;li&gt;趋势递增  &lt;/li&gt;
&lt;li&gt;效率高（生成、使用、索引）&lt;/li&gt;
&lt;li&gt;控
      
    
    </summary>
    
      <category term="分布式" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="分布式" scheme="http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Springboot集成mybatis自定义插件开发</title>
    <link href="http://yoursite.com/2019/12/20/Springboot%E9%9B%86%E6%88%90mybatis%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    <id>http://yoursite.com/2019/12/20/Springboot集成mybatis自定义插件开发/</id>
    <published>2019-12-20T12:14:43.000Z</published>
    <updated>2019-12-20T12:18:12.339Z</updated>
    
    <content type="html"><![CDATA[<h2 id="mybatis架构"><a href="#mybatis架构" class="headerlink" title="mybatis架构"></a>mybatis架构</h2><p><img src="/images/mybatis_structure.png" alt="Pasted Graphi"></p><h2 id="mybatis工作原理"><a href="#mybatis工作原理" class="headerlink" title="mybatis工作原理"></a>mybatis工作原理</h2><p><img src="/images/mybatis_process.jpg" alt="-w777"></p><p>执行流程：</p><ol><li>读取核心配置文件并返回InputStream流对象。 </li><li>根据InputStream流对象解析出Configuration对象，然后创建SqlSessionFactory工厂对象 </li><li>根据一系列属性从SqlSessionFactory工厂中创建SqlSession </li><li>从SqlSession中调用Executor执行数据库操作&amp;&amp;生成具体SQL指令 </li><li>对执行结果进行二次封装 </li><li>提交与事务</li></ol><h2 id="mybatis插件简介"><a href="#mybatis插件简介" class="headerlink" title="mybatis插件简介"></a>mybatis插件简介</h2><p>mybatis插件就是在执行数据库操作的时候，对于特定方法进行拦截增强，做一些额外的处理的一种方式。<br>myabtis的插件的增强原理是利用动态代理实现的，可以对数据库操作的执行类做拦截，mybatis主要操作流程如下：</p><p><img src="/images/mybatis_process.jpg" alt></p><p>mybatis中的几个操作数据库的执行类是：Executor、StatementHandler、ParameterHandler、ResultSetHandler，其中：</p><ul><li><p>Executor 是总的执行者，他就像一个大总管，用于协调管理其他执行者。</p></li><li><p>StatementHandler 拦截Sql语法构建的处理, 是用于生成Statement或者PreparedStatement的执行者，同时他会调用ParameterHandler进行对sql语句中的参数设值，设置完了之后会通过StatementHandler 去调用sql在数据库中执行，最后返回一个结果集，通过ResultSetHandler将结果集和对应的实体进行映射填充数据，之后会把结果实体返回给StatementHandler。</p></li><li><p>ParameterHandler ：拦截参数的处理 </p></li><li><p>ResultSetHandler ：拦截结果集的处理 </p></li></ul><p>所以，我们对这几个执行者进行拦截，比如对于StatementHandler 拦截，即是对于sql操作进行拦截，Mybatis自定义插件必须实现Interceptor接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">    <span class="function">Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line">    <span class="function">Object <span class="title">plugin</span><span class="params">(Object target)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>intercept方法：拦截器具体处理逻辑方法 </li><li>plugin方法：根据签名signatureMap生成动态代理对象 </li><li>setProperties方法：设置Properties属性</li></ul><p>下面就对于这个StatementHandler 进行拦截做一个分页实例。</p><h2 id="分页插件"><a href="#分页插件" class="headerlink" title="分页插件"></a>分页插件</h2><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>拦截数据sql,实现分页功能</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Austin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2019/9/1 11:37   Sun</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Intercepts</span>(<span class="meta">@Signature</span>(</span><br><span class="line">        type = StatementHandler.class,</span><br><span class="line">        method = <span class="string">"prepare"</span>,</span><br><span class="line">        args = &#123;Connection.class, Integer.class&#125;</span><br><span class="line">))</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PagePlugin</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;mybatis.page.plugin.dialect&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String dialect;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;mybatis.page.plugin.pageSqlId&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String pageSqlId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插件需要做的事情</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// 确定哪些方法需要做分页</span></span><br><span class="line">        StatementHandler statementHandler = (StatementHandler) invocation.getTarget();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取原始sql</span></span><br><span class="line">        BoundSql boundSql = statementHandler.getBoundSql();</span><br><span class="line">        String sql = boundSql.getSql();</span><br><span class="line">        System.out.println(<span class="string">"原始sql: "</span> + sql);</span><br><span class="line"></span><br><span class="line">        MetaObject metaObject = MetaObject.forObject(statementHandler,</span><br><span class="line">                SystemMetaObject.DEFAULT_OBJECT_FACTORY,</span><br><span class="line">                SystemMetaObject.DEFAULT_OBJECT_WRAPPER_FACTORY,</span><br><span class="line">                <span class="keyword">new</span> DefaultReflectorFactory());</span><br><span class="line"></span><br><span class="line">        MappedStatement mappedStatement = (MappedStatement) metaObject.getValue(<span class="string">"delegate.mappedStatement"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//        //sql语句类型 select、delete、insert、update</span></span><br><span class="line">        <span class="comment">//        String sqlCommandType = mappedStatement.getSqlCommandType().toString();</span></span><br><span class="line">        <span class="comment">// 获取mapper接口中的方法名</span></span><br><span class="line">        String mapperMethodName = mappedStatement.getId();</span><br><span class="line"></span><br><span class="line">        Object paramObj = boundSql.getParameterObject();</span><br><span class="line">        <span class="keyword">if</span> (mapperMethodName.matches(<span class="string">".*ByPage$"</span>)) &#123;</span><br><span class="line">            Map&lt;String, Object&gt; params = (Map&lt;String, Object&gt;) paramObj;</span><br><span class="line">            PageInfo pageInfo = (PageInfo) params.get(<span class="string">"page"</span>);   <span class="comment">// map.put("page", pageInfo)</span></span><br><span class="line"></span><br><span class="line">            String countSql = <span class="string">"select count(1) from ("</span> + sql + <span class="string">") temp "</span>;</span><br><span class="line">            System.out.println(<span class="string">"查询总数sql: "</span> + countSql);</span><br><span class="line"></span><br><span class="line">            Connection connection = (Connection) invocation.getArgs()[<span class="number">0</span>];</span><br><span class="line">            PreparedStatement countStatement = connection.prepareStatement(countSql);</span><br><span class="line">            ParameterHandler parameterHandler = (ParameterHandler) metaObject.getValue(<span class="string">"delegate.parameterHandler"</span>);</span><br><span class="line">            parameterHandler.setParameters(countStatement);</span><br><span class="line">            ResultSet rs = countStatement.executeQuery();</span><br><span class="line">            <span class="keyword">if</span> (rs.next()) &#123;</span><br><span class="line">                pageInfo.setTotalNumber(rs.getInt(<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            rs.close();</span><br><span class="line">            countStatement.close();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 改造sql limit count</span></span><br><span class="line">            String pageSql = <span class="keyword">this</span>.generatePageSql(sql, pageInfo);</span><br><span class="line">            System.out.println(<span class="string">"分页sql: "</span> + pageSql);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 改造后的sql放回</span></span><br><span class="line">            metaObject.setValue(<span class="string">"delegate.boundSql.sql"</span>, pageSql);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行流程提交mybatis</span></span><br><span class="line">        <span class="keyword">return</span> invocation.proceed();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">generatePageSql</span><span class="params">(String sql, PageInfo pageInfo)</span> </span>&#123;</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">if</span> (dialect.equals(<span class="string">"mysql"</span>)) &#123;</span><br><span class="line">            sb.append(sql);</span><br><span class="line">            sb.append(<span class="string">" limit "</span> + pageInfo.getStartIndex() + <span class="string">" ,"</span> + pageInfo.getTotalSelect());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">plugin</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Plugin.wrap(target, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>myabtis自定义插件只需要实现Interceptor接口即可，并且注解@Intercepts以及@Signature配置需要拦截的对象，其中</p><ul><li>type是需要拦截的对象Class，</li><li>method是对象里面的方法，</li><li>args是方法参数类型。</li></ul><h2 id="注入插件到拦截链"><a href="#注入插件到拦截链" class="headerlink" title="注入插件到拦截链"></a>注入插件到拦截链</h2><p>这里有两种方式注入</p><ul><li><p>方式一：直接注入</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Spring boot项目中只需要在拦截器类上加 @Component 注解即可。</span><br></pre></td></tr></table></figure></li><li><p>方式二：通过myabtis配置加入到拦截链中(多个拦截器时，这种方式可以控制拦截顺序）</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@MapperScan</span>(&#123;<span class="string">"com.springboot.demo.mapper"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperConfig</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//将插件加入到mybatis插件拦截链中</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ConfigurationCustomizer <span class="title">configurationCustomizer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConfigurationCustomizer() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(Configuration configuration)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//插件拦截链采用了责任链模式，执行顺序和加入连接链的顺序有关</span></span><br><span class="line">                MyPlugin myPlugin = <span class="keyword">new</span> MyPlugin();</span><br><span class="line">                <span class="comment">//设置参数，比如阈值等，可以在配置文件中配置，这里直接写死便于测试</span></span><br><span class="line">                Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">                <span class="comment">//这里设置慢查询阈值为1毫秒，便于测试</span></span><br><span class="line">                properties.setProperty(<span class="string">"time"</span>, <span class="string">"1"</span>);</span><br><span class="line">                myPlugin.setProperties(properties);</span><br><span class="line">                </span><br><span class="line">                configuration.addInterceptor(myPlugin);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;mybatis架构&quot;&gt;&lt;a href=&quot;#mybatis架构&quot; class=&quot;headerlink&quot; title=&quot;mybatis架构&quot;&gt;&lt;/a&gt;mybatis架构&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/images/mybatis_structure.png&quot; a
      
    
    </summary>
    
      <category term="数据库中间件" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
      <category term="Mybatis" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E9%97%B4%E4%BB%B6/Mybatis/"/>
    
    
      <category term="Mybatis" scheme="http://yoursite.com/tags/Mybatis/"/>
    
      <category term="Springboot" scheme="http://yoursite.com/tags/Springboot/"/>
    
  </entry>
  
  <entry>
    <title>java编译执行有第三方依赖的类</title>
    <link href="http://yoursite.com/2019/12/20/java%E7%BC%96%E8%AF%91%E6%89%A7%E8%A1%8C%E6%9C%89%E7%AC%AC%E4%B8%89%E6%96%B9%E4%BE%9D%E8%B5%96%E7%9A%84%E7%B1%BB/"/>
    <id>http://yoursite.com/2019/12/20/java编译执行有第三方依赖的类/</id>
    <published>2019-12-20T11:53:51.000Z</published>
    <updated>2019-12-20T11:54:48.749Z</updated>
    
    <content type="html"><![CDATA[<p>有时候在进行开发的过程中，需要自己写个测试类来进行某个局部功能的测试，在测试的过程中，需要引入第三方jar包或者公司其他成员的帮助类，比如说：我需要测试一个<br>net.sf.json.JSONObject解析数据的时候中文乱码问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> net.sf.json.JSONException;</span><br><span class="line"><span class="keyword">import</span> net.sf.json.JSONObject;</span><br><span class="line"><span class="keyword">import</span> net.sf.json.JsonConfig;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.URLEncoder;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by 神器 on 2017/3/29.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZyhqErrorMsgDemo</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        InputStream inputStream = <span class="keyword">null</span>;</span><br><span class="line">        InputStreamReader inputStreamReader = <span class="keyword">null</span>;</span><br><span class="line">        BufferedReader in = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            String filePath = <span class="string">"/home/1.txt"</span>;</span><br><span class="line">            File file = <span class="keyword">new</span> File(filePath);</span><br><span class="line">            String code = codeString(filePath);</span><br><span class="line">            System.out.println(<span class="string">"文件类型:"</span> + code);</span><br><span class="line">            inputStream = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">            inputStreamReader = <span class="keyword">new</span> InputStreamReader(inputStream, <span class="string">"UTF-8"</span>);</span><br><span class="line">            in = <span class="keyword">new</span> BufferedReader(inputStreamReader);</span><br><span class="line">            String firstLine = in.readLine();<span class="comment">//过滤掉首行，以便循环体从第二行（申赎明细处理结果）</span></span><br><span class="line">            String line = <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">while</span> ((line = in.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"line:=====&gt;"</span>+ line);</span><br><span class="line">                System.out.println();</span><br><span class="line">                System.out.println();</span><br><span class="line">                JSONObject jsonObject = JSONObject.fromObject(line);</span><br><span class="line">                String status = jsonObject.getString(<span class="string">"status"</span>);</span><br><span class="line">                String objectStr = jsonObject.getString(<span class="string">"content"</span>);</span><br><span class="line">                String errorMessage = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    errorMessage = jsonObject.get(<span class="string">"errorMessage"</span>).toString();</span><br><span class="line">                &#125;<span class="keyword">catch</span> (JSONException ex) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"there is no errorMessage from Zyhq holding respon file"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"errorMessage:------&gt;"</span> + errorMessage);</span><br><span class="line">            &#125;</span><br><span class="line">            in.close();</span><br><span class="line">            inputStreamReader.close();</span><br><span class="line">            inputStream.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception ex)&#123;</span><br><span class="line">            System.out.println(<span class="string">"下载文件并解析文件内容时出错"</span>+ex.getStackTrace());</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (in != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    in.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"> </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (inputStreamReader != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    inputStreamReader.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"> </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (inputStream != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    inputStream.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"> </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断文件的编码格式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fileName :file</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 文件编码格式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">codeString</span><span class="params">(String fileName)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        BufferedInputStream bin = <span class="keyword">new</span> BufferedInputStream(</span><br><span class="line">                <span class="keyword">new</span> FileInputStream(fileName));</span><br><span class="line">        <span class="keyword">int</span> p = (bin.read() &lt;&lt; <span class="number">8</span>) + bin.read();</span><br><span class="line">        String code = <span class="keyword">null</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">switch</span> (p) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xefbb</span>:</span><br><span class="line">                code = <span class="string">"UTF-8"</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xfffe</span>:</span><br><span class="line">                code = <span class="string">"Unicode"</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xfeff</span>:</span><br><span class="line">                code = <span class="string">"UTF-16BE"</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                code = <span class="string">"GBK"</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写好之后上传到服务器上，需要自己在java文件目录上传好依赖的第三方jar包，然后编译：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac -cp commons-beanutils-1.8.3.jar:commons-collections-3.2.1.jar:commons-lang-2.6.jar:commons-logging-1.2.jar:json-lib-2.4-jdk15.jar: ZyhqErrorMsgDemo.java</span><br></pre></td></tr></table></figure><p><font color="red"><strong>切记：最后一个jar包后的：后面要加上一个空格再引入自己的Java文件</strong></font></p><p>执行的命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac -cp commons-beanutils-1.8.3.jar:commons-collections-3.2.1.jar:commons-lang-2.6.jar:commons-logging-1.2.jar:json-lib-2.4-jdk15.jar: ZyhqErrorMsgDemo</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有时候在进行开发的过程中，需要自己写个测试类来进行某个局部功能的测试，在测试的过程中，需要引入第三方jar包或者公司其他成员的帮助类，比如说：我需要测试一个&lt;br&gt;net.sf.json.JSONObject解析数据的时候中文乱码问题&lt;/p&gt;
&lt;figure class=&quot;
      
    
    </summary>
    
      <category term="教程" scheme="http://yoursite.com/categories/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Java" scheme="http://yoursite.com/categories/%E6%95%99%E7%A8%8B/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="基础" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Guice使用入门</title>
    <link href="http://yoursite.com/2019/12/20/Guice%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2019/12/20/Guice使用入门/</id>
    <published>2019-12-20T11:49:15.000Z</published>
    <updated>2019-12-20T11:51:13.622Z</updated>
    
    <content type="html"><![CDATA[<p>Guice是谷歌推出的一个轻量级依赖注入框架，帮助我们解决Java项目中的依赖注入问题。如果使用过Spring的话，会了解到依赖注入是个非常方便的功能。不过假如只想在项目中使用依赖注入，那么引入Spring未免大材小用了。这时候我们可以考虑使用Guice。本文参考了Guice官方文档，详细信息可以直接查看Guice文档。</p><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>如果使用Maven的话，添加下面的依赖项。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.google.inject&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;guice&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;4.2.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><p>Guice的注入非常方便，不需要配置文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 被依赖的dao</span></span><br><span class="line"><span class="meta">@Singleton</span> <span class="comment">// 打上了这个标记说明是单例的，否则Guice每次回返回一个新的对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDao</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"dao is saying"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// service，依赖 UserDao</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">private</span> UserDao mUserDao;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mUserDao.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Start</span>  </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//这步就是我们问Guice去要对象</span></span><br><span class="line">        <span class="keyword">final</span> Injector injector = Guice.createInjector();</span><br><span class="line">        <span class="keyword">final</span> UserService userService = injector.getInstance(UserService.class);</span><br><span class="line">        userService.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果输出：</p><pre><code>dao is saying</code></pre><p>复制代码可以看到没有任何的xml配置，唯一需要做的，就是在需要注入的属性上打上<code>@inject</code>。<br>使用 <code>Guice.createInjector()</code> 启动。通常需要尽早在程序中创建注入器。这样 Guice 能够帮助您创建大部分对象.</p><p><strong>该demo中，并没有用到Module，也成功运行了，是因为之前没有涉及到接口，当只是依赖<font color="red"> 确切的实现类 </font> 的时候，Guice会自动的找到需要注入的实现类</strong></p><h2 id="依赖绑定"><a href="#依赖绑定" class="headerlink" title="依赖绑定"></a>依赖绑定</h2><h3 id="链式绑定"><a href="#链式绑定" class="headerlink" title="链式绑定"></a>链式绑定</h3><p>我们在绑定依赖的时候不仅可以将父类和子类绑定，还可以将子类和更具体的子类绑定。下面的例子中，当我们需要<code>TransactionLog</code>的时候，<code>Guice</code>最后会为我们注入<code>MySqlDatabaseTransactionLog</code>对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BillingModule</span> <span class="keyword">extends</span> <span class="title">AbstractModule</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        bind(TransactionLog.class).to(DatabaseTransactionLog.class);</span><br><span class="line">        bind(DatabaseTransactionLog.class).to(MySqlDatabaseTransactionLog.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注解绑定"><a href="#注解绑定" class="headerlink" title="注解绑定"></a>注解绑定</h3><p>当我们需要将多个同一类型的对象注入不同对象的时候，就需要使用注解区分这些依赖了。最简单的办法就是使用@Named注解进行区分。</p><p>首先需要在要注入的地方添加@Named注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealBillingService</span> <span class="keyword">implements</span> <span class="title">BillingService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Inject</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">RealBillingService</span><span class="params">(@Named(<span class="string">"Checkout"</span>)</span> CreditCardProcessor processor,</span></span><br><span class="line"><span class="function">      TransactionLog transactionLog) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>然后在绑定中添加<code>annotatedWith</code>方法指定<code>@Named中</code>指定的名称。由于编译器无法检查字符串，所以Guice官方建议我们保守地使用这种方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bind(CreditCardProcessor.class)</span><br><span class="line">    .annotatedWith(Names.named(<span class="string">"Checkout"</span>))</span><br><span class="line">    .to(CheckoutCreditCardProcessor.class);</span><br></pre></td></tr></table></figure><p>如果希望使用<strong>类型安全</strong>的方式，可以自定义注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BindingAnnotation</span> </span><br><span class="line"><span class="meta">@Target</span>(&#123; FIELD, PARAMETER, METHOD &#125;) </span><br><span class="line"><span class="meta">@Retention</span>(RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> PayPal &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在需要注入的类上应用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealBillingService</span> <span class="keyword">implements</span> <span class="title">BillingService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Inject</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">RealBillingService</span><span class="params">(@PayPal CreditCardProcessor processor,</span></span></span><br><span class="line"><span class="function"><span class="params">      TransactionLog transactionLog)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>在配置类中，使用方法也和@Named类似。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bind(CreditCardProcessor.class)</span><br><span class="line">    .annotatedWith(PayPal.class)</span><br><span class="line">    .to(PayPalCreditCardProcessor.class);</span><br></pre></td></tr></table></figure><h3 id="实例绑定"><a href="#实例绑定" class="headerlink" title="实例绑定"></a>实例绑定</h3><p>有时候需要直接注入一个对象的实例，而不是从依赖关系中解析。如果我们要注入基本类型的话只能这么做。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">bind(String.class)</span><br><span class="line">    .annotatedWith(Names.named(<span class="string">"JDBC URL"</span>))</span><br><span class="line">    .toInstance(<span class="string">"jdbc:mysql://localhost/pizza"</span>);</span><br><span class="line">    </span><br><span class="line">bind(Integer.class)</span><br><span class="line">    .annotatedWith(Names.named(<span class="string">"login timeout seconds"</span>))</span><br><span class="line">    .toInstance(<span class="number">10</span>);</span><br><span class="line">```    </span><br><span class="line">    </span><br><span class="line">如果使用`toInstance()`方法注入的实例比较复杂的话，可能会影响程序启动。这时候可以使用`<span class="meta">@Provides</span>`方法代替。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### @Provides方法</span><br><span class="line">当一个对象很复杂，无法使用简单的构造器来生成的时候，我们可以使用`<span class="meta">@Provides</span>`方法，也就是在配置类中生成一个注解了`<span class="meta">@Provides</span>`的方法。在该方法中我们可以编写任意代码来构造对象。</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BillingModule</span> <span class="keyword">extends</span> <span class="title">AbstractModule</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Provides</span></span><br><span class="line">  <span class="function">TransactionLog <span class="title">provideTransactionLog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DatabaseTransactionLog transactionLog = <span class="keyword">new</span> DatabaseTransactionLog();</span><br><span class="line">    transactionLog.setJdbcUrl(<span class="string">"jdbc:mysql://localhost/pizza"</span>);</span><br><span class="line">    transactionLog.setThreadPoolSize(<span class="number">30</span>);</span><br><span class="line">    <span class="keyword">return</span> transactionLog;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@Provides</code>方法也可以应用<code>@Named</code>和自定义注解，还可以注入其他依赖，Guice会在调用方法之前注入需要的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Provides</span> <span class="meta">@PayPal</span></span><br><span class="line"><span class="function">CreditCardProcessor <span class="title">providePayPalCreditCardProcessor</span><span class="params">(@Named(<span class="string">"PayPal API key"</span>)</span> String apiKey) </span>&#123;</span><br><span class="line">  PayPalCreditCardProcessor processor = <span class="keyword">new</span> PayPalCreditCardProcessor();</span><br><span class="line">  processor.setApiKey(apiKey);</span><br><span class="line">  <span class="keyword">return</span> processor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Provider绑定"><a href="#Provider绑定" class="headerlink" title="Provider绑定"></a>Provider绑定</h3><p>如果项目中存在多个比较复杂的对象需要构建，使用<code>@Provides</code>方法会让配置类变得比较乱。我们可以使用Guice提供的<code>Provider</code>接口将复杂的代码放到单独的类中。办法很简单，实现<code>Provider&lt;T&gt;</code>接口的<code>get</code>方法即可。在<code>Provider</code>类中，我们可以使用<code>@Inject</code>任意注入对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DatabaseTransactionLogProvider</span> <span class="keyword">implements</span> <span class="title">Provider</span>&lt;<span class="title">TransactionLog</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Connection connection;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Inject</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DatabaseTransactionLogProvider</span><span class="params">(Connection connection)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.connection = connection;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> TransactionLog <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DatabaseTransactionLog transactionLog = <span class="keyword">new</span> DatabaseTransactionLog();</span><br><span class="line">    transactionLog.setConnection(connection);</span><br><span class="line">    <span class="keyword">return</span> transactionLog;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在配置类中使用<code>toProvider</code>方法绑定到<code>Provider</code>上即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BillingModule</span> <span class="keyword">extends</span> <span class="title">AbstractModule</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    bind(TransactionLog.class)</span><br><span class="line">        .toProvider(DatabaseTransactionLogProvider.class);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>默认情况下Guice会在每次注入的时候创建一个新对象。如果希望创建一个单例依赖的话，可以在实现类上应用<code>@Singleton</code>注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Singleton</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InMemoryTransactionLog</span> <span class="keyword">implements</span> <span class="title">TransactionLog</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* everything here should be threadsafe! */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者也可以在配置类中指定。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bind(TransactionLog.class)</span><br><span class="line">    .to(InMemoryTransactionLog.class)</span><br><span class="line">    .in(Singleton.class);</span><br></pre></td></tr></table></figure><p>在<code>@Provides</code>方法中也可以指定单例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Provides</span> </span><br><span class="line"><span class="meta">@Singleton</span></span><br><span class="line"><span class="function">TransactionLog <span class="title">provideTransactionLog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果一个类型上存在多个冲突的作用域，<code>Guice</code>会使用<code>bind()</code>方法中指定的作用域。如果不想使用注解的作用域，可以在<code>bind()</code>方法中将对象绑定为<code>Scopes.NO_SCOPE</code>。</p><p>Guice和它的扩展提供了很多作用域，有单例<code>Singleton</code>，Session作用域<code>SessionScoped</code>，Request请求作用域<code>RequestScoped</code>等等。我们可以根据需要选择合适的作用域。</p><p>参考：<br><a href="https://juejin.im/post/5a375e156fb9a0452a3c6b96" target="_blank" rel="noopener">Google-Guice入门教程</a></p><p><a href="https://www.jianshu.com/p/a648322dc680" target="_blank" rel="noopener">Guice 快速入门</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Guice是谷歌推出的一个轻量级依赖注入框架，帮助我们解决Java项目中的依赖注入问题。如果使用过Spring的话，会了解到依赖注入是个非常方便的功能。不过假如只想在项目中使用依赖注入，那么引入Spring未免大材小用了。这时候我们可以考虑使用Guice。本文参考了Guic
      
    
    </summary>
    
      <category term="教程" scheme="http://yoursite.com/categories/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Guice" scheme="http://yoursite.com/categories/%E6%95%99%E7%A8%8B/Guice/"/>
    
    
      <category term="教程" scheme="http://yoursite.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Guice" scheme="http://yoursite.com/tags/Guice/"/>
    
  </entry>
  
  <entry>
    <title>Kafka进阶-基本原理</title>
    <link href="http://yoursite.com/2019/12/20/Kafka%E8%BF%9B%E9%98%B6-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2019/12/20/Kafka进阶-基本原理/</id>
    <published>2019-12-20T11:34:19.000Z</published>
    <updated>2019-12-20T11:45:27.290Z</updated>
    
    <content type="html"><![CDATA[<h2 id="集群架构图"><a href="#集群架构图" class="headerlink" title="集群架构图"></a>集群架构图</h2><p><img src="/images/kafka_cluster_architecture.png" alt="kafka_cluster_architecture"></p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul><li><p>日志收集：一个公司可以用Kafka可以收集各种服务的log，通过kafka以统一接口服务的方式开放给各种consumer，例如hadoop、Hbase、Solr等。</p></li><li><p>消息系统：解耦和生产者和消费者、缓存消息等。</p></li><li><p>用户活动跟踪：Kafka经常被用来记录web用户或者app用户的各种活动，如浏览网页、搜索、点击等活动，这些活动信息被各个服务器发布到kafka的topic中，然后订阅者通过订阅这些topic来做实时的监控分析，或者装载到hadoop、数据仓库中做离线分析和挖掘。</p></li><li><p>运营指标：Kafka也经常用来记录运营监控数据。包括收集各种分布式应用的数据，生产各种操作的集中反馈，比如报警和报告。</p></li><li><p>流式处理：比如spark streaming和storm</p></li><li><p>事件源</p></li></ul><h2 id="如何做到高吞吐、低延迟"><a href="#如何做到高吞吐、低延迟" class="headerlink" title="如何做到高吞吐、低延迟"></a>如何做到高吞吐、低延迟</h2><p>Kafka写数据的大致方式：<strong>先写操作系统的页缓存（Page Cache）,然后由操作系统自行决定何时刷到磁盘</strong>。</p><p>因此 Kafka 达到高吞吐、低延迟的原因主要有以下4点：</p><ul><li><p><strong>页缓存是在内存中分配的</strong>，所以消息写入的速度很快。</p></li><li><p>Kafka不必和底层的文件系统进行交互，所有<strong>繁琐的I/O操作都由操作系统来处理</strong>。</p></li><li><p>Kafka采用<strong>追加写的方式，避免了磁盘随机写操作</strong>。</p></li><li><p><strong>使用以Sendfile为代表的零拷贝技术</strong>提高了读取数据的效率。</p></li></ul><blockquote><p>PS: 使用页缓存而非堆内存还有一个好处，就是当Kafka broker的进程崩溃时，堆内存的数据会丢失，但是<strong>页缓存的数据依然存在</strong>，重启Kafka broker后可以继续提供服务。</p></blockquote><h2 id="Producer工作流程"><a href="#Producer工作流程" class="headerlink" title="Producer工作流程"></a>Producer工作流程</h2><p><img src="/images/kafka_producer_process.jpg" alt></p><h3 id="序列化消息-amp-amp-计算partition"><a href="#序列化消息-amp-amp-计算partition" class="headerlink" title="序列化消息 &amp;&amp; 计算partition"></a>序列化消息 &amp;&amp; 计算partition</h3><p>根据key和value的配置对消息进行序列化,然后计算partition：  </p><ul><li><p>ProducerRecord对象中如果指定了partition，就使用这个partition;</p></li><li><p>否则根据key和topic的partition数目取余;</p></li><li><p>如果key也没有的话就随机生成一个counter，使用这个counter来和partition数目取余。这个counter每次使用的时候递增。</p></li></ul><h3 id="发送到batch-amp-amp-唤醒Sender线程"><a href="#发送到batch-amp-amp-唤醒Sender线程" class="headerlink" title="发送到batch &amp;&amp; 唤醒Sender线程"></a>发送到batch &amp;&amp; 唤醒Sender线程</h3><p>根据topic-partition获取对应的<code>batchs（Dueue&lt;ProducerBatch&gt;）</code>，然后将消息append到batch中. 如果有batch满了则唤醒Sender线程。队列的操作是加锁执行，所以batch内消息是有序的，后续的Sender操作为异步操作。  </p><h3 id="Sender把消息有序发到broker（tp-replia-leader）"><a href="#Sender把消息有序发到broker（tp-replia-leader）" class="headerlink" title="Sender把消息有序发到broker（tp replia leader）"></a>Sender把消息有序发到broker（tp replia leader）</h3><p><strong>确定tp relica leader 所在的broker</strong></p><ul><li><p>Kafka中每台broker都保存了kafka集群的<code>metadata</code>信息，metadata信息里包括了每个topic的所有partition的信息: <code>leader</code>, <code>leader_epoch</code>, <code>controller_epoch</code>, <code>isr</code>, <code>replicas</code>等; Kafka客户端从任一broker都可以获取到需要的metadata信息; sender线程通过metadata信息可以知道tp leader的brokerId</p></li><li><p>producer也保存了metada信息，同时根据metadata更新策略（定期更新<code>metadata.max.age.ms</code>、失效检测，强制更新)：检查到metadata失效以后，调用<code>metadata.requestUpdate()</code>强制更新</p></li></ul><p><strong>幂等性发送</strong><br>为实现Producer的幂等性，Kafka引入了<code>Producer ID</code>（即PID）和<code>Sequence Number</code>。<strong>对于每个PID，该Producer发送消息的每个&lt;Topic, Partition&gt;都对应一个单调递增的Sequence Number</strong>。同样，Broker端也会为每个&lt;PID, Topic, Partition&gt;维护一个序号，并且每Commit一条消息时将其对应序号递增。对于接收的每条消息，如果其序号比Broker维护的序号）大一，则Broker会接受它，否则将其丢弃：  </p><ul><li><p>如果消息序号比Broker维护的序号差值比一大，说明中间有数据尚未写入，即乱序，此时Broker拒绝该消息，Producer抛出<code>InvalidSequenceNumber</code></p></li><li><p>如果消息序号小于等于Broker维护的序号，说明该消息已被保存，即为重复消息，Broker直接丢弃该消息，Producer抛出<code>DuplicateSequenceNumber</code></p></li></ul><h3 id="Sender处理broker发来的produce-response"><a href="#Sender处理broker发来的produce-response" class="headerlink" title="Sender处理broker发来的produce response"></a>Sender处理broker发来的produce response</h3><p>一旦broker处理完Sender的produce请求，就会发送produce response给Sender，此时producer将执行我们为send()设置的回调函数。至此producer的send执行完毕。   </p><h2 id="Consumer工作流程"><a href="#Consumer工作流程" class="headerlink" title="Consumer工作流程"></a>Consumer工作流程</h2><h3 id="Poll消息"><a href="#Poll消息" class="headerlink" title="Poll消息"></a>Poll消息</h3><p><img src="/images/kafka_consumer_poll.jpg" alt></p><ul><li><p>消费者通过fetch线程拉消息（单线程）</p></li><li><p>消费者通过心跳线程来与broker发送心跳。超时会认为挂掉</p></li><li><p>每个<code>consumer group</code>在<code>broker</code>上都有一个<code>coordnator</code>来管理，消费者加入和退出，以及消费消息的位移都由<code>coordnator</code>处理。</p></li></ul><h3 id="位移管理"><a href="#位移管理" class="headerlink" title="位移管理"></a>位移管理</h3><p>consumer的消息位移代表了当前group对topic-partition的消费进度，consumer宕机重启后可以继续从该offset开始消费。</p><p>在kafka0.8之前，位移信息存放在zookeeper上，由于zookeeper不适合高并发的读写，新版本Kafka把位移信息当成消息，发往 <strong><em>__consumers_offsets</em></strong> 这个 topic 所在的 broker，<strong><em>__consumers_offsets</em></strong> 默认有50个分区。<br>消息的key 是 <code>groupId+topic_partition</code>, value 是<code>offset</code>.<br><img src="/images/kafka_weiyi_manage.jpg" alt="-w887"></p><h3 id="Kafka-Group状态"><a href="#Kafka-Group状态" class="headerlink" title="Kafka Group状态"></a>Kafka Group状态</h3><p><img src="/images/kafka_group_status.jpg" alt></p><ul><li><p><strong>Empty</strong>：初始状态，Group 没有任何成员，如果所有的 offsets 都过期的话就会变成 Dead</p></li><li><p><strong>PreparingRebalance</strong>：Group 正在准备进行 Rebalance</p></li><li><p><strong>AwaitingSync</strong>：Group 正在等待 group leader 的分配方案</p></li><li><p><strong>Stable</strong>：稳定的状态（Group is stable）；</p></li><li><p><strong>Dead</strong>： Group 内已经没有成员，并且它的 Metadata 已经被移除</p></li></ul><h3 id="重平衡Reblance"><a href="#重平衡Reblance" class="headerlink" title="重平衡Reblance"></a>重平衡Reblance</h3><p>当一些原因导致consumer对partition消费不再均匀时，kafka 会自动执行rebalance，使得consumer对partition的消费再次平衡。</p><p>什么时候发生rebalance？：</p><ul><li><p>组订阅topic数变更</p></li><li><p>topic partition数变更</p></li><li><p>consumer成员变更</p></li></ul><h4 id="Reblance过程"><a href="#Reblance过程" class="headerlink" title="Reblance过程"></a>Reblance过程</h4><ul><li><p><strong>举例1 consumer被检测为崩溃引起的rebalance</strong><br>比如心跳线程在 <code>timeout</code> 时间内没和 <code>broker</code> 发送心跳，此时 <code>coordinator</code> 认为该group应该进行rebalance。接下来其他consumer发来fetch请求后，coordinator将回复他们进行rebalance通知。当consumer成员收到请求后，只有leader会根据分配策略进行分配，然后把各自的分配结果返回给coordinator。 这个时候只有consumer leader返回的是实质数据，其他返回的都为空。收到分配方法后，coordinator将会把分配策略同步给各consumer.</p></li><li><p><strong>举例2 consumer加入引起的rebalance</strong></p><ul><li><p>使用 <strong>join</strong> 协议，表示有consumer 要加入到group中<br><img src="/images/kafka_rebalance_join.jpg" alt></p></li><li><p>使用 <strong>sync</strong> 协议，根据分配规则进行分配<br><img src="/images/kafka_rebalance_sync.jpg" alt></p></li></ul></li></ul><h3 id="Rebalance机制存在的问题"><a href="#Rebalance机制存在的问题" class="headerlink" title="Rebalance机制存在的问题"></a>Rebalance机制存在的问题</h3><p>在大型系统中，一个topic可能对应数百个consumer实例。 </p><ul><li><p>这些consumer陆续加入到一个空消费组将导致多次的rebalance； </p></li><li><p>此外consumer 实例启动的时间不可控，很有可能超出coordinator确定的rebalance timeout(即max.poll.interval.ms)，将会再次触发rebalance，而每次rebalance的代价又相当地大，因为很多状态都需要在rebalance前被持久化，而在rebalance后被重新初始化</p><h3 id="新版本改进"><a href="#新版本改进" class="headerlink" title="新版本改进"></a>新版本改进</h3><p>通过延迟进入 <code>PreparingRebalance</code> 状态减少 rebalance 次数<br><img src="/images/kafka_preparing_rebalance.jpg" alt></p><p>  新版本新增了 <code>group.initial.rebalance.delay.ms</code> 参数。<strong>空消费组接受到成员加入请求时，不立即转化到 <code>PreparingRebalance</code> 状态来开启rebalance。当时间超过<code>group.initial.rebalance.delay.ms</code>后，再把group状态改为PreparingRebalance（开启rebalance）</strong>。</p><p>  <strong>实现机制是在coordinator底层新增一个group状态：<code>InitialRebalance</code></strong>。假设此时有多个consumer陆续启动，那么group状态先转化为 <code>InitialRebalance</code>，待<code>group.initial.rebalance.delay.ms</code> 时间后，再转换为<code>PreparingRebalance</code>（开启rebalance）.</p></li></ul><h3 id="消息传输一致"><a href="#消息传输一致" class="headerlink" title="消息传输一致"></a>消息传输一致</h3><p>Kafka提供3种消息传输一致性语义：最多1次，最少1次，恰好1次。</p><ul><li><p><strong>at most once</strong>: 消费者fetch消息, 然后保存offset,然后处理消息; 当client保存offset之后,但是在消息处理过程中consumer进程失效(crash), 导致部分消息未能继续处理.那么此后可能其他consumer会接管,但是因为offset已经提前保存,那么新的consumer将不能fetch到offset之前的消息(尽管它们尚没有被处理), 这就是”at most once”.** 可能会出现数据丢失情况;**</p></li><li><p><strong>at least once</strong>: 消费者fetch消息, 然后处理消息, 然后保存offset. 如果消息处理成功之后, 但是在保存offset阶段zookeeper异常或者consumer失效,导致保存offset操作未能执行成功, 这就导致接下来再次fetch时可能获得上次已经处理过的消息,这就是”at least once”.<strong>可能会重传数据，有可能出现数据被重复处理的情况;</strong></p></li><li><p><strong>exactly once</strong>：并不是指真正只传输1次，只不过有一个机制。确保不会出现“数据被重复处理”和“数据丢失”的情况。消费者的场景中可以采取以下方案来得到“恰好1次”的一致性语义：</p><blockquote><p> 最少1次 ＋ 消费者的输出中额外增加已处理消息最大编号：由于已处理消息最大编号的存在，不会出现重复处理消息的情况</p></blockquote></li></ul><h2 id="Broker设计原理"><a href="#Broker设计原理" class="headerlink" title="Broker设计原理"></a>Broker设计原理</h2><p>Broker 是Kafka 集群中的节点。负责处理生产者发送过来的消息，消费者消费的请求。以及集群节点的管理等。</p><h3 id="broker消息存储"><a href="#broker消息存储" class="headerlink" title="broker消息存储"></a>broker消息存储</h3><ul><li><p>Kafka的消息<strong>以二进制的方式紧凑地存储</strong>，节省了很大空间</p></li><li><p>此外<strong>消息存在 ByteBuffer 而不是堆</strong>，这样broker进程挂掉时，数据不会丢失，同时避免了gc问题</p></li><li><p>通过<strong>零拷贝和顺序寻址</strong>，让消息存储和读取速度都非常快</p></li><li><p>处理fetch请求的时候<strong>通过 zero-copy 加快速度</strong></p></li></ul><h3 id="broker状态数据"><a href="#broker状态数据" class="headerlink" title="broker状态数据"></a>broker状态数据</h3><p>broker设计中，每台机器都保存了相同的状态数据。主要包括以下：</p><ul><li><p>Controller所在的broker ID，即保存了当前集群中controller是哪台broker;</p></li><li><p>集群中所有broker的信息：比如每台broker的ID、机架信息以及配置的若干组连接信息</p></li><li><p>集群中所有节点的信息：严格来说，它和上一个有些重复，不过此项是按照<strong>broker ID</strong>和<strong>监听器类型</strong>进行分组的。 对于超大集群来说，使用这一项缓存可以快速地定位和查找给定节点信息，而无需遍历上一项中的内容，算是一个优化吧</p></li><li><p>集群中所有分区的信息：所谓分区信息指的是<strong>分区的leader、ISR和AR信息以及当前处于offline状态的副本集合</strong>。 这部分数据按照 topic-partitionID 进行分组，可以快速地查找到每个分区的当前状态。（注：AR表示assigned replicas，即创建topic时为该分区分配的副本集合）</p></li></ul><h3 id="broker负载均衡"><a href="#broker负载均衡" class="headerlink" title="broker负载均衡"></a>broker负载均衡</h3><ul><li><p><strong>分区数量负载</strong>：各台broker的partition数量应该均匀<br>partition Replica分配算法如下：</p><ul><li><p>将所有Broker（假设共n个Broker）和待分配的Partition排序;</p></li><li><p>将第i个Partition分配到第（i mod n）个Broker上</p></li><li><p>将第i个Partition的第j个Replica分配到第（(i + j) mod n）个Broker上</p></li></ul></li></ul><ul><li><strong>容量大小负载</strong>：每台broker的硬盘占用大小应该均匀<br>在kafka1.1之前，Kafka能够保证各台broker上partition数量均匀，但由于每个partition内的消息数不同，可能存在不同硬盘之间内存占用差异大的情况。在Kafka1.1中增加了<strong>副本跨路径迁移功能</strong> <code>kafka-reassign-partitions.sh</code>，我们可以结合它和监控系统，实现自动化的负载均衡</li></ul><h2 id="Kafaka重要参数"><a href="#Kafaka重要参数" class="headerlink" title="Kafaka重要参数"></a>Kafaka重要参数</h2><ul><li><p>acks  </p><blockquote><p>producer收到多少broker的答复才算真的发送成功<br>acks = 0 : 不接收发送结果<br>acks = all 或者 -1: 表示发送消息时，不仅要写入本地日志，还要等待所有副本写入成功。<br>acks = 1: 写入本地日志即可，是上述二者的折衷方案，也是默认值。</p></blockquote></li><li><p>retries  </p><blockquote><p>默认为 0，即不重试，立即失败。<br>一个大于 0 的值，表示重试次数。</p></blockquote></li><li><p>buffer.memory</p><blockquote><p>指定 producer 端用于缓存消息的缓冲区的大小，默认 32M；<br>适当提升该参数值，可以增加一定的吞吐量, 但是batch太大会增大延迟，可搭配linger_ms参数使用</p></blockquote></li><li><p>linger_ms</p><blockquote><p>如果batch太大，或者producer qps不高，batch添加的会很慢，我们可以强制在linger_ms时间后发送batch数据</p></blockquote></li><li><p>batch.size</p><blockquote><p>producer 会将发送分区的多条数据封装在一个 batch 中进行发送，这里的参数指的就是 batch 的大小。<br>该参数值过小的话，会降低吞吐量，过大的话，会带来较大的内存压力。<br>默认为 16K，建议合理增加该值。</p></blockquote></li></ul><h2 id="丢失数据的场景及解决方案"><a href="#丢失数据的场景及解决方案" class="headerlink" title="丢失数据的场景及解决方案"></a>丢失数据的场景及解决方案</h2><h3 id="consumer端"><a href="#consumer端" class="headerlink" title="consumer端"></a>consumer端</h3><p>不是严格意义的丢失，其实只是漏消费了。<br>设置了 <code>auto.commit.enable=true</code> ，当 consumer fetch 了一些数据但还没有完全处理掉的时候，刚好到 commit interval 触发了提交 offset 操作，接着 consumer 挂掉。这时已经fetch的数据还没有处理完成但已经被commit掉，因此没有机会再次被处理，数据丢失。</p><p><strong>解决方案：</strong><br><code>enable.auto.commit=false</code> 关闭自动提交位移，在消息被完整处理之后再手动提交位移</p><h3 id="producer端"><a href="#producer端" class="headerlink" title="producer端"></a>producer端</h3><p>I/O 线程发送消息之前，producer 崩溃， 则 producer 的内存缓冲区的数据将丢失</p><p><strong>解决方案：</strong></p><ul><li><p>同步发送，性能差，不推荐。</p></li><li><p>仍然异步发送，通过“无消息丢失配置”（来自胡夕的《Apache Kafka 实战》）极大降低丢失的可能性：</p><ul><li><p><code>block.on.buffer.full = true</code> 尽管该参数在0.9.0.0已经被标记为“deprecated”，但鉴于它的含义非常直观，所以这里还是显式设置它为true，<strong>使得producer将一直等待缓冲区直至其变为可用。否则如果producer生产速度过快耗尽了缓冲区，producer将抛出异常</strong></p></li><li><p><code>acks=all</code> 很好理解，所有follower都响应了才认为消息提交成功，即”committed”</p></li><li><p><code>retries = MAX</code> 无限重试，直到你意识到出现了问题:)</p></li><li><p><code>max.in.flight.requests.per.connection = 1</code> 限制客户端在单个连接上能够发送的未响应请求的个数。设置此值是1表示kafka broker在响应请求之前client不能再向同一个broker发送请求。注意：<strong>设置此参数是为了避免消息乱序</strong></p></li><li><p>使用<code>KafkaProducer.send(record, callback)</code>而不是<code>send(record)</code>方法 自定义回调逻辑处理消息发送失败</p></li><li><p>callback逻辑中最好显式关闭<code>producer：close(0)</code> 注意：设置此参数是为了避免消息乱序</p></li><li><p><code>unclean.leader.election.enable=false</code> 关闭unclean leader选举，即<strong>不允许非ISR中的副本被选举为leader，以避免数据丢失</strong></p></li><li><p><code>replication.factor &gt;= 3</code> 这个完全是个人建议了，参考了Hadoop及业界通用的三备份原则</p></li><li><p><code>min.insync.replicas &gt; 1</code> 消息至少要被写入到这么多副本才算成功，也是提升数据持久性的一个参数。与acks配合使用</p></li><li><p>保证<code>replication.factor &gt; min.insync.replicas</code> 如果两者相等，当一个副本挂掉了分区也就没法正常工作了。通常设置<code>replication.factor = min.insync.replicas + 1</code> 即可</p></li></ul></li></ul><h2 id="如何选择Partiton的数量"><a href="#如何选择Partiton的数量" class="headerlink" title="如何选择Partiton的数量"></a>如何选择Partiton的数量</h2><ul><li><p>在创建 Topic 的时候可以指定 Partiton 数量，也可以在创建完后手动修改。但 <strong>Partiton 数量只能增加不能减少</strong>。中途增加 Partiton，<strong>partition里面的message不会重新进行分配，原来的partition里面的message数据不会变</strong>，新加的这个partition刚开始是空的，随后进入这个topic的message就会重新参与所有partition的load balance。</p></li><li><p>Partition 的数量直接决定了该 Topic 的并发处理能力。但也并不是越多越好。<strong>Partition 的数量对消息延迟性会产生影响</strong>。</p></li><li><p>一般建议选择 <strong>Broker Num * Consumer Num</strong>，这样<strong>平均每个 Consumer 会同时读取 Broker 数目个 Partition</strong> ， 这些 Partition 压力可以平摊到每台 Broker 上</p></li></ul><h2 id="controller的职责"><a href="#controller的职责" class="headerlink" title="controller的职责"></a>controller的职责</h2><p>在 kafka 集群中，某个 broker 会被选举承担特殊的角色，即<strong>控制器（controller)</strong>，用于<strong>管理和协调 kafka 集群</strong>，具体职责如下：</p><ul><li><p>管理副本和分区的状态</p></li><li><p>更新集群元数据信息</p></li><li><p>创建、删除 topic</p></li><li><p>分区重分配</p></li><li><p>leader 副本选举</p></li><li><p>topic 分区扩展</p></li><li><p>broker 加入、退出集群</p></li><li><p>受控关闭</p></li><li><p>controller leader选举</p></li></ul><h2 id="节点异常情形"><a href="#节点异常情形" class="headerlink" title="节点异常情形"></a>节点异常情形</h2><h3 id="leader挂了（leader-failover）"><a href="#leader挂了（leader-failover）" class="headerlink" title="leader挂了（leader failover）"></a>leader挂了（leader failover）</h3><p>当 leader 挂了之后，controller 默认会从 <strong><em>ISR</em></strong> 中选择一个 replica 作为 leader 继续工作，条件是<strong>新 leader 必须有挂掉 leader 的所有数据</strong>。</p><p>如果为了系统的可用性，而容忍降低数据的一致性的话，可以将 <code>unclean.leader.election.enable = true</code>，开启 kafka 的<strong>“脏 leader 选举”</strong>。当 ISR 中没有 replica，则选一个幸存的replica作为leader 继续响应请求，如此操作提高了 Kafka 的分区容忍度，但是数据一致性降低了。</p><h3 id="broker挂了（broker-failover）"><a href="#broker挂了（broker-failover）" class="headerlink" title="broker挂了（broker failover）"></a>broker挂了（broker failover）</h3><p>broker上面有很多 partition 和多个 leader 。因此至少需要处理如下内容：</p><ul><li><p>更新该 broker 上所有 follower 的状态</p></li><li><p>重新给 leader 在该 broker 上的 partition 选举 leader</p></li><li><p>选举完成后，要更新 partition 的状态，比如谁是 leader 等</p></li></ul><p>kafka 集群启动后，所有的 broker 都会被 controller 监控，一旦有 broker 宕机，<strong>ZK 的监听机制会通知到 controller</strong>， controller 拿到挂掉 broker 中所有的 partition，以及它上面的存在的 leader，然后从 partition的 <strong><em>ISR</em></strong> 中选择一个 follower 作为 leader，更改 partition 的 follower 和 leader 状态。</p><h3 id="controller挂了（controller-failover）"><a href="#controller挂了（controller-failover）" class="headerlink" title="controller挂了（controller failover）"></a>controller挂了（controller failover）</h3><ul><li><p>由于每个 broker 都会在 zookeeper 的 “/controller” 节点注册 watcher，当 controller 宕机时 zookeeper 中的临时节点消失，所有存活的 broker 收到 fire 的通知</p></li><li><p>存活的 broker 收到 fire 的通知后，每个 broker 都尝试创建新的 controller path，只有一个竞选成功并当选为 controller。</p></li></ul><h2 id="Zookeeper在Kafka中作用"><a href="#Zookeeper在Kafka中作用" class="headerlink" title="Zookeeper在Kafka中作用"></a>Zookeeper在Kafka中作用</h2><ul><li><p>管理 broker 与 consumer 的动态加入与离开。（Producer 不需要管理，随便一台计算机都可以作为Producer 向 Kakfa Broker 发消息）</p></li><li><p>触发负载均衡，当 broker 或 consumer 加入或离开时会触发负载均衡算法，使得一个 consumer group 内的多个 consumer 的消费负载平衡。（因为一个 comsumer 消费一个或多个partition，一个 partition 只能被一个 consumer 消费）</p></li><li><p>维护消费关系及每个 partition 的消费信息</p></li></ul><h2 id="Page-Cache带来的好处"><a href="#Page-Cache带来的好处" class="headerlink" title="Page Cache带来的好处"></a>Page Cache带来的好处</h2><p>Linux 总会把系统中还没被应用使用的内存挪来给 Page Cache，在命令行输入<code>free</code>，或者 <code>cat /proc/meminfo</code> ，“Cached”的部分就是 Page Cache。</p><p>Page Cache 中每个文件是一棵 <strong>Radix 树</strong>（又称 PAT 位树, 一种多叉搜索树），节点由 <strong><em>4k</em></strong> 大小的 Page 组成，可以通过文件的偏移量（如 0x1110001）快速定位到某个Page。</p><p>当写操作发生时，它只是将数据写入 Page Cache 中，并将该页置上 dirty 标志。</p><p>当读操作发生时，它会<strong>首先在 Page Cache 中查找，如果有就直接返回，没有的话就会从磁盘读取文件写入 Page Cache 再读取</strong>。</p><p>可见，<strong>只要生产者与消费者的速度相差不大，消费者会直接读取之前生产者写入Page Cache的数据，大家在内存里完成接力，根本没有磁盘访问</strong>。</p><p>而比起在内存中维护一份消息数据的传统做法，这<strong>既不会重复浪费一倍的内存，Page Cache 又不需要 GC</strong> （可以放心使用60G内存了），而且<strong>即使 Kafka 重启了，Page Cache 还依然在</strong>。</p><p>参考：<br>[1] <a href="https://zhuanlan.zhihu.com/p/65512721" target="_blank" rel="noopener">Kafka常见问题 [知乎]</a><br>[2] <a href="https://mp.weixin.qq.com/s/zxPz_aFEMrshApZQ727h4g" target="_blank" rel="noopener">Kafka系统设计开篇</a><br>[3] <a href="https://blog.csdn.net/u013573133/article/details/48142677" target="_blank" rel="noopener">Kafka史上最详细原理总结</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;集群架构图&quot;&gt;&lt;a href=&quot;#集群架构图&quot; class=&quot;headerlink&quot; title=&quot;集群架构图&quot;&gt;&lt;/a&gt;集群架构图&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/images/kafka_cluster_architecture.png&quot; alt=&quot;kaf
      
    
    </summary>
    
      <category term="中间件" scheme="http://yoursite.com/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
      <category term="Kafka" scheme="http://yoursite.com/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/Kafka/"/>
    
    
      <category term="kafka" scheme="http://yoursite.com/tags/kafka/"/>
    
      <category term="基本原理" scheme="http://yoursite.com/tags/%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Mysql锁机制</title>
    <link href="http://yoursite.com/2019/12/20/Mysql%E9%94%81%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2019/12/20/Mysql锁机制/</id>
    <published>2019-12-20T11:23:50.000Z</published>
    <updated>2019-12-20T12:03:52.269Z</updated>
    
    <content type="html"><![CDATA[<h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><p>MySQL/InnoDB的加锁，一直是一个常见的话题。例如，数据库如果有高并发请求，如何保证数据完整性？产生死锁问题如何排查并解决？下面是不同锁等级的区别</p><ul><li><p><strong>表级锁</strong><br>开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高 ，并发度最低。</p></li><li><p><strong>页面锁</strong><br>开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</p></li><li><p><strong>行级锁</strong><br>开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</p></li></ul><p>查看数据库支持的存储引擎：</p><blockquote><p>SHOW ENGINES</p></blockquote><p><img src="/images/msyql_lock_transaction.jpg" alt></p><h2 id="InnoDB存储引擎"><a href="#InnoDB存储引擎" class="headerlink" title="InnoDB存储引擎"></a>InnoDB存储引擎</h2><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>用数据版本（Version）记录机制实现，这是乐观锁最常用的一种实现方式。</p><p>何谓数据版本？</p><p>即为数据增加一个版本标识，一般是通过为数据库表增加一个数字类型的 “version” 字段来实现。</p><ul><li><p>当读取数据时，将version字段的值一同读出，数据每更新一次，对此version值加1。</p></li><li><p>当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的version值进行比对，如果数据库表当前版本号与第一次取出来的version值相等，则予以更新，否则认为是过期数据。</p></li></ul><p>举例：<br>1、数据库表三个字段，分别是id、value、version</p><blockquote><p>select id,value,version from TABLE where id = #{id}</p></blockquote><p>2、每次更新表中的value字段时，为了防止发生冲突，需要这样操作</p><blockquote><p>update TABLE<br>set value=2,version=version+1<br>where id=#{id} and version=#{version}</p></blockquote><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>悲观锁就是在操作数据时，认为此操作会出现数据冲突，所以<strong>在进行每次操作时都要通过获取锁才能进行对相同数据的操作</strong>，这点跟java中的synchronized很相似，所以悲观锁需要耗费较多的时间。</p><p>另外与乐观锁相对应的，<strong>悲观锁是由数据库自己实现</strong>了的，要用的时候，我们直接调用数据库的相关语句就可以了。</p><p>说到这里，由悲观锁涉及到的另外两个锁概念就出来了，它们就是共享锁与排它锁。共享锁和排它锁是悲观锁的不同的实现，它俩都属于悲观锁的范畴。</p><h4 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h4><p>共享锁又称读锁 (read lock)，是读操作创建的锁。其他用户可以并发读取数据，但任何事务都不能对数据进行修改（获取数据上的排他锁），直到已释放所有共享锁。当如果事务对读锁进行修改操作，很可能会造成死锁。如下图所示。<br><img src="/images/mysql_share_lock.jpg" alt></p><p><strong>如果事务T对数据A加上共享锁后，则其他事务只能对A再加共享锁，不能加排他锁</strong>。获得共享锁的事务只能读数据，不能修改数据。</p><p>在查询语句后面增加 <code>LOCK IN SHARE MODE</code>，Mysql会<strong>对查询结果中的每行都加共享锁</strong>，当没有其他线程对查询结果集中的任何一行使用排他锁时，可以成功申请共享锁，否则会被阻塞。 其他线程也可以读取使用了共享锁的表，而且这些线程读取的是同一个版本的数据。</p><p>加上共享锁后，对于<code>update</code>，<code>insert</code>，<code>delete</code>语句会自动加排它锁。</p><h4 id="排它锁"><a href="#排它锁" class="headerlink" title="排它锁"></a>排它锁</h4><p>排他锁<code>Exclusive Lock</code>（也叫writer lock）又称写锁。</p><p>名词解释：若某个事物对某一行加上了排他锁，<strong>只能这个事务对其进行读写，在此事务结束之前，其他事务不能对其进行加任何锁</strong>，其他进程可以读取, 不能进行写操作，需等待其释放。</p><p>若事务 1 对数据对象A加上X锁，事务 1 可以读A也可以修改A，其他事务不能再对A加任何锁，直到事物 1 释放A上的锁。这保证了其他事务在事物 1 释放A上的锁之前不能再读取和修改A。<strong>排它锁会阻塞所有的排它锁和共享锁.</strong></p><p>读取为什么要加读锁呢？</p><blockquote><p>防止数据在被读取的时候被别的线程加上写锁。</p></blockquote><p>排他锁使用方式：在需要执行的语句后面加上<code>for update</code>就可以了</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">status</span> <span class="keyword">from</span> <span class="keyword">TABLE</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure><p>排他锁，也称写锁，独占锁，当前写操作没有完成前，它会阻断其他写锁和读锁。<br><img src="/images/mysql_exclusive_lock.jpg" alt></p><p>排他锁之所以能阻止<code>update</code>,<code>delete</code>等操作是因为<code>update</code>，<code>delete</code>操作会自动加排他锁，<br>也就是说<strong>即使加了排他锁也无法阻止<code>select</code>操作</strong>。而<code>select XXX for update</code> 语法可以对<code>select</code>操作加上排他锁。 所以为了防止更新丢失可以在<code>select</code>时加上<code>for update</code>加锁, 这样就可以阻止其余事务的<code>select for update</code> <strong>(但注意无法阻止select)</strong>.</p><p>要使用排他锁，我们必须关闭mysql数据库的自动提交属性，因为MySQL默认使用autocommit模式，也就是说，当你执行一个更新操作后，MySQL会立刻将结果进行提交。</p><h3 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h3><p>多个事务操作同一行数据时，后来的事务处于阻塞等待状态。这样可以避免了脏读等数据一致性的问题。后来的事务可以操作其他行数据，解决了表锁高并发性能低的问题。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Transaction-A</span></span><br><span class="line">mysql&gt; set autocommit = 0;</span><br><span class="line">mysql&gt; update innodb_lock set v='1001' where id=1;</span><br><span class="line">mysql&gt; commit;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Transaction-B</span></span><br><span class="line">mysql&gt; update innodb_lock set v='2001' where id=2;</span><br><span class="line">Query OK, 1 row affected (0.37 sec)</span><br><span class="line">mysql&gt; update innodb_lock set v='1002' where id=1;  ## 被事务A阻塞</span><br><span class="line">Query OK, 1 row affected (37.51 sec)</span><br></pre></td></tr></table></figure><p>现实：<strong>当执行批量修改数据脚本的时候，行锁升级为表锁</strong>。其他对订单的操作都处于等待中，，，</p><p>原因：<strong>InnoDB只有在通过索引条件检索数据时使用行级锁，否则使用表锁</strong>！ 而模拟操作正是通过id去作为检索条件，而id又是MySQL自动创建的唯一索引，所以才忽略了行锁变表锁的情况</p><p><strong>总结</strong>：<font color="red"><strong>InnoDB的行锁是针对索引加的锁，不是针对记录加的锁。并且该索引不能失效，否则都会从行锁升级为表锁。</strong></font></p><ul><li><p>行锁的劣势<br>开销大；加锁慢；会出现死锁</p></li><li><p>行锁的优势<br>锁的粒度小，发生锁冲突的概率低；处理并发的能力强</p></li><li><p>加锁的方式<br>自动加锁。对于<code>UPDATE</code>、<code>DELETE</code>和<code>INSERT</code>语句，InnoDB会自动给涉及数据集加排他锁；对于普通SELECT语句，InnoDB不会加任何锁；当然我们也可以显示的加锁：</p></li></ul><p>从上面的案例看出，行锁变表锁似乎是一个坑，可MySQL没有这么无聊给你挖坑。这是因为MySQL有自己的执行计划。</p><p>当你需要更新一张较大表的大部分甚至全表的数据时。而你又傻乎乎地用索引作为检索条件。一不小心开启了行锁(没毛病啊！保证数据的一致性！)。可MySQL却认为大量对一张表使用行锁，会导致事务执行效率低，从而可能造成其他事务长时间锁等待和更多的锁冲突问题，性能严重下降。所以MySQL会将行锁升级为表锁，即实际上并没有使用索引。</p><p>我们仔细想想也能理解，既然整张表的大部分数据都要更新数据，在一行一行地加锁效率则更低。其实我们可以通过<code>explain</code>命令查看MySQL的执行计划，你会发现key为null。表明MySQL实际上并没有使用索引，行锁升级为表锁也和上面的结论一致。</p><p>注意：<strong>行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁</strong>。</p><p>行锁根据锁定范围又分为间隙锁、临键锁和记录锁。<br><img src="/images/mysql_lock_partition.jpg" alt></p><h4 id="临健锁"><a href="#临健锁" class="headerlink" title="临健锁"></a>临健锁</h4><p>当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的临键锁（Next-Key锁）。<br><img src="/images/mysql_next_key_lock.jpg" alt></p><p>危害(坑)：若执行的条件是范围过大，则InnoDB会将整个范围内所有的索引键值全部锁定，很容易对性能造成影响。</p><h4 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h4><p><img src="/images/mysql_gap_lock.jpg" alt></p><h4 id="记录锁"><a href="#记录锁" class="headerlink" title="记录锁"></a>记录锁</h4><p><img src="/images/mysql_record_lock.jpg" alt><br>记录锁在锁定非主键索引时，也会一并锁定主键；</p><h3 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h3><p>Innodb 的行锁是在有索引的情况下，没有索引的表是锁定全表的。</p><p>在Innodb引擎中既支持行锁也支持表锁，那么什么时候会锁住整张表，什么时候只锁住一行呢？</p><blockquote><p>只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！</p></blockquote><p>在实际应用中，要特别注意InnoDB行锁的这一特性，不然的话，可能导致大量的锁冲突，从而影响并发性能。</p><p>行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁。</p><p>行级锁的缺点是：<strong>由于需要请求大量的锁资源，所以速度慢，内存消耗大。</strong></p><h3 id="死锁（Deadlock）"><a href="#死锁（Deadlock）" class="headerlink" title="死锁（Deadlock）"></a>死锁（Deadlock）</h3><p>所谓死锁：是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。由于资源占用是互斥的，当某个进程提出申请资源后，使得有关进程在无外力协助下，永远分配不到必需的资源而无法继续运行，这就产生了一种特殊现象死锁。</p><p>解除正在死锁的状态有两种方法：<br><strong>第一种：</strong></p><ul><li><p>1、查询是否锁表  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">OPEN</span> <span class="keyword">TABLES</span> <span class="keyword">where</span> In_use &gt; <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li><li><p>2、查询进程（如果您有SUPER权限，您可以看到所有线程。否则，您只能看到您自己的线程）  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">processlist</span></span><br></pre></td></tr></table></figure></li><li><p>3、杀死进程id（就是上面命令的id列）   </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">kill</span> <span class="keyword">id</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>第二种：</strong></p><ul><li>1、查看当前的事务  </li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> INFORMATION_SCHEMA.INNODB_TRX;</span><br></pre></td></tr></table></figure><ul><li><p>2、查看当前锁定的事务  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> INFORMATION_SCHEMA.INNODB_LOCKS;</span><br></pre></td></tr></table></figure></li><li><p>3、查看当前等锁的事务  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> INFORMATION_SCHEMA.INNODB_LOCK_WAITS;</span><br></pre></td></tr></table></figure></li><li><p>4、杀死进程  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">kill</span> 进程<span class="keyword">ID</span></span><br></pre></td></tr></table></figure></li></ul><p>产生死锁的四个必要条件：</p><ul><li>互斥条件：一个资源每次只能被一个进程使用。</li><li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li><li>不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。</li><li>循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</li></ul><p>如果系统资源充足，进程的资源请求都能够得到满足，死锁出现的可能性就很低，否则就会因争夺有限的资源而陷入死锁。其次，进程运行推进顺序与速度不同，也可能产生死锁。虽然不能完全避免死锁，但可以使死锁的数量减至最少。将死锁减至最少可以增加事务的吞吐量并减少系统开销，因为只有很少的事务回滚，而回滚会取消事务执行的所有工作。由于死锁时回滚的操作由应用程序重新提交。</p><p>下列方法有助于最大限度地降低死锁：</p><ul><li>按同一顺序访问对象。</li><li>避免事务中的用户交互。</li><li>保持事务简短并在一个批处理中。</li><li>使用低隔离级别。</li><li>使用绑定连接。</li></ul><h2 id="MyISAM存储引擎"><a href="#MyISAM存储引擎" class="headerlink" title="MyISAM存储引擎"></a>MyISAM存储引擎</h2><p>InnoDB和MyISAM的最大不同点有两个：</p><ul><li>InnoDB支持事务(transaction)；MyISAM不支持事务</li><li>Innodb默认采用行锁， MyISAM是默认采用表锁。</li></ul><p><strong>MyISAM不适合高并发</strong></p><h3 id="共享读锁"><a href="#共享读锁" class="headerlink" title="共享读锁"></a>共享读锁</h3><p>对MyISAM表的读操作（加读锁），不会阻塞其他进程对同一表的读操作，但会阻塞对同一表的写操作。只有当读锁释放后，才能执行其他进程的写操作。在锁释放前不能读其他表。<br><img src="/images/mysql_myisam_share_lock.jpg" alt></p><h3 id="独占写锁"><a href="#独占写锁" class="headerlink" title="独占写锁"></a>独占写锁</h3><p>对MyISAM表的写操作（加写锁）<strong>，会阻塞其他进程对同一表的读和写操作，只有当写锁释放后，才会执行其他进程的读写操作。</strong>在锁释放前不能写其他表。<br><img src="/images/mysql_myisam_exclusive_lock.jpg" alt></p><p><strong>总结：</strong></p><ul><li><p>表锁，读锁会阻塞写，不会阻塞读。而写锁则会把读写都阻塞。</p></li><li><p>表锁的加锁/解锁方式：MyISAM在执行查询语句(SELECT)前,会<strong>自动给涉及的所有表加读锁</strong>,在执行更新操作 (<code>UPDATE</code>、<code>DELETE</code>、<code>INSERT</code>等)前，会自动给涉及的表加写锁，这个过程并不需要用户干预，因此，用户一般不需要直接用LOCK TABLE命令给MyISAM表显式加锁。</p></li></ul><p>如果用户想要显示的加锁可以使用以下命令：<br><strong>锁定表</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LOCK</span> <span class="keyword">TABLES</span> tbl_name &#123;<span class="keyword">READ</span> | WRITE&#125;,[ tbl_name &#123;<span class="keyword">READ</span> | WRITE&#125;,…]</span><br></pre></td></tr></table></figure><p><strong>解锁表</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UNLOCK</span> <span class="keyword">TABLES</span></span><br></pre></td></tr></table></figure><p>在用 <code>LOCK TABLES</code> 给表显式加表锁时, 必须同时取得所有涉及到表的锁。</p><p>在执行 <code>LOCK TABLES</code> 后，只能访问显式加锁的这些表，不能访问未加锁的表;</p><p><strong>如果加的是读锁，那么只能执行查询操作，而不能执行更新操作。</strong></p><p>在自动加锁的情况下也基本如此，MyISAM 总是一次获得 SQL 语句所需要的全部锁。这也正是 MyISAM 表不会出现死锁(Deadlock Free)的原因。</p><p>对表test_table增加读锁：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LOCK</span> <span class="keyword">TABLES</span> test_table <span class="keyword">READ</span> </span><br><span class="line"><span class="keyword">UNLOCK</span> test_table</span><br></pre></td></tr></table></figure><p>对表test_table增加写锁</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LOCK</span> <span class="keyword">TABLES</span> test_table WRITE</span><br><span class="line"><span class="keyword">UNLOCK</span> test_table</span><br></pre></td></tr></table></figure><p>当使用 <code>LOCK TABLES</code> 时，不仅需要一次锁定用到的所有表,而且,同一个表在 SQL 语句中出现多少次，就要通过与 SQL 语句中相同的别名锁定多少次，否则也会出错！<br>比如如下SQL语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> a.first_name,b.first_name, <span class="keyword">from</span> actor a,actor b <span class="keyword">where</span> a.first_name = b.first_name;</span><br></pre></td></tr></table></figure><p>该Sql语句中，<code>actor</code>表以别名的方式出现了两次，分别是<code>a</code>,<code>b</code>，这时如果要在该Sql执行之前加锁就要使用以下Sql:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lock</span> <span class="keyword">table</span> actor <span class="keyword">as</span> a <span class="keyword">read</span>, actor <span class="keyword">as</span> b <span class="keyword">read</span>;</span><br></pre></td></tr></table></figure><h3 id="并发插入"><a href="#并发插入" class="headerlink" title="并发插入"></a>并发插入</h3><p>上文说到过 MyISAM 表的读和写是串行的, 但这是就总体而言的。在一定条件下,MyISAM表也支持查询和插入操作的并发进行。 MyISAM存储引擎有一个系统变量<code>concurrent_insert</code>,专门用以控制其并发插入的行为,其值分别可以为0、1或2。</p><blockquote><p>0: 不允许并发插入;<br>1: 如果MyISAM表中没有空洞(即表的中间没有被删除的行), MyISAM允许在一个进程读表的同时,另一个进程从表尾插入记录。这也是MySQL 的默认设置;<br>2: 无论MyISAM表中有没有空洞, 都允许在表尾并发插入记录;</p></blockquote><p>可以利用MyISAM存储引擎的并发插入特性,来解决应用中对同一表查询和插入的锁争用。</p><h3 id="MyISAM的锁调度"><a href="#MyISAM的锁调度" class="headerlink" title="MyISAM的锁调度"></a>MyISAM的锁调度</h3><p>MyISAM 存储引擎的读锁和写锁是互斥的，读写操作是串行的。那么，一个进程请求某个 MyISAM 表的读锁，同时另一个进程也请求同一表的写锁，MySQL 如何处理呢?</p><p><strong>答案是<font color="red">写进程</font>先获得锁。</strong></p><p>不仅如此，即使读请求先到锁等待队列，写请求后到，写锁也会插到读锁请求之前！这是因为 MySQL 认为写请求一般比读请求要重要。这也正是 MyISAM 表不太适合于有大量更新操作和查询操作应用的原因，因为大量的更新操作会造成查询操作很难获得读锁，从而可能永远阻塞。这种情况有时可能会变得非常糟糕！</p><p>幸好我们可以通过一些设置来调节 MyISAM 的调度行为。</p><p>通过指定启动参数<code>low-priority-updates</code>，使MyISAM引擎默认给予读请求以优先的权利。</p><ul><li><p>通过执行命令<code>SET LOWPRIORITYUPDATES=1</code>, 使该连接发出的更新请求优先级降低。</p></li><li><p>通过指定<code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>语句的<code>LOW_PRIORITY</code>属性, 降低该语句的优先级。</p></li><li><p>另外, MySQL也供了一种折衷的办法来调节读写冲突, 即给系统参数<code>max_write_lock_count</code> 设置一个合适的值, 当一个表的读锁达到这个值后, MySQL就暂时将写请求的优先级降低, 给读进程一定获得锁的机会。</p></li></ul><p><strong>总结</strong></p><ul><li><p>MySQL的MyISAM引擎支持表级锁。</p></li><li><p>表级锁分为两种：共享读锁、互斥写锁。这两种锁都是阻塞锁。</p></li><li><p>可以在读锁上增加读锁，不能在读锁上增加写锁。在写锁上不能增加写锁。</p></li><li><p>默认情况下，MySql在执行查询语句之前会加读锁，在执行更新语句之前会执行写锁。</p></li><li><p>如果想要显示的加锁/解锁的花可以使用LOCK TABLES和UNLOCK来进行。</p></li><li><p>在使用LOCK TABLES之后，在解锁之前，不能操作未加锁的表。</p></li><li><p>在加锁时，如果显示的指明是要增加读锁，那么在解锁之前，只能进行读操作，不能执行写操作。</p></li><li><p>如果一次Sql语句要操作的表以别名的方式多次出现，那么就要在加锁时都指明要加锁的表的别名。</p></li><li><p>MyISAM存储引擎有一个系统变量<code>concurrent_insert</code>, 专门用以控制其并发插入的行为,其值分别可以为0、1或2。</p></li><li><p>由于读锁和写锁互斥，那么在调度过程中，默认情况下，MySql会本着写锁优先的原则。可以通过<code>low-priority-updates</code>来设置。</p></li></ul><h2 id="利用锁实现事务"><a href="#利用锁实现事务" class="headerlink" title="利用锁实现事务"></a>利用锁实现事务</h2><h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h3><p>修改加上排他锁，那么其他事务就无法读取到正在修改的数据行；<br><img src="/images/mysql_tx_read.png" alt></p><h3 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h3><p>查询加上读锁，则其他事务就无法修改；<br><img src="/images/mysql_tx_repeated_read.jpg" alt></p><h3 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h3><p>范围查询会通过间隙锁使其他事务无法插入范围数据，这不会出现幻读；<br><img src="/images/mysql_tx_huandu.jpg" alt></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.im/post/5b82e0196fb9a019f47d1823#heading-10" target="_blank" rel="noopener">全面了解mysql锁机制（InnoDB）与问题排查</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;总览&quot;&gt;&lt;a href=&quot;#总览&quot; class=&quot;headerlink&quot; title=&quot;总览&quot;&gt;&lt;/a&gt;总览&lt;/h2&gt;&lt;p&gt;MySQL/InnoDB的加锁，一直是一个常见的话题。例如，数据库如果有高并发请求，如何保证数据完整性？产生死锁问题如何排查并解决？下面是不
      
    
    </summary>
    
      <category term="Mysql" scheme="http://yoursite.com/categories/Mysql/"/>
    
      <category term="锁机制" scheme="http://yoursite.com/categories/Mysql/%E9%94%81%E6%9C%BA%E5%88%B6/"/>
    
    
      <category term="Mysql" scheme="http://yoursite.com/tags/Mysql/"/>
    
      <category term="锁" scheme="http://yoursite.com/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>Redis底层数据结构</title>
    <link href="http://yoursite.com/2019/12/20/Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2019/12/20/Redis底层数据结构/</id>
    <published>2019-12-20T11:07:50.000Z</published>
    <updated>2020-01-10T13:01:56.841Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/redis_logo.png" alt></p><h2 id="5种基本数据类型"><a href="#5种基本数据类型" class="headerlink" title="5种基本数据类型"></a>5种基本数据类型</h2><p><img src="/images/redis_five_data_structure.png" alt></p><p>对于每种数据结构，实际上都有自己底层的 <strong>内部编码</strong> 实现，而且是多种实现。这样 Redis 会在合适的 场景 选择合适的 内部编码，如图所示：<br><img src="/images/redis_structure_basic.png" alt></p><p>可以看到，每种 数据结构 都有 两种以上 的 内部编码实现。例如 <code>list</code> 数据结构 包含了 <code>linkedlist</code> 和 <code>ziplist</code> 两种 内部编码。同时有些 内部编码，例如 <code>ziplist</code>，可以作为多种外部数据结构的内部实现，可以通过 <code>object encoding</code> 命令查询内部编码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; object encoding hello</span><br><span class="line">"embstr"</span><br><span class="line">127.0.0.1:6379&gt; object encoding mylist</span><br><span class="line">"quicklist"</span><br></pre></td></tr></table></figure><p>Redis 这样设计有两个好处：</p><ul><li><p>其一：可以改进内部编码，而对外的数据结构和命令没有影响。例如：Redis3.2 提供的 <code>quicklist</code>，结合了 <code>ziplist</code> 和 <code>linkedlist</code> 两者的优势，为 <code>列表类型</code> 提供了一种更加高效的内部编码实现。</p></li><li><p>其二：不同内部编码可以在不同场景下发挥各自的优势。例如 <code>ziplist</code> 比较节省内存，但是在列表元素比较多的情况下，性能会有所下降，这时候Redis会根据配置，将列表类型的内部实现 转换为<code>linkedlist</code>。</p></li></ul><h2 id="String底层结构"><a href="#String底层结构" class="headerlink" title="String底层结构"></a>String底层结构</h2><p>字符串类型是Redis最基础的数据结构。字符串类型的值实际可以是字符串（<strong>简单</strong> 和 <strong>复杂</strong> 的字符串，例如 JSON、XML）、数字（整数、浮点数），甚至是 二进制（图片、音频、视频），但是值最大不能超过 <code>512MB</code>。</p><p>字符串类型的内部编码有 3 种：</p><ul><li><p><strong>int</strong>：8个字节的长整型。</p></li><li><p><strong>embstr</strong>：小于等于39个字节的字符串。</p></li><li><p><strong>raw</strong>：大于39个字节的字符串。</p></li></ul><p>Redis 会根据当前值的 <strong>类型</strong> 和 <strong>长度</strong> 决定使用哪种内部编码实现。</p><h2 id="Hash底层结构"><a href="#Hash底层结构" class="headerlink" title="Hash底层结构"></a>Hash底层结构</h2><p>大部分编程语言都提供了哈希（hash）类型，它们的叫法可能是 <strong>哈希</strong>、<strong>字典</strong>、<strong>关联数组</strong>。在 Redis 中，哈希类型是指键值本身又是一个键值对结构。</p><h3 id="压缩列表-ziplist"><a href="#压缩列表-ziplist" class="headerlink" title="压缩列表(ziplist)"></a>压缩列表(ziplist)</h3><p>当哈希类型元素个数 小于 <code>hash-max-ziplist-entries</code> 配置（默认 512 个）、同时所有值都小于 <code>hash-max-ziplist-value</code> 配置（默认 64 字节）时，Redis会使用<code>ziplist</code> 作为哈希的内部实现，<code>ziplist</code>使用<strong>更加紧凑的结构实现多个元素的连续存储</strong>，所以在节省内存方面比<code>hashtable</code>更加优秀.</p><h3 id="哈希表-hashtable"><a href="#哈希表-hashtable" class="headerlink" title="哈希表(hashtable)"></a>哈希表(hashtable)</h3><p>当哈希类型无法满足 <code>ziplist</code> 的条件时，Redis会使用<code>hashtable</code>作为哈希的内部实现，因为此时 <code>ziplist</code> 的 <strong>读写效率</strong> 会下降，而 <code>hashtable</code> 的读写时间复杂度为 O(1)。</p><p>下面的示例演示了哈希类型的内部编码，以及相应的变化。</p><p>当field个数比较少，且没有大的value时，内部编码为<code>ziplist</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hmset hashkey f1 v1 f2 v2</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; object encoding hashkey</span><br><span class="line">"ziplist"</span><br></pre></td></tr></table></figure><p>当有value大于64字节时，内部编码会由 <code>ziplist</code> 变为 <code>hashtable</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hset hashkey f3 "one string is bigger than 64 byte...忽略..."</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; object encoding hashkey</span><br><span class="line">"hashtable"</span><br></pre></td></tr></table></figure><p>当field个数超过 512，内部编码也会由 <code>ziplist</code> 变为<code>hashtable</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hmset hashkey f1 v1 f2 v2 f3 v3 ... f513 v513</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; object encoding hashkey</span><br><span class="line">"hashtable"</span><br></pre></td></tr></table></figure><h2 id="List底层结构"><a href="#List底层结构" class="headerlink" title="List底层结构"></a>List底层结构</h2><p>列表（list）类型是用来存储多个有序的字符串。在Redis中，可以对列表的<strong>两端</strong>进行 <strong>插入</strong>（push）和 <strong>弹出</strong>（pop）操作，还可以获取 <strong>指定范围</strong> 的 <strong>元素列表</strong>、获取 <strong>指定索引下标</strong> 的 <strong>元素</strong> 等， 一个列表最多可以存储 <code>2^32 - 1</code> 个元素。</p><p>列表是一种比较灵活的数据结构，它可以充当 <strong>栈</strong> 和 <strong>队列</strong> 的角色，在实际开发上有很多应用场景。</p><p>列表类型的内部编码有两种：</p><ul><li><p><strong>ziplist</strong>（压缩列表）<br>当列表的元素个数小于 <code>list-max-ziplist-entries</code> 配置（默认 <code>512</code> 个），同时列表中 每个元素的值都小于  <code>list-max-ziplist-value</code> 配置时（默认 <code>64字节</code>），Redis会选用 <code>ziplist</code>来作为列表的内部实现来减少内存的使用。</p></li><li><p><strong>linkedlist</strong>（链表）<br>当列表类型无法满足<code>ziplist</code>的条件时， Redis会使用 <code>linkedlist</code> 作为列表的内部实现。</p></li></ul><h2 id="Set底层结构"><a href="#Set底层结构" class="headerlink" title="Set底层结构"></a>Set底层结构</h2><p>集合（set）类型也是用来保存多个字符串元素，但和列表类型不一样的是，<strong>集合中不允许有重复元素，并且集合中的元素是无序的，不能通过索引下标获取元素</strong>， 一个集合最多可以存储 <code>2^32 - 1</code> 个元素。</p><p>集合类型的内部编码有两种：</p><ul><li><strong>intset</strong>（整数集合）<br>当集合中的元素都是整数且元素个数小于 <code>set-max-intset-entries</code> 配置（默认 <code>512个</code>）时，Redis会选用 <code>intset</code> 来作为集合的内部实现，从而减少内存的使用。</li></ul><ul><li><strong>hashtable</strong>（哈希表）<br>当集合类型无法满足<code>intset</code>的条件时，Redis会使用<code>hashtable</code>作为集合的内部实现。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.im/post/5b76e732f265da4376203849" target="_blank" rel="noopener">深入剖析Redis系列(一) - Redis入门简介与主从搭建</a></p><p><a href="https://juejin.im/post/5b7d226a6fb9a01a1e01ff64#heading-7" target="_blank" rel="noopener">深入剖析Redis系列(二) - Redis哨兵模式与高可用集群</a></p><p><a href="https://juejin.im/post/5b8fc5536fb9a05d2d01fb11" target="_blank" rel="noopener">深入剖析Redis系列(三) - Redis集群模式搭建与原理详解</a></p><p><a href="https://juejin.im/post/5bb01064e51d453eb93d8028" target="_blank" rel="noopener">深入剖析Redis系列(四) - Redis数据结构与全局命令概述</a></p><p><a href="https://juejin.im/post/5bbc9d03f265da0ab915e3b5" target="_blank" rel="noopener">深入剖析Redis系列(五) - Redis数据结构之字符串</a></p><p><a href="https://juejin.im/post/5bcb3b066fb9a05d1c14c712" target="_blank" rel="noopener">深入剖析Redis系列(七) - Redis数据结构之列表</a></p><p><a href="https://juejin.im/post/5be455d75188250e8601b3e0#heading-23" target="_blank" rel="noopener">深入剖析Redis系列(八) - Redis数据结构之集合</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/redis_logo.png&quot; alt&gt;&lt;/p&gt;
&lt;h2 id=&quot;5种基本数据类型&quot;&gt;&lt;a href=&quot;#5种基本数据类型&quot; class=&quot;headerlink&quot; title=&quot;5种基本数据类型&quot;&gt;&lt;/a&gt;5种基本数据类型&lt;/h2&gt;&lt;p&gt;
      
    
    </summary>
    
      <category term="中间件" scheme="http://yoursite.com/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
      <category term="Redis" scheme="http://yoursite.com/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
      <category term="原理" scheme="http://yoursite.com/tags/%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>TCP TIME_WAIT状态</title>
    <link href="http://yoursite.com/2019/12/18/TCP-TIME-WAIT%E7%8A%B6%E6%80%81/"/>
    <id>http://yoursite.com/2019/12/18/TCP-TIME-WAIT状态/</id>
    <published>2019-12-18T10:57:17.000Z</published>
    <updated>2020-01-10T13:01:56.863Z</updated>
    
    <content type="html"><![CDATA[<p><strong>TIME_WAIT</strong>状态是TCP连接中<strong>主动关闭连接</strong>的一方会进入的状态，在发出最后一个ACK包之后，主动关闭方进入<strong>TIME_WAIT</strong>状态，从而确保:</p><ul><li>ACK包到达对端</li><li>等待网络中之前迷路的数据包完全消失，防止端口被复用的时候收到迷路包从而出现收包错误</li></ul><p><strong>TIME_WAIT</strong>状态会持续<strong>2MSL</strong>（max segment lifetime）的时间，一般1分钟到4分钟。在这段时间内端口不能被重新分配使用。</p><p><strong>TIME_WAIT</strong>并不会占用过多的系统资源，但是可以通过修改内核参数<code>/etc/sysctl.conf</code>来限制<strong>TIME_WAIT</strong>数量。</p><h3 id="四次挥手过程"><a href="#四次挥手过程" class="headerlink" title="四次挥手过程"></a>四次挥手过程</h3><p>先来了解TCP四次挥手的过程：</p><p><img src="/images/tcp_ip_3_handshake.png" alt></p><ul><li><p>第一次：主机 1（可以是客户端，也可以是服务器端），设置 <strong>Sequence Number</strong> 和 <strong>Acknowledgment Number</strong>，向主机 2 发送一个 <strong>FIN</strong> 报文段；此时，主机1进入 <strong>FIN_WAIT_1</strong> 状态；这表示主机 1 没有数据要发送给主机 2 了； </p></li><li><p>第二次：主机 2 收到了主机 1 发送的 <strong>FIN</strong> 报文段，向主机 1 回一个 <strong>ACK</strong> 报文段，<strong>Acknowledgment Number</strong> 为 <strong>Sequence Number</strong> 加 1 ；主机 1 进入 <strong>FIN_WAIT_2</strong> 状态；主机 2 告诉主机 1，我“同意”你的关闭请求；</p></li><li><p>第三次：主机 2 向主机 1 发送FIN报文段，请求关闭连接，同时主机 2 进入<strong>LAST_ACK</strong> 状态；</p></li><li><p>第四次：主机 1 收到主机 2 发送的 <strong>FIN报文段</strong>，向主机2发送 <strong>ACK</strong> 报文段，然后主机1进入 <strong>TIME_WAIT</strong> 状态；主机 2 收到主机 1 的<strong>ACK</strong>报文段以后，就关闭连接；此时，主机1等待 <strong>2 * MSL</strong> 后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。</p></li></ul><p><strong>注：</strong> <strong>MSL</strong>是指<code>Max Segment Lifetime</code>，即<strong>一个IP数据包能在网络中生存的最长时间</strong>，超过这个时间，IP数据包将在网络中消失。每种TCP协议的实现方法均要指定一个合适的MSL值，如RFC1122给出的建议值为2分钟，又如Berkeley体系的TCP实现通常选择30秒作为MSL值。这意味着<strong>TIME_WAIT</strong>的典型持续时间为<code>1-4</code>分钟。</p><h3 id="TCP四次挥手过程中通信双方状态解析"><a href="#TCP四次挥手过程中通信双方状态解析" class="headerlink" title="TCP四次挥手过程中通信双方状态解析"></a>TCP四次挥手过程中通信双方状态解析</h3><ul><li><p><strong>FIN_WAIT_1</strong><br>其实<strong>FIN_WAIT_1</strong>和<strong>FIN_WAIT_2</strong>状态的真正含义都是表示等待对方的<strong>FIN</strong>报文。而这两种状态的区别是：</p><ul><li><strong>FIN_WAIT_1</strong>状态实际上是当<strong>SOCKET</strong>在<strong>ESTABLISHED</strong>状态时，它想主动关闭连接，向对方发送了<strong>FIN</strong>报文，此时该<strong>SOCKET</strong>即进入到<strong>FIN_WAIT_1</strong>状态。而当对方回应ACK报文后，则进入到<strong>FIN_WAIT_2</strong>状态，当然在实际的正常情况下，无论对方何种情况下，都应该马上回应ACK报文，所以<strong>FIN_WAIT_1状态一般是比较难见到的</strong>，而<strong>FIN_WAIT_2</strong>状态还有时常常可以用<strong>netstat</strong>看到。（主动方）</li></ul></li><li><p><strong>FIN_WAIT_2</strong><br>实际上<strong>FIN_WAIT_2</strong>状态下的<strong>SOCKET</strong>，表示<strong>半连接</strong>，也即有一方要求close连接，但另外还告诉对方，我暂时还有点数据需要传送给你(ACK信息)，稍后再关闭连接。（主动方）</p></li><li><p><strong>CLOSE_WAIT</strong><br>表示在等待关闭。当对方<strong>close</strong>一个<strong>SOCKET</strong>后发送<strong>FIN</strong>报文给你，你自然会回应一个<strong>ACK</strong>报文给对方，此时则进入到<strong>CLOSE_WAIT</strong>状态。接下来呢，实际上你真正需要考虑的事情是察看你是否还有数据发送给对方，如果没有的话，那么你也就可以 <strong>close</strong>这个<strong>SOCKET</strong>，发送<strong>FIN</strong>报文给对方，也即关闭连接。所以你在<strong>CLOSE_WAIT</strong>状态下，需要完成的事情是等待你去关闭连接。（被动方）</p></li><li><p><strong>LAST_ACK</strong><br>被动关闭一方在发送<strong>FIN</strong>报文后，最后等待对方的<strong>ACK</strong>报文。当收到ACK报文后，也即可以进入到<strong>CLOSED</strong>状态了。（被动方）</p></li><li><p><strong>TIME_WAIT</strong><br>表示收到了对方的<strong>FIN</strong>报文，并发送出了<strong>ACK</strong>报文，就等<strong>2MSL</strong>后即可回到<strong>CLOSED</strong>状态了。如果<strong>FIN</strong> WAIT1状态下，收到了对方同时带<strong>FIN</strong>标志和<strong>ACK</strong>标志的报文时，可以直接进入到<strong>TIME_WAIT</strong>状态，而无须经过<strong>FIN_WAIT_2</strong>状态。（主动方）</p></li><li><p><strong>CLOSED</strong><br>表示SOCKET连接已中断</p></li></ul><h3 id="为什么会有TIME-WAIT状态"><a href="#为什么会有TIME-WAIT状态" class="headerlink" title="为什么会有TIME_WAIT状态"></a>为什么会有TIME_WAIT状态</h3><ul><li><p><strong>可靠地实现TCP全双工连接的可靠终止</strong><br>TCP协议在关闭连接的四次握手过程中，<strong>最终ACK是由主动关闭连接的一端发出的</strong>，如果这个<strong>ACK</strong>丢失，被动方将重发最终的<strong>FIN</strong>，因此主机1就必须维护状态信息<strong>TIME_WAIT</strong> 允许它发送最终的ACK。如果主机1不维持<strong>TIME_WAIT</strong>的状态，而是处于<strong>CLOSED</strong>状态，那么主机1将响应<strong>RST</strong>（reset）数据包，主机2收到后将此数据报解释成一个异常（Java中会抛出<code>connection reset</code>的SocketException）。因而，要实现TCP全双工连接的正常终止，必须处理终止过程中四个数据包任何一个分节丢失的情况，主动关闭连接的主机1必须维持TIME_WAIT的状态。</p></li><li><p><strong>保证此次连接的重复数据段从网络中消失</strong><br>TCP数据包可能由于路由器异常而“迷路”，在“迷路”期间，TCP发送端可能因确认超时而重发这个分节，“迷路”的分节在路由器恢复正常后也会被发送到最终的目的地，这个迟到的“迷路”数据包到达时可能会引起问题。在关闭“前一个连接”之后，马上又建立起一个相同的IP和端口之间的“新连接”，这会导致“前一个连接”的迷路重复分组在“前一个连接”终止后到达，从而被“新连接”接收到了。</p><p>  为了避免以上情况，TCP/IP协议不允许处于TIME_WAIT状态的连接启动一个新的可用连接，因为TIME_WAIT状态持续2MSL，这就可以<strong>保证当成功建立一个新TCP连接的时候，来自旧连接重复分组已经在网络中消失</strong>。</p></li></ul><h3 id="出现太多TIME-WAIT危害"><a href="#出现太多TIME-WAIT危害" class="headerlink" title="出现太多TIME_WAIT危害"></a>出现太多TIME_WAIT危害</h3><blockquote><p>在<strong>高并发短连接的TCP服务器</strong>上，当服务器处理完请求后会立刻按照主动正常关闭连接。这个场景下，会出现大量socket处于<strong>TIMEWAIT</strong>状态。如果客户端的并发量持续很高，此时部分客户端就会显示连接不上。</p></blockquote><p>解释下这个场景。主动正常关闭TCP连接，都会出现<strong>TIMEWAIT</strong>。为什么我们要关注这个高并发短连接呢？有两个方面需要注意：</p><ul><li><p>① 高并发可以让服务器在短时间范围内同时占用大量端口，而端口有个0~65535的范围，并不是很多，刨除系统和其他服务要用的，剩下的就更少了。</p></li><li><p>② 在这个场景中，短连接表示“业务处理+传输数据的时间 远远小于 <strong>TIMEWAIT</strong>超时的时间”的连接。 这里有个相对长短的概念，比如，取一个web页面，1秒钟的http短连接处理完业务，在关闭连接之后，这个业务用过的端口会停留在<strong>TIMEWAIT</strong>状态几分钟，而这几分钟，其他HTTP请求来临的时候是无法占用此端口的。单用这个业务计算服务器的利用率会发现，服务器干正经事的时间和端口（资源）被挂着无法被使用的时间的比例是 <code>1 ：几百</code>，服务器资源严重浪费。</p></li></ul><p>说个题外话，从这个意义出发来考虑服务器性能调优的话，长连接业务的服务就不需要考虑<strong>TIMEWAIT</strong>状态。同时，假如你对服务器业务场景非常熟悉，你会发现，在实际业务场景中，一般长连接对应的业务的并发量并不会很高.</p><p>综合这两个方面，<strong>持续的到达一定量的高并发短连接，会使服务器因端口资源不足而拒绝为一部分客户服务</strong>。</p><h3 id="TIME-WAIT太多怎么解决"><a href="#TIME-WAIT太多怎么解决" class="headerlink" title="TIME_WAIT太多怎么解决"></a>TIME_WAIT太多怎么解决</h3><p>修改<code>/etc/sysctl.conf</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 表示开启重用</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭；</span></span><br><span class="line">net.ipv4.tcp_tw_reuse = 1  </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> net.ipv4.tcp_timestamps 开启时，net.ipv4.tcp_tw_recycle开启才能生效</span></span><br><span class="line">net.ipv4.tcp_tw_recycle = 1 </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭</span></span><br><span class="line">net.ipv4.tcp_timestamps = 1     </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 用来设置保持在FIN_WAIT_2状态的时间</span></span><br><span class="line">net.ipv4.tcp_fin_timeout = 2</span><br></pre></td></tr></table></figure><p>保存后<code>sysctl -p</code>生效</p><h3 id="地址reuse问题"><a href="#地址reuse问题" class="headerlink" title="地址reuse问题"></a>地址reuse问题</h3><p>在写一个unix server程序时，经常需要在命令行重启它，绝大多数时候工作正常，但是某些时候会抛出异常 <code>bind: address already in use</code>，于是重启失败。</p><p>上面这个就是地址reuse问题，就是由于<strong>TIME_WAIT</strong>状态产生的，我们有以下方案来解决这个问题：</p><h4 id="SO-REUSEADDR"><a href="#SO-REUSEADDR" class="headerlink" title="SO_REUSEADDR"></a>SO_REUSEADDR</h4><p>这个socket选项通知内核：<strong>如果端口忙，但TCP状态位于TIME_WAIT，可以重用端口</strong>。</p><blockquote><p>一个socket由相关五元组构成: <strong>协议、本地地址、本地端口、远程地址、远程端口</strong>。<strong>SO_REUSEADDR仅仅表示可以重用本地本地地址、本地端口，整个相关五元组还是唯一确定的</strong>。所以，重启后的服务程序有可能收到非期望数据。必须慎重使用SO_REUSEADDR选项。</p></blockquote><p><strong>一般来说，一个端口释放后会等待两分钟之后才能再被使用，SO_REUSEADDR是让端口释放后立即就可以被再次使用。</strong></p><p><strong>SO_REUSEADDR</strong>用于对TCP处于<strong>TIME_WAIT</strong>状态下的socket，才可以重复绑定使用。server程序总是应该在调用bind()之前设置SO_REUSEADDR选项。先调用close()的一方会进入TIME_WAIT状态。</p><p>SO_REUSEADDR允许启动一个监听服务器并捆绑其众所周知端口，即使以前建立的将此端口用做他们的本地端口的连接仍存在。这通常是重启监听服务器时出现，若不设置此选项，则bind时将出错。</p><h4 id="SO-LINGER"><a href="#SO-LINGER" class="headerlink" title="SO_LINGER"></a>SO_LINGER</h4><p>Linux网络编程中，socket的选项很多。其中几个比较重要的选项就包括SO_LINGER。</p><p>在默认情况下,当调用close()关闭socket的使用，close()会立即返回,但是,如果<code>send buffer</code>中还有数据，系统会试着先把<code>send buffer</code>中的数据发送出去，SO_LINGER选项则是用来修改这种默认操作的。</p><p>SO_LINGER是一个socket选项，可以通过<code>set sockopt API</code>进行设置，使用起来比较简单，但其实现机制比较复杂，且字面意思上比较难理解。SO_LINGER的值用如下数据结构表示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">linger</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l_onoff <span class="comment">//0 = off, nonzero = on(开关)</span></span><br><span class="line">    <span class="keyword">int</span> l_linger <span class="comment">//linger time(延迟时间)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其取值和处理如下：</p><ul><li><p>设置 l_onoff 为0，则该选项关闭，l_linger的值被忽略，等于内核缺省情况，close()调用会立即返回给调用者，如果可能将会传输任何未发送的数据；</p></li><li><p>设置 l_onoff 为非0，l_linger为0，当调用close()的时候,TCP连接会立即断开。send buffer中未被发送的数据将被丢弃，并向对方发送一个RST信息。值得注意的是，由于这种方式，不是以4次握手方式结束TCP连接，所以，TCP连接将不会进入TIME_WAIT状态，这样会导致新建立的可能和旧连接的数据造成混乱。这种关闭方式称为“强制”或“失效”关闭。通常会看到 <code>Connection reset by peer</code> 之类的错误；</p></li><li><p>设置 l_onoff 为非0，l_linger为非0，在这种情况下，会使得close()返回得到延迟。调用close()去关闭socket的时候，内核将会延迟。也就是说，如果send buffer中还有数据尚未发送，该进程将会被休眠直到一下任何一种情况发生：</p><blockquote><p>a. send buffer中的所有数据都被发送并且得到对方TCP的应答消息；</p><p>b.延迟时间消耗完。在延迟时间被消耗完之后，send buffer中的所有数据都将会被丢弃。这种关闭称为“优雅的”关闭。</p></blockquote></li></ul><p>因此，<strong>在正常情况下，在socket调用close()之前设置SO_LINGER超时为0都不是个好的选择</strong>。但也有些情况下需要使用SO_LINGER：</p><ul><li><p>如果server返回无效数据或者超时时，<strong>SO_LINGER有助于避免卡在CLOSE_WAIT或TIME_WAIT的状态</strong>；</p></li><li><p>如果必须启动有数千个客户端连接的app，则可以考虑设置SO_LINGER，从而<strong>避免数千个socket处于TIME_WAIT状态，从而减少可用端口在服务重启后，新客户端连接受到的影响</strong>；</p></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过上面的讨论，我们知道<strong>TIME_WAIT</strong>状态是友好的，并不是多余的。TCP要保证在所有可能的情况下使得所有的数据都能够正确送达。当你关闭一个socket时，主动关闭一端的socket将进入TIME_WAIT状态，而被动关闭的一方则进入CLOSED状态，这的确能够保证所有的数据都被传送。</p><p>当一个socket关闭的时候，是通过两端四次挥手完成的，当一端调用close()时，就说明本端没有数据要传送了，这好像看来在挥手完成以后，socket就可以处于CLOSED状态了，其实不然，原因是这样安排状态有两个问题：</p><ul><li>第一，我们没有任何机制保证最后的一个ACK能够正常传输；</li><li>第二，网络仍然可能有残余的数据包，我们也必须能够正常处理。</li></ul><p>TIME_WAIT状态就是为了解决这两个问题而生的。服务端为了解决这个TIME_WAIT问题，可选的方式有3种：</p><ul><li>保证由客户端主动发起关闭</li><li>关闭的时候使用RST方式（set SO_LINGER）</li><li>对处于TIME_WAIT状态的TPC允许重用（set SO_REUSEADDR）</li></ul><p>参考：<br><a href="https://blog.yangx.site/2018/07/03/tcp-ip-time-wait/" target="_blank" rel="noopener">TCP/IP中TIME_WAIT状态详解</a><br><a href="https://blog.51cto.com/11859650/1917938" target="_blank" rel="noopener">TCP——-为什么会有TIME_WAIT状态 ?</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;TIME_WAIT&lt;/strong&gt;状态是TCP连接中&lt;strong&gt;主动关闭连接&lt;/strong&gt;的一方会进入的状态，在发出最后一个ACK包之后，主动关闭方进入&lt;strong&gt;TIME_WAIT&lt;/strong&gt;状态，从而确保:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
      
    
    </summary>
    
      <category term="网络" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="Tcp" scheme="http://yoursite.com/tags/Tcp/"/>
    
      <category term="Http" scheme="http://yoursite.com/tags/Http/"/>
    
  </entry>
  
  <entry>
    <title>JVM基础 - 入门篇</title>
    <link href="http://yoursite.com/2019/12/13/JVM%E5%9F%BA%E7%A1%80-%E5%85%A5%E9%97%A8%E7%AF%87/"/>
    <id>http://yoursite.com/2019/12/13/JVM基础-入门篇/</id>
    <published>2019-12-13T08:15:47.000Z</published>
    <updated>2019-12-20T11:07:55.179Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JDK体系结构"><a href="#JDK体系结构" class="headerlink" title="JDK体系结构"></a>JDK体系结构</h1><p><img src="/images/jdk_structure.jpg" alt></p><h1 id="JVM内存模型"><a href="#JVM内存模型" class="headerlink" title="JVM内存模型"></a>JVM内存模型</h1><p>一张图描述JVM内存模型<br><img src="/images/jvm_structure.png" alt></p><p>JVM包括两个子系统和两个组件：</p><h2 id="两个子系统"><a href="#两个子系统" class="headerlink" title="两个子系统"></a>两个子系统</h2><ul><li><p><strong>ClassLoader（类装载）</strong><br>根据给定的全限定名类名(如：java.lang.Object)来装载 class文件 到 <strong>运行时数据区</strong> 中的 <strong>方法区</strong>。程序中可以继承 <code>java.lang.ClassLoader</code> 类来实现自己的ClassLoader。</p></li><li><p><strong>ExecutionEngine（执行引擎）</strong><br>执行classes中的指令。任何JVM <code>specification</code>实现(JDK)的核心都是Execution engine，不同的JDK例如Sun的JDK和IBM的JDK好坏主要就取决于他们各自实现的Execution engine的好坏。</p></li></ul><h2 id="两个组件"><a href="#两个组件" class="headerlink" title="两个组件"></a>两个组件</h2><ul><li><p><strong>Native Interface(本地接口)</strong><br>与native libraries交互，是其它编程语言交互的接口。当调用native方法的时候，就进入了一个全新的并且不再受虚拟机限制的世界，所以也很容易出现JVM无法控制的native heap OutOfMemory。</p></li><li><p><strong>Runtime Data Area（运行时数据区）</strong><br>这就是我们常说的JVM的内存。主要分为五个部分：</p><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>有时候也成为<strong>永久代</strong>，该区域是被<strong>线程共享</strong>的。</p></li><li><p>作用<br>方法区主要用来存储已被虚拟机加载的<strong>类的信息</strong>、<strong>常量</strong>、<strong>静态变量</strong> 和 <strong>即时编译器(JIT)编译后的代码</strong> 等数据.</p></li><li><p>GC<br>在该区内很少发生垃圾回收，但是并不代表不发生GC，在这里进行的GC主要是 <strong>对方法区里的常量池和对类型的卸载</strong>，但<strong>回收效率很低</strong>，当方法区无法满足内存需求时，会报 <strong>OOM</strong> 异常；</p></li></ul><p>方法区里有一个<strong>运行时常量池</strong>，用于存放<strong>静态编译产生的字面量和符号引用</strong>。该常量池具有动态性，也就是说常量并不一定是编译时确定，<strong>运行时生成的常量也会存在这个常量池</strong>中。</p><blockquote><p><strong>方法区和元数据区是不同jdk版本对JVM协议的不同实现；</strong></p></blockquote><h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><p>虚拟机栈也就是我们平常所称的栈内存, 它为java方法服务，每个方法在执行的时候都会创建一个栈帧，用于存储<strong>局部变量表</strong>、<strong>操作数栈</strong>、<strong>动态链接</strong> 和 <strong>方法出口</strong>等信息。<br><img src="/images/jvm_thread_stack.png" alt="-w728"></p><ul><li><p><strong>虚拟机栈</strong><br>是线程私有的，它的<strong>生命周期与线程相同</strong>。每个方法从调用到执行过程，就对应着栈桢在虚拟机栈中从入栈到出栈的过程。</p></li><li><p><strong>栈桢</strong><br>虚拟机栈由多个栈桢（Stack Frame）组成。一个线程会执行一个或多个方法，一个方法对应一个栈桢。</p></li><li><p><strong>局部变量表</strong><br>局部变量表里存储的是<strong>基本数据类型</strong>、<strong>returnAddress类型</strong>（指向一条字节码指令的地址）和<strong>对象引用</strong>，这个对象引用有可能是指向对象起始地址的一个指针，也有可能是代表对象的句柄或者与对象相关联的位置。<strong>局部变量所需的内存空间在编译器间确定</strong>。</p></li><li><p><strong>操作数栈</strong><br>操作数栈的作用主要用来<strong>存储运算结果以及运算的操作数</strong>，它不同于局部变量表通过索引来访问，而是<strong>压栈和出栈的方式</strong></p></li></ul><p>每个栈帧都包含一个指向运行时常量池中<strong>该栈帧所属方法的引用</strong>，持有这个引用是为了<strong>支持方法调用过程中的动态连接</strong>. 动态链接就是<strong>将常量池中的符号引用在运行期转化为直接引用</strong>。</p><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>本地方法栈和虚拟机栈类似，虚拟机栈是为虚拟机执行Java方法而准备的，而本地方法栈为虚拟机执行Native本地方法而准备的。</p><h3 id="堆（Heap）"><a href="#堆（Heap）" class="headerlink" title="堆（Heap）"></a>堆（Heap）</h3><p>Java堆是所有线程所共享的一块内存。</p><p>在虚拟机启动时创建，几乎所有的对象实例、数组都在这里存放，对于大多数应用来说，堆是JVM管理的内存中最大的一块区域，也是最容易发生OOM的区域，因此该区域经常发生垃圾回收操作。</p><p>大多数JVM都会将堆实现为大小可扩展的，通过-Xmx、-Xms等参数控制。</p><p><img src="/images/eden_survior.jpg" alt></p><p>新生的对象默认放在Eden区, Eden区满了会触发minor GC/yong GC;</p><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>占用内存空间小，字节码解释器工作时通过改变这个计数值可以<strong>选取下一条需要执行的字节码指令</strong>，<strong>分支、循环、跳转、异常处理和线程恢复</strong>等功能都需要依赖这个计数器完成。该内存区域是唯一一个java虚拟机规范没有规定任何OOM情况的区域。</p><h1 id="JVM内存快照示例"><a href="#JVM内存快照示例" class="headerlink" title="JVM内存快照示例"></a>JVM内存快照示例</h1><p>基于上述原理，现在写一个简单的代码来举例描述下具体各个区域是怎么分配的。</p><blockquote><p>Math.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Math</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> initData = <span class="number">666</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> c = (a + b) * <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Math math = <span class="keyword">new</span> Math();</span><br><span class="line">        <span class="keyword">int</span> result = math.compute();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>javap是jdk自带的一个工具在jdk安装目录的/bin下面可以找到，可以对代码反编译，也可以查看java编译器生成的字节码，对代码的执行过程进行分析，了解jvm内部的工作。</p></blockquote><p>通过以下指令可以得到Java字节码指令：</p><blockquote><p>javac Math.java<br>javap -c Math.class &gt; Math.txt</p></blockquote><p>Math.txt(为了便于编译，Math.txt中去掉了User相关内容)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">Compiled from <span class="string">"Math.java"</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Math</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> initData;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> User user  = <span class="keyword">new</span> User();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Math</span><span class="params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       1: invokespecial #1     // Method java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compute</span><span class="params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: iconst_1</span><br><span class="line">       <span class="number">1</span>: istore_1</span><br><span class="line">       <span class="number">2</span>: iconst_2</span><br><span class="line">       <span class="number">3</span>: istore_2</span><br><span class="line">       <span class="number">4</span>: iload_1</span><br><span class="line">       <span class="number">5</span>: iload_2</span><br><span class="line">       <span class="number">6</span>: iadd</span><br><span class="line">       <span class="number">7</span>: bipush        <span class="number">10</span>  </span><br><span class="line">       <span class="number">9</span>: imul</span><br><span class="line">      <span class="number">10</span>: istore_3</span><br><span class="line">      <span class="number">11</span>: iload_3</span><br><span class="line">      <span class="number">12</span>: ireturn</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       0: new           #2      // class Math</span><br><span class="line">       <span class="number">3</span>: dup </span><br><span class="line">       4: invokespecial #3      // Method "&lt;init&gt;":()V</span><br><span class="line">       <span class="number">7</span>: astore_1</span><br><span class="line">       <span class="number">8</span>: aload_1</span><br><span class="line">       9: invokevirtual #4      // Method compute:()I</span><br><span class="line">      <span class="number">12</span>: istore_2</span><br><span class="line">      13: getstatic     #5      // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">      <span class="number">16</span>: iload_2</span><br><span class="line">      17: invokevirtual #6      // Method java/io/PrintStream.println:(I)V</span><br><span class="line">      <span class="number">20</span>: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过查询<a href="https://gist.github.com/pwxcoo/d8b321c24ccf031c3ee94ff36bc857d4" target="_blank" rel="noopener">javap 字节码指令集</a>，可以看到每一步操作:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">栈和局部变量操作 </span><br><span class="line">将常量压入栈的指令 </span><br><span class="line">aconst_null 将<span class="keyword">null</span>对象引用压入栈 </span><br><span class="line">iconst_m1 将<span class="keyword">int</span>类型常量-<span class="number">1</span>压入栈 </span><br><span class="line">iconst_0 将<span class="keyword">int</span>类型常量<span class="number">0</span>压入栈 </span><br><span class="line">iconst_1 将<span class="keyword">int</span>类型常量<span class="number">1</span>压入栈 </span><br><span class="line">iconst_2 将<span class="keyword">int</span>类型常量<span class="number">2</span>压入栈 </span><br><span class="line">iconst_3 将<span class="keyword">int</span>类型常量<span class="number">3</span>压入栈 </span><br><span class="line">iconst_4 将<span class="keyword">int</span>类型常量<span class="number">4</span>压入栈 </span><br><span class="line">iconst_5 将<span class="keyword">int</span>类型常量<span class="number">5</span>压入栈 </span><br><span class="line">lconst_0 将<span class="keyword">long</span>类型常量<span class="number">0</span>压入栈 </span><br><span class="line">lconst_1 将<span class="keyword">long</span>类型常量<span class="number">1</span>压入栈 </span><br><span class="line">fconst_0 将<span class="keyword">float</span>类型常量<span class="number">0</span>压入栈 </span><br><span class="line">fconst_1 将<span class="keyword">float</span>类型常量<span class="number">1</span>压入栈 </span><br><span class="line">dconst_0 将<span class="keyword">double</span>类型常量<span class="number">0</span>压入栈 </span><br><span class="line">dconst_1 将<span class="keyword">double</span>类型常量<span class="number">1</span>压入栈 </span><br><span class="line">bipush 将一个<span class="number">8</span>位带符号整数压入栈 </span><br><span class="line">sipush 将<span class="number">16</span>位带符号整数压入栈 </span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>此时内存区域如下图所示：</p><p><img src="/images/jvm_math_snapshot.png" alt></p><h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><p><strong>Minor GC和Full GC区别</strong></p><ul><li>Minor GC/Young GC: 指新生代发生的垃圾收集动作，Minor GC非常频繁，回收速度一般比较快；</li><li>Major GC/Full GC: 一般会回收老年代，年轻代，方法区（永久区）的垃圾，Major GC的速度一般会比Minor GC慢10倍以上。</li></ul><h2 id="什么时候回收"><a href="#什么时候回收" class="headerlink" title="什么时候回收"></a>什么时候回收</h2><ul><li><p>Minor GC触发条件<br>当Eden区满时，触发Minor GC。</p></li><li><p>Full GC触发条件</p><ul><li><p>（1）调用System.gc时，系统建议执行Full GC，但是不必然执行</p></li><li><p>（2）老年代空间不足</p></li><li><p>（3）方法区空间不足</p></li><li><p>（4）通过Minor GC后进入老年代的平均大小大于老年代的可用内存</p></li><li><p>（5）由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小、</p><h2 id="怎么回收"><a href="#怎么回收" class="headerlink" title="怎么回收"></a>怎么回收</h2><p>从GC的底层机制可以看出，对于可以搜索到的对象进行复制操作，对于搜索不到的对象，<strong>调用finalize()方法进行释放</strong>。</p></li></ul></li></ul><p>具体过程：当GC线程启动时，会通过可达性分析法把Eden区和From Space区的存活对象复制到To Space区，然后把Eden Space和From Space区的对象释放掉。当GC轮训扫描To Space区一定次数后，把依然存活的对象复制到老年代，然后释放To Space区的对象。</p><p>对于用可达性分析法搜索不到的对象，GC并不一定会回收该对象。要完全回收一个对象，至少需要经过<strong>两次标记的过程</strong>。</p><ul><li><p>第一次标记<br>对于一个没有其他引用的对象，筛选该对象是否有必要执行finalize()方法，如果没有执行必要，则意味可直接回收。（筛选依据：是否复写或执行过finalize()方法；因为finalize方法只能被执行一次）。</p></li><li><p>第二次标记<br>如果被筛选判定位有必要执行，则会放入FQueue队列，并自动创建一个低优先级的finalize线程来执行释放操作。如果在一个对象释放前被其他对象引用，则该对象会被移除FQueue队列。</p></li></ul><h2 id="JVM内存分配与回收策略"><a href="#JVM内存分配与回收策略" class="headerlink" title="JVM内存分配与回收策略"></a>JVM内存分配与回收策略</h2><h3 id="对象优先在Eden区分配"><a href="#对象优先在Eden区分配" class="headerlink" title="对象优先在Eden区分配"></a>对象优先在Eden区分配</h3><p>大多数情况下，对象在新生代中Eden区分配，当Eden区没有足够空间时，虚拟机将发起一次Minor GC.</p><h3 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h3><ul><li><p>既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须识别哪些对象应该放在新生代，哪些需要放在老年代。为了做到这一点，虚拟机给每个对象一个对象年龄（Age）计数器。</p></li><li><p>如果对象在Eden区出生并经过一次minor gc后仍然存活，并且大小能被Survivor容纳的话，将会移动到另一个Survivor区，并将对象年龄设为1。对象在Survivor中每熬过一次minor gc，年龄就增1岁，当增加到一定大小（默认为15岁），就会晋升到老年代。对象晋升到老年代的年龄阈值可以通过<code>-XX:MaxTenuringThreshold</code>来设置。</p></li></ul><h3 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h3><ul><li><p>大对象就是需要大量连续内存空间的对象，比如：长字符串、数组</p></li><li><p>JVM参数<code>-神器:PretenureSizeThreshold</code>可以设置大对象的大小，如果对象超过了设置大小，在创建时就会直接进入老年代，不会进入年轻代，这个参数只在<strong>Serial</strong>和<strong>ParNew</strong>两个收集器下有效</p></li><li><p>例如 <code>-神器:PretenureSizeThreshold=1000000 -XX:+UseSerialGC</code></p></li><li><p>这么做的目的：<strong>避免为大对象分配内存时的复制操作而降低效率</strong>；</p></li></ul><h3 id="对象动态年龄判断"><a href="#对象动态年龄判断" class="headerlink" title="对象动态年龄判断"></a>对象动态年龄判断</h3><ul><li><p>当前放置对象的Survivor区域里（另一块Survivor为空），一批对象的总大小大于这块Survivor区域内存大小的50%，那么此时大于这批对象年龄最大值的对象，就可以直接提前进入老年代了；</p></li><li><p>例如Survivor区域里现有一批对象：<code>年龄为1对象 + 年龄为2对象 + ... +  年龄为n对象</code> 所占空间总和超过了Survivor区总大小的50%，此时就会把年龄大于n的对象提前放入老年代；</p></li></ul><h3 id="老年代空间分配担保机制"><a href="#老年代空间分配担保机制" class="headerlink" title="老年代空间分配担保机制"></a>老年代空间分配担保机制</h3><p>年轻代每次Minor gc之前，JVM都会计算下老年代剩余可用空间：</p><ul><li><p>如果老年代剩余可用空间小于年轻代里现有的所有对象的大小之和（包括垃圾对象），就会看一个 <code>-神器:-HandlePromotionFailure</code> （JDK1.8默认就设置了）的参数是否配置了，如果有这个参数，就会看看老年代的可用内存大小，是否大于之前每次minor gc后进入老年代的对象平均大小；</p></li><li><p>如果上一步结果是小于或者没有设置该参数，JVM就会发起一次Full GC，对老年代和年轻代一起进行垃圾回收；</p></li><li><p>如果上一步结果是大于该参数，正常进行Minor GC;当然如果Minor GC后，剩余存活对象里需要移动到老年代的总大小超过了老年代可用空间，还是会触发Full GC;</p></li><li><p>如果回收完还是没有足够空间存放新建的对象，就会发生 <strong>OOM</strong>；</p></li></ul><p><img src="/images/jvm_fenpei_danbao.jpg" alt></p><h2 id="垃圾对象判断"><a href="#垃圾对象判断" class="headerlink" title="垃圾对象判断"></a>垃圾对象判断</h2><p>如何判断一个对象是否可以被回收，常见的做法有两种：</p><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>给对象头中添加一个引用计数器，每当有一个地方引用它，就给它的计数器+1；当引用失效，计数器就-1；只要计数器为0，就表示当前对象没有被使用，可以被回收。</p><ul><li><p><strong>优点</strong><br>引用计数收集器可以很快的执行，交织在程序运行中。对程序需要不被长时间打断的实时环境比较有利。</p></li><li><p><strong>缺点</strong><br>无法检测出循环引用。如父对象有一个对子对象的引用，子对象反过来引用父对象。这样，他们的引用计数永远不可能为0.</p></li></ul><p>Java的引用类型一般分为四种：</p><ul><li><p><strong>强引用</strong><br>普通的变量引用；</p></li><li><p><strong>软引用</strong><br>将对象用SoftReference软引用类型的对象包裹，正常情况下不会被回收，但是GC做完之后发现释放不出空间存放新对象，就会把这些软引用的对象回收掉。软引用可用来实现对内存敏感度不高的高速缓存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> SoftReference&lt;User&gt;  user = <span class="keyword">new</span> SoftReference&lt;User&gt;(<span class="keyword">new</span> User());</span><br></pre></td></tr></table></figure></li><li><p><strong>弱引用</strong><br>将对象用WeakReference弱引用类型的对象包裹，弱引用跟没引用差不多，GC会直接回收掉，很少用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> WeakReference&lt;User&gt; user = <span class="keyword">new</span> WeakReference&lt;User&gt;(<span class="keyword">new</span> User());</span><br></pre></td></tr></table></figure></li><li><p><strong>虚引用</strong><br>也成为幽灵引用或者幻影引用，它是最弱的一种引用关系，几乎不用。</p></li></ul><h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>这个算法的基本思想是通过一系列被称为”GC Roots”的对象作为起始点，从这些节点向下搜索，找到的对象都标记为非垃圾对象，剩余的都为垃圾对象；</p><p><strong>GC Roots:</strong> <font color="red">线程栈的本地变量、静态属性、常量、本地方法栈的变量等</font>；</p><p><strong>finalize()方法最终判定对象是否存活</strong><br>即使在可达性分析算法中不可达的对象，也并非是 『<strong>非死不可</strong>』，标记完之后只是暂时处于 『<strong>缓刑</strong>』 阶段，要真正宣告一个对象死亡，至少要经历再次标记过程。</p><p>标记的前提是：<strong>对象在进行可达性分析之后发现没有与任何GC Roots相连的引用链</strong>。</p><ul><li><p>第一次标记并进行一次筛选<br>对象如果没有覆盖<code>finalize()</code>方法，将会直接被回收；</p></li><li><p>第二次标记<br>如果这个对象覆盖了<code>finalize()</code>方法，只要在该方法中重新与引用链上的任何一个对象建立了关联，就可以拯救自己，不会被回收。</p></li></ul><p><strong>如何判断一个类是无用类：</strong><br>类需要同时满足下面3个条件才能算是 <strong>无用类</strong>：</p><ul><li><p>该类所有的实例都已经被回收，也就是堆中不存在该类的任何实例；</p></li><li><p>加载该类的ClassLoader已经被回收；</p></li><li><p>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法；</p></li></ul><h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><p>常用的垃圾回收算法有：标记-清除算法、复制算法、标记-整理算法、分代收集算法。目前主流的JVM（HotSpot）采用的是分代收集算法。</p><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>标记-清除算法采用从根集合进行扫描，对存活的对象对象标记，标记完毕后，再扫描整个空间中未被标记的对象，进行回收。标记-清除算法不需要进行对象的移动，并且仅对不存活的对象进行处理，在<strong>存活对象比较多的情况下极为高效</strong>，但由于标记-清除算法直接回收不存活的对象，因此会<strong>造成内存碎片</strong>。<br><img src="/images/jvm_mark_swep.jpg" alt></p><h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p><img src="/images/jvm_copy.jpg" alt></p><h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><p><img src="/images/jvm_mark_zhengli.jpg" alt></p><h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p><img src="/images/jvm_fendai_collection.jpg" alt></p><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p><img src="/images/java_gc_collectors.png" alt></p><h3 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h3><p><img src="/images/java_gc_serial.jpg" alt></p><h3 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h3><p><img src="/images/java_gc_parnew.jpg" alt></p><h3 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h3><p><img src="/images/java_gc_scavenge.jpg" alt></p><h3 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h3><p><img src="/images/java_gc_cms-collec.jpg" alt></p><p><img src="/images/java_cms_advantage.jpg" alt></p><p><img src="/images/java_cms_parameter.jpg" alt></p><h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h3><p><img src="/images/java_gc_g1.jpg" alt></p><p><img src="/images/java_gc_g1_process.jpg" alt></p><p><img src="/images/java_gc_g1_class.jpg" alt></p><h1 id="JVM优化"><a href="#JVM优化" class="headerlink" title="JVM优化"></a>JVM优化</h1><h2 id="能否对JVM调优，让其几乎不发生Full-GC"><a href="#能否对JVM调优，让其几乎不发生Full-GC" class="headerlink" title="能否对JVM调优，让其几乎不发生Full GC?"></a>能否对JVM调优，让其几乎不发生Full GC?</h2><p>评估对象大小和生命周期，调整年轻代大小和Eden/Survivor区比例，保证minor gc就能够回收基本所有对象，避免对象因为过大或年龄太大进入老年代。<br><img src="/images/jvm_full_gc_optimize.jpg" alt></p><p>需要放入survivor区的对象大于survivor区大小的50%时，会触发担保机制，直接放入老年代；</p><h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><p><a href="https://juejin.im/post/5df5c76ee51d45581634f256?utm_source=gold_browser_extension" target="_blank" rel="noopener">【搞定Jvm面试】Java 内存区域揭秘附常见面试题解析</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JDK体系结构&quot;&gt;&lt;a href=&quot;#JDK体系结构&quot; class=&quot;headerlink&quot; title=&quot;JDK体系结构&quot;&gt;&lt;/a&gt;JDK体系结构&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/images/jdk_structure.jpg&quot; alt&gt;&lt;/p&gt;
&lt;h1 
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
      <category term="JVM" scheme="http://yoursite.com/categories/Java/JVM/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Jvm" scheme="http://yoursite.com/tags/Jvm/"/>
    
  </entry>
  
  <entry>
    <title>Redis数据结构及常见使用场景</title>
    <link href="http://yoursite.com/2019/12/06/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%B8%B8%E8%A7%81%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <id>http://yoursite.com/2019/12/06/Redis数据结构及常见使用场景/</id>
    <published>2019-12-06T12:25:19.000Z</published>
    <updated>2020-01-10T11:13:29.668Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis基础数据类型及使用场景"><a href="#Redis基础数据类型及使用场景" class="headerlink" title="Redis基础数据类型及使用场景"></a>Redis基础数据类型及使用场景</h2><p><img src="/images/redis_basitc_data_structure.jpg" alt></p><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p><img src="/images/redis_string_basic_op.jpg" alt></p><p><img src="/images/redis_string_basic_caculate.jpg" alt></p><ul><li><p>缓存功能：String字符串是最常用的数据类型，不仅仅是Redis，各个语言都是最基本类型，因此，利用Redis作为缓存，配合其它数据库作为存储层，利用Redis支持高并发的特点，可以大大加快系统的读写速度、以及降低后端数据库的压力。</p></li><li><p>计数器：许多系统都会使用Redis作为系统的实时计数器，可以快速实现计数和查询的功能。而且最终的数据结果可以按照特定的时间落地到数据库或者其它存储介质当中进行永久保存。</p></li><li><p>共享用户Session：用户重新刷新一次界面，可能需要访问一下数据进行重新登录，或者访问页面缓存Cookie，但是可以利用Redis将用户的Session集中管理，在这种模式只需要保证Redis的高可用，每次用户Session的更新和获取都可以快速完成。大大提高效率。</p></li></ul><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p><img src="/images/redis_hash_basic_op.jpg" alt></p><p><img src="/images/redis_hash_basic_cache.jpg" alt></p><p><img src="/images/redis_hash_elec_strore.jpg" alt></p><p>这个是类似 Map 的一种结构，这个一般就是可以将结构化的数据，比如一个对象（前提是这个对象没嵌套其他的对象）给缓存在 Redis 里，然后每次读写缓存的时候，可以就操作 Hash 里的某个字段。<br>但是这个的场景其实还是多少单一了一些，因为现在很多对象都是比较复杂的，比如你的商品对象可能里面就包含了很多属性，其中也有对象。我自己使用的场景用得不是那么多。</p><p><img src="/images/redis_hash_advantage.jpg" alt></p><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>List 是有序列表，这个还是可以玩儿出很多花样的。</p><p><img src="/images/redis_list_basic_op.jpg" alt></p><p><img src="/images/redis_list_stack.jpg" alt></p><ul><li>比如可以通过 List 存储一些<strong>列表型的数据结构</strong>，类似粉丝列表、文章的评论列表之类的东西。<br>比如可以通过 <code>lrange</code> 命令，读取某个闭区间内的元素，可以基于 List 实现<code>分页查询</code>，这个是很棒的一个功能，基于 Redis 实现简单的高性能分页，可以做类似微博那种下拉不断分页的东西，性能高，就一页一页走。</li></ul><p>比如可以搞个简单的消息队列，从 List 头怼进去，从 List 屁股那里弄出来。List本身就是我们在开发过程中比较常用的数据结构了，热点数据更不用说了。</p><ul><li><p>消息队列：Redis的链表结构，可以轻松实现阻塞队列，可以使用<strong>左进右出的命令</strong>组成来完成队列的设计。比如：数据的生产者可以通过<code>Lpush</code>命令从左边插入数据，多个数据消费者，可以使用<code>BRpop</code>命令阻塞的“抢”列表尾部的数据。</p></li><li><p>文章列表或者数据分页展示的应用。<br>比如，我们常用的博客网站的文章列表，当用户量越来越多时，而且每一个用户都有自己的文章列表，而且当文章多时，都需要分页展示，这时可以考虑使用Redis的列表，列表不但有序同时还支持按照范围内获取元素，可以完美解决分页查询功能。大大提高查询效率。</p></li></ul><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>Set 是无序集合，会自动去重的那种。</p><p><img src="/images/redis_set_basic_op.jpg" alt></p><p><img src="/images/redis_set_basic_weixin.jpg" alt></p><p><img src="/images/redis_set_basic_weibo.jpg" alt></p><p><img src="/images/redis_set_basic_weibo_guanzhu.jpg" alt></p><ul><li><p><strong>去重：</strong> 直接基于 Set 将系统里需要去重的数据扔进去，自动就给去重了，如果你需要对一些数据进行快速的全局去重，你当然也可以基于 JVM 内存里的 HashSet 进行去重，但是如果你的某个系统部署在多台机器上呢？得基于Redis进行全局的 Set 去重。</p></li><li><p>可以基于 Set 玩 <strong>交集、并集、差集</strong> 的操作。比如交集吧，我们可以把两个人的好友列表整一个交集，看看俩人的共同好友是谁？对吧。反正这些场景比较多，因为对比很快，操作也简单，两个查询一个Set搞定。</p></li></ul><h3 id="Sorted-Set"><a href="#Sorted-Set" class="headerlink" title="Sorted Set"></a>Sorted Set</h3><p>Sorted set 是排序的 Set，<strong>去重并可以排序</strong>，写进去的时候给一个分数，自动根据分数排序。</p><p>有序集合的使用场景与集合类似，但是set集合不是自动有序的，而<strong>Sorted set可以利用分数进行成员间的排序，而且是插入时就排序好</strong>。所以当你需要一个有序且不重复的集合列表时，就可以选择Sorted set数据结构作为选择方案。</p><p><img src="/images/redis_sorted_weibo.jpg" alt></p><ul><li><p>排行榜：有序集合经典使用场景。例如视频网站需要对用户上传的视频做排行榜，榜单维护可能是多方面：按照时间、按照播放量、按照获得的赞数等。</p></li><li><p>用<code>Sorted Sets</code>来做带权重的队列，比如普通消息的score为1，重要消息的score为2，然后工作线程可以选择按score的倒序来获取工作任务。让重要的任务优先执行。</p></li></ul><h3 id="Redis更多应用场景"><a href="#Redis更多应用场景" class="headerlink" title="Redis更多应用场景"></a>Redis更多应用场景</h3><p><img src="/images/redis_more_yingyong.jpg" alt></p><p><img src="/images/redis_collect_elec.jpg" alt></p><h2 id="Redis-和-Memcached-区别"><a href="#Redis-和-Memcached-区别" class="headerlink" title="Redis 和 Memcached 区别"></a>Redis 和 Memcached 区别</h2><h3 id="Memcache"><a href="#Memcache" class="headerlink" title="Memcache"></a>Memcache</h3><p>先来看看 MC 的特点：</p><ul><li><p>MC 处理请求时使用<code>多线程异步IO</code> 的方式，可以合理利用 CPU 多核的优势，性能非常优秀；</p></li><li><p>MC 功能简单，使用内存存储数据；</p></li><li><p>MC 的内存结构以及钙化问题；</p></li><li><p>MC 对缓存的数据可以设置失效期，过期后的数据会被清除；</p></li><li><p>失效的策略采用延迟失效，就是当再次使用数据时检查是否失效；</p></li><li><p>当容量存满时，会对缓存中的数据进行剔除，剔除时除了会对过期 key 进行清理，还会按 LRU 策略对数据进行剔除。</p></li></ul><p>另外，使用 MC 有一些限制，这些限制在现在的互联网场景下很致命，成为大家选择Redis、MongoDB的重要原因：</p><ul><li><p>key 不能超过 250 个字节；</p></li><li><p>value 不能超过 1M 字节；</p></li><li><p>key 的最大失效时间是 30 天；</p></li><li><p>只支持 K-V 结构，不提供持久化和主从同步功能。</p></li></ul><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><p>简单说一下 Redis 的特点，方便和 Memcache 比较。</p><ul><li><p>与 MC 不同的是，Redis 采用单线程模式处理请求。这样做的原因有 2 个：</p><ul><li><p>一个是因为采用了非阻塞的异步事件处理机制；</p></li><li><p>另一个是缓存数据都是内存操作 IO 时间不会太长，单线程可以避免线程上下文切换产生的代价。</p></li></ul></li><li><p>Redis 支持持久化，所以 Redis 不仅仅可以用作缓存，也可以用作 NoSQL 数据库。</p></li><li><p>相比 MC，Redis 还有一个非常大的优势，就是除了 K-V 之外，还支持复杂的数据结构，例如 list、set、sorted set、hash 等。</p></li><li><p>Redis 提供主从同步机制，以及原生支持集群模式，能够提供高可用服务, 在 redis3.x 版本中，便能支持 Cluster 模式; 而 Memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据。</p></li></ul><h3 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h3><p>由于 Redis 只使用单核，而 Memcached 可以使用多核，所以<strong>平均每一个核上 Redis 在存储小数据时比 Memcached 性能更高。而在 100k 以上的数据中，Memcached 性能要高于 Redi</strong>s，虽然 Redis 最近也在存储大数据的性能上进行优化，但是比起 Remcached，还是稍有逊色。</p><h2 id="Redis-线程模型"><a href="#Redis-线程模型" class="headerlink" title="Redis 线程模型"></a>Redis 线程模型</h2><p>Redis 内部使用 <strong>文件事件处理器</strong> <code>file event handler</code>，这个文件事件处理器是单线程的，所以 Redis 才叫做单线程的模型。它<strong>采用 IO 多路复用机制同时监听多个 Socket</strong>，根据 Socket 上的事件来选择对应的事件处理器进行处理。</p><p>文件事件处理器的结构包含 4 个部分：</p><ul><li>多个 Socket</li><li>IO 多路复用程序</li><li>文件事件分派器</li><li>事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）</li></ul><p>多个 Socket 可能会并发产生不同的操作，每个操作对应不同的文件事件，但是 IO 多路复用程序会监听多个 Socket，会将 Socket 产生的事件放入队列中排队，事件分派器每次从队列中取出一个事件，把该事件交给对应的事件处理器进行处理。</p><h2 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h2><h3 id="Bitmap"><a href="#Bitmap" class="headerlink" title="Bitmap"></a>Bitmap</h3><p>位图是支持按 bit 位来存储信息，可以用来实现 <code>布隆过滤器（BloomFilter）</code>；</p><h3 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h3><p>供不精确的去重计数功能，比较适合用来做大规模数据的去重统计，例如统计 UV；</p><h3 id="Geospatial"><a href="#Geospatial" class="headerlink" title="Geospatial"></a>Geospatial</h3><p>可以用来保存地理位置，并作<code>位置距离计算</code>或者<code>根据半径计算位置</code>等。有没有想过用Redis来实现附近的人？或者计算最优地图路径？</p><h3 id="pub-sub"><a href="#pub-sub" class="headerlink" title="pub/sub"></a>pub/sub</h3><p>功能是订阅发布功能，可以用作简单的消息队列。 </p><h3 id="Pipeline"><a href="#Pipeline" class="headerlink" title="Pipeline"></a>Pipeline</h3><p>可以批量执行一组指令，一次性返回全部结果，可以减少频繁的请求应答。</p><h3 id="Lua"><a href="#Lua" class="headerlink" title="Lua"></a>Lua</h3><p>Redis 支持提交 Lua 脚本来执行一系列的功能, 利用他的原子性。</p><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>最后一个功能是事务，但 Redis 提供的不是严格的事务，Redis 只保证串行执行命令，并且能保证全部执行，但是执行命令失败时并不会回滚，而是会继续执行下去。</p><h2 id="Redisson实现分布式锁"><a href="#Redisson实现分布式锁" class="headerlink" title="Redisson实现分布式锁"></a>Redisson实现分布式锁</h2><p><img src="/images/redisson_distributed_lock.png" alt></p><h2 id="Redis集群"><a href="#Redis集群" class="headerlink" title="Redis集群"></a>Redis集群</h2><p><img src="/images/redis_cluster_crc_ms.jpg" alt></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1]<a href="https://juejin.im/post/5db66ed9e51d452a2f15d833" target="_blank" rel="noopener">《吊打面试官》系列-Redis基础</a><br>[2]<a href="https://juejin.im/post/5dbef8306fb9a0203f6fa3e2" target="_blank" rel="noopener">《吊打面试官》系列-缓存雪崩、击穿、穿透</a><br>[3]<a href="https://juejin.im/post/5dc3a9fbf265da4d3c072eab" target="_blank" rel="noopener">《吊打面试官》系列-Redis哨兵、持久化、主从、手撕LRU</a><br>[4]<a href="https://juejin.im/post/5dc850b4e51d452c2308ee27" target="_blank" rel="noopener">《吊打面试官》系列-Redis终章凛冬将至、FPX新王登基</a><br>[5]<a href="https://juejin.im/post/5dd09f5af265da0be72aacbd" target="_blank" rel="noopener">《吊打面试官》系列-秒杀系统设计</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Redis基础数据类型及使用场景&quot;&gt;&lt;a href=&quot;#Redis基础数据类型及使用场景&quot; class=&quot;headerlink&quot; title=&quot;Redis基础数据类型及使用场景&quot;&gt;&lt;/a&gt;Redis基础数据类型及使用场景&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/ima
      
    
    </summary>
    
      <category term="中间件" scheme="http://yoursite.com/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
      <category term="Redis" scheme="http://yoursite.com/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="入门" scheme="http://yoursite.com/tags/%E5%85%A5%E9%97%A8/"/>
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Tomcat系统架构[转载]</title>
    <link href="http://yoursite.com/2019/12/06/Tomcat%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84-%E8%BD%AC%E8%BD%BD/"/>
    <id>http://yoursite.com/2019/12/06/Tomcat系统架构-转载/</id>
    <published>2019-12-06T12:09:24.000Z</published>
    <updated>2019-12-09T12:07:22.663Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Tomcat顶层架构"><a href="#Tomcat顶层架构" class="headerlink" title="Tomcat顶层架构"></a>Tomcat顶层架构</h2><p>先上一张Tomcat的顶层结构图，如下<br><img src="/images/tomcat_structure.jpg" alt></p><p>简化清晰版<br><img src="/images/tomcat_stucture2.jpg" alt></p><ul><li><p>Tomcat中最顶层的容器是Server，代表着整个服务器，从上图中可以看出，一个Server可以包含至少一个Service，用于具体提供服务。</p></li><li><p>Service主要包含两个部分：<strong>Connector</strong>和<strong>Container</strong>。从上图中可以看出 Tomcat 的心脏就是这两个组件，他们的作用如下：</p><ul><li><p>Connector用于<strong>处理连接相关的事情，并提供Socket与Request和Response相关的转化</strong>; </p></li><li><p>Container用于<strong>封装和管理Servlet，以及具体处理Request请求</strong>；</p></li></ul></li></ul><p><font color="red"><strong>一个Tomcat中只有一个Server，一个Server可以包含多个Service，一个Service只有一个Container，但是可以有多个Connectors，这是因为一个服务可以有多个连接，如同时提供Http和Https链接，也可以提供向相同协议不同端口的连接</strong></font></p><p>示意图如下（Engine、Host、Context下边会说到）：<br><img src="/images/engine_host_context.jpg" alt></p><p>多个 Connector 和一个 Container 就形成了一个 Service，有了 Service 就可以对外提供服务了，但是 Service 还要一个生存的环境，必须要有人能够给它生命、掌握其生死大权，那就非 Server 莫属了！所以<strong>整个 Tomcat 的生命周期由 Server 控制</strong>。</p><p>另外，上述的包含关系或者说是父子关系，都可以在tomcat的conf目录下的<code>server.xml</code>配置文件中看出，如下是删除了注释内容之后的一个完整的<code>server.xml</code>配置文件（Tomcat版本为8.0）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version='1.0' encoding='utf-8'?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Server</span> <span class="attr">port</span>=<span class="string">"8005"</span> <span class="attr">shutdown</span>=<span class="string">"SHUTDOWN"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.startup.VersionLoggerListener"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.core.AprLifecycleListener"</span> <span class="attr">SSLEngine</span>=<span class="string">"on"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.core.JreMemoryLeakPreventionListener"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.mbeans.GlobalResourcesLifecycleListener"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.core.ThreadLocalLeakPreventionListener"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">GlobalNamingResources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Resource</span> <span class="attr">name</span>=<span class="string">"UserDatabase"</span> <span class="attr">auth</span>=<span class="string">"Container"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">type</span>=<span class="string">"org.apache.catalina.UserDatabase"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">description</span>=<span class="string">"User database that can be updated and saved"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">factory</span>=<span class="string">"org.apache.catalina.users.MemoryUserDatabaseFactory"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">pathname</span>=<span class="string">"conf/tomcat-users.xml"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">GlobalNamingResources</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">Service</span> <span class="attr">name</span>=<span class="string">"Catalina"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8060"</span> <span class="attr">protocol</span>=<span class="string">"HTTP/1.1"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">connectionTimeout</span>=<span class="string">"20000"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">redirectPort</span>=<span class="string">"8443"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8009"</span> <span class="attr">protocol</span>=<span class="string">"AJP/1.3"</span> <span class="attr">redirectPort</span>=<span class="string">"8443"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Engine</span> <span class="attr">name</span>=<span class="string">"Catalina"</span> <span class="attr">defaultHost</span>=<span class="string">"localhost"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Realm</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.realm.LockOutRealm"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Realm</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.realm.UserDatabaseRealm"</span> <span class="attr">resourceName</span>=<span class="string">"UserDatabase"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">Realm</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">Host</span> <span class="attr">name</span>=<span class="string">"localhost"</span>  <span class="attr">appBase</span>=<span class="string">"webapps"</span> <span class="attr">unpackWARs</span>=<span class="string">"true"</span> <span class="attr">autoDeploy</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Context</span> <span class="attr">path</span>=<span class="string">""</span> <span class="attr">docBase</span>=<span class="string">"/xxx/target/bigdata-web"</span> </span></span><br><span class="line"><span class="tag">                    <span class="attr">debug</span>=<span class="string">"0"</span> <span class="attr">reloadable</span>=<span class="string">"true"</span> <span class="attr">crossContext</span>=<span class="string">"true"</span> <span class="attr">allowLinking</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">Valve</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.valves.AccessLogValve"</span> <span class="attr">directory</span>=<span class="string">"logs"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">prefix</span>=<span class="string">"localhost_access_log"</span> <span class="attr">suffix</span>=<span class="string">".txt"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">pattern</span>=<span class="string">"%h %l %u %t &amp;quot;%r&amp;quot; %s %b"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">Host</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Engine</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">Service</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Server</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上边的配置文件，还可以通过下边的一张结构图更清楚的理解：</p><p><img src="/images/web_xml.jpg" alt></p><p>Server标签设置的端口号为8005，shutdown=”SHUTDOWN” ，表示在8005端口监听“SHUTDOWN”命令，如果接收到了就会关闭Tomcat。一个Server有一个Service，当然还可以进行配置。Service左边的内容都属于Container的，Service下边是多个Connector。</p><h2 id="Tomcat顶层架构小结"><a href="#Tomcat顶层架构小结" class="headerlink" title="Tomcat顶层架构小结"></a>Tomcat顶层架构小结</h2><ul><li><p>（1）Tomcat中只有一个Server，一个Server可以有多个Service，一个Service可以有多个Connector和一个Container；</p></li><li><p>（2） Server掌管着整个Tomcat的生死大权；</p></li><li><p>（4）Service 是对外提供服务的；</p></li><li><p>（5）Connector用于接受请求并将请求封装成Request和Response来具体处理；</p></li><li><p>（6）Container用于封装和管理Servlet，以及具体处理request请求；</p></li></ul><p>以上是整个Tomcat顶层的分层架构和各个组件之间的关系以及作用，但对于绝大多数的开发人员来说Server和Service对我们来说确实很远，而我们开发中绝大部分进行配置的内容是属于Connector和Container的，所以接下来介绍一下<strong>Connector</strong>和<strong>Container</strong>。</p><h2 id="Connector和Container的微妙关系"><a href="#Connector和Container的微妙关系" class="headerlink" title="Connector和Container的微妙关系"></a>Connector和Container的微妙关系</h2><p><img src="/images/connector_container.jpg" alt="-w578"></p><p>由上述内容我们大致可以知道一个请求发送到Tomcat之后，首先经过<strong>Service</strong>然后会交给我们的<strong>Connector</strong>，<strong>Connector</strong>用于接收请求并将接收的请求封装为Request和Response来具体处理，Request和Response封装完之后再交由Container进行处理，Container处理完请求之后再返回给Connector，最后在由Connector通过Socket将处理的结果返回给客户端，这样整个请求的就处理完了！</p><p>Connector最底层使用的是Socket来进行连接的，Request和Response是按照HTTP协议来封装的，所以Connector同时需要实现TCP/IP协议和HTTP协议！</p><p>Tomcat既然处理请求，那么肯定需要先接收到这个请求，接收请求这个东西我们首先就需要看一下Connector！</p><h2 id="Connector架构分析"><a href="#Connector架构分析" class="headerlink" title="Connector架构分析"></a>Connector架构分析</h2><p>Connector用于接受请求并将请求封装成Request和Response，然后交给Container进行处理，Container处理完之后在交给Connector返回给客户端。</p><p>因此，我们可以把Connector分为四个方面进行理解：</p><blockquote><p>（1）Connector如何接受请求的？<br>（2）如何将请求封装成Request和Response的？<br>（3）封装完之后的Request和Response如何交给Container进行处理的？<br>（4）Container处理完之后如何交给Connector并返回给客户端的？</p></blockquote><p>首先看一下Connector的结构图，如下所示：</p><p> <img src="/images/connector_structure.jpg" alt></p><p><strong>Connector</strong>就是使用<strong>ProtocolHandler</strong>来处理请求的，不同的<strong>ProtocolHandler</strong>代表不同的连接类型，比如：<strong>Http11Protocol</strong>使用的是普通Socket来连接的，<strong>Http11NioProtocol</strong>使用的是NioSocket来连接的。</p><p>其中ProtocolHandler由包含了三个部件：<strong>Endpoint</strong>、<strong>Processor</strong>、<strong>Adapter</strong>。</p><ul><li><p><strong>Endpoint</strong> 用来处理底层Socket的网络连接</p><ul><li><p>Endpoint由于是处理底层的Socket网络连接，因此Endpoint是用来实现<strong>TCP/IP</strong>协议的</p></li><li><p>Endpoint 的抽象实现<code>AbstractEndpoint</code>里面定义的 <code>Acceptor</code> 和 <code>AsyncTimeout</code> 两个内部类和一个 <code>Handler</code> 接口。</p><blockquote><p><code>Acceptor</code>用于监听请求<br><code>AsyncTimeout</code>用于检查异步Request的超时<br><code>Handler</code> 用于处理接收到的Socket，在内部调用Processor进行处理</p></blockquote></li></ul></li><li><p><strong>Processor</strong> 用于将Endpoint接收到的Socket封装成Request</p><ul><li>Processor用来实现<strong>HTTP</strong>协议的</li></ul></li><li><p><strong>Adapter</strong> 用于将Request交给Container进行具体的处理</p><ul><li>Adapter将请求适配到Servlet容器进行具体的处理</li></ul></li></ul><p>至此，我们应该很轻松的回答（1）（2）（3）的问题了，但是（4）还是不知道，那么我们就来看一下Container是如何进行处理的以及处理完之后是如何将处理完的结果返回给Connector的？</p><h2 id="Container架构分析"><a href="#Container架构分析" class="headerlink" title="Container架构分析"></a>Container架构分析</h2><p>Container用于封装和管理Servlet，以及具体处理Request请求，在Connector内部包含了4个子容器，结构图如下：</p><p><img src="/images/container_structure.jpg" alt></p><p>4个子容器的作用分别是：</p><ul><li><p><strong>Engine</strong>：引擎，用来管理多个站点，一个Service最多只能有一个Engine；</p></li><li><p><strong>Host</strong>：代表一个站点，也可以叫虚拟主机，通过配置Host就可以添加站点；</p></li><li><p><strong>Context</strong>：代表一个应用程序，对应着平时开发的一套程序，或者一个 <code>WEB-INF</code> 目录以及下面的 <code>web.xml</code> 文件；</p></li><li><p><strong>Wrapper</strong>：每一Wrapper封装着一个Servlet；</p></li></ul><p>下面找一个Tomcat的文件目录对照一下，如下图所示：<br><img src="/images/tomcat_deploy_folder.jpg" alt></p><p><strong>Context和Host的区别</strong></p><p><strong>Context</strong>表示一个应用，<strong>Tomcat中默认的配置下 webapps 下的每一个文件夹目录都是一个<code>Context</code></strong>，其中ROOT目录中存放着主应用，其他目录存放着子应用，而<strong>整个 webapps 就是一个Host站点</strong>。</p><p>我们访问应用Context的时候，如果是<code>ROOT</code>下的则直接使用域名就可以访问，例如：<a href="http://www.ledouit.com" target="_blank" rel="noopener">www.ledouit.com</a>.</p><p>如果是Host（webapps）下的其他应用，则可以使用 <a href="http://www.ledouit.com/docs" target="_blank" rel="noopener">www.ledouit.com/docs</a> 进行访问，当然默认指定的根应用（ROOT）是可以进行设定的，只不过Host站点下默认的主应用是ROOT目录下的。</p><p>看到这里我们知道Container是什么，但是还是不知道Container是如何进行处理的以及处理完之后是如何将处理完的结果返回给Connector的？别急！下边就开始探讨一下Container是如何进行处理的！</p><h2 id="Container如何处理请求的"><a href="#Container如何处理请求的" class="headerlink" title="Container如何处理请求的"></a>Container如何处理请求的</h2><p>Container处理请求是使用 <strong>Pipeline-Valve</strong> 管道来处理的！（Valve是阀门之意）</p><p><strong>Pipeline-Valve</strong> 是<strong>责任链模式</strong>，责任链模式是指在一个请求处理的过程中有很多处理者依次对请求进行处理，每个处理者负责做自己相应的处理，处理完之后将处理后的请求返回，再让下一个处理着继续处理。但是！Pipeline-Valve使用的责任链模式和普通的责任链模式有些不同！区别主要有以下两点：</p><ul><li><p>每个Pipeline都有特定的Valve，而且是在管道的最后一个执行，这个Valve叫做 <strong>BaseValve</strong>，<strong>BaseValve是不可删除的</strong>；</p></li><li><p>在上层容器的管道的BaseValve中会调用下层容器的管道。</p></li></ul><p>我们知道 Container 包含四个子容器，而这四个子容器对应的 BaseValve 分别是：</p><blockquote><p><strong>StandardEngineValve</strong>、<strong>StandardHostValve</strong>、<strong>StandardContextValve</strong>、<strong>StandardWrapperValve</strong></p></blockquote><p>Pipeline的处理流程图如下（图D）：<br><img src="/images/tomcat_pipeline_valve.jpg" alt></p><p>（1）Connector在接收到请求后会首先调用最顶层容器的Pipeline来处理，这里的最顶层容器的Pipeline就是<strong>EnginePipeline</strong>（Engine的管道）；</p><p>（2）在Engine的管道中依次会执行EngineValve1、EngineValve2等等，最后会执行StandardEngineValve，在StandardEngineValve中会调用Host管道，然后再依次执行Host的HostValve1、HostValve2等，最后在执行StandardHostValve，然后再依次调用Context的管道和Wrapper的管道，最后执行到StandardWrapperValve。</p><p>（3）当执行到StandardWrapperValve的时候，会在 <strong>StandardWrapperValve中创建FilterChain</strong>，并调用其doFilter方法来处理请求，这个FilterChain包含着我们配置的与请求相匹配的Filter和Servlet，其<strong>doFilter方法会依次调用所有的Filter的doFilter方法和Servlet的service方法</strong>，这样请求就得到了处理！</p><p>（4）当所有的Pipeline-Valve都执行完之后，并且处理完了具体的请求，这个时候就可以将返回的结果交给Connector了，Connector在通过Socket的方式将结果返回给客户端。</p><h2 id="Servlet生命周期"><a href="#Servlet生命周期" class="headerlink" title="Servlet生命周期"></a>Servlet生命周期</h2><p><img src="/images/servlet_lifecycle.png" alt></p><h2 id="Tomcat优化"><a href="#Tomcat优化" class="headerlink" title="Tomcat优化"></a>Tomcat优化</h2><h3 id="硬件优化"><a href="#硬件优化" class="headerlink" title="硬件优化"></a>硬件优化</h3><p>单个服务器所能提供CPU、内存、硬盘的性能对处理能力有决定性影响，所以说服务器性能好，Tomcat也不会太差</p><h3 id="Tomcat本身优化"><a href="#Tomcat本身优化" class="headerlink" title="Tomcat本身优化"></a>Tomcat本身优化</h3><p>Tomcat 的自身参数的优化，这块很像 ApacheHttp Server。修改一下 xml 配置文件中的参数，调整最大连接数，超时等.</p><h4 id="Connector-连接器的配置"><a href="#Connector-连接器的配置" class="headerlink" title="Connector 连接器的配置"></a>Connector 连接器的配置</h4><p>Tomcat连接器的三种方式： <code>bio</code>、<code>nio</code> 和 <code>apr</code>，三种方式性能差别很大，<code>apr</code>的性能最优， <code>bio</code> 的性能最差。而 Tomcat 7 使用的 Connector  默认就启用的 Apr 协议，但需要系统安装 Apr 库，否则就会使用 bio 方式。</p><h4 id="配置文件优化"><a href="#配置文件优化" class="headerlink" title="配置文件优化"></a>配置文件优化</h4><p>配置文件优化其实就是对 <code>server.xml</code> 优化，可以提大大提高 Tomcat 的处理请求的能力，下面我们来看 Tomcat 容器内的优化。</p><p>默认配置下，Tomcat 会为每个连接器创建一个绑定的线程池（最大线程数 200），服务启动时，默认创建了 5 个空闲线程随时等待用户请求。</p><p>首先，打开 ${TOMCAT_HOME}/conf/server.xml，搜索【&lt;Executor name=”tomcatThreadPool”】，开启并调整为:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Executor</span> <span class="attr">name</span>=<span class="string">"tomcatThreadPool"</span> <span class="attr">namePrefix</span>=<span class="string">"catalina-exec-"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">maxThreads</span>=<span class="string">"500"</span> <span class="attr">minSpareThreads</span>=<span class="string">"20"</span> <span class="attr">maxSpareThreads</span>=<span class="string">"50"</span> <span class="attr">maxIdleTime</span>=<span class="string">"60000"</span>/&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>注意， Tomcat 7 在开启线程池前，一定要安装好 Apr 库，并可以启用，否则会有错误报出，shutdown.sh 脚本无法关闭进程。</p></blockquote><p>然后，修改&lt;Connector …&gt;节点，增加 executor 属性，搜索【port=”8080”】，调整为:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">executor</span>=<span class="string">"tomcatThreadPool"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">port</span>=<span class="string">"8080"</span> <span class="attr">protocol</span>=<span class="string">"HTTP/1.1"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">URIEncoding</span>=<span class="string">"UTF-8"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">connectionTimeout</span>=<span class="string">"30000"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">enableLookups</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">disableUploadTimeout</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">connectionUploadTimeout</span>=<span class="string">"150000"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">acceptCount</span>=<span class="string">"300"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">keepAliveTimeout</span>=<span class="string">"120000"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">maxKeepAliveRequests</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">compression</span>=<span class="string">"on"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">compressionMinSize</span>=<span class="string">"2048"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">compressableMimeType</span>=<span class="string">"text/html,text/xml,text/javascript,text/css,text/plain,image/gif,image/jpg,image/png"</span> </span></span><br><span class="line"><span class="tag">           <span class="attr">redirectPort</span>=<span class="string">"8443"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><p><strong>maxThreads</strong> : Tomcat使用线程来处理接收的每个请求，这个值表示 Tomcat 可创建的最大的线程数，默认值是 200</p></li><li><p><strong>minSpareThreads</strong>：最小空闲线程数，Tomcat 启动时的初始化的线程数，表示即使没有人使用也开这么多空线程等待，默认值是 10。</p></li><li><p><strong>maxSpareThreads</strong>：最大备用线程数，一旦创建的线程超过这个值，Tomcat 就会关闭不再需要的 socket 线程。</p></li></ul><p>上边配置的参数，最大线程 500（一般服务器足以），要根据自己的实际情况合理设置，设置越大会耗费内存和 CPU，因为 CPU 疲于线程上下文切换，没有精力提供请求服务了，最小空闲线程数 20，线程最大空闲时间 60 秒，当然允许的最大线程连接数还受制于操作系统的内核参数设置，设置多大要根据自己的需求与环境。当然<strong>线程可以配置在“tomcatThreadPool”中，也可以直接配置在“Connector”中，但不可以重复配置</strong>。</p><ul><li><p><strong>URIEncoding</strong>：指定 Tomcat 容器的 URL 编码格式，语言编码格式这块倒不如其它 WEB 服务器软件配置方便，需要分别指定。</p></li><li><p><strong>connnectionTimeout</strong>： 网络连接超时，单位：毫秒，设置为 0 表示永不超时，这样设置有隐患的。通常可设置为 30000 毫秒，可根据检测实际情况，适当修改。</p></li><li><p><strong>enableLookups</strong>： 是否反查域名，以返回远程主机的主机名，取值为：true 或 false，如果设置为false，则直接返回IP地址，为了提高处理能力，应设置为 false。</p></li><li><p><strong>disableUploadTimeout</strong>：上传时是否使用超时机制。</p></li><li><p><strong>connectionUploadTimeout</strong>：上传超时时间，毕竟文件上传可能需要消耗更多的时间，这个根据你自己的业务需要自己调，以使Servlet有较长的时间来完成它的执行，需要与上一个参数一起配合使用才会生效。</p></li><li><p><strong>acceptCount</strong>：指定当所有可以使用的处理请求的线程数都被使用时，可传入连接请求的最大队列长度，超过这个数的请求将不予处理，默认为100个。</p></li><li><p><strong>keepAliveTimeout</strong>：长连接最大保持时间（毫秒），表示在下次请求过来之前，Tomcat保持该连接多久，默认是使用 connectionTimeout 时间，-1 为不限制超时。</p></li><li><p><strong>maxKeepAliveRequests</strong>：表示在服务器关闭之前，该连接最大支持的请求数。超过该请求数的连接也将被关闭，1表示禁用，-1表示不限制个数，默认100个，一般设置在100~200之间。</p></li><li><p><strong>compression</strong>：是否对响应的数据进行 GZIP 压缩，off：表示禁止压缩；on：表示允许压缩（文本将被压缩）、force：表示所有情况下都进行压缩，默认值为off，压缩数据后可以有效的减少页面的大小，一般可以减小1/3左右，节省带宽。</p></li><li><p><strong>compressionMinSize</strong>：表示压缩响应的最小值，只有当响应报文大小大于这个值的时候才会对报文进行压缩，如果开启了压缩功能，默认值就是2048。</p></li><li><p><strong>compressableMimeType</strong>：压缩类型，指定对哪些类型的文件进行数据压缩。</p></li><li><p><strong>noCompressionUserAgents</strong>=”gozilla, traviata”： 对于以下的浏览器，不启用压缩。</p></li></ul><p><strong>如果已经对代码进行了动静分离，静态页面和图片等数据就不需要Tomcat处理了，那么也就不需要配置在 Tomcat 中配置压缩了。</strong></p><p>以上是一些常用的配置参数属性，当然还有好多其它的参数设置，还可以继续深入的优化，HTTP Connector 与 AJP Connector 的参数属性值，可以参考官方文档的详细说明：<br><a href="https://tomcat.apache.org/tomcat-7.0-doc/config/http.html" target="_blank" rel="noopener">https://tomcat.apache.org/tomcat-7.0-doc/config/http.html</a></p><h4 id="禁用AJP连接器"><a href="#禁用AJP连接器" class="headerlink" title="禁用AJP连接器"></a>禁用AJP连接器</h4><p>AJP（Apache JServer Protocol）AJPv13协议是面向包的。WEB服务器和Servlet容器通过TCP连接来交互；为了节省SOCKET创建的昂贵代价，WEB服务器会尝试维护一个永久TCP连接到servlet容器，并且在多个请求和响应周期过程会重用连接。如图:<br><img src="/images/tomcat_aij.png" alt><br>在Nginx+tomcat的架构中，禁用AJP连接器：<br><img src="/images/forbidden_aij.png" alt></p><h3 id="JVM优化"><a href="#JVM优化" class="headerlink" title="JVM优化"></a>JVM优化</h3><p>根据服务器物理内容情况配置相关参数优化tomcat性能。</p><p>当应用程序需要的内存超出堆的最大值时虚拟机就会提示内存溢出，并且导致应用服务崩溃。因此一般建议堆的最大值设置为可用内存的最大值的80%。 Tomcat默认可以使用的内存为128MB，在较大型的应用项目中，这点内存是不够的，需要调大.</p><p>Unix下，在文件/bin/catalina.sh的前面，增加如下设置： </p><blockquote><p>JAVA_OPTS=’-Xms【初始化内存大小】 -Xmx【可以使用的最大内存】 -XX:PermSize=64M -XX:MaxPermSize=128m’</p></blockquote><p>需要把几个参数值调大。例如： <code>JAVA_OPTS=’-Xms256m -Xmx512m’</code> 表示初始化内存为256MB，可以使用的最大内存为512MB。</p><p>参数详解:   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-server  启用jdk 的 server 版；</span><br><span class="line">-Xms    java虚拟机初始化时的最小内存；</span><br><span class="line">-Xmx    java虚拟机可使用的最大内存；</span><br><span class="line">-XX:PermSize    内存永久代保留区域</span><br><span class="line">-XX:MaxPermSize   内存最大永久代保留区域 </span><br><span class="line">-Xmn    jvm最小内存</span><br></pre></td></tr></table></figure><p>原文链接： <a href="https://blog.csdn.net/xlgen157387/article/details/79006434" target="_blank" rel="noopener">四张图带你了解Tomcat系统架构–让面试官颤抖的Tomcat回答系列</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Tomcat顶层架构&quot;&gt;&lt;a href=&quot;#Tomcat顶层架构&quot; class=&quot;headerlink&quot; title=&quot;Tomcat顶层架构&quot;&gt;&lt;/a&gt;Tomcat顶层架构&lt;/h2&gt;&lt;p&gt;先上一张Tomcat的顶层结构图，如下&lt;br&gt;&lt;img src=&quot;/imag
      
    
    </summary>
    
      <category term="Web" scheme="http://yoursite.com/categories/Web/"/>
    
      <category term="Tomcat" scheme="http://yoursite.com/categories/Web/Tomcat/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Web" scheme="http://yoursite.com/tags/Web/"/>
    
      <category term="Tomcat" scheme="http://yoursite.com/tags/Tomcat/"/>
    
  </entry>
  
  <entry>
    <title>Java动态代理</title>
    <link href="http://yoursite.com/2019/11/29/Java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    <id>http://yoursite.com/2019/11/29/Java动态代理/</id>
    <published>2019-11-29T09:04:34.000Z</published>
    <updated>2019-11-29T09:13:55.882Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是代理"><a href="#什么是代理" class="headerlink" title="什么是代理"></a>什么是代理</h2><p>我们大家都知道微商代理，简单地说就是代替厂家卖商品，厂家“委托”代理为其销售商品。关于微商代理，首先我们从他们那里买东西时通常不知道背后的厂家究竟是谁，也就是说，“委托者”对我们来说是不可见的;其次，微商代理主要以朋友圈的人为目标客户，这就相当于为厂家做了一次对客户群体的“过滤”。我们把微商代理和厂家进一步抽象，前者可抽象为代理类，后者可抽象为委托类(被代理类)。通过使用代理，通常有两个优点，并且能够分别与我们提到的微商代理的两个特点对应起来：</p><ul><li><p>优点一：可以隐藏委托类的实现;</p></li><li><p>优点二：可以实现客户与委托类间的解耦，在不修改委托类代码的情况下能够做一些额外的处理。</p></li></ul><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>代理模式：给某一个对象提供一个代理，并由代理对象来控制对真实对象的访问。代理模式是一种结构型设计模式。</p><p>代理模式角色分为 3 种：</p><ul><li><p>Subject（抽象主题角色）：定义代理类和真实主题的公共对外方法，也是代理类代理真实主题的方法；</p></li><li><p>RealSubject（真实主题角色）：真正实现业务逻辑的类；</p></li><li><p>Proxy（代理主题角色）：用来代理和封装真实主题；</p></li></ul><p>代理模式的结构比较简单，其核心是代理类，为了让客户端能够一致性地对待真实对象和代理对象，在代理模式中引入了抽象层</p><p><img src="/images/proxy_model_dynamic.png" alt></p><p>如果根据字节码的创建时机来分类，可以分为静态代理和动态代理：</p><ul><li><p>静态代理<br>就是在程序运行前就已经存在代理类的字节码文件，代理类和真实主题角色的关系在运行前就确定了。</p></li><li><p>动态代理<br>源码是在程序运行期间由JVM根据反射等机制动态的生成，所以在运行前并不存在代理类的字节码文件。</p></li></ul><h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><p>我们先通过实例来学习静态代理，然后理解静态代理的缺点，再来学习本文的主角：动态代理</p><p>编写一个接口 UserService ，以及该接口的一个实现类 UserServiceImpl：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">()</span></span>;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"查询 selectById"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"更新 update"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将通过静态代理对 UserServiceImpl 进行功能增强，在调用 select 和 update 之前记录一些日志。写一个代理类 UserServiceProxy，代理类需要实现 UserService</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceProxy</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> UserService target; <span class="comment">// 被代理的对象</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserServiceProxy</span><span class="params">(UserService target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        before();</span><br><span class="line">        target.select();    <span class="comment">// 这里才实际调用真实主题角色的方法</span></span><br><span class="line">        after();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        before();</span><br><span class="line">        target.update();    <span class="comment">// 这里才实际调用真实主题角色的方法</span></span><br><span class="line">        after();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;     <span class="comment">// 在执行方法之前执行</span></span><br><span class="line">        System.out.printf(<span class="string">"log start time [%s] \n"</span>, <span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;      <span class="comment">// 在执行方法之后执行</span></span><br><span class="line">        System.out.printf(<span class="string">"log end time [%s] \n"</span>, <span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        UserService userServiceImpl = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line">        UserService proxy = <span class="keyword">new</span> UserServiceProxy(userServiceImpl);</span><br><span class="line"></span><br><span class="line">        proxy.select();</span><br><span class="line">        proxy.update();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">log start time [Thu Dec 20 14:13:25 CST 2018] </span><br><span class="line">查询 selectById</span><br><span class="line">log end time [Thu Dec 20 14:13:25 CST 2018] </span><br><span class="line">log start time [Thu Dec 20 14:13:25 CST 2018] </span><br><span class="line">更新 update</span><br><span class="line">log end time [Thu Dec 20 14:13:25 CST 2018]</span><br></pre></td></tr></table></figure><p>通过静态代理，我们达到了功能增强的目的，而且没有侵入原代码，这是静态代理的一个优点。</p><h3 id="静态代理缺点"><a href="#静态代理缺点" class="headerlink" title="静态代理缺点"></a>静态代理缺点</h3><p>虽然静态代理实现简单，且不侵入原代码，但是，当场景稍微复杂一些的时候，静态代理的缺点也会暴露出来。</p><ul><li><p>1、 当需要代理多个类的时候，由于代理对象要实现与目标对象一致的接口，有两种方式：</p><ul><li><p>只维护一个代理类，由这个代理类实现多个接口，但是这样就导致<strong>代理类过于庞大</strong>;</p></li><li><p>新建多个代理类，每个目标对象对应一个代理类，但是这样会<strong>产生过多的代理类</strong>;</p></li></ul></li><li><p>2、 当接口需要增加、删除、修改方法的时候，目标对象与代理类都要同时修改，<strong>不易维护</strong>。</p></li></ul><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><h3 id="生成原理"><a href="#生成原理" class="headerlink" title="生成原理"></a>生成原理</h3><p>Java虚拟机类加载过程主要分为五个阶段：<code>加载</code>、<code>验证</code>、<code>准备</code>、<code>解析</code>、`初始化。其中加载阶段需要完成以下3件事情：</p><ul><li><p>通过一个类的全限定名来获取定义此类的二进制字节流</p></li><li><p>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</p></li><li><p>在内存中生成一个代表这个类的 <code>java.lang.Class</code> 对象，作为方法区这个类的各种数据访问入口</p></li></ul><p>由于虚拟机规范对这3点要求并不具体，所以实际的实现是非常灵活的，关于第1点，获取类的二进制字节流（class字节码）就有很多途径：</p><ul><li><p>从ZIP包获取，这是JAR、EAR、WAR等格式的基础</p></li><li><p>从网络中获取，典型的应用是 Applet</p></li><li><p>运行时计算生成，这种场景使用最多的是<strong>动态代理技术</strong>，在 <code>java.lang.reflect.Proxy</code> 类中，就是用了 <code>ProxyGenerator.generateProxyClass</code>来为特定接口生成形式为 <code>*$Proxy</code> 的代理类的二进制字节流</p></li><li><p>由其它文件生成，典型应用是JSP，即由JSP文件生成对应的Class类</p></li><li><p>从数据库中获取等等</p></li></ul><p>所以，动态代理就是想办法，根据接口或目标对象，计算出代理类的字节码，然后再加载到JVM中使用。但是如何计算？如何生成？情况也许比想象的复杂得多，我们需要借助现有的方案。</p><h3 id="常见的字节码操作类库"><a href="#常见的字节码操作类库" class="headerlink" title="常见的字节码操作类库"></a>常见的字节码操作类库</h3><blockquote><p>这里有一些介绍：java-source.net/open-source…</p></blockquote><ul><li><p>Apache BCEL (Byte Code Engineering Library)：是Java classworking广泛使用的一种框架，它可以深入到JVM汇编语言进行类操作的细节。</p></li><li><p>ObjectWeb ASM：是一个Java字节码操作框架。它可以用于直接以二进制形式动态生成stub根类或其他代理类，或者在加载时动态修改类。</p></li><li><p>CGLIB(Code Generation Library)：是一个功能强大，高性能和高质量的代码生成库，用于扩展JAVA类并在运行时实现接口。</p></li><li><p>Javassist：是Java的加载时反射系统，它是一个用于在Java中编辑字节码的类库; 它使Java程序能够在运行时定义新类，并在JVM加载之前修改类文件。 </p></li></ul><p>为了让生成的代理类与目标对象（真实主题角色）保持一致性，从现在开始将介绍以下两种最常见的方式：</p><blockquote><p>通过实现接口的方式 -&gt; JDK动态代理<br>通过继承类的方式 -&gt; CGLIB动态代理</p></blockquote><p>注：使用ASM对使用者要求比较高，使用Javassist会比较麻烦</p><h3 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h3><p>JDK动态代理主要涉及两个类：<code>java.lang.reflect.Proxy</code> 和<code>java.lang.reflect.InvocationHandler</code>，我们仍然通过案例来学习.</p><p>编写一个调用逻辑处理器 LogHandler 类，提供日志增强功能，并实现 InvocationHandler 接口；在 LogHandler 中维护一个目标对象，这个对象是被代理的对象（真实主题角色）；在 invoke 方法中编写方法调用的逻辑处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    Object target;  <span class="comment">// 被代理的对象，实际的方法执行者</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LogHandler</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        before();</span><br><span class="line">        <span class="comment">// 调用 target 的 method 方法</span></span><br><span class="line">        Object result = method.invoke(target, args);  </span><br><span class="line">        after();</span><br><span class="line">        <span class="keyword">return</span> result;  <span class="comment">// 返回方法的执行结果</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用invoke方法之前执行</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">"log start time [%s] \n"</span>, <span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用invoke方法之后执行</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">"log end time [%s] \n"</span>, <span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写客户端，获取动态生成的代理类的对象须借助 Proxy 类的 newProxyInstance 方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> proxy.UserService;</span><br><span class="line"><span class="keyword">import</span> proxy.UserServiceImpl;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserClientJdkDynamic</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IllegalAccessException, InstantiationException </span>&#123;</span><br><span class="line">        <span class="comment">// 设置变量可以保存动态代理类，默认名称以 $Proxy0 格式命名</span></span><br><span class="line">        <span class="comment">// System.getProperties().setProperty("sun.misc.ProxyGenerator.saveGeneratedFiles", "true");</span></span><br><span class="line">        <span class="comment">// 1. 创建被代理的对象，UserService接口的实现类</span></span><br><span class="line">        UserServiceImpl userServiceImpl = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 获取对应的 ClassLoader</span></span><br><span class="line">        ClassLoader classLoader = userServiceImpl.getClass().getClassLoader();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 获取所有接口的Class，这里的UserServiceImpl只实现了一个接口UserService，</span></span><br><span class="line">        Class[] interfaces = userServiceImpl.getClass().getInterfaces();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 4. 创建一个将传给代理类的调用请求处理器，处理所有的代理对象上的方法调用</span></span><br><span class="line">        <span class="comment">//     这里创建的是一个自定义的日志处理器，须传入实际的执行对象 userServiceImpl</span></span><br><span class="line">        InvocationHandler logHandler = <span class="keyword">new</span> LogHandler(userServiceImpl);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">   5.根据上面提供的信息，创建代理对象 在这个过程中，</span></span><br><span class="line"><span class="comment">               a.JDK会通过根据传入的参数信息动态地在内存中创建和.class 文件等同的字节码</span></span><br><span class="line"><span class="comment">               b.然后根据相应的字节码转换成对应的class，</span></span><br><span class="line"><span class="comment">               c.然后调用newInstance()创建代理实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">        UserService proxy = (UserService) Proxy.newProxyInstance(classLoader, interfaces, logHandler);</span><br><span class="line">        <span class="comment">// 调用代理的方法</span></span><br><span class="line">        proxy.select();</span><br><span class="line">        proxy.update();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 6. 保存JDK动态代理生成的代理类，类名保存为 UserServiceProxy</span></span><br><span class="line">        ProxyUtils.generateClassFile(userServiceImpl.getClass(), <span class="string">"UserServiceProxy2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">log start time [Thu Dec 20 16:55:19 CST 2018] </span><br><span class="line">查询 selectById</span><br><span class="line">log end time [Thu Dec 20 16:55:19 CST 2018] </span><br><span class="line">log start time [Thu Dec 20 16:55:19 CST 2018] </span><br><span class="line">更新 update</span><br><span class="line">log end time [Thu Dec 20 16:55:19 CST 2018]</span><br></pre></td></tr></table></figure><h4 id="InvocationHandler和Proxy核心方法介绍"><a href="#InvocationHandler和Proxy核心方法介绍" class="headerlink" title="InvocationHandler和Proxy核心方法介绍"></a>InvocationHandler和Proxy核心方法介绍</h4><h5 id="java-lang-reflect-InvocationHandler"><a href="#java-lang-reflect-InvocationHandler" class="headerlink" title="java.lang.reflect.InvocationHandler"></a>java.lang.reflect.InvocationHandler</h5><p><code>Object invoke(Object proxy, Method method, Object[] args)</code>  定义了代理对象调用方法时希望执行的动作，用于集中处理在动态代理类对象上的方法调用</p><h5 id="java-lang-reflect-Proxy"><a href="#java-lang-reflect-Proxy" class="headerlink" title="java.lang.reflect.Proxy"></a>java.lang.reflect.Proxy</h5><p><code>static InvocationHandler getInvocationHandler(Object proxy)</code>  用于获取指定代理对象所关联的调用处理器</p><p><code>static Class&lt;?&gt; getProxyClass(ClassLoader loader, Class&lt;?&gt;... interfaces)</code> 返回指定接口的代理类</p><p><code>static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</code>   构造实现指定接口的代理类的一个新实例，所有方法会调用给定处理器对象的 invoke 方法</p><p><code>static boolean isProxyClass(Class&lt;?&gt; cl)</code>  返回 cl 是否为一个代理类</p><h4 id="代理类"><a href="#代理类" class="headerlink" title="代理类"></a>代理类</h4><p>JDK自动生成的代理类到底长什么样子呢？借助上面第6步操作，可以把代理类保存下来一探究竟， target 的类路径下找到 UserServiceProxy2.class，双击后IDEA的反编译插件会将该二进制class文件转变成java文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line"><span class="keyword">import</span> proxy.UserService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceProxy2</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m4;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserServiceProxy2</span><span class="params">(InvocationHandler var1)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object var1)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="comment">// 省略...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="comment">// 省略...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m4, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="comment">// 省略...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m3, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            m1 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"equals"</span>, Class.forName(<span class="string">"java.lang.Object"</span>));</span><br><span class="line">            m2 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"toString"</span>);</span><br><span class="line">            m4 = Class.forName(<span class="string">"proxy.UserService"</span>).getMethod(<span class="string">"select"</span>);</span><br><span class="line">            m0 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"hashCode"</span>);</span><br><span class="line">            m3 = Class.forName(<span class="string">"proxy.UserService"</span>).getMethod(<span class="string">"update"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError(var2.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoClassDefFoundError(var3.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 UserServiceProxy 的代码中我们可以发现：</p><ul><li><p><code>UserServiceProxy2</code> 继承了 <code>Proxy</code> 类，并且实现了被代理的所有接口，以及equals、hashCode、toString等方法</p></li><li><p>由于<code>UserServiceProxy2</code>继承了 <code>Proxy</code> 类，所以每个代理类都会关联一个 <code>InvocationHandler</code> 方法调用处理器</p></li><li><p>类和所有方法都被 <code>public final</code> 修饰，所以代理类只可被使用，不可以再被继承</p></li><li><p>每个方法都有一个 <code>Method</code> 对象来描述，<code>Method</code> 对象在<code>static</code>静态代码块中创建，以 <code>m+</code> 数字 的格式命名</p></li><li><p>调用方法的时候通过 <code>super.h.invoke(this, m1, (Object[])null)</code> 调用，其中的 <code>super.h.invoke</code> 实际上是在创建代理的时候传递给 <code>Proxy.newProxyInstance</code> 的 <code>LogHandler</code> 对象，它继承 <code>InvocationHandler</code> 类，负责实际的调用处理逻辑</p></li></ul><p>而 LogHandler 的 invoke 方法接收到 method、args 等参数后，进行一些处理，然后通过反射让被代理的对象 target 执行方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    before();</span><br><span class="line">    <span class="comment">// 调用 target 的 method 方法</span></span><br><span class="line">    Object result = method.invoke(target, args);            </span><br><span class="line">    after();</span><br><span class="line">    <span class="keyword">return</span> result;  <span class="comment">// 返回方法的执行结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JDK动态代理执行方法调用的过程简图如下：</p><p><img src="/images/dynamic_process.png" alt></p><h3 id="CGLIB动态代理"><a href="#CGLIB动态代理" class="headerlink" title="CGLIB动态代理"></a>CGLIB动态代理</h3><p>maven引入CGLIB包，然后编写一个UserDao类，它没有接口，只有两个方法，select() 和 update()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"UserDao 查询 selectById"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"UserDao 更新 update"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写一个 LogInterceptor ，继承了 MethodInterceptor，用于方法的拦截回调</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object target;  <span class="comment">//目标类</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LogInterceptor</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回代理对象</span></span><br><span class="line"><span class="comment">     * 具体实现，暂时先不追究。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">createProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);  <span class="comment">// 回调函数  拦截器</span></span><br><span class="line">        <span class="comment">// 设置代理对象的父类,可以看到代理对象是目标对象的子类。所以这个接口类就可以省略了</span></span><br><span class="line">        enhancer.setSuperclass(<span class="keyword">this</span>.target.getClass());</span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> object      表示要进行增强的对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method      表示拦截的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> objects     数组表示参数列表，基本数据类型需要传入其包装类型，如int--&gt;Integer、long-Long、double--&gt;Double</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> methodProxy 表示对方法的代理，invokeSuper方法表示对被代理对象方法的调用</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 执行结果</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object object, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        before();</span><br><span class="line">        <span class="comment">// 注意这里是调用 invokeSuper 而不是 invoke，否则死循环，</span></span><br><span class="line">        <span class="comment">// methodProxy.invokesuper执行的是原始类的方法，method.invoke执行的是子类的方法</span></span><br><span class="line">        Object result = methodProxy.invokeSuper(object, objects);</span><br><span class="line">        after();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(String.format(<span class="string">"log start time [%s] "</span>, <span class="keyword">new</span> Date()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(String.format(<span class="string">"log end time [%s] "</span>, <span class="keyword">new</span> Date()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//目标对象</span></span><br><span class="line">        UserDao userDao = <span class="keyword">new</span> UserDao();</span><br><span class="line">        LogInterceptor interceptor = <span class="keyword">new</span> LogInterceptor(userDao);</span><br><span class="line">        <span class="comment">// 代理对象，调用cglib系统方法自动生成</span></span><br><span class="line">        <span class="comment">// 注意：代理类是目标类的子类。</span></span><br><span class="line">        UserDao proxy = (UserDao) interceptor.createProxy();</span><br><span class="line">        proxy.select();</span><br><span class="line">        proxy.update();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">log start time [Fri Nov 29 10:51:17 CST 2019] </span><br><span class="line">UserDao 查询 selectById</span><br><span class="line">log end time [Fri Nov 29 10:51:17 CST 2019] </span><br><span class="line">log start time [Fri Nov 29 10:51:17 CST 2019] </span><br><span class="line">UserDao 更新 update</span><br><span class="line">log end time [Fri Nov 29 10:51:17 CST 2019]</span><br></pre></td></tr></table></figure><p><strong>CGLIB 创建动态代理类的模式是：</strong></p><ul><li><p>查找目标类上的所有非final 的public类型的方法定义；</p></li><li><p>将这些方法的定义转换成字节码；</p></li><li><p>将组成的字节码转换成相应的代理的class对象；</p></li><li><p>实现 <code>MethodInterceptor</code> 接口，用来处理对代理类上所有方法的请求</p></li></ul><h3 id="JDK与CGLIB动态代理对比"><a href="#JDK与CGLIB动态代理对比" class="headerlink" title="JDK与CGLIB动态代理对比"></a>JDK与CGLIB动态代理对比</h3><ul><li><p>JDK动态代理：基于<font color="red">Java反射机制</font>实现，必须要<font color="red">实现了接口</font>的业务类才能用这种办法生成代理对象。</p></li><li><p>Cglib动态代理：基于<font color="red">ASM机制</font>实现，通过<font color="red">生成业务类的子类</font>作为代理类。</p></li></ul><p><strong>JDK动态代理优势</strong></p><ul><li><p>最小化依赖关系，减少依赖意味着简化开发和维护，JDK 本身的支持，可能比 cglib 更加可靠。</p></li><li><p>平滑进行 JDK 版本升级，而字节码类库通常需要进行更新以保证在新版 Java 上能够使用。</p></li><li><p>代码实现简单。</p></li></ul><p><strong>基于类似 cglib 框架的优势</strong></p><ul><li>无需实现接口，达到代理类无侵入</li><li>只操作我们关心的类，而不必为其他相关类增加工作量。</li><li>高性能</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://juejin.im/post/5c1ca8df6fb9a049b347f55c" target="_blank" rel="noopener">Java 动态代理详解</a></p><p>[2] <a href="https://juejin.im/post/5ad3e6b36fb9a028ba1fee6a" target="_blank" rel="noopener">Java动态代理</a></p><p>[3] <a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&mid=2247483785&idx=1&sn=f696c8c49cb7ecce9818247683482a1c&chksm=e9c2ed84deb564925172b2dd78d307d4dc345fa313d3e44f01e84fa22ac5561b37aec5cbd5b4&scene=0#rd" target="_blank" rel="noopener">Java反射机制详解</a></p><p>[4] <a href="https://blog.csdn.net/lovejj1994/article/details/78080124" target="_blank" rel="noopener">从代理模式再出发！Proxy.newProxyInstance的秘密</a></p><p>[5] <a href="https://blog.csdn.net/yhl_jxy/article/details/80586785" target="_blank" rel="noopener">JDK动态代理实现原理(jdk8)</a></p><h2 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h2><p>文中代码： <a href="https://github.com/austin-brant/dynamic-proxy-demo" target="_blank" rel="noopener">https://github.com/austin-brant/dynamic-proxy-demo</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是代理&quot;&gt;&lt;a href=&quot;#什么是代理&quot; class=&quot;headerlink&quot; title=&quot;什么是代理&quot;&gt;&lt;/a&gt;什么是代理&lt;/h2&gt;&lt;p&gt;我们大家都知道微商代理，简单地说就是代替厂家卖商品，厂家“委托”代理为其销售商品。关于微商代理，首先我们从他们那里买
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
      <category term="基础" scheme="http://yoursite.com/categories/Java/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="基础" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
